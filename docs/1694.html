<html>
<head>
<title>The unparalleled design of Eclipse Collections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Eclipse集合的无与伦比的设计</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/the-unparalleled-design-of-eclipse-collections-e4340b00f79f?source=collection_archive---------1-----------------------#2021-10-31">https://medium.com/javarevisited/the-unparalleled-design-of-eclipse-collections-e4340b00f79f?source=collection_archive---------1-----------------------#2021-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="11b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">探索<a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合中并行性的进化设计</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/eae0e00ffa36c3ad263e332f356ce1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VzAbVkDDVmffXu9y"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@fanfandyuen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jason Yuen </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="eaeb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">大量数据、内存和内核</h1><p id="c7f3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">2006年，我在一家大型金融服务公司从事专有分布式Java缓存架构的工作。我们在内存中的一个复杂对象图中缓存并索引了公司的所有交易和头寸，这样我们就可以高速分割它。此时，我已经构建并广泛利用了一个名为Caramel的内部库的串行eager API。这个库最终成为我们现在所知的<a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>。</p><p id="77b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在2006年我工作的地方，我们有许多大小为几十亿字节的缓存，联网在一起。有许多大型集合(数百万个对象),我们将在内存中迭代执行各种流水线计算，这些计算通常涉及分组、结网和聚合各种余额。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/70b684df3a18885d566b9d394695f720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tR5zZr5mBV7ApCWxkta7uQ.jpeg"/></div></div></figure><p id="7c14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约在这个时候，我在最初的<code class="du ky kz la lb b">EDU.oswego</code>并发实用程序库中发现了Doug Lea的Fork/Join框架。当Java 5发布时，Fork/Join框架最初被排除在<code class="du ky kz la lb b">java.util.concurrent</code>之外。它后来被包含在Java 7中。我在Doug Lea的<a class="ae jd" href="https://www.oreilly.com/library/view/concurrent-programming-in/0201310090/" rel="noopener ugc nofollow" target="_blank">“Java并发编程”</a> (CPJ)和本文<a class="ae jd" href="http://gee.cs.oswego.edu/dl/papers/fj.pdf" rel="noopener ugc nofollow" target="_blank">“一个Java Fork/Join框架”</a>中了解了Fork/Join框架。</p><p id="7c60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我写这篇博客的时候，我去书架上找我的CPJ，当我找不到的时候，我给自己买了一本全新的。这本书是所有有志的高级Java开发人员的必读之作。</p><h1 id="efb1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">渴望串行、并行和分叉/连接</h1><p id="5154" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">焦糖文库最初的方法都是连载的，急切的。我偶尔会添加融合的方法，将一些操作结合在一起以提高性能。比如方法<code class="du ky kz la lb b">collectIf</code>就是<code class="du ky kz la lb b">select</code>(含<code class="du ky kz la lb b">filter</code>)和<code class="du ky kz la lb b">collect</code> ( <code class="du ky kz la lb b">map</code>或<code class="du ky kz la lb b">transform</code>)的组合。再过几年，我们才会在Eclipse集合中向API添加惰性方法。</p><p id="a815" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有关融合方法的更多信息和示例，请查看下面的博客。</p><div class="lc ld ez fb le lf"><a rel="noopener follow" target="_blank" href="/javarevisited/from-eager-to-fused-to-lazy-66450e290002"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">从渴望到融合到懒惰</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">Eclipse集合中迭代API的演变</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">medium.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt jo lf"/></div></div></a></div><p id="8db7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Caramel中并行API的最初实现是热切的。今天，Eclipse集合中仍然有一个实用程序类提供了这种急切的并行功能。这个类被命名为<code class="du ky kz la lb b">ParallelIterate</code>。该类最初使用了来自<code class="du ky kz la lb b">EDU.oswego </code>并发库中的Fork/Join框架。在没有Fork/Join框架的Java 5中引入了<code class="du ky kz la lb b">java.util.concurrent</code>包之后，它后来被转换成使用<code class="du ky kz la lb b">Executor</code>。当在Java 7中添加Fork/Join框架时，一个名为<code class="du ky kz la lb b">FJIterate</code>的新实用程序类被添加到GS集合中。<code class="du ky kz la lb b">FJIterate</code>包含在Eclipse集合中自己的模块中，并分布在一个单独的jar文件中。<code class="du ky kz la lb b">FJIterate</code>从2013年年中就存在了，也就是Java 7发布(2011年7月)两年后。如果您想使用它，将需要一个额外的Maven依赖项。</p><pre class="jf jg jh ji fd lu lb lv lw aw lx bi"><span id="bd6a" class="ly jv hi lb b fi lz ma l mb mc">&lt;<strong class="lb hj">dependency</strong>&gt;<br/>    &lt;<strong class="lb hj">groupId</strong>&gt;org.eclipse.collections&lt;/<strong class="lb hj">groupId</strong>&gt;<br/>    &lt;<strong class="lb hj">artifactId</strong>&gt;eclipse-collections-forkjoin&lt;/<strong class="lb hj">artifactId</strong>&gt;<br/>    &lt;<strong class="lb hj">version</strong>&gt;${eclipse-collections.version}&lt;/<strong class="lb hj">version</strong>&gt;<br/>&lt;/<strong class="lb hj">dependency</strong>&gt;</span></pre><p id="0675" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la lb b"><a class="ae jd" href="https://www.eclipse.org/collections/javadoc/10.4.0/org/eclipse/collections/impl/parallel/ParallelIterate.html" rel="noopener ugc nofollow" target="_blank">ParallelIterate</a></code>和<code class="du ky kz la lb b"><a class="ae jd" href="https://www.eclipse.org/collections/javadoc/10.4.0/org/eclipse/collections/impl/forkjoin/FJIterate.html" rel="noopener ugc nofollow" target="_blank">FJIterate</a></code>上可用的方法几乎相同。实现非常相似，主要区别在于<code class="du ky kz la lb b">ParallelIterate</code>使用<code class="du ky kz la lb b">Executor</code>和<code class="du ky kz la lb b">FJIterate</code>使用Fork/Join框架。使用<code class="du ky kz la lb b">Executor</code>使<code class="du ky kz la lb b">ParallelIterate</code>更适合一些任务。对于原始的内存计算性能，<code class="du ky kz la lb b">FJIterate</code>有时是更好的选择。</p><p id="d035" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la lb b">ParallelIterate</code>和<code class="du ky kz la lb b">FJIterate</code>都是因为同样的原因建造的。我们希望获得由阵列支持的大型内存数据集的原始并行性能。这两个类都将并行执行任何<code class="du ky kz la lb b">Iterable</code>类型的固定算法集。<code class="du ky kz la lb b">ParallelIterate</code>和<code class="du ky kz la lb b">FJIterate</code>的主要工具是平行的<code class="du ky kz la lb b">forEach</code>。所有其他并行算法都是使用并行<code class="du ky kz la lb b">forEach</code>实现的。<code class="du ky kz la lb b">ParallelIterate</code>和<code class="du ky kz la lb b">FJIterate</code>上的<code class="du ky kz la lb b">forEach</code>有十二种重载形式。重载采用不同的参数，以便尽可能地给予开发人员更多的控制。这种设计的基本原理很简单。我们相信，如果有人能够证明他们将从并行性中受益，那么他们将处于最佳位置来决定如何调整各种参数，以便为他们拥有的并行用例从硬件中获取尽可能多的性能。</p><h2 id="12db" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">平行文学</h2><p id="7383" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">以下是<code class="du ky kz la lb b">ParallelIterate</code>上可用的方法。</p><div class="lc ld ez fb le lf"><a href="https://www.eclipse.org/collections/javadoc/10.4.0/org/eclipse/collections/impl/parallel/ParallelIterate.html" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">并行读写(Eclipse集合- 10.4.0)</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">public final class parallel elevate extends object parallel elevate类包含了几个并行算法…</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">www.eclipse.org</p></div></div></div></a></div><h2 id="0276" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">FJIterate</h2><p id="544a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">以下是<code class="du ky kz la lb b">FJIterate</code>上可用的方法</p><div class="lc ld ez fb le lf"><a href="https://www.eclipse.org/collections/javadoc/10.4.0/org/eclipse/collections/impl/forkjoin/FJIterate.html" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">FJIterate (Eclipse集合- 10.4.0)</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">公共最终类FJIterate extends object FJIterate类包含几个并行算法，这些算法与…</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">www.eclipse.org</p></div></div></div></a></div><h2 id="9ec7" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">平行文学与自由比率</h2><p id="2572" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这两个实用程序类上的方法的对称差异和交集如下。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mq"><img src="../Images/e5cbe3a00d2da1a15749f7652823474b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dKjUCkclae96RqKcuIdLQQ.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">ParallelIterate和FJIterate方法的对称差和交</p></figure><p id="1105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最大的区别是几个<code class="du ky kz la lb b">sumBy</code>方法被添加到了<code class="du ky kz la lb b">ParallelIterate</code>中，但没有移植到<code class="du ky kz la lb b">FJIterate</code>中。</p><h1 id="ea65" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">效用的无用</h1><p id="1982" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">像<code class="du ky kz la lb b">ParallelIterate</code>和<code class="du ky kz la lb b">FJIterate</code>这样的实用类的缺点是方法只能返回单一类型。您只有一个选择，所以如果您想根据输入参数类型从一个方法返回不同的实现，您必须选择一个公共的父类型。<code class="du ky kz la lb b">ParallelIterate</code>和<code class="du ky kz la lb b">FJIterate</code>上的方法以任意一个<code class="du ky kz la lb b">java.lang.Iterable</code>作为输入参数，返回集合的方法(例如<code class="du ky kz la lb b">select</code>、<code class="du ky kz la lb b">reject</code>、<code class="du ky kz la lb b">collect</code>)不得不不幸返回<code class="du ky kz la lb b">java.util.Collection</code>。开发人员可以通过使用同名的重载方法来控制返回类型，这些方法将目标集合作为参数。如果用作源参数的<code class="du ky kz la lb b">Iterable</code>实现了<code class="du ky kz la lb b"><a class="ae jd" href="https://www.eclipse.org/collections/javadoc/10.4.0/org/eclipse/collections/impl/parallel/BatchIterable.html" rel="noopener ugc nofollow" target="_blank">BatchIterable</a></code>接口，它将为<code class="du ky kz la lb b">ParallelIterate</code>和<code class="du ky kz la lb b">FJIterate</code>的并行性进行优化。如果源没有实现<code class="du ky kz la lb b">BatchIterable</code>，或者没有实现<code class="du ky kz la lb b">java.util.List</code>，两个实用程序类都将默认在并行化之前将元素复制到一个数组中。</p><p id="83d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一些使用基本形式的<code class="du ky kz la lb b">select</code>(包含<code class="du ky kz la lb b">filter</code>)和重载形式的<code class="du ky kz la lb b">select</code>(接受目标集合)的<code class="du ky kz la lb b">ParallelIterate</code>的例子。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="85cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la lb b">ParallelIterate</code> <code class="du ky kz la lb b">select</code>方法的行为是返回一个类似于传入的<code class="du ky kz la lb b">Iterable</code>类型的类型。对于一个<code class="du ky kz la lb b">List</code>，将返回一个<code class="du ky kz la lb b">List</code>实现。对于<code class="du ky kz la lb b">Set</code>，返回一个<code class="du ky kz la lb b">Set</code>实现。不幸的是，因为这个方法只能有一个签名，所以返回类型必须是最抽象的类型<code class="du ky kz la lb b">Collection</code>。作为一个接口并不十分有用。如果我有时间重构这个实用程序，我将返回<code class="du ky kz la lb b">MutableCollection</code>或<code class="du ky kz la lb b">RichIterable</code>而不是<code class="du ky kz la lb b">Collection</code>。这将使实用程序方法变得更加有用，也许只是稍微少一点无用。</p><h1 id="942d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">懒惰的平行</h1><p id="1c85" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在Eclipse集合中设计和实现惰性并行API时，我们采用了不同的方法。我们决定要求开发人员提供一个<code class="du ky kz la lb b">Executor</code>和一个<em class="mt">批量大小</em>，而不是提供旋钮和开关的多种组合来通过重载进行配置，就像我们对并行实用程序类所做的那样。根据我们七年来支持热切并行的经验，这两个参数似乎是开发人员想要控制的最重要的配置选项。这使得Eclipse集合中的惰性并行API比JDK中的<code class="du ky kz la lb b">parallelStream</code>稍难使用。这是故意的。对于开发人员来说，编写并行代码应该更加困难，因为他们首先需要确定使用并行算法是会加快还是减慢操作。如果开发人员确切地了解他们在做什么，因为他们运行了基准测试并证明并行性确实有助于特定用例的性能，那么他们将处于最佳位置来确定如何配置并行性以获得最佳性能。</p><p id="f0a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">eager和lazy并行API之间的另一个更重要的区别是，算法可以通过数据结构本身用于lazy，而不是位于像<code class="du ky kz la lb b">ParallelIterate</code>这样的实用程序类中。</p><p id="a2ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个例子，它从一百万个整数中过滤出所有的质数。我首先展示了一种流畅的方法，然后将流畅的调用分解成它们的中间结果，以展示中间返回类型。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="2f4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意有一个非常特殊的类型叫做<code class="du ky kz la lb b">ParallelListIterable</code>，它是从<code class="du ky kz la lb b">asParallel</code>返回的。这种类型是惰性的，所以在调用终端操作之前不会发生真正的计算。调用<code class="du ky kz la lb b">select</code>后返回相同的类型。方法<code class="du ky kz la lb b">toBag</code>是一个终止操作，导致一个<code class="du ky kz la lb b">MutableBag</code>被创建。现在让我们看看如果初始集合是一个<code class="du ky kz la lb b">MutableSet</code>而不是一个<code class="du ky kz la lb b">MutableList</code>，我们的类型会发生什么。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="33d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<code class="du ky kz la lb b">MutableSet</code>的<code class="du ky kz la lb b">asParallel</code>的返回类型是<code class="du ky kz la lb b">ParallelUnsortedSetIterable</code>。</p><h2 id="bd06" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">ParallelListIterable与parallel literable</h2><p id="61a0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果我们将<code class="du ky kz la lb b">ParallelListIterable</code>上可用的方法与<code class="du ky kz la lb b">ParallelIterate</code>上可用的方法进行比较，就会发现在Eclipse集合中增加并行惰性API的投资明显增加了。下面显示了两者之间可用方法的对称差异和交集。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mu"><img src="../Images/7072b5f7e93f033d259f0e5b8942be76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QT_uV6zZ3GOhRcU77MUIRw.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">ParallelListIterable和ParallelIterate方法的对称差和交</p></figure><h1 id="d603" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">JDK流与平行流</h1><p id="03b5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">你是否注意到JDK中<code class="du ky kz la lb b">stream</code>和<code class="du ky kz la lb b">parallelStream</code>的返回类型是相同的？他们都返回<code class="du ky kz la lb b">Stream</code>。您可能认为为方法返回的实现可能是实现相同接口的不同类，但事实并非如此。<code class="du ky kz la lb b">stream</code>和<code class="du ky kz la lb b">parallelStream</code>都返回<code class="du ky kz la lb b">ReferencePipeline.Head</code>的新实例。它们之间的区别是一个名为<code class="du ky kz la lb b">parallel</code>的<code class="du ky kz la lb b">boolean</code>参数。这意味着串行和并行代码路径混合在一起，通常在一个布尔表达式上分开，该表达式涉及对名为<code class="du ky kz la lb b">isParallel</code>的方法的调用，其中并行可能选择不同的路径。我在<code class="du ky kz la lb b">AbstractPipeline</code>中搜索了<code class="du ky kz la lb b">isParallel</code>的用法，发现在父类和四个子类(<code class="du ky kz la lb b">ReferencePipeline</code>、<code class="du ky kz la lb b">IntPipeline</code>、<code class="du ky kz la lb b">LongPipeline</code>、<code class="du ky kz la lb b">DoublePipeline</code>)中有48种用法。</p><p id="ad8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有利的一面是，带流的JDK中的串行惰性和并行惰性API是相同的。为串行和并行使用一个实现类可以保证这一点，因为它们共享完全相同的代码路径。缺点是仅仅通过阅读代码很难理解代码路径，并且很难跟踪，即使有调试器的帮助。</p><h1 id="f8f7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Eclipse集合并行性与并行性</h1><p id="1b5c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们已经看到<code class="du ky kz la lb b">asParallel</code>的返回类型对于定义该方法的类型是协变的。返回类型将始终是<code class="du ky kz la lb b">ParallelIterable</code>的子类型。<code class="du ky kz la lb b">ParallelIterable</code>与<code class="du ky kz la lb b">RichIterable</code>没有直接关系。在<code class="du ky kz la lb b">RichIterable</code>上定义的方法<code class="du ky kz la lb b">asLazy</code>返回一个<code class="du ky kz la lb b">LazyIterable</code>。<code class="du ky kz la lb b">LazyIterable</code>延伸<code class="du ky kz la lb b">RichIterable</code>。</p><p id="da57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的类图显示了<code class="du ky kz la lb b">RichIterable</code>、<code class="du ky kz la lb b">LazyIterable</code>和<code class="du ky kz la lb b">ParallelIterable</code>之间的继承关系。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mv"><img src="../Images/99eef5c0437dbfd55c1a3e29abf7e930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFV7cRegpqGaxy4Ui5ZVSw.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">丰富的、惰性的和并行的接口</p></figure><p id="98c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la lb b">RichIterable</code>是<code class="du ky kz la lb b">LazyIterable</code>和Eclipse集合中所有容器类型的父类型(例如<code class="du ky kz la lb b">MutableList</code> / <code class="du ky kz la lb b">ImmutableList</code>、<code class="du ky kz la lb b">MutableSet</code> / <code class="du ky kz la lb b">ImmutableSet</code>等)。).<code class="du ky kz la lb b">LazyIterable</code>提供串行懒惰算法实现。</p><p id="8204" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la lb b">ParallelIterable</code>是所有对应的并行惰性适配器的父类型。在Eclipse集合中，串行和并行API之间有明显的区别。这意味着<code class="du ky kz la lb b">LazyIterable</code>和<code class="du ky kz la lb b">ParallelIterable</code>之间存在不对称。这允许我们将并行API限制在那些如果并行化将会有合理的性能优势的算法上。这也允许串行实现尽可能简单，并且并行实现可以针对特定类型进行优化(例如，<code class="du ky kz la lb b">Bag</code>、<code class="du ky kz la lb b">List</code>、<code class="du ky kz la lb b">Set</code>)。</p><h2 id="14dc" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">可并行与可并行</h2><p id="c1f4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">与<code class="du ky kz la lb b">ParallelIterable</code>相比，<code class="du ky kz la lb b">LazyIterable</code>上有更多可用的方法。如果我们确定实现一个并行版本的懒惰串行方法是有必要和有好处的，那么这总是会随着时间而改变的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mw"><img src="../Images/ed6e8bd639b5b3f3e35af9edde8e64bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6GEia8puDwxj_QCpPCv4ew.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">可并行和可并行方法的对称差和交</p></figure><h1 id="5127" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">性能基准</h1><p id="e288" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">几年前我写了一些基准测试，比较了串行、并行、急切、懒惰、对象和基本类型的组合<code class="du ky kz la lb b">filter</code>、<code class="du ky kz la lb b">map</code>、<code class="du ky kz la lb b">reduce</code>和<code class="du ky kz la lb b">filter</code> + <code class="du ky kz la lb b">map</code> + <code class="du ky kz la lb b">reduce</code>。基准测试的代码和结果记录在下面的博客中。正如你将在博客中看到的，我在JDK 8上运行了基准测试。</p><div class="lc ld ez fb le lf"><a rel="noopener follow" target="_blank" href="/javarevisited/the-4am-jamestown-scotland-ferry-and-other-optimization-strategies-66365ac415ef"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">凌晨4点詹姆斯敦-苏格兰渡轮和其他优化策略</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">当性能很重要时，了解您的可用选项也很重要。</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">medium.com</p></div></div><div class="lo l"><div class="mx l lq lr ls lo lt jo lf"/></div></div></a></div><p id="6fe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我开始写这个博客时，我决定要写新的基准。我想在JDK 17上运行基准测试，这样我就可以看到旧的eager parallel和fork/join实用程序类如何支持JDK最近九个版本中的所有优化。我还想让基准测试代码立即开源，供开发人员自己进行实验，并在他们自己的硬件上得出他们自己的结论。基准是<a class="ae jd" href="https://github.com/BNYMellon/CodeKatas" rel="noopener ugc nofollow" target="_blank"> BNYM Code Katas repo </a>中JMH Kata模块的一部分。这次我关注的是<code class="du ky kz la lb b">filter</code> + <code class="du ky kz la lb b">map</code>的一个用例。在名为<code class="du ky kz la lb b">collectIf</code>的<code class="du ky kz la lb b">ParallelIterate</code>和<code class="du ky kz la lb b">FJIterate</code>实用程序类上有一个用于<code class="du ky kz la lb b">filter</code> + <code class="du ky kz la lb b">map</code>的融合方法。该方法也可用于</p><div class="lc ld ez fb le lf"><a href="https://github.com/BNYMellon/CodeKatas/blob/master/jmh-kata/src/test/java/bnymellon/codekatas/jmhkata/FilterMapJMHBenchmark.java" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">code katas/filtermapjmhbenchmar . Java位于主BNYMellon/CodeKatas</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">BNY梅隆代码卡塔斯。通过在GitHub上创建一个帐户，为BNYMellon/CodeKatas的开发做出贡献。</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">github.com</p></div></div><div class="lo l"><div class="my l lq lr ls lo lt jo lf"/></div></div></a></div><p id="aa06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JMH式是我所说的“沙盒式”。您可以将它作为一个沙箱来运行您自己的实验，测试您自己的基准。它可以运行一些初级的JMH基准测试，并节省您设置项目做同样事情的时间。</p><h2 id="140d" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">五金器具</h2><p id="a5f9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我使用我的MacPro“垃圾桶”和以下硬件规格来测量基准:</p><pre class="jf jg jh ji fd lu lb lv lw aw lx bi"><span id="be2e" class="ly jv hi lb b fi lz ma l mb mc">Processor Name: 12-Core Intel Xeon E5<br/>Processor Speed: 2.7 GHz<br/>Number of Processors: 1<br/>Total Number of Cores: 12<br/>L2 Cache (per Core): 256 KB<br/>L3 Cache: 30 MB<br/>Memory: 64 GB</span></pre><h2 id="1708" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">软件和基准配置</h2><p id="41c9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我将OpenJDK 17与Java Streams和Eclipse Collections 11.0.0.M2一起使用。我使用1.33版作为测试的基准工具。我运行了10次预热迭代，10次测量迭代使用了2个分叉。预热时间和测量时间都是5秒。我在测试中使用了<code class="du ky kz la lb b">Mode.Throughput </code>,以便于阅读。这些数字是以每秒操作数为单位的。<strong class="ih hj"> <em class="mt">数字越大，结果越好。</em> </strong></p><h2 id="8e49" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">数据</h2><p id="bffc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我使用一个名为<code class="du ky kz la lb b">Person</code>的简单类运行基准测试。<code class="du ky kz la lb b">Person</code>有<code class="du ky kz la lb b">name</code>(<code class="du ky kz la lb b">String</code>)<code class="du ky kz la lb b">age</code>(<code class="du ky kz la lb b">int</code>)<code class="du ky kz la lb b">heightInInches</code>(<code class="du ky kz la lb b">double</code>)<code class="du ky kz la lb b">weightInPounds</code>(<code class="du ky kz la lb b">double</code>)。我运行了以下数据大小的基准测试。</p><ul class=""><li id="aaed" class="mz na hi ih b ii ij im in iq nb iu nc iy nd jc ne nf ng nh bi translated"><code class="du ky kz la lb b">10,000</code>(过滤器和映射<code class="du ky kz la lb b">4,995</code>值)</li><li id="0210" class="mz na hi ih b ii ni im nj iq nk iu nl iy nm jc ne nf ng nh bi translated"><code class="du ky kz la lb b">100,000</code>(过滤器和映射<code class="du ky kz la lb b">49,942</code>值)</li><li id="5b02" class="mz na hi ih b ii ni im nj iq nk iu nl iy nm jc ne nf ng nh bi translated"><code class="du ky kz la lb b">1,000,000</code>(过滤器和映射<code class="du ky kz la lb b">499,615</code>值)</li><li id="922d" class="mz na hi ih b ii ni im nj iq nk iu nl iy nm jc ne nf ng nh bi translated"><code class="du ky kz la lb b">8,675,309</code>(过滤器和映射<code class="du ky kz la lb b">4,337,179</code>值)</li></ul><h2 id="b7dc" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">排行榜</h2><p id="7a36" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我将图表中的列从最少到最多排序，因此很容易找到最慢(最左边)和最快(最右边)的结果。因此请注意，对于不同的数据大小，列可能会有所不同。</p><h2 id="a6b0" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">结果— 10K人</h2><p id="673b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">最快并行:Eclipse集合渴望并行(<code class="du ky kz la lb b">ParallelIterate</code> ) <br/>最慢并行:JDK并行<code class="du ky kz la lb b">Stream.toList()</code></p><p id="f5d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最快连载:Eclipse Collections急切连载<br/>最慢连载:JDK连载流<code class="du ky kz la lb b">Collectors.toList()</code></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nn"><img src="../Images/901650e8ccf9597c907b18b8e097d4e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8YgL_CuuzCCZDMygFptuA.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">过滤器/地图—每秒操作数— 10，000人</p></figure><h2 id="7155" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">结果— 10万人</h2><p id="3923" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">最快并行:Eclipse集合渴望并行(<code class="du ky kz la lb b">ParallelIterate</code> ) <br/>最慢并行:JDK并行流<code class="du ky kz la lb b">Collectors.toList()</code></p><p id="2fb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最快连载:Eclipse Collections急切连载<br/>最慢连载:JDK连载流<code class="du ky kz la lb b">Collector.toList()</code></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nn"><img src="../Images/a2273d2d85740bf92c0dbfd20371ac5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXGX7pIHIz9IIoA2wp13Lw.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">过滤器/地图—每秒操作数— 100，000人</p></figure><h2 id="0f4c" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">结果——100万人</h2><p id="0503" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">最快的并行:Eclipse集合渴望Fork/Join ( <code class="du ky kz la lb b">FJIterate</code> ) <br/>最慢的并行:Eclipse集合懒惰<code class="du ky kz la lb b">asParallel()</code></p><p id="2164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最快连载:Eclipse Collections渴望连载<br/>最慢连载:JDK连载流<code class="du ky kz la lb b">Collector.toList()</code></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nn"><img src="../Images/825768819de17736180d534016ca4e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xf4AMjCfIDlhGWlsPy8WRQ.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">过滤器/地图-每秒操作数-100万人</p></figure><h2 id="b11e" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">结果——8，675，309人</h2><p id="ed0b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">最快并行:Eclipse Collections Eager Fork/Join(<code class="du ky kz la lb b">FJIterate</code>)<br/>最慢并行:JDK并行流<code class="du ky kz la lb b">Collectors.toList()</code></p><p id="e952" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最快连载:Eclipse Collections渴望连载<br/>最慢连载:JDK连载流<code class="du ky kz la lb b">Collectors.toList()</code></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nn"><img src="../Images/dc9be7cc18126ccbcfe840cf91641967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMo3DYIoTJuf2e8TXqWDSA.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">过滤器/地图-每秒操作数-8，675，309人</p></figure><h2 id="ecf0" class="ly jv hi bd jw md me mf ka mg mh mi ke iq mj mk ki iu ml mm km iy mn mo kq mp bi translated">结果— JMH输出</h2><p id="3856" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">下面是上图中使用的原始综合JMH输出。还有三个我测试过的大码(<code class="du ky kz la lb b">25M</code>、<code class="du ky kz la lb b">50M</code>、<code class="du ky kz la lb b">100M</code>)，我没有包括它们的图表。我不得不在它们上从每秒操作数切换到每毫秒操作数，所以我不想让图形变得混乱。对于特大尺寸，<strong class="ih hj"> <em class="mt">数字越小越好</em> </strong>。大数据量的结果与Eclipse集合Eager Fork/Join ( <code class="du ky kz la lb b">FJIterate</code>)是并行最快的一致。Eclipse Collections Eager Serial是除最大测试之外所有测试中最快的，其中JDK Serial <code class="du ky kz la lb b">Stream.toList()</code>名列榜首。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><h1 id="882b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">一些经验教训</h1><p id="f0c9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在Eclipse集合中构建并行eager实用程序类超过15年之后，我学到了一些东西。我已经忘记了一路上学到的一些经验，但是写这篇博客帮助我在编写代码的时候重新发现了其中的一些。编写高效的并行算法是极其艰苦的工作，您将花费大量时间运行和重新运行基准测试。这是一个兔子洞，如果你掉进去了，你会损失几天或几周的寿命。</p><p id="87e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，您可以针对特定的急切算法进行性能调优，这样与更一般的懒惰算法相比，您可能会获得5%、10%甚至20%的加速。如果性能对你真的很重要，那么你可能会发现用较低层次的框架如Fork/Join或Executors来实现特定的用例是有益的。有时，甚至使用更高级的结构手工编写一个算法，比如具有高效并发数据结构的parallel <code class="du ky kz la lb b">forEach</code>,也会有很好的回报。</p><p id="8b02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2013年，购买一台拥有足够数量的内核和RAM的个人台式机，我可以对其运行并行基准测试，这似乎是对Eclipse集合的一项不错的长期投资。回想起来，我认为这是一笔不错的投资，因为这些年来我一直用这台机器为各种演讲和博客准备基准。我的计划是，在10年过去之前，甚至不再考虑升级我的个人电脑。令人惊讶的是，即使在笔记本电脑和台式机中出现了多核的所有承诺，直到最近，我们才看到内核和RAM的数量以不到一个完全离谱的价格出现了像样的增长，就像我在2013年为我的Mac Pro“垃圾桶”支付的费用一样。</p><p id="712d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管这些年来我在MacPro上运行了很多基准测试，但实际上我并没有对Eclipse集合中的任何并行算法进行太多的调优。我之前在以前的雇主那里用一台非常大的机器(24个内核，256GB RAM)测试过Eclipse集合。我们已经看到了我们实现的许多并行急切和懒惰算法的良好加速。正如我上面提到的，我们的并行懒惰算法比并行渴望算法实现得更晚，但自2014年末以来也没有真正调整过。<a class="no np ge" href="https://medium.com/u/82b613b921f6?source=post_page-----e4340b00f79f--------------------------------" rel="noopener" target="_blank"> Craig Motlin </a>在2014年6月做了一个关于Eclipse集合并行惰性实现方法的精彩演讲。它对三种不同的实现(Java 8，Scala，Eclipse Collections，以前的GS Collections)如何针对特定的并行算法进行调优做了很好的解释和总结。我将把它链接到这里，给那些想学习并行算法优化策略的人。</p><div class="lc ld ez fb le lf"><a href="https://www.infoq.com/presentations/java-streams-scala-parallel-collections/" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">并行惰性性能:Java 8 vs Scala vs GS集合</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">由高盛赞助。Java 8有流，Scala有并行集合，GS集合有…</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">www.infoq.com</p></div></div><div class="lo l"><div class="nq l lq lr ls lo lt jo lf"/></div></div></a></div><h1 id="a06e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">未来</h1><p id="fd90" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">既然JDK 17已经发布，而且市场上有新的、更便宜的具有更多内核的机器，那么再次测试和调整Eclipse集合中的并行算法可能是值得的。扩展当前的并行惰性实现可能也是有用的。对于一些并行用例来说，Java流似乎正在改进，并且可能仍然会受益于Eclipse Collections用来优化特定算法(如<code class="du ky kz la lb b">filter</code>和<code class="du ky kz la lb b">map</code>)的方法。克雷格在上面的演讲中描述了我们使用的方法，所以这绝对值得一看。通常未来可以从过去的经验中获益。</p><p id="e6d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想重构和清理Eclipse集合中的并行eager实现，并改善<code class="du ky kz la lb b">ParallelIterate</code>和<code class="du ky kz la lb b">FJIterate</code>之间的对称性。我想做的最大改变是将返回类型从<code class="du ky kz la lb b">Collection</code>改为<code class="du ky kz la lb b">RichIterable</code>或<code class="du ky kz la lb b">MutableCollection</code>。在<code class="du ky kz la lb b">ParallelIterate</code>和<code class="du ky kz la lb b">FJIterate</code>中。</p><p id="0fec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我也希望看到一些人抓住机会继续从事Eclipse集合的并行惰性实现的工作。正如我在上面展示的<code class="du ky kz la lb b">LazyIterable</code>和<code class="du ky kz la lb b">ParallelIterable</code>之间的区别一样，还有很多方法没有添加进来。改善对称性有成本也有好处。到目前为止，添加更多并行方法的成本已经超过了收益，这就是为什么我们没有在这个领域做更多的工作。但是对于合适的人来说，他们可能会尝试并行编程，可能会用M1 Max测试他们新买的MacBook Pro中的所有内核，学习如何构建优化的并行算法的好处可能会超过成本。</p><p id="3f4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我相信并行编程对于更多的Java开发人员来说会变得越来越重要。学习如何有效地编程和调优并行算法将是许多开发人员需要学习的内容。来自道格·李的《CPJ》和布莱恩·戈茨的《实践中的Java并发》(<a class="ae jd" href="https://jcip.net/" rel="noopener ugc nofollow" target="_blank"> JCIP </a>)等书籍的知识和经验将变得重要和受欢迎。现在我有了我的第二本全新的《CPJ 》,还有我之前签名的《JCIP 》,我准备重新学习并发和并行的课程。</p><h1 id="bbbd" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">最后的想法</h1><p id="86b4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我写这个博客的目的是分享我从过去15年中学到的一些教训，否则这些教训可能会被发现或完全遗忘。我怀疑大多数使用Eclipse集合的开发人员在阅读这篇博客之前会钻研库中可用的并行算法。我希望一些Java开发人员阅读这篇博客，并发现它有助于帮助他们了解更多他们以前可能不知道的并行编程方法。如果你读了它并且喜欢它，你可以通过鼓掌和/或评论让我知道。我通常不喜欢在博客中包含微基准，但我认为人们会发现它们足够有趣，足以开始调查和了解更多。带着巨大的怀疑和两磅的怀疑来接受我的基准。我不建议根据它们做任何决定。我强烈建议为您自己的特定用例编写您自己的应用程序基准，并自行确定某个特定方法是否会帮助您实现更好或更差的性能。正如我在上面链接的博客中所推荐的:</p><blockquote class="nr ns nt"><p id="79d4" class="if ig mt ih b ii ij ik il im in io ip nu ir is it nv iv iw ix nw iz ja jb jc hb bi translated">先证明再并行。</p></blockquote><p id="12ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p><p id="7825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mt">我是</em><a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="mt">Eclipse Collections</em></a><em class="mt">OSS项目在</em><a class="ae jd" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="mt">Eclipse Foundation</em></a><em class="mt">的项目负责人。</em> <a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="mt">月食收藏</em> </a> <em class="mt">是开投</em> <a class="ae jd" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="mt">投稿</em> </a> <em class="mt">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div></div>    
</body>
</html>