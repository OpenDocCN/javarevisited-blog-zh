<html>
<head>
<title>The Debugger Checklist — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试器清单—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/the-debugger-checklist-part-i-b5bf56765bb8?source=collection_archive---------4-----------------------#2021-09-15">https://medium.com/javarevisited/the-debugger-checklist-part-i-b5bf56765bb8?source=collection_archive---------4-----------------------#2021-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="46d0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过遵循有组织的过程和利用您已经拥有的工具来赢得调试</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/1ea6f654784a317186e675ff4a8c13e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BN2hHDicakhZOo0_s94gQ.jpeg"/></div></div></figure><p id="97aa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我天生就是一个没有条理的人。当我遵循一个过程时，那是出于习惯和直觉。但是，当一个调试问题让我夜不能寐，让我觉得在新西兰养羊似乎是一个很有吸引力的选择时，那就是我需要退后一步，有条不紊地完成这个过程的时候。这个过程从不失败。当你走过它，你可以跟踪任何问题。</p><p id="ed17" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我要跳过很多常见的建议。大多数调试教程都是从与过程相关的事情开始的:提出一个问题，作为测试用例重现等等。我认为网上有很多这样的文章。人们用它来填充，因为他们认为调试是一个简单的过程。有时候是这样。但是正如我们将在这篇博客中了解到的，这个容易让人误解的简单过程有很大的深度和广度。</p><p id="6a90" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将跳到这样一个点，您有一个可以重现的bug(无论是一致的还是不一致的),但是您不理解或者无法证明原因。</p><p id="8e1f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这不是一个初学者的教程，这是一个不同的帖子，在其中我将涵盖许多额外的东西，并进入更多的细节。</p><h1 id="1951" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">在我的机器上工作</h1><p id="f61d" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">如果这不能在本地重现，您可能需要利用远程调试。这对于大多数现代开发工具来说相当容易，例如<a class="ae lc" href="https://lightrun.com/debugging/how-to-debug-remotely-in-intellij/" rel="noopener ugc nofollow" target="_blank">本文</a>涵盖了在IntelliJ/IDEA中远程<a class="ae lc" href="https://javarevisited.blogspot.com/2011/02/how-to-setup-remote-debugging-in.html" rel="noopener ugc nofollow" target="_blank">调试Java进程的过程</a>。您可以将相同的技术应用于大多数ide和语言/平台。</p><p id="d1be" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里的主要问题是这是否只发生在生产环境中。在这种情况下，标准的远程调试是非常危险的。无论是在安全性方面(这是不存在的)，还是在服务器的可靠性方面。注意，有很多方法可以安全、方便地调试远程服务器，比如<a class="ae lc" href="https://www.lightrun.com/" rel="noopener ugc nofollow" target="_blank"> Lightrun </a>。</p><p id="bac3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果没有，你可以试试下面的技巧:</p><ul class=""><li id="a23c" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">在本地运行，但是通过隧道连接到远程数据库——我通常只使用SSH隧道，但是我听说过关于<a class="ae lc" href="https://goteleport.com/" rel="noopener ugc nofollow" target="_blank">传送</a>的好消息</li><li id="7fa3" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">记录用户发送的确切入口点凭据，并尝试在本地重现请求</li></ul><p id="6882" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">根据我的经验，这是调试远程问题时最难做的事情之一。尤其是在群集/多语言环境中。</p><h1 id="1872" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">如果Bug不一致</h1><p id="2be7" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">这些是我们最需要帮助的难以追踪的错误。这些也是人们对调试失去信心的bug。我将把这个问题分为两种不同的情况:</p><ul class=""><li id="a0ae" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">很少发生</li><li id="06ac" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">如果我们停在一个断点上，就不会发生</li></ul><p id="fe09" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这两种情况下，最好的解决方案是日志记录，是的，日志记录是调试的一种形式…我们可以添加一个日志，“应用代码更改”(或编辑并继续)，并立即在我们的日志中看到输出。</p><p id="1ad4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果当我们有一个断点时问题没有发生，即使有一个日志，它也可能不会重现。那是因为问题是线程问题。调试一个<a class="ae lc" href="http://javarevisited.blogspot.sg/2012/02/what-is-race-condition-in.html#axzz59AbkWuk9" rel="noopener ugc nofollow" target="_blank">竞争条件</a>或者一个<a class="ae lc" href="https://javarevisited.blogspot.com/2018/08/how-to-avoid-deadlock-in-java-threads.html#axzz6ccm5KWKs" rel="noopener ugc nofollow" target="_blank">死锁</a>实际上并不像有时想象的那么痛苦。我将在本文稍后讨论这个问题。请注意，调试这是“容易的部分”，修复它…这是困难的部分…</p><p id="2ed1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果这种情况很少发生，那么我们仍然需要验证这与线程问题没有直接关系。在这种情况下，我经常确保记录当前线程，以查看是否与调用线程相关。我还尝试记录堆栈，看看问题是否因有意义的堆栈而异。一个很酷的技巧是对堆栈进行哈希或校验和处理，以减少噪声。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="01f6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以在我们的日志中使用这些代码，然后我们可以立即浏览这些代码，以发现错误是否与特定堆栈的调用相关。</p><h1 id="0d82" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">条件断点</h1><p id="8235" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">你可能知道<a class="ae lc" href="https://www.java67.com/2018/01/how-to-remote-debug-java-application-in-Eclipse.html" rel="noopener ugc nofollow" target="_blank">条件断点</a>，但是你最后一次使用它们是什么时候？</p><p id="4b91" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果那是最近的事，那就恭喜你了！你是被选中的少数人之一。</p><p id="be9a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个特性并没有得到应有的使用。例如，我们可以使用先前校验和当前堆栈代码来验证所有调用都来自同一个堆栈。我们可以使用该方法的输出作为条件。</p><p id="8299" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">假设我们正在跟踪的bug仅在处理特定用户的数据时发生。在条件为<code class="du lt lu lv lw b">userId == problematicUser</code>的地方创建一个断点，可以让我们专注于重要的部分。我们可以使用线程名作为条件来有效地调试竞争条件。</p><p id="e04b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">条件断点存在一些问题。例如，它们会影响性能，导致执行速度降低到我们无法正确重现问题的程度。</p><h1 id="1435" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">重复冲洗</h1><p id="c959" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">你知道那种感觉，当你花了很长时间才把所有的事情都做对，然后你走得太远了，你“错过了”！这是最令人沮丧的感觉…它让你想发脾气。</p><p id="2be5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">嗯，有一个解决办法。我们都应该知道“运行到光标处”，这很好。但是大多数ide也支持Go to Cursor，它允许你操作指令指针，将执行向后(或向前)移动到一个任意(合法)的位置。</p><p id="2164" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">奇怪的是，直到最近IntelliJ还不支持这一点。它仍然不是…但是有一个插件！</p><p id="27cd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个<a class="ae lc" href="https://plugins.jetbrains.com/plugin/14877-jump-to-line" rel="noopener ugc nofollow" target="_blank">跳转行插件</a>，是为数不多的必须为<a class="ae lc" rel="noopener" href="/javarevisited/7-best-courses-to-learn-intellij-idea-for-beginners-and-experienced-java-programmers-2e9aa9bb0c05?source=---------16------------------"> IntelliJ </a>提供的插件之一，对每个人都有用。它是生命的拯救者和快乐的增强者。有了这个插件，你可以将左边的执行箭头拖动到一个新的位置…太神奇了。</p><p id="8f31" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">再加上在监视窗口中编辑变量值的能力，您就可以在单步执行代码块的同时在方法中测试您的理论。您可以很容易地模拟许多需要几个小时(如果不是几天)才能重现的场景作为测试用例。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/964a01a7acf3aa5b5219fe54f7b42560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Xn22PPmE_TcwVKzImtcR0Q.gif"/></div></div></figure><h1 id="5e27" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">待续</h1><p id="8bc8" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">下次我将回顾应用程序的调试过程。这是一个非常简单的过程，但像往常一样“细节决定成败”。</p><p id="db06" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你有自己的流程吗？</p><p id="6cd6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我很想听听你的想法和调试技巧。</p></div></div>    
</body>
</html>