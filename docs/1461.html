<html>
<head>
<title>Count and Rearrange</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计数并重新排列</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/count-and-rearrange-2efb209330d3?source=collection_archive---------6-----------------------#2021-08-10">https://medium.com/javarevisited/count-and-rearrange-2efb209330d3?source=collection_archive---------6-----------------------#2021-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5050a05f7ec2504e16bc2b86ca892385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIetqus0mfmpZNt7ahW9DQ.png"/></div></div></figure><h2 id="c962" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">问题陈述:</h2><p id="7153" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">万寿之露的任务是从一组已排序的数字中找出一个给定数字的计数，然后将这些数字推到数组的前面，以便于拾取和计数。</p><h2 id="7530" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">讨论的解决方法:</h2><ul class=""><li id="5872" class="kj kk hi jq b jr js jv jw jb kl jf km jj kn ki ko kp kq kr bi translated">使用循环的暴力方法</li><li id="e152" class="kj kk hi jq b jr ks jv kt jb ku jf kv jj kw ki ko kp kq kr bi translated">使用<a class="ae kx" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>的优化方法</li></ul><h2 id="473d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">这个编码问题的关键是:</h2><ul class=""><li id="4ddb" class="kj kk hi jq b jr js jv jw jb kl jf km jj kn ki ko kp kq kr bi translated">了解一下<a class="ae kx" rel="noopener" href="/javarevisited/binary-search-in-java-algorithm-eca288cb9bc2">二分搜索法</a></li><li id="11b9" class="kj kk hi jq b jr ks jv kt jb ku jf kv jj kw ki ko kp kq kr bi translated">了解<a class="ae kx" href="https://javarevisited.blogspot.com/2015/03/how-to-reverse-array-in-place-in-java.html" rel="noopener ugc nofollow" target="_blank">交换数组中的元素</a></li></ul><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="4bbc" class="iq ir hi ld b fi lh li l lj lk">For example:</span><span id="d8c3" class="iq ir hi ld b fi ll li l lj lk">If the numbers are 1, 1, 2, 2, 2, 2, 6 and you are given number 2 to count and push it to the front then, the final output would look like</span><span id="816f" class="iq ir hi ld b fi ll li l lj lk">Output: 2, 2, 2, 2, 1, 1, 6</span></pre><p id="07f6" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated"><strong class="jq hj">能做到时间复杂度为O(logn)空间复杂度为O(1)吗？只考虑寻找和计算数字</strong></p><p id="8fc0" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">现在，暂时忘记你被给予的找出解决方案的时间复杂性，现在，想一想找到问题的解决方案的最基本的方法。</p><p id="b546" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">让我们把问题分解成两个子问题:- <br/> 1。求给定数字<br/> 2的计数。将给定的数字排列在所有其他数字的开头</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/db13df6df9006575497c2d59cc840c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/1*ZeYBlVyHQw9trIm4pwomGA.gif"/></div><p class="ls lt et er es lu lv bd b be z dx translated">让我们编码</p></figure><h2 id="5fe5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">天真的解决方案:</h2><p id="40a9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">该问题的<strong class="jq hj">强力</strong>解决方案是使用<a class="ae kx" href="https://javarevisited.blogspot.com/2020/01/how-to-implement-linear-or-sequential-search-in-java.html#axzz6VYKcmyZz" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">线性搜索</strong> </a> <strong class="jq hj"> </strong>来计算该数字的出现次数，然后将该数字重新排列到所有其他数字的前面。</p><p id="31d6" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">我们来看看这个方法的算法:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="4297" class="iq ir hi ld b fi lh li l lj lk">start function searchElementandSwapp(array, array_size, number){<br/>     count = 0<br/>     initialIndex = 0</span><span id="3c09" class="iq ir hi ld b fi ll li l lj lk">     /* Get the count of the number and the index where it was first found */</span><span id="0e05" class="iq ir hi ld b fi ll li l lj lk">     start for (index is 0 to index is less than array_size increment index by 1)<br/>          start if(array[index] is equal to number and count = 0)<br/>                increment count by 1<br/>                set initialIndex as index<br/>          end if<br/>          start if(array[index] is equal to number and count != 0)<br/>                increment count by 1<br/>          end if<br/>     end for</span><span id="48bc" class="iq ir hi ld b fi ll li l lj lk">     /* Now swapp the numbers */</span><span id="e9a4" class="iq ir hi ld b fi ll li l lj lk">     start for (index is 0 to index is less than array_size and array[initialIndex] is equal to number increment  by 1)<br/>        start if(array[initialIndex] is equal to number and initialIndex is less than array_size)<br/>             swapp array[index] and array[initialIndex]<br/>             increment initialIndex by 1<br/>        end if<br/>     end for</span><span id="6dbb" class="iq ir hi ld b fi ll li l lj lk">end searchElementandSwapp</span></pre><p id="9ee1" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated"><strong class="jq hj">该算法的执行时间为O(n ),完成运算的空间为O(1) </strong></p><p id="7807" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">这个算法对于大规模的数组肯定会失败，对于更大规模的数组效率很低，那么我们应该怎么想来进一步优化它呢？</p><p id="4879" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">你听说过一个<a class="ae kx" href="https://javarevisited.blogspot.com/2019/04/top-20-searching-and-sorting-algorithms-interview-questions.html" rel="noopener ugc nofollow" target="_blank">T21二分搜索法</a>的算法吗？</p><p id="13a7" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">这个问题满足了所有二分搜索法的使用规则，因为数组是完全排序的，我们可以在时间<strong class="jq hj"> O(logn) </strong>内找到我们想要的元素！</p><h2 id="298d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">二分搜索法方法:</h2><p id="3382" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">让我们讨论首先找到元素在数组中出现的位置的算法:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="bde5" class="iq ir hi ld b fi lh li l lj lk">start function searchElement(array, start_index, end_index, number)</span><span id="aac3" class="iq ir hi ld b fi ll li l lj lk">       start if(end_index is less than 1)<br/>           return -1<br/>       end if</span><span id="1385" class="iq ir hi ld b fi ll li l lj lk">       mid_index = start_index + (end_index - start_index) / 2<br/>  <br/>       start if(array[mid_index] is equal to number)<br/>            return mid_index<br/>       end if</span><span id="49f6" class="iq ir hi ld b fi ll li l lj lk">       start if(array[mid_index] is less than number)<br/>            searchElement(array, mid_index + 1, end_index, number)<br/>       end if</span><span id="0cce" class="iq ir hi ld b fi ll li l lj lk">       start else<br/>            searchElement(array, start_index, mid_index - 1, number)<br/>       end else</span><span id="e532" class="iq ir hi ld b fi ll li l lj lk">end searchElement</span></pre><p id="b9a6" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">现在，在搜索之后，我们将需要<a class="ae kx" rel="noopener" href="/javarevisited/20-array-coding-problems-and-questions-from-programming-interviews-869b475b9121">计算一个给定数字在数组</a>中的出现次数，为此我们可以将算法写成</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="d608" class="iq ir hi ld b fi lh li l lj lk">start function countElement(array, array_size, number)</span><span id="f43e" class="iq ir hi ld b fi ll li l lj lk">     getIndex = searchElement(array, 0, array_size - 1, number)</span><span id="1d2b" class="iq ir hi ld b fi ll li l lj lk">     /* if the element is not present */</span><span id="7c1f" class="iq ir hi ld b fi ll li l lj lk">     start if(getIndex is equal to -1)<br/>         return 0<br/>     end if<br/>     <br/>     count = 0<br/>     leftCountIndex = getIndex<br/>     rightCountIndex = getIndex<br/>     initialIndex = 0 /* this will let us know the first position where the number was found to swapp it later on */</span><span id="e33a" class="iq ir hi ld b fi ll li l lj lk">     /* count left side */<br/> <br/>     start while(leftCountIndex is greater than or equal to 0 and array[leftCountIndex] is equal to number)<br/>           increment count by 1<br/>           set initialIndex to leftCountIndex<br/>           decrement leftCountIndex by 1<br/>     end while</span><span id="00c9" class="iq ir hi ld b fi ll li l lj lk">     /* count right side */</span><span id="7931" class="iq ir hi ld b fi ll li l lj lk">     start while(rightCountIndex is less than the array_size and   array[rightCountIndex] is equal to number)<br/>           increment count by 1<br/>           incrementrightCountIndex by 1<br/>     end while</span><span id="1c5d" class="iq ir hi ld b fi ll li l lj lk">     print count </span><span id="2910" class="iq ir hi ld b fi ll li l lj lk">     return initialIndex</span><span id="2aa2" class="iq ir hi ld b fi ll li l lj lk">end countElement</span></pre><p id="10f1" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">现在，我们有了<strong class="jq hj"> initialIndex </strong>，所以我们可以很容易地用它来交换前面的数字<strong class="jq hj">(如天真的交换方法所示，我们将使用相同的方法)</strong>，然后嘣！你在预期的时间内解决了问题。</p><p id="62d2" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">现在，既然你已经知道了问题背后的<a class="ae kx" rel="noopener" href="/javarevisited/20-algorithms-coding-problems-to-crack-you-next-technical-interviews-23191f229788">算法</a>，那么你可以用你想要的编程语言编写你自己的功能性<strong class="jq hj">代码</strong>。</p><h1 id="64b3" class="lw ir hi bd is lx ly lz iw ma mb mc ja md me mf je mg mh mi ji mj mk ml jm mm bi translated">分析:</h1><ul class=""><li id="d02b" class="kj kk hi jq b jr js jv jw jb kl jf km jj kn ki ko kp kq kr bi translated">时间复杂度:<code class="du mn mo mp ld b">O(logn)</code>，其中<strong class="jq hj"> n </strong>是给定数组的大小，这是因为我们使用了二分搜索法方法。</li><li id="d938" class="kj kk hi jq b jr ks jv kt jb ku jf kv jj kw ki ko kp kq kr bi translated">空间复杂度:<code class="du mn mo mp ld b">O(1)</code>，因为我们没有使用任何额外的空间来存储元素。</li></ul><p id="2593" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated"><strong class="jq hj">不断学习，不断成长，不断探索！</strong></p><p id="f0e2" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated"><strong class="jq hj">万事如意！</strong></p><p id="a370" class="pw-post-body-paragraph jo jp hi jq b jr lm jt ju jv ln jx jy jb lo ka kb jf lp kd ke jj lq kg kh ki hb bi translated">更多有趣和信息丰富的文章和提示，请关注我的<a class="ae kx" href="https://swapnilkant11.medium.com/" rel="noopener"> <strong class="jq hj"> Medium </strong> </a> <strong class="jq hj">和</strong><a class="ae kx" href="https://www.linkedin.com/in/swapnil-kant-279a3b148/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">Linkedin</strong></a></p></div></div>    
</body>
</html>