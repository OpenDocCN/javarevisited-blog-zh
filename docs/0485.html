<html>
<head>
<title>SOLID Principles Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了坚实的原则</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/solid-principle-explained-de634c6a754?source=collection_archive---------3-----------------------#2020-06-08">https://medium.com/javarevisited/solid-principle-explained-de634c6a754?source=collection_archive---------3-----------------------#2020-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://dev.to/javinpaul/top-10-object-oriented-design-principles-for-writing-clean-code-4pe1"><div class="er es if"><img src="../Images/eb1e9d46c4ecf3a7889085578c3c16d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-cuv19OC_F4_xQid"/></div></a><p class="im in et er es io ip bd b be z dx translated">坚实的原则</p></figure><p id="2d90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">坚实的原则最初是由<strong class="is hj"> <em class="jo"> Robert C Martin </em> </strong>在2000年的论文<a class="ae jp" href="https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf" rel="noopener ugc nofollow" target="_blank">设计原则和设计模式</a>中概念化的。尽管是迈克尔·费哲提出了固体这个缩写词。</p><blockquote class="jq"><p id="705f" class="jr js hi bd jt ju jv jw jx jy jz jn dx translated">在面向对象编程中，SOLID是五个设计原则的首字母缩写，主要是为了使软件设计更容易理解、更灵活、更易维护。—维基百科</p></blockquote><p id="3ea0" class="pw-post-body-paragraph iq ir hi is b it ka iv iw ix kb iz ja jb kc jd je jf kd jh ji jj ke jl jm jn hb bi translated">该原则是下图中给出的五个原则的缩写。</p><figure class="kg kh ki kj fd ij er es paragraph-image"><a href="https://medium.com/swlh/5-free-object-oriented-programming-online-courses-for-programmers-156afd0a3a73"><div class="er es kf"><img src="../Images/4cd7dafe056f376dd04a246d1da413e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5eDjs3mPvoEqQ3nI2V6Ww.png"/></div></a></figure><p id="f9bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些原则将帮助我们减少类之间的紧密耦合。意味着一组应该避免的高度相互依赖的类。</p><h2 id="6834" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">每个原则的详细概念都有示例</h2><p id="ec6d" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">让我们以一位顾客为例，他去了一家餐馆，想要付款。在这里，客户需要什么？</p><ol class=""><li id="363d" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated">账单金额。</li><li id="0030" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">生成的报告/详细报表。</li></ol><p id="d476" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看，如果账单计算和发票生成在同一个类中，RestaurantExample类是什么样子的。</p><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h2 id="415a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">上面例子中的代码有味道</h2><p id="676d" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">在上面的代码中，有不同类型的报告或详细报表，餐馆可以生成客户请求。如果将来餐馆可以生成新类型的报告(EXCEL报告),那么将在<code class="du ma mb mc md b">RestaurantExample </code>类中添加一个名为<em class="jo"> generateReportExcel </em>的新方法。这将导致整个类的重新测试，维护一个新的方法和类中的代码行数是值得关注的。</p><p id="1070" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面提到的上述代码的<strong class="is hj">类图</strong>:</p><figure class="kg kh ki kj fd ij er es paragraph-image"><a href="https://dev.to/javinpaul/5-courses-to-learn-object-oriented-programming-in-2019-l0o"><div class="er es me"><img src="../Images/1d62132834b5f95480b499c464cf95a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2UD3S3IPDN7B8ImbzCi7w.png"/></div></a><p class="im in et er es io ip bd b be z dx translated">餐馆类图示例</p></figure></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="793e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类图应用<a class="ae jp" rel="noopener" href="/javarevisited/10-oop-design-principles-you-can-learn-in-2020-f7370cccdd31"> <strong class="is hj">后的稳固原理</strong> </a> <strong class="is hj"> </strong>在给出的问题语句上提到如下:</p><figure class="kg kh ki kj fd ij er es paragraph-image"><a href="https://medium.com/javarevisited/my-favorite-courses-to-learn-object-oriented-programming-and-design-in-2019-197bab351733?source=collection_home---4------0-----------------------"><div class="er es mm"><img src="../Images/ee204163a049e5d69a826e37580c3f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQZO-02D67pJPFpIOUDdjA.png"/></div></a><p class="im in et er es io ip bd b be z dx translated">餐馆类图示例，Post SOLID原理</p></figure><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="6dd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，<code class="du ma mb mc md b">BillingService </code>类的作用:</p><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="33f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">BillingService类只有<strong class="is hj">一个</strong> <strong class="is hj">职责和一个改变</strong>的原因，那就是为客户计算账单。</p><p id="b9a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，它可以被称为单一责任原则。</p><p id="1ebd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注:</strong>生成报表不是“开单服务”责任，而是“T2”责任。我们将进一步讨论这个问题。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><h1 id="8607" class="mn kl hi bd km mo mp mq kq mr ms mt ku mu mv mw kx mx my mz la na nb nc ld nd bi translated">单一责任</h1><p id="428f" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">单一责任原则规定:</p><blockquote class="jq"><p id="5527" class="jr js hi bd jt ju jv jw jx jy jz jn dx translated">"一个类应该只有一个改变的理由."</p></blockquote><figure class="nf ng nh ni nj ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-java-design-pattern-courses-for-developers.html"><div class="er es ne"><img src="../Images/30d5ded2a2fb48d62ad9e8706a550866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*crtZ0W8BIb2fkhO1.jpg"/></div></a></figure><p id="646f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个类都有一个<strong class="is hj">单一职责</strong>的好处是<strong class="is hj">很少的测试用例、</strong> <strong class="is hj">更少的功能、更少的依赖性、</strong>和<strong class="is hj">易于调试。</strong></p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><h2 id="d029" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">接下来，报告服务、报告生成器接口和报告上下文。</h2><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="4e8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">餐馆支持一组报告格式，如PDF、XML、JSON和CSV。</p><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><figure class="kg kh ki kj fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="0981" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，Restaurant希望在不影响现有行为和代码的情况下，通过引入名为excelReport的新报告生成特性来增强现有功能。</p><p id="2c5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅通过引入一个名为<code class="du ma mb mc md b">ExcelReport</code>的新类，就可以轻松实现这种需求变化。因此，它减少了开发、单元测试和系统测试的时间。</p><p id="12c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着模块的行为可以根据需求的变化进行扩展。但是，扩展模块的行为不会导致模块的源代码或二进制代码发生变化。</p><h1 id="5c39" class="mn kl hi bd km mo nk mq kq mr nl mt ku mu nm mw kx mx nn mz la na no nc ld nd bi translated">开闭原理</h1><p id="9be3" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">开闭原则规定:</p><blockquote class="jq"><p id="d3f7" class="jr js hi bd jt ju jv jw jx jy jz jn dx translated">“软件实体(类、模块、函数等)。)应该对扩展开放，但对修改关闭。”</p></blockquote><figure class="nf ng nh ni nj ij er es paragraph-image"><a href="http://javarevisited.blogspot.sg/2015/07/strategy-design-pattern-and-open-closed-principle-java-example.html#axzz5CqPlkiLV"><div class="er es np"><img src="../Images/afbdaa9a0d4f64f180193a1d3ba1f43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUiW3xtRIvExwaJubcFjUA.png"/></div></a><p class="im in et er es io ip bd b be z dx translated">开闭原理</p></figure></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><h1 id="2805" class="mn kl hi bd km mo mp mq kq mr ms mt ku mu mv mw kx mx my mz la na nb nc ld nd bi translated">界面分离原理</h1><p id="b833" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">界面分离原则规定:</p><blockquote class="jq"><p id="a55d" class="jr js hi bd jt ju jv jw jx jy jz jn dx translated">"具体的类不应该被强制实现不需要的接口."</p></blockquote><figure class="nf ng nh ni nj ij er es paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="er es nq"><img src="../Images/082a3e06cf42ac28cf8947399bc1f33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njEQk7UYUYAqn32MJIAj_w.png"/></div></div><p class="im in et er es io ip bd b be z dx translated">界面分离原理</p></figure><p id="e8e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上面的类图所示，ReportGenerator接口的工作是提供一个抽象，根据餐馆的请求生成各种报告。<code class="du ma mb mc md b">ExcelReport </code>类可以直接实现ReportGenerator接口的抽象，而不是拥有自己的行为。此外，BillingService类可以独立于ReportGenerator接口而存在。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><h1 id="a0d8" class="mn kl hi bd km mo mp mq kq mr ms mt ku mu mv mw kx mx my mz la na nb nc ld nd bi translated">从属倒置原则</h1><p id="8823" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">依赖性反转原则声明:</p><blockquote class="jq"><p id="7a7c" class="jr js hi bd jt ju jv jw jx jy jz jn dx translated">较高级别的模块不应该直接依赖于较低级别的模块，反之亦然。但是，模块应该总是依赖于它的抽象。”</p></blockquote><figure class="nf ng nh ni nj ij er es paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="er es nv"><img src="../Images/9ea1b9772e96cde0e8fe99fa8ac4a61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osnNWWZxR018Fhc13wTBEA.png"/></div></div><p class="im in et er es io ip bd b be z dx translated">依赖注入原理</p></figure><p id="4299" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考上面的类图显示，ReportGenerator接口上下文是通过构造函数注入到ReportContext类中的。ReportGenerator保存报告抽象的类型。</p><h1 id="025d" class="mn kl hi bd km mo nk mq kq mr nl mt ku mu nm mw kx mx nn mz la na no nc ld nd bi translated">利斯科夫替代原理</h1><p id="00e8" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">利斯科夫的替代原理指出:</p><blockquote class="jq"><p id="ce79" class="jr js hi bd jt ju jv jw jx jy jz jn dx translated">"在面向对象的编程中，某个类的任何对象都可以用子类的对象来代替。"</p></blockquote><p id="01e8" class="pw-post-body-paragraph iq ir hi is b it ka iv iw ix kb iz ja jb kc jd je jf kd jh ji jj ke jl jm jn hb bi translated">示例的链接可以在下面提到的GitHub中找到:</p><div class="nw nx ez fb ny nz"><a href="https://github.com/naveenkulkarni029/solid-priniciples" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab dw"><div class="ob ab oc cl cj od"><h2 class="bd hj fi z dy oe ea eb of ed ef hh bi translated">naveenkulkarni 029/固体原理</h2><div class="og l"><h3 class="bd b fi z dy oe ea eb of ed ef dx translated">这个项目是如何在Java中应用SOLID原理的一个例子。S -&gt;单一责任原则O -&gt;…</h3></div><div class="oh l"><p class="bd b fp z dy oe ea eb of ed ef dx translated">github.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ik nz"/></div></div></a></div><p id="7d5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">或</strong></p><p id="1a60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jp" href="https://github.com/naveenkulkarni029/solid-priniciples" rel="noopener ugc nofollow" target="_blank">点击此处</a>进入。</p><h1 id="bfb7" class="mn kl hi bd km mo nk mq kq mr nl mt ku mu nm mw kx mx nn mz la na no nc ld nd bi translated">结论</h1><p id="3c91" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">可靠的编程是开发高度可伸缩、可维护的应用程序的基本原则，它可以避免代码味道。在这些原则的帮助下，开发人员不应该试图重新发明轮子，而应该用已经可用且经过验证的解决方案来实现它。</p></div></div>    
</body>
</html>