<html>
<head>
<title>How I Spun Up 5 Million Virtual Threads Without Stalling The JVM.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何在不停止JVM的情况下启动500万个虚拟线程的。</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/how-i-spun-up-5-million-virtual-threads-without-stalling-the-jvm-1188d806e6bd?source=collection_archive---------0-----------------------#2022-07-19">https://medium.com/javarevisited/how-i-spun-up-5-million-virtual-threads-without-stalling-the-jvm-1188d806e6bd?source=collection_archive---------0-----------------------#2022-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://www.java67.com/2016/08/10-jvm-options-for-java-production-application.html"><div class="er es if"><img src="../Images/a6e9ff2ded823c7c4185856dd40667bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*9xu383t5kMJ3DGpz66y_Rw.gif"/></div></a></figure><p id="f071" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你没看错！这篇文章举例说明了我如何在我的<em class="jk"> M1 Macbook Pro </em>上启动<strong class="io hj">500万个Java虚拟线程</strong>，每个线程休眠<em class="jk"> 100毫秒</em>而不停止<a class="ae jl" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686"> JVM </a>。项目织机使这成为可能。</p><p id="1e99" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我首先从<a class="ae jl" href="https://jdk.java.net/19/" rel="noopener ugc nofollow" target="_blank">这里</a>下载了JDK 19的早期版本(因为截至2022年7月17日该版本尚未发布)。</p><p id="21be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我更喜欢使用<a class="ae jl" rel="noopener" href="/javarevisited/7-best-courses-to-learn-intellij-idea-for-beginners-and-experienced-java-programmers-2e9aa9bb0c05"> Intellij Idea </a>。我确保我运行的是Idea的最新版本。我创建了一个简单的Java项目，项目SDK设置为<em class="jk"> JDK 19 </em>。由于这是我第一次使用JDK 19，我不得不通过按下“<code class="du jm jn jo jp b">Add JDK</code>”按钮，然后按下“<code class="du jm jn jo jp b">Next</code>”按钮来添加新下载并解压缩的JDK(已被添加到<code class="du jm jn jo jp b">/Library/Java/JavaVirtualMachines</code>目录中)。</p><figure class="jr js jt ju fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/09/top-5-courses-to-learn-intellij-idea-java-and-android-development.html"><div class="er es jq"><img src="../Images/80b7e6be825d3bee94f0c5d5a3bb8763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zQ9w0ZVnMKocEAs3ai72A.png"/></div></a></figure><p id="fd2f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我给这个项目起了一个合适的名字，然后点击了“T3”按钮。</p><figure class="jr js jt ju fd ij er es paragraph-image"><a href="https://dev.to/javinpaul/5-best-courses-to-learn-intellij-idea-for-java-developers-5e6n"><div class="er es jq"><img src="../Images/26410df558fdba2e7d92828e9c73482a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppsfVWCJhRJtRMr9tLQbfQ.png"/></div></a></figure><p id="67bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我创建了一个项目结构，如下所示。</p><figure class="jr js jt ju fd ij er es paragraph-image"><a href="https://www.youtube.com/watch?v=g4rPdPxNb5w"><div class="er es jv"><img src="../Images/bcddbca2140c6c3d917b7c0941938f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tf31XumOsm3Oi1M3vXe-qA.png"/></div></a></figure><p id="30e8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<code class="du jm jn jo jp b">App.java</code>内部，我借助新的<code class="du jm jn jo jp b">Thread.startVirtualThread()</code>函数旋转了<strong class="io hj">100万个</strong>虚拟线程(以后会升级到500万个)。</p><pre class="jr js jt ju fd jw jp jx jy aw jz bi"><span id="e52e" class="ka kb hi jp b fi kc kd l ke kf">package com.asavio.loom;<br/><br/>import static java.lang.Thread.<em class="jk">startVirtualThread</em>;<br/><br/>public class App {<br/><br/>    public static void main(String[] args) {<br/>        <em class="jk">startVirtualThreads</em>();<br/>    }<br/><br/>    private static void startVirtualThreads() {<br/>        for (int i = 0; i &lt; 1000000; i++) {<br/>            <em class="jk">startVirtualThread</em>(() -&gt; System.<em class="jk">out</em>.println(Thread.<em class="jk">currentThread</em>()));<br/>        }<br/>    }<br/>}</span></pre><p id="c06e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我运行它时，我看到了下面的错误。</p><pre class="jr js jt ju fd jw jp jx jy aw jz bi"><span id="4bf3" class="ka kb hi jp b fi kc kd l ke kf">java: startVirtualThread(java.lang.Runnable) is a preview API and is disabled by default.</span><span id="513f" class="ka kb hi jp b fi kg kd l ke kf">(use --enable-preview to enable preview APIs)</span></pre><p id="d7a9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了解决这个问题，在<code class="du jm jn jo jp b">Preferences -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Java Compiler</code>下，我取消了<code class="du jm jn jo jp b">Use '--release’</code>选项，并在<code class="du jm jn jo jp b">Additional Command Line parameters</code>文本框中添加了以下内容，点击<code class="du jm jn jo jp b">Apply</code>，然后点击<code class="du jm jn jo jp b">OK</code>。</p><pre class="jr js jt ju fd jw jp jx jy aw jz bi"><span id="8bf6" class="ka kb hi jp b fi kc kd l ke kf">--enable-preview --source 19</span></pre><figure class="jr js jt ju fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/11/hotspot-jvm-options-java-examples.html"><div class="er es jq"><img src="../Images/02d499f6a6e2d77372a44935aec4fccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPQGHkB_C3ljiV6kMqv9oA.png"/></div></a></figure><p id="3a7c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我进入了<code class="du jm jn jo jp b">Run/Debug Configurations</code>菜单，点击了<code class="du jm jn jo jp b">Modify options</code>。它揭示了一堆选择。我检查了“T14”下的“T13”</p><figure class="jr js jt ju fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/05/top-5-courses-to-learn-eclipse-ide-for-java-developers.html"><div class="er es jq"><img src="../Images/df4501db5617e41cfbead72a35298404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrfL23VaBk6DoElb_sepew.png"/></div></a></figure><p id="7dc8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它添加了一个名为“<code class="du jm jn jo jp b">VM Options</code>”的新字段，我在其中添加了以下内容，单击了“<code class="du jm jn jo jp b">Apply</code>”和“<code class="du jm jn jo jp b">OK</code>”</p><pre class="jr js jt ju fd jw jp jx jy aw jz bi"><span id="8f6f" class="ka kb hi jp b fi kc kd l ke kf">--enable-preview</span></pre><figure class="jr js jt ju fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2014/07/top-50-java-multithreading-interview-questions-answers.html"><div class="er es jq"><img src="../Images/cb9b7778635a5adf62835956710578d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIlw2DsSeDqLOXk0pGwidw.png"/></div></a></figure><p id="2261" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我重新运行它时，万岁，它旋转了一百万个虚拟线程！</p><figure class="jr js jt ju fd ij er es paragraph-image"><a href="https://www.java67.com/2012/08/5-thread-interview-questions-answers-in.html"><div class="er es jq"><img src="../Images/63757cb1a40b0533f0082d5c34083d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tsoz9eUL7MhY9hjBXDYYA.png"/></div></a></figure><p id="4983" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了增加趣味，我让每个虚拟线程休眠100毫秒。</p><pre class="jr js jt ju fd jw jp jx jy aw jz bi"><span id="c920" class="ka kb hi jp b fi kc kd l ke kf">package com.asavio.loom;<br/><br/>import static java.lang.Thread.<em class="jk">startVirtualThread</em>;<br/><br/>public class App {<br/><br/>    public static void main(String[] args) {<br/>        <em class="jk">startVirtualThreads</em>();<br/>    }<br/><br/>    private static void startVirtualThreads() {<br/>        for (int i = 0; i &lt; 1000000; i++) {<br/>            <em class="jk">startVirtualThread</em>(() -&gt; {<br/>                System.<em class="jk">out</em>.println(Thread.<em class="jk">currentThread</em>());<br/>                try {<br/>                    Thread.<em class="jk">sleep</em>(100);<br/>                } catch (InterruptedException e) {<br/>                    e.printStackTrace();<br/>                }<br/>            });<br/>        }<br/>    }<br/>}</span></pre><p id="2ff6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下是我运行它时目睹的情况。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/8a55bc81e2b80a36f85e94694ee7114d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*t2fWLt-ad1857aYz9BTspw.gif"/></div></figure><p id="023d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jk">虚拟线程</em>在<code class="du jm jn jo jp b">sleep()</code>或其他大多数阻塞操作被调用时(例如<code class="du jm jn jo jp b">Future.get()</code>)不会阻塞。相反，当它们即将被阻塞时，它们<strong class="io hj">从正在运行的平台线程上卸载</strong>自己，允许其他虚拟线程将自己安装到平台线程上并运行。当虚拟线程准备好恢复执行时(在这种情况下，当睡眠时间耗尽时)，它们会返回到JVM的调度程序。你可以在这里阅读更多关于虚拟线程<a class="ae jl" rel="noopener" href="/javarevisited/is-the-thread-per-request-model-a-good-thing-after-project-loom-6d08012839e8">的内容。</a></p><p id="3a6d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">默认情况下，虚拟线程是<a class="ae jl" href="https://javarevisited.blogspot.com/2012/03/what-is-daemon-thread-in-java-and.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">守护线程</strong> </a>，这意味着JVM不会等待这些线程完成。因此，我收集了线程并<code class="du jm jn jo jp b">join</code>它们，让<a class="ae jl" href="https://www.java67.com/2019/08/best-books-to-learn-java-virtual-machine-in-depth.html" rel="noopener ugc nofollow" target="_blank"> JVM </a>等待那一百万个线程的完成。找到下面更新的<code class="du jm jn jo jp b">startVirtualThreads()</code>功能。</p><pre class="jr js jt ju fd jw jp jx jy aw jz bi"><span id="d9c1" class="ka kb hi jp b fi kc kd l ke kf">package com.asavio.loom;<br/><br/>import java.util.ArrayList;<br/><br/>import static java.lang.Thread.<em class="jk">sleep</em>;<br/>import static java.lang.Thread.<em class="jk">startVirtualThread</em>;<br/><br/>public class App {<br/><br/>    public static void main(String[] args) throws InterruptedException {<br/>    System.<em class="jk">out</em>.println("Main Started");<br/>    <em class="jk">startVirtualThreads</em>();<br/>    System.<em class="jk">out</em>.println("Main Ended");<br/>}<br/><br/>    private static void startVirtualThreads() throws InterruptedException {<br/><br/>        var threads = new ArrayList&lt;Thread&gt;(1000000);<br/><br/>        for (int i = 0; i &lt; 1000000; i++) {<br/>            var thread = <em class="jk">startVirtualThread</em>(() -&gt; {<br/>                System.<em class="jk">out</em>.println(Thread.<em class="jk">currentThread</em>());<br/>                try {<br/>                    <em class="jk">sleep</em>(100);<br/>                } catch (InterruptedException e) {<br/>                    e.printStackTrace();<br/>                }<br/>            });<br/>            threads.add(thread);<br/>        }</span><span id="a832" class="ka kb hi jp b fi kg kd l ke kf">        for (Thread thread : threads) {<br/>            thread.join();<br/>        }<br/>    }<br/><br/>}</span></pre><p id="475f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这将启动并等待创建的所有100万个虚拟线程完成。在屏幕上显示“<em class="jk"> Main Ended </em>”之前，所有虚拟线程都将完成执行。</p><p id="6521" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我删除了剩余的<a class="ae jl" href="https://javarevisited.blogspot.com/2022/05/how-to-print-left-triangle-star-pattern.html" rel="noopener ugc nofollow" target="_blank">打印声明</a>，因为它们会分散注意力。我还将线程数增加到了500万。</p><pre class="jr js jt ju fd jw jp jx jy aw jz bi"><span id="18ab" class="ka kb hi jp b fi kc kd l ke kf">private static void startVirtualThreads() throws InterruptedException {<br/><br/>    var threads = new ArrayList&lt;Thread&gt;(5000000);<br/><br/>    for (int i = 0; i &lt; 5000000; i++) {<br/>        var thread = <em class="jk">startVirtualThread</em>(() -&gt; {<br/>            try {<br/>                <em class="jk">sleep</em>(100);<br/>            } catch (InterruptedException e) {<br/>                e.printStackTrace();<br/>            }<br/>        });<br/>        threads.add(thread);<br/>    }<br/>    for (Thread thread : threads) {<br/>        thread.join();<br/>    }<br/>}</span></pre><p id="b8b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">回答是:</p><pre class="jr js jt ju fd jw jp jx jy aw jz bi"><span id="2786" class="ka kb hi jp b fi kc kd l ke kf">Main Started<br/>Main Ended</span><span id="f236" class="ka kb hi jp b fi kg kd l ke kf">Process finished with exit code 0</span></pre><p id="3e9c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我能够在我的M1机器上运行五百万个虚拟线程。</p></div></div>    
</body>
</html>