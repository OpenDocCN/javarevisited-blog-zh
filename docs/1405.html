<html>
<head>
<title>Filtering a Java Collection by type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按类型过滤Java集合</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/filtering-a-java-collection-by-type-7c1d611d0d95?source=collection_archive---------1-----------------------#2021-07-25">https://medium.com/javarevisited/filtering-a-java-collection-by-type-7c1d611d0d95?source=collection_archive---------1-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9a1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">了解如何在混合的Java集合中过滤特定的类型</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7b3e2a4abd4286a893a15af303d15dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IP-qLI__g3QL32lf"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">亚历克斯·钱伯斯在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="c714" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题是</h1><p id="5d99" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有时你在Java中有一个混合的集合。一个简单的例子是拥有一个<code class="du kx ky kz la b">List&lt;Number&gt;</code>，其中列表可能包含<code class="du kx ky kz la b">Integer</code>、<code class="du kx ky kz la b">Float</code>、<code class="du kx ky kz la b">Long</code>和<code class="du kx ky kz la b">Double</code>实例。如何轻松过滤掉<code class="du kx ky kz la b">List&lt;Integer&gt;</code>或者<code class="du kx ky kz la b">List&lt;Double&gt;</code>？我将演示如何用传统的Java实现这一点，在Java 16中使用instanceof的模式匹配，并使用两种不同的方法处理<a class="ae jt" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>。我还在Switch中添加了一个使用JDK 17 EA和模式匹配的预览解决方案。</p><h1 id="dc69" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决方案:经典Java</h1><p id="eff2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是使用标准Java foreach循环解决问题的一种方法。</p><pre class="je jf jg jh fd lb la lc ld aw le bi"><span id="591c" class="lf jv hi la b fi lg lh l li lj">@Test<br/>public void classicJava()<br/>{<br/>    List&lt;Number&gt; numbers = List.<em class="lk">of</em>(1, 2L, 3.0, 4.0f);<br/>    List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();<br/>    List&lt;Long&gt; longs = new ArrayList&lt;&gt;();<br/>    List&lt;Double&gt; doubles = new ArrayList&lt;&gt;();<br/>    List&lt;Float&gt; floats = new ArrayList&lt;&gt;();<br/>    for (Number each : numbers)<br/>    {<br/>        if (each instanceof Integer)<br/>        {<br/>            integers.add((Integer) each);<br/>        }<br/>        else if (each instanceof Long)<br/>        {<br/>            longs.add((Long) each);<br/>        }<br/>        else if (each instanceof Double)<br/>        {<br/>            doubles.add((Double) each);<br/>        }<br/>        else if (each instanceof Float)<br/>        {<br/>            floats.add((Float) each);<br/>        }<br/>    }<br/><br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(1), integers);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(2L), longs);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(3.0), doubles);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(4.0f), floats);</span></pre><p id="9398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的好处是我们只对数字列表迭代一次。缺点是它非常冗长，并且需要强制转换。</p><h1 id="9e80" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决方案:Java 16 —实例的模式匹配</h1><p id="f701" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">另一个解决问题的方法是在Java 16中使用instanceof的模式匹配。</p><pre class="je jf jg jh fd lb la lc ld aw le bi"><span id="a2c0" class="lf jv hi la b fi lg lh l li lj">@Test<br/>public void patternMatchingForInstanceOfJava16()<br/>{<br/>    List&lt;Number&gt; numbers = List.<em class="lk">of</em>(1, 2L, 3.0, 4.0f);<br/>    List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();<br/>    List&lt;Long&gt; longs = new ArrayList&lt;&gt;();<br/>    List&lt;Double&gt; doubles = new ArrayList&lt;&gt;();<br/>    List&lt;Float&gt; floats = new ArrayList&lt;&gt;();<br/>    numbers.forEach(number -&gt;<br/>    {<br/>        if (number instanceof Integer each)<br/>        {<br/>            <em class="lk">integers</em>.add(each);<br/>        }<br/>        else if (number instanceof Long each)<br/>        {<br/>            <em class="lk">longs</em>.add(each);<br/>        }<br/>        else if (number instanceof Float each)<br/>        {<br/>            <em class="lk">floats</em>.add(each);<br/>        }<br/>        else if (number instanceof Double each)<br/>        {<br/>            <em class="lk">doubles</em>.add(each);<br/>        }<br/>    });<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(1), integers);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(2L), longs);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(3.0), doubles);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(4.0f), floats);<br/>}</span></pre><p id="6b04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做的好处是，我们只对数字列表迭代一次，没有不安全的类型转换。缺点是还是比较啰嗦。这将在Java 17中得到改进，为switch提供模式匹配。</p><h1 id="b4aa" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决方案:Eclipse集合选择实例</h1><p id="ff5c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是使用Eclipse集合中的<code class="du kx ky kz la b">selectInstanceOf</code>解决问题的另一种方法。</p><pre class="je jf jg jh fd lb la lc ld aw le bi"><span id="09dd" class="lf jv hi la b fi lg lh l li lj">@Test<br/>public void selectInstancesOf()<br/>{<br/>    MutableList&lt;Number&gt; numbers = <br/>        Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(1, 2L, 3.0, 4.0f);<br/>    MutableList&lt;Integer&gt; integers =<br/>        numbers.selectInstancesOf(Integer.class);<br/>    MutableList&lt;Long&gt; longs = <br/>        numbers.selectInstancesOf(Long.class);<br/>    MutableList&lt;Double&gt; doubles =<br/>        numbers.selectInstancesOf(Double.class);<br/>    MutableList&lt;Float&gt; floats =<br/>        numbers.selectInstancesOf(Float.class);<br/><br/>    Assertions.<em class="lk">assertEquals</em>(Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(1), integers);<br/>    Assertions.<em class="lk">assertEquals</em>(Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(2L), longs);<br/>    Assertions.<em class="lk">assertEquals</em>(Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(3.0), doubles);<br/>    Assertions.<em class="lk">assertEquals</em>(Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(4.0f), floats);<br/>}</span></pre><p id="e56d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的好处是非常简洁。缺点是它需要对数字列表进行多次迭代。</p><h1 id="ee8c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决方案:Eclipse集合CaseProcedure</h1><p id="b96d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这就是如何使用Eclipse集合中的CaseProcedure来解决这个问题。</p><pre class="je jf jg jh fd lb la lc ld aw le bi"><span id="664e" class="lf jv hi la b fi lg lh l li lj">@Test<br/>public void caseProcedure()<br/>{<br/>    MutableList&lt;Number&gt; numbers =<br/>            Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(1, 2L, 3.0, 4.0f);<br/>    MutableList&lt;Integer&gt; integers = Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.empty();<br/>    MutableList&lt;Long&gt; longs = Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.empty();<br/>    MutableList&lt;Double&gt; doubles = Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.empty();<br/>    MutableList&lt;Float&gt; floats = Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.empty();<br/><br/>    numbers.forEach(new CaseProcedure&lt;&gt;()<br/>            .addCase(Integer.class::isInstance,<br/>                    each -&gt; <em class="lk">integers</em>.add((Integer) each))<br/>            .addCase(Float.class::isInstance,<br/>                    each -&gt; <em class="lk">floats</em>.add((Float) each))<br/>            .addCase(Long.class::isInstance,<br/>                    each -&gt; <em class="lk">longs</em>.add((Long) each))<br/>            .addCase(Double.class::isInstance,<br/>                    each -&gt; <em class="lk">doubles</em>.add((Double) each)));<br/><br/>    Assertions.<em class="lk">assertEquals</em>(Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(1), integers);<br/>    Assertions.<em class="lk">assertEquals</em>(Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(2L), longs);<br/>    Assertions.<em class="lk">assertEquals</em>(Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(3.0), doubles);<br/>    Assertions.<em class="lk">assertEquals</em>(Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(4.0f), floats);<br/>}</span></pre><p id="88ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的优点是相对简洁，并且只需要迭代一次数字列表。缺点是它需要显式和不安全的强制转换。</p><h1 id="e884" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决方案:Java 17—Switch中的模式匹配</h1><p id="edcb" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当Java 17发布后，我们可以在switch中使用模式匹配来解决这个问题。</p><pre class="je jf jg jh fd lb la lc ld aw le bi"><span id="4714" class="lf jv hi la b fi lg lh l li lj">@Test<br/>public void patternMatchingForSwitchJava17()<br/>{<br/>    List&lt;Number&gt; numbers = List.<em class="lk">of</em>(1, 2L, 3.0, 4.0f);<br/>    List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();<br/>    List&lt;Long&gt; longs = new ArrayList&lt;&gt;();<br/>    List&lt;Double&gt; doubles = new ArrayList&lt;&gt;();<br/>    List&lt;Float&gt; floats = new ArrayList&lt;&gt;();<br/>    numbers.forEach(number -&gt; {<br/>            switch(number)<br/>            {<br/>                case Integer each -&gt; <em class="lk">integers</em>.add(each);<br/>                case Float each -&gt; <em class="lk">floats</em>.add(each);<br/>                case Long each -&gt; <em class="lk">longs</em>.add(each);<br/>                case Double each -&gt; <em class="lk">doubles</em>.add(each);<br/>                default -&gt; { break; }<br/>            };<br/>    });<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(1), integers);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(2L), longs);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(3.0), doubles);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(4.0f), floats);<br/>}</span></pre><p id="4f86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的优点是简洁、清晰和单次迭代。我想不出有什么坏处。</p><h1 id="8917" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">实验:Java 17—Switch中的记录、模式匹配、Var和Eclipse集合注入</h1><p id="9d94" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这纯粹是我拿到Java 17 EA安装工作后加的一个思想实验。我想看看在Switch中使用Java记录和Eclipse集合注入模式匹配能做些什么。然后我扔进去<code class="du kx ky kz la b">var</code>只是因为。</p><pre class="je jf jg jh fd lb la lc ld aw le bi"><span id="151f" class="lf jv hi la b fi lg lh l li lj">@Test<br/>public void recordsPatternMatchingInSwitchAndInjectInto()<br/>{<br/>    record Numbers(List&lt;Integer&gt; integers, List&lt;Long&gt; longs,<br/>                   List&lt;Double&gt; doubles, List&lt;Float&gt; floats)<br/>    {<br/>        public Numbers()<br/>        {<br/>            this(<em class="lk">mList</em>(), <em class="lk">mList</em>(), <em class="lk">mList</em>(), <em class="lk">mList</em>());<br/>        }<br/><br/>        Numbers filter(Number number)<br/>        {<br/>            switch(number)<br/>            {<br/>                case Integer each -&gt; integers.add(each);<br/>                case Float each -&gt; floats.add(each);<br/>                case Long each -&gt; longs.add(each);<br/>                case Double each -&gt; doubles.add(each);<br/>                default -&gt; { break; }<br/>            }<br/>            return this;<br/>        }<br/>    }<br/><br/>    var numbers = Lists.<strong class="la hj"><em class="lk">mutable</em></strong>.with(1, 2L, 3.0, 4.0f);<br/>    var filtered = <br/>        numbers.injectInto(new Numbers(), Numbers::filter);<br/><br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(1), filtered.integers);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(2L), filtered.longs);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(3.0), filtered.doubles);<br/>    Assertions.<em class="lk">assertEquals</em>(List.<em class="lk">of</em>(4.0f), filtered.floats);<br/>}</span></pre><h1 id="45ca" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">一些想法</h1><p id="43f2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">基于类型过滤一个混合的Java集合可能是痛苦的，但是作为今天的Java开发人员，我们有一些选择。Eclipse Collections给出了当今最简洁的选项。<code class="du kx ky kz la b">selectInstancesOf</code>方法结合了过滤和更具体的返回类型，缺点是需要对每个子类型进行单独的迭代。<code class="du kx ky kz la b">CaseProcedure</code>给出了当今最简洁、性能最好的选择，但缺点是仍然需要演员阵容。当Java 17在Switch中发布模式匹配时，可用的选项将真正得到改进。Java 17在发布时将提供最简洁和性能最好的选择。</p><p id="def8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk">我是</em><a class="ae jt" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="lk">Eclipse Collections</em></a><em class="lk">OSS项目在</em><a class="ae jt" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="lk">Eclipse Foundation</em></a><em class="lk">的项目负责人和提交人。</em> <a class="ae jt" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="lk">月食收藏</em> </a> <em class="lk">开作</em> <a class="ae jt" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="lk">投稿</em> </a> <em class="lk">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p><p id="86f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他<strong class="ih hj"> Java编程文章</strong>你可能喜欢:<br/><a class="ae jt" rel="noopener" href="/javarevisited/9-things-java-programmers-should-learn-in-2018-3f0b2207dfc4">Java程序员应该学习的10件事</a> <br/> <a class="ae jt" rel="noopener" href="/hackernoon/10-best-programming-languages-to-learn-in-2019-e5b05af4a972">你可以学习的10种编程语言</a> <br/> <a class="ae jt" href="http://www.java67.com/2018/04/10-tools-java-developers-should-learn.html" rel="noopener ugc nofollow" target="_blank"> 10个工具每个Java开发者都应该知道的</a><br/><a class="ae jt" href="http://javarevisited.blogspot.sg/2013/04/10-reasons-to-learn-java-programming.html" rel="noopener ugc nofollow" target="_blank">2021年学习Java编程语言的10个理由</a><br/><a class="ae jt" rel="noopener" href="/javarevisited/the-java-programmer-roadmap-f9db163ef2c2">完整的Java开发者路线图</a> <br/> <a class="ae jt" rel="noopener" href="/javarevisited/top-10-free-interactive-programming-courses-from-educative-for-beginners-to-learn-in-2021-713cbf96d4eb">我最喜欢的初学者免费编程课程</a></p></div></div>    
</body>
</html>