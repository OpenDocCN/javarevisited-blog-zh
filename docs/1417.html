<html>
<head>
<title>Job Scoped Beans in Spring Batch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring批处理中作业范围的Beans</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/job-scoped-beans-in-spring-batch-3fe1dde47531?source=collection_archive---------2-----------------------#2021-07-29">https://medium.com/javarevisited/job-scoped-beans-in-spring-batch-3fe1dde47531?source=collection_archive---------2-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a854b113a6c8d32c39376174cbb6ec4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORRyw4jw_VJ9V6BuSI-YuA.png"/></div></div></figure><p id="e75e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如本文前面所讨论的<a class="ae jo" rel="noopener" href="/javarevisited/step-scoped-beans-in-a-spring-batch-job-570a09184fa5">https://medium . com/Java re visited/step-scoped-beans-in-a-spring-batch-job-570 a 09184 fa 5</a>关于spring批处理作业的边界和生命范围，我们有几个作用域，使得在spring批处理应用程序中定义和重用bean更加容易。</p><p id="8706" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">工作范围就是这样一个由<a class="ae jo" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> spring框架</a>定义的范围。它使我们能够定义生命周期与活动作业实例相关联的beans。该bean是在第一次调用作业时创建的，并在作业终止时销毁。</p><p id="6aa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，作业范围bean的生命周期与活动作业实例的存在相关联。</p><p id="8467" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑下面的例子</p><figure class="jq jr js jt fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/08/top-5-courses-to-learn-spring-mvc-for.html"><div class="er es jp"><img src="../Images/0feee518fae1ef5594360fab6e828744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*8HA0tRXSU00gcFKTZQ-Mng.png"/></div></a></figure><p id="1e20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个从数据库中读取数据、处理数据并将处理后的数据写入文件的任务。</p><p id="e596" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每一步都从数据库中读取数据，并写入不同的文件。我们对所有步骤使用相同的读取器(customItemReader)，对每个步骤使用不同的写入器(<code class="du ju jv jw jx b">customItemWriterforStep1</code>、customItemWriterforStep2、customItemWriterforStep3)</p><figure class="jq jr js jt fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/06/top-6-spring-framework-online-courses-Java-programmers.html"><div class="er es jy"><img src="../Images/7baa98728fe84b8892103cdafe79fb58.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*3pqAMx3aBZqZTxRCX1zcjQ.png"/></div></a></figure><p id="ab45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">.</p><p id="679e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑一个场景，其中我们有几个数据库配置，要从中检索数据的数据库是在运行时指定的。</p><p id="87dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">项目阅读器的配置对于确保从正确的数据库中检索数据至关重要。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/352ca1079dc1208af8060aa0c2d8b68a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtfByMw6yplPsrtzeF4iig.png"/></div></div></figure><p id="ce05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于作业参数env中的参数集，确定用于该作业运行的数据库配置。由于这种配置在整个作业中保持不变，因此在各个步骤之间共享一个实例是有意义的。</p><p id="441e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个作业范围通过确保每次调用作业时都有一个新的实例，并且在各个步骤之间共享同一个实例，使我们的生活变得更加轻松。</p><p id="beea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面分享的例子是一个简单的单线程顺序作业。但是当我们配置一个多线程作业并试图使用一个作业范围的bean时，我们会遇到下面的错误。</p><p id="64de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ju jv jw jx b">Caused by: java.lang.IllegalStateException: No context holder available for job scope</code></p><p id="c303" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">原因是多线程作业使用任务执行器来管理线程。该作业上下文信息存储在<a class="ae jo" href="https://javarevisited.blogspot.com/2012/05/how-to-use-threadlocal-in-java-benefits.html" rel="noopener ugc nofollow" target="_blank">线程本地</a>中，并且不是由默认任务执行器在工作线程中隐式配置的。</p><figure class="jq jr js jt fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2014/07/top-50-java-multithreading-interview-questions-answers.html#axzz6hX6XfwBD"><div class="er es jp"><img src="../Images/8a77e73afaf3a5f874dcd9bd1fc72018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*YP3OQuXLzuAZEk0OVgBncA.png"/></div></a></figure><p id="c038" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">处理这个问题的一种方法是定制任务执行器，在每次创建新线程时，在每个线程上显式配置作业上下文信息。</p><figure class="jq jr js jt fd ij er es paragraph-image"><a href="https://www.java67.com/2016/01/7-differences-between-extends-thread-vs-implements-Runnable-java.html"><div class="er es jp"><img src="../Images/9738061cb5fb68db37e7879140fb69a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*Ba8vKDoxqjqV6Tx2sOGfDg.png"/></div></a></figure><p id="0693" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用JobSynchronisation允许我们在多线程spring作业中使用作业范围的beans。</p><p id="3c36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们如何使应用程序能够保留作业范围beans的信息，方法是让执行器知道作业执行上下文，这反过来又确保所有创建来运行异步任务的线程知道作业执行上下文，并知道作业范围信息的意图。</p></div></div>    
</body>
</html>