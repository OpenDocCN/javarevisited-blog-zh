<html>
<head>
<title>Debugging RAM: Java Garbage Collection — Java Heap Deep Dive, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试RAM: Java垃圾收集— Java堆深度探讨，第1部分</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/debugging-ram-java-garbage-collection-java-heap-deep-dive-part-1-8c140b716cc9?source=collection_archive---------1-----------------------#2022-01-06">https://medium.com/javarevisited/debugging-ram-java-garbage-collection-java-heap-deep-dive-part-1-8c140b716cc9?source=collection_archive---------1-----------------------#2022-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html"><div class="er es if"><img src="../Images/2e65dbb3a16d8d5c291136ad0d3583e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*stC_fezwuKeWKB9oEMSeQQ.jpeg"/></div></a></figure><p id="e4b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有许多关于Java垃圾收集、Java内存使用和一般Java堆的优秀文章。不幸的是，他们到处都是。他们将架构、概念和问题解决作为独立的部分混合在一起。许多材料已经过时，或者不包含解决垃圾收集器问题的实用信息。例如暂停时间、堆空间使用等。</p><p id="14c0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这篇文章中，我不会讨论内存泄漏。它们很重要，但这是一个不同的主题，我想在一篇文章中单独讨论。</p><h1 id="6567" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">垃圾收集器权衡</h1><p id="bada" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">GC是惊人的，未被引用的对象在一个自动的过程中被收集。但是垃圾收集仍然要做一些权衡:</p><ul class=""><li id="25ac" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">内存占用</li><li id="897d" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">暂停</li><li id="a4a3" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">表演</li></ul><p id="51b5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">挑两个吧。垃圾收集器可以权衡RAM以提供更快的性能和更少的GC延迟。在这篇文章中，我将讨论挑选和调优GC的策略。</p><p id="bdb5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通常，当我们想要选择一个库时，我们只需要做一个基准测试。但是对GC进行基准测试要困难得多。如果我们让一个GC过载，我们可能最终得到一个可以很好地处理压力的GC，但是对于典型的内存分配来说不是最佳的。理解垃圾收集器是如何工作的，以及我们用“真实世界”的工作负载来分析GC是至关重要的。</p><h1 id="e1e6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">不是你的父亲阻止了世界大扫荡</h1><p id="1a3c" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">自从Java 1.0终结了世界GC以来，Java GC已经走过了漫长的道路。虽然有许多类型的垃圾收集器，但大多数新的垃圾收集器都是分代的、并行/并发的。当在我们的本地机器上工作时，这似乎并不重要。但是当GCing非常大的堆时，这种差异是非常明显的。</p><p id="3d3d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">GCs“无缝地”检测未使用的对象以回收堆空间。但是也有权衡。何时将一个对象视为“未使用的对象”是核心内存管理权衡。</p><h1 id="1924" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">分代垃圾收集</h1><p id="3ab6" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">大多数现代GCs假设对象生命周期符合世代范式。老一代空间物体寿命很长，很少被收集。他们不需要频繁扫描。年轻一代对象生老病死很快。经常在一起。</p><p id="664b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">分代垃圾收集(通常)更频繁地遍历年轻一代，并特别注意各代之间的联系。这一点很重要，因为在较小的垃圾收集周期中需要扫描的区域较少。相对于完整的GC周期，较短周期的术语是增量GC。GC通常会尽量减少完整的GC周期。</p><h1 id="2aa1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">并发与并行垃圾收集器</h1><p id="e4e1" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">并行GC经常与并发GC混淆。更令人困惑的是，一个GC既可以是并行GC，也可以是并发GC(例如G1)。</p><p id="ceeb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不过区别很简单:</p><ul class=""><li id="fdf2" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">并行GC有多个GC线程。GC线程执行实际的垃圾回收。它们对于大规模收集至关重要</li><li id="5379" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">并发GC允许JVM在标记阶段或者其他阶段做其他事情</li></ul><p id="273b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">直觉上，我们大多数人都希望一直拥有这两者，并充分利用应用程序线程。但这并不总是正确的选择。并发性和多个应用程序线程会产生开销。此外，这些GC经常做出权衡，错过一些不可到达的对象，并使一些堆内存在更长的时间内不被回收。明确地说，他们会在一个完整的GC周期中找到所有未使用的内存，但是他们会尽量避免这样的周期，这样您可能会付出代价。</p><p id="e182" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下是截至JDK 17年的大型GC。</p><h1 id="44ec" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">串行收集器</h1><p id="ef1f" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">这是一个单线程垃圾收集器。这意味着它比大多数GC稍快，但会导致更多的停顿。如果您正在进行性能基准测试，那么打开这个GC来减少差异是有意义的。因为几乎所有的CPU都是多核的，所以这种GC对于大多数真实世界的部署来说并不有用，但是它使得调试一些行为变得更加容易。</p><p id="7154" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在一种情况下，串行收集器可能会给生产带来很大好处，那就是无服务器工作负载(例如lambdas等。).在这些情况下，最小/最快的解决方案胜出，这可能是在单核虚拟机上使用有限物理内存的正确解决方案。</p><p id="7a3f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，尽管串行收集器相对简单，但它是一个分代的GC。因此，它比旧的Java GCs要现代得多。</p><p id="1a8a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以使用<code class="du lb lc ld le b">-XX:+UseSerialGC</code>明确地打开这个GC。</p><h1 id="8c29" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">并行收集器又名吞吐量收集器</h1><p id="a333" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">相当于串行收集器的多线程。这是一个很好的收集器，可以用于生产，但还有更好的。串行收集器更适合基准测试，ZGC/G1通常提供更好的性能。</p><p id="ae4f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以使用<code class="du lb lc ld le b">-XX:+UseParallelGC</code>选项明确地打开这个GC。</p><p id="d816" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">并行GC的一大好处是它的可配置性。您可以使用以下JVM选项来优化它:</p><ul class=""><li id="ff47" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated"><code class="du lb lc ld le b">-XX:ParallelGCThreads=ThreadCount</code> -收集器使用的GC线程数量</li><li id="1221" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated"><code class="du lb lc ld le b">-XX:MaxGCPauseMillis=MaxDurationMilliseconds</code> -以毫秒为单位限制GC暂停。这默认为无限制</li><li id="bf0d" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated"><code class="du lb lc ld le b">-XX:GCTimeRatio=ratio</code> -在<code class="du lb lc ld le b">1/(ratio + 1)</code>中设置专用于GC的时间，因此<code class="du lb lc ld le b">9</code>的值意味着<code class="du lb lc ld le b">1 / (9 + 1)</code>或<code class="du lb lc ld le b">10%</code>。所以<code class="du lb lc ld le b">10%</code>的CPU时间会花在GC上。默认值为<code class="du lb lc ld le b">99</code>，即<code class="du lb lc ld le b">1%</code></li></ul><h1 id="3fd7" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">G1垃圾收集器</h1><p id="97f0" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">G1垃圾收集器是一个重型GC，设计用于具有大堆大小(大约6GB或更高)的机器上的大工作负载。它试图适应给定机器中的工作条件。您可以使用JVM选项<code class="du lb lc ld le b">-XX:+UseG1GC</code>显式地启用它。</p><p id="50cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">G1是一个并发GC，它在后台工作，最大限度地减少暂停。它的一个更酷的特性是字符串重复数据删除，这减少了RAM中字符串的开销。您可以使用<code class="du lb lc ld le b">-XX:+UseStringDeduplication</code>激活该功能。</p><h1 id="a6cc" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">z垃圾收集器(ZGC)</h1><p id="5c76" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在JVM的最新版本之前，ZGC一直是试验性的。它是为比G1更大的堆大小而设计的，也是一个并发GC。它支持较小的环境，可用于从8mb到16TB的堆大小！</p><p id="0e45" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它最大的特点之一是它不会暂停应用程序超过10毫秒。代价是吞吐量的降低。</p><p id="ab1a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以使用<code class="du lb lc ld le b">-XX:+UseZGC</code> JVM选项启用ZGC。</p><h1 id="5535" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">挑选和调试垃圾收集器</h1><p id="13e7" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Java 8使用了<code class="du lb lc ld le b">-verbose:gc</code>标志来生成GC日志和<code class="du lb lc ld le b">-XX:+PrintGCDetails</code>标志。</p><p id="83a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">较新的JDK使用<code class="du lb lc ld le b">-Xlog:gc:file.log</code>,它将GC细节打印到给定的文件中。通过启用这些特性并正常运行您的应用程序，您可以跟踪GC行为并适当地调优您的代码/部署。</p><p id="96c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不久前，我遇到了GCeasy，这是一个非常好地分析GC日志的网站。还有几个类似的工具，它们可以为你提供一些有趣的信息。然而，日志文件也是可以直接阅读的，您可以从阅读它中学到很多东西。</p><p id="d2eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，您可以使用JVM选项获得更详细的GC信息:</p><pre class="lg lh li lj fd lk le ll lm aw ln bi"><span id="604f" class="lo jl hi le b fi lp lq l lr ls">-Xlog:gc*=debug:file=gc-verbose.log</span></pre><p id="9a27" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，在Linux/Unix上，您需要用引号将这个命令括起来，这样shell就不会试图展开它。</p><p id="7164" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用详细输出，您可以更深入地了解GC的内部工作方式，并且可以继续调优JVM堆。事实上，我建议任何JVM开发人员至少尝试一次这个标志，以了解Java堆空间的内部工作方式。</p><h1 id="9678" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">基准/测量</h1><p id="4a99" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">正如我之前提到的，对于应用程序性能基准来说，GC很糟糕。如果我们只是使用常规基准测试，串行GC通常会胜出，尽管它不应该是我们大多数人的首选。诀窍是使用真实的负载，然后查看GC日志。</p><p id="563a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们可以根据每个GC提供的统计数据，决定我们愿意接受的折衷方案。注意，我们也可以将自己限制在外部指标上，比如CPU和RAM的使用情况。这可能是一个非常好的方法。然而，进行重负载测试可能不是GC性能的最佳表现。要明确的是，你仍然应该做一个重负荷测试。</p><h1 id="fd6f" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">GC调优</h1><p id="e221" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">几乎所有Java开发人员在调优内存时做的第一件事就是定义最大大小和最小大小。使用已经存在了几十年的JVM参数<code class="du lb lc ld le b">-Xmx</code>和- <code class="du lb lc ld le b">Xms</code>很容易确定初始堆大小。</p><p id="95a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一种常见的方法是将两者设置为相同的大小。这不一定是坏事。它简化了GC中的内存管理逻辑，现在只关注一个值。不过，这确实会带来风险。这意味着没有犯错的余地。</p><p id="6fb0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以通过应用程序代码实现最重要的性能提升。性能问题落到GC标志调优上的情况非常罕见(尽管这种情况可能会发生)。</p><h1 id="2d84" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">减少RAM的使用</h1><p id="9f19" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">大多数开发人员喜欢减少垃圾收集时间，但是对于一些人来说，内存消耗是一个更大的问题。如果您在受限环境中运行，例如微服务或无服务器容器。您可以使用以下Java标志来解决内存不足的问题:</p><ul class=""><li id="1e73" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">减小默认为<code class="du lb lc ld le b">70%</code>的<code class="du lb lc ld le b">-XX:MaxHeapFreeRatio</code>和默认为<code class="du lb lc ld le b">40%</code>的<code class="du lb lc ld le b">-XX:MinHeapFreeRatio</code>的值。最大值可以减少到<code class="du lb lc ld le b">10%</code></li><li id="8767" class="kn ko hi io b ip kw it kx ix ky jb kz jf la jj ks kt ku kv bi translated">您可以使用<code class="du lb lc ld le b">-XX:-ShrinkHeapInSteps</code>,这将更频繁地触发GC，并以牺牲性能为代价降低内存使用</li></ul><h1 id="ea0b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">世代优化</h1><p id="265f" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">通常，当您添加RAM时，大多数Java应用程序的性能会更好。但是有时大量的RAM会触发很长时间的GC暂停，有时甚至会触发超时。</p><p id="7b5b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">停滞的一个重要来源是完整的GC周期，如果GC无法为年轻/幸存代构建正确的内存池，就会发生这种情况。例如，如果你有一个快速创建和丢弃对象的应用程序，你可能需要比老一代更年轻的一代。你可以使用<code class="du lb lc ld le b">-XX:NewRatio</code>来调整它，让你定义老一代和年轻一代之间的比例。这默认为2，这意味着新一代的大小是老一代的两倍。</p><p id="0674" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您还可以调整-XX:NewSize值，该值指定专用于新一代的RAM数量。</p><h1 id="c30a" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">元空间、永久生成、堆栈大小等。</h1><p id="d68c" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">从技术上讲，这些不是GC的一部分，但是它们经常与Java堆内存相关的问题混淆在一起，所以这是讨论它们的好地方。</p><p id="13a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您有一个线程繁重的应用程序，您可能要考虑减少堆栈大小(如果适用)。通常栈的大小被调整为允许更大的大小，这让我们支持深度递归算法。</p><p id="66ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">用Java 8 PermGen(又名永久一代)终于被干掉了。PermGen是一个存储类文件和元数据的特殊内存空间。我们偶尔不得不为动态生成字节码的应用程序调整它，因为如果有太多的类文件，它会触发内存错误。新的Metaspace具有自动内存管理功能，解决了PermGen中的大部分问题。</p><p id="b2b0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们仍然可以使用提示<code class="du lb lc ld le b">-XX:MaxMetaspaceSize</code>来设置元空间的大小。</p><p id="ab82" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将应用程序适当地调优到GC是很重要的。减少本机代码(和终结器)、弱引用、软引用和幻像引用的使用。所有这些特性都会增加GC的开销。虽然公平地说，在服务器上的大多数情况下，这些都不是决定性因素。</p><h1 id="15e5" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">瓦尔哈拉的未来</h1><p id="eff3" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">GC是惊人的，但是在Java堆内存性能方面存在一些边缘情况。</p><p id="3998" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，如果我们用C和Java编写本机内存处理，我们可以获得与本机代码大致相当的性能，如下所示:</p><pre class="lg lh li lj fd lk le ll lm aw ln bi"><span id="9bbe" class="lo jl hi le b fi lp lq l lr ls">int[] myArray = new int[2000];</span></pre><p id="6566" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在某些情况下，由于Javas快速分配器代码和原语支持，这比C执行得更快。</p><p id="0146" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这种情况不适用于:</p><pre class="lg lh li lj fd lk le ll lm aw ln bi"><span id="e3ca" class="lo jl hi le b fi lp lq l lr ls">Integer myArray = new Integer[2000];</span></pre><p id="bc24" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或用于:</p><pre class="lg lh li lj fd lk le ll lm aw ln bi"><span id="542f" class="lo jl hi le b fi lp lq l lr ls">Point[] myPointArray = new Point[2000];</span></pre><p id="9f8f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在C++中，我们可以定义一个堆栈对象，它的内存直接连接到它的父对象。无论是堆栈框架还是包含它的对象。这有它的缺点，因为数据需要被复制，它不再只是一个指针。但是数据位于相同的页面甚至寄存器中，因此不存在内存碎片，开销也非常低。</p><p id="a8f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是瓦尔哈拉试图解决的巨大问题的一部分。它将增加将对象定义为值或原语的能力，这将让我们将它们定义为其他东西的一部分。这将有效地消除<code class="du lb lc ld le b">Optional</code>和原始包装器的开销。这也将使可空性变得更加微妙。</p><p id="fb94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对GC的影响也将是巨大的。想象一个由2000个点对象组成的数组作为一个单一的操作…</p><p id="e375" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是Java SE在语言和虚拟机方面的一个巨大变化。因此，我过去对此一直持观望态度。但是在阅读了一些与项目相关的<a class="ae lf" href="https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2021-December/001747.html" rel="noopener ugc nofollow" target="_blank">材料后，我持谨慎乐观的态度。</a></p><h1 id="a12d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="15ff" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">垃圾收集器线程很少是你的应用程序性能差甚至内存不足的原因。对于<code class="du lb lc ld le b">99.9%</code>的情况，原因可能在应用程序代码中。不要指望命令行选项会神奇地修复问题。</p><p id="fdde" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，这些工具允许您从GC的角度跟踪应用程序的内部工作。当您在JVM进程中遇到内存问题时，您可以使用这些工具来缩小范围。</p><p id="1ba5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">尽管如此，GC暂停是一个真正的问题，可能会导致生产失败。尤其是在非常大的堆中。同样，您需要首先检查内存中的对象，但是理解虚拟机对内存的权衡是至关重要的。</p><h2 id="0ce3" class="lo jl hi bd jm lt lu lv jq lw lx ly ju ix lz ma jy jb mb mc kc jf md me kg mf bi translated">了解更多信息</h2><p id="cc56" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在<a class="ae lf" href="https://twitter.com/debugagent/" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，了解更多信息并获取未来帖子的更新。</p></div></div>    
</body>
</html>