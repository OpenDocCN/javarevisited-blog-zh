<html>
<head>
<title>Database Integration Testing with Testcontainers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Testcontainers进行数据库集成测试</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/database-integration-testing-with-testcontainers-8b4be2404a55?source=collection_archive---------2-----------------------#2021-10-28">https://medium.com/javarevisited/database-integration-testing-with-testcontainers-8b4be2404a55?source=collection_archive---------2-----------------------#2021-10-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/56e37889004ecefaf07f0469e39af5c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vpcO8LZX4FA8AyGGZN-khw.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">用Testcontainers进行数据库集成测试</p></figure><h1 id="d4f0" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="2afb" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在本文中，我们将关注Testcontainers，以及如何使用它来为您的集成测试构建一次性测试数据库。您将看到Testcontainers为内存数据库(如H2)提供了一个很好的替代方案。</p><p id="e690" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">在内存中，数据库在速度和简单性方面有优势，但是有一个根本性的缺点。您的集成测试使用的数据库技术与您的应用程序将在生产中使用的数据库技术有很大不同。Testcontainers允许您旋转您选择的数据库，以便您的持久性测试运行在您将在生产中使用的相同数据库技术上。这使你的测试更加可信，并降低风险。</p><p id="a516" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">注意:除了数据库，Testcontainers还支持很多其他技术，比如Rabbit MQ、Kafka和Elasticsearch。本文将关注数据库支持。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="107e" class="iu iv hi bd iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr bi translated">Spring Boot演示应用程序</h1><p id="c4e0" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">为了演示如何在典型的Java项目中使用Testcontainers，我创建了一个简单的Spring Boot REST API来创建和检索客户。REST API使用Hibernate持久层与MySQL数据库对话。我将向您展示如何使用Testcontainers来支持持久层集成测试和端到端测试。</p><p id="441d" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">完整的源代码可以在<a class="ae lh" href="https://github.com/reachansari/spring-boot-testcontainers-db-it" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到，所以在你进一步研究之前，请随意下载。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="9c3d" class="iu iv hi bd iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr bi translated">Rest API</h1><p id="69ab" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">REST API使用一个<strong class="ju hj"> <em class="li">客户道</em> </strong>来创建和读取<strong class="ju hj"> <em class="li">客户</em> </strong>实体。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="5bb4" class="ls iv hi lo b fi lt lu l lv lw">@Slf4j<br/>@RestController<br/>@AllArgsConstructor<br/>public class CustomerController {</span><span id="0806" class="ls iv hi lo b fi lx lu l lv lw">  private CustomerDao customerDao;</span><span id="137e" class="ls iv hi lo b fi lx lu l lv lw">  @PostMapping(path = "/api/customer")<br/>  public Customer createCustomer(@RequestBody Customer customer) {<br/>    log.info("saving [{}]", customer);<br/>    Long persistedCustomerId = customerDao.save(customer);<br/>    log.info("returning [{}]", persistedCustomerId);<br/>    return customerDao.findById(persistedCustomerId).get();<br/>  }</span><span id="af66" class="ls iv hi lo b fi lx lu l lv lw">  @GetMapping(path = "/api/customer/{id}")<br/>  public Customer getCustomer(@PathVariable("id") Integer customerId) {<br/>    log.info("retrieving customer Id [{}]", customerId);<br/>    Optional &lt;Customer&gt; customer = customerDao.findById(Long.valueOf(customerId));<br/>    log.info("returning [{}]", customer);<br/>    return customer.orElseThrow(() -&gt; new RuntimeException("customer not found for Id " + customerId));<br/>  }<br/>}</span></pre><h1 id="7780" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">顾客道</h1><p id="c9c6" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated"><strong class="ju hj"> <em class="li">客户道</em> </strong>提供了按客户Id查询、按名字查询和保存<strong class="ju hj"> <em class="li">客户</em> </strong>的方法。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="ad38" class="ls iv hi lo b fi lt lu l lv lw">@Repository<br/>@AllArgsConstructor<br/>public class CustomerDao {</span><span id="4a5c" class="ls iv hi lo b fi lx lu l lv lw">  private SessionFactory sessionFactory;</span><span id="9750" class="ls iv hi lo b fi lx lu l lv lw">  @Transactional<br/>  public List &lt;Customer&gt; findByLastName(final String lastName) {<br/>    Query &lt;Customer&gt; query = sessionFactory.getCurrentSession()<br/>      .createQuery("From Customer Where lastName= :lastName")<br/>      .setParameter("lastName", lastName);<br/>    return query.list();<br/>  }</span><span id="a352" class="ls iv hi lo b fi lx lu l lv lw">  @Transactional<br/>  public Optional &lt;Customer&gt; findById(Long customerId) {<br/>    return Optional.ofNullable(sessionFactory.getCurrentSession().get(Customer.class, customerId));<br/>  }</span><span id="358c" class="ls iv hi lo b fi lx lu l lv lw">  @Transactional<br/>  public Long save(Customer customer) {<br/>    return (Long) sessionFactory.getCurrentSession().save(customer);<br/>  }<br/>}</span></pre></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="0250" class="iu iv hi bd iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr bi translated">测试演示应用</h1><p id="1086" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在编写任何集成或端到端测试之前，我们将创建一个定制的测试容器，以便我们可以启动MySQL数据库。</p><p id="fdc9" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><strong class="ju hj"> <em class="li">定义一个定制的测试容器</em> </strong> <br/>对于简单的用例来说，Testcontainers附带了一组预定义的数据库容器，您可以开箱即用。例如，默认的<strong class="ju hj"><em class="li">MySQL container</em></strong>容器可以添加到您的测试中，如下所示。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="94ba" class="ls iv hi lo b fi lt lu l lv lw">private static MySQLContainer sqlContainer = new MySQLContainer&lt;&gt;(“mysql:8.0”);</span></pre><p id="1655" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">如果您需要更多的控制，比如访问启动和关闭挂钩，您可以通过扩展一个标准容器来定义自己的测试容器。下面我用<strong class="ju hj"><em class="li">custom MySQL container</em></strong>就是这么做的。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="694d" class="ls iv hi lo b fi lt lu l lv lw">@Slf4j<br/>public class CustomMySqlContainer extends MySQLContainer &lt;CustomMySqlContainer&gt; {</span><span id="73bc" class="ls iv hi lo b fi lx lu l lv lw">  <strong class="lo hj"><em class="li"># Step 1</em></strong><br/>  private static final String DB_IMAGE = "mysql:5.7";</span><span id="062f" class="ls iv hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="li">  # Step 2</em></strong><br/>  private static CustomMySqlContainer mysqlContainer;</span><span id="172d" class="ls iv hi lo b fi lx lu l lv lw">  <strong class="lo hj"><em class="li"># Step 3</em></strong><br/>  private CustomMySqlContainer() {<br/>    super(DB_IMAGE);<br/>  }</span><span id="225d" class="ls iv hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="li">  # Step 4</em></strong><br/>  public static synchronized CustomMySqlContainer getInstance() {<br/>    if (mysqlContainer == null) {<br/>      mysqlContainer = new CustomMySqlContainer();<br/>    }<br/>    return mysqlContainer;<br/>  }</span><span id="80ef" class="ls iv hi lo b fi lx lu l lv lw"> <strong class="lo hj"><em class="li"> # Step 5</em></strong><br/>  @Override<br/>  public void start() {<br/>    super.start();<br/>    System.setProperty("TEST_DB_URL", mysqlContainer.getJdbcUrl());<br/>    System.setProperty("TEST_DB_USERNAME", mysqlContainer.getUsername());<br/>    System.setProperty("TEST_DB_PASSWORD", mysqlContainer.getPassword());</span><span id="34cb" class="ls iv hi lo b fi lx lu l lv lw">log.info("started MySql container TEST_DB_URL [{}] TEST_DB_USERNAME [{}] TEST_DB_PASSWORD [{}]");<br/>  }</span><span id="98bb" class="ls iv hi lo b fi lx lu l lv lw"> <strong class="lo hj"><em class="li"> # Step 6</em></strong><br/>  @Override<br/>  public void stop() {}<br/>}</span></pre><p id="01fc" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><strong class="ju hj"> <em class="li">第一步</em> </strong> —定义我要在测试容器中运行的Docker映像。这里我指定了mysql:5.7，它将从公共Docker Hub repo中提取。在企业环境中，您可以从私有企业容器存储库中指定一个映像。<br/> <strong class="ju hj"> <em class="li">第二步</em> </strong> —将CustomMysqlContainer定义为静态。这是为了让我们可以将CustomMysqlContainer创建为单例。<br/> <strong class="ju hj"> <em class="li">第三步</em> </strong> —私有构造函数使用指定的映像创建MysqlContainer的实例。<br/> <strong class="ju hj"> <em class="li">步骤4</em></strong>—synchronized getInstance方法创建一个CustomMysqlContainer singleton。<br/> <strong class="ju hj"> <em class="li">步骤5 </em> </strong> —是一个容器启动事件挂钩，启动后可以使用它来访问容器。这是获取测试中可能需要的容器元数据的一个好方法。我还从容器中获取URL、用户名和密码，并将它们设置为系统属性，以便以后在Spring配置文件application.yaml中引用它们。这允许我们获得关于测试容器的重要信息，并在Spring bootstraps之前将其作为环境变量公开。<br/> <strong class="ju hj"> <em class="li">步骤6 </em> </strong> —调用父容器类上的stop。</p><p id="2e5c" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">注意<strong class="ju hj"><em class="li">custommysql container</em></strong>是一个通用组件，因此将这个类添加到每个项目中是没有意义的。相反，它可以被添加到一个utils Jar中，并跨项目重用。</p><p id="8ac2" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们现在有了一个定制的测试容器，可以在任何需要的时候使用它来启动MySQL实例。接下来，我们将看看如何将<strong class="ju hj"><em class="li">custommysql container</em></strong>用作DAO集成测试的一部分。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="4d95" class="iu iv hi bd iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr bi translated"><strong class="ak"> <em class="ly">定制道集成测试与测试容器</em> </strong></h1><p id="4139" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">CustomerDaoTests是一个标准的Spring Boot集成测试，它使用JUnit 5和我们在上面创建的自定义<strong class="ju hj"><em class="li">custommysql container</em></strong>。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="fd78" class="ls iv hi lo b fi lt lu l lv lw"><strong class="lo hj"><em class="li"># Step 1</em></strong><br/>@SpringBootTest</span><span id="a652" class="ls iv hi lo b fi lx lu l lv lw"><strong class="lo hj"><em class="li"># Step 2</em></strong><br/>@Testcontainers</span><span id="a867" class="ls iv hi lo b fi lx lu l lv lw">class CustomerDaoTests {<br/>  @Autowired<br/>  private CustomerDao customerDao;</span><span id="1dc0" class="ls iv hi lo b fi lx lu l lv lw">  <strong class="lo hj"><em class="li"># Step 3</em></strong><br/>  @Container<br/>  public static CustomMySqlContainer mySqlContainer = CustomMySqlContainer.getInstance()<br/>    .withInitScript("database/customer-schema.sql");</span><span id="4851" class="ls iv hi lo b fi lx lu l lv lw">  <strong class="lo hj"><em class="li"># Step 4</em></strong><br/>  @Test<br/>  public void should_returnCustomers_with_LastNameJones() {<br/>    List &lt;Customer&gt; customers = customerDao.findByLastName("jones");<br/>    assertThat(customers.get(0).getFirstName(), is("Jack"));<br/>    assertThat(customers.get(0).getLastName(), is("jones"));<br/>    assertThat(customers.get(0).getDob(), is(LocalDate.of(1990, 01, 11)));<br/>    assertThat(customers.get(0).getGender(), is("male"));<br/>  }</span><span id="c449" class="ls iv hi lo b fi lx lu l lv lw">  <strong class="lo hj"><em class="li"># Step 5</em></strong><br/>  @Test<br/>  public void should_returnSavedCustomer() {<br/>    Customer customer = new Customer();<br/>    customer.setFirstName("Olivia");<br/>    customer.setLastName("mia");<br/>    customer.setDob(LocalDate.of(2001, 10, 19));<br/>    customer.setGender("female");<br/>    customerDao.save(customer);<br/>    List &lt;Customer&gt; customers = customerDao.findByLastName("mia");<br/>    assertThat(customers.get(0).getFirstName(), is("Olivia"));<br/>    assertThat(customers.get(0).getLastName(), is("mia"));<br/>    assertThat(customers.get(0).getDob(), is(LocalDate.of(2001, 10, 19)));<br/>    assertThat(customers.get(0).getGender(), is("female"));<br/>  }<br/>}</span></pre><p id="1ad2" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><strong class="ju hj"> <em class="li">第一步</em></strong>——@ Spring Boot test是加载Spring test应用上下文的标准引导注释。测试应用程序上下文包括应用程序中所有的Spring托管组件，并允许我们注入@CustomerDao测试主题。<br/> <strong class="ju hj"> <em class="li">第二步</em></strong>——@ test containers是JUnit 5 Jupiter的扩展。它扫描测试中用@Container注释的字段，并调用注释容器引用的生命周期方法。<br/> <strong class="ju hj"> <em class="li">第三步</em></strong>——@ Container用于标记我们之前创建的CustomMySqlContainer。这确保了Testcontainers将调用CustomMySqlContainer上的生命周期方法来启动和停止测试的一部分。CustomMySqlContainer被定义为一个静态字段，因此它在类中的所有测试方法之间共享。如果我们将CustomMySqlContainer定义为一个实例字段，那么将为每个测试方法启动和停止一个新的容器实例。<strong class="ju hj"> <em class="li">。withInitScript(" database/customer-schema . SQL ")</em></strong>将一个初始化脚本传递给容器，容器一启动就对数据库运行。这是创建模式和设置测试数据的理想挂钩。<br/> <strong class="ju hj"> <em class="li">第4步</em> </strong> —一个简单的DAO测试，按姓氏Jones检索客户。为了让这些数据存在于数据库中，我们在启动时使用customer-schema.sql脚本将其植入。<br/> <strong class="ju hj"> <em class="li">第五步</em> </strong> —通过创建一个客户然后检索它来测试保存方法。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="20d2" class="iu iv hi bd iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr bi translated">使用Testcontainers进行端到端测试</h1><p id="2995" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">Testcontainers对于编写可信的端到端测试也很有用。该模式几乎与上述<strong class="ju hj"> <em class="li">客户测试</em> </strong>中描述的模式相同。然而，这一次，我们正在测试我们的API端到端，包括dta访问层。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="6a69" class="ls iv hi lo b fi lt lu l lv lw">@Testcontainers<br/>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br/>class CustomerAPITest {</span><span id="80f0" class="ls iv hi lo b fi lx lu l lv lw">@Autowired<br/>private TestRestTemplate restTemplate;</span><span id="51c6" class="ls iv hi lo b fi lx lu l lv lw">@Container<br/>public static CustomMySqlContainer mySqlContainer = CustomMySqlContainer.getInstance()<br/>    .withInitScript("database/customer-schema.sql");</span><span id="20b8" class="ls iv hi lo b fi lx lu l lv lw">@Test<br/>public void should_returnCustomer_forCustomerId_1() {</span><span id="ba80" class="ls iv hi lo b fi lx lu l lv lw">ResponseEntity &lt;Customer&gt; customerResponse = restTemplate.getForEntity("/api/customer/1", Customer.class);</span><span id="5b49" class="ls iv hi lo b fi lx lu l lv lw">assertThat(customerResponse.getStatusCode(), is(HttpStatus.OK));</span><span id="313b" class="ls iv hi lo b fi lx lu l lv lw">assertThat(customerResponse.getBody().getFirstName(), is("Jack"));<br/>    assertThat(customerResponse.getBody().getLastName(), is("jones"));<br/>    assertThat(customerResponse.getBody().getDob(), is(LocalDate.of(1990, 01, 11)));<br/>    assertThat(customerResponse.getBody().getGender(), is("male"));<br/>  }</span><span id="e1e6" class="ls iv hi lo b fi lx lu l lv lw">@Test<br/>  public void should_saveCustomer_andReturnNewEntity() {</span><span id="087a" class="ls iv hi lo b fi lx lu l lv lw">Customer customer = new Customer();<br/>    customer.setFirstName("Olivia");<br/>    customer.setLastName("mia");<br/>    customer.setDob(LocalDate.of(2001, 10, 19));<br/>    customer.setGender("female");</span><span id="1de1" class="ls iv hi lo b fi lx lu l lv lw">HttpEntity customerEntity = new HttpEntity &lt; &gt; (customer);</span><span id="1c0c" class="ls iv hi lo b fi lx lu l lv lw">ResponseEntity &lt; Customer &gt; savedCustomerResponse = restTemplate.postForEntity("/api/customer", customerEntity, Customer.class);</span><span id="0c57" class="ls iv hi lo b fi lx lu l lv lw">assertThat(savedCustomerResponse.getBody().getId(), is(notNullValue()));<br/>    assertThat(savedCustomerResponse.getBody().getFirstName(), is("Olivia"));<br/>    assertThat(savedCustomerResponse.getBody().getLastName(), is("mia"));<br/>    assertThat(savedCustomerResponse.getBody().getDob(), is(LocalDate.of(2001, 10, 19)));<br/>    assertThat(savedCustomerResponse.getBody().getGender(), is("female"));<br/>  }</span><span id="899e" class="ls iv hi lo b fi lx lu l lv lw">}</span></pre></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="c6b1" class="iu iv hi bd iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr bi translated">测试执行时间</h1><p id="20c6" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">Testcontainers是对您的测试工具箱的一个很好的补充，也是内存数据库的一个很好的替代品。也就是说，有一个你应该知道的性能权衡。Testcontainer集成测试比内存测试慢。这并不奇怪，因为在运行测试之前，Testcontainers需要启动一个容器，启动您选择的数据库并从容器中公开它。相比之下，内存中的数据库启动非常快，并导致更快的测试执行和开发人员反馈。</p><p id="e5f3" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">您可以通过为多个测试重用测试数据库容器来加快速度。根据经验，我认为如果你想要合理的执行时间，这几乎是必不可少的。如果您真的需要在每次测试中隔离一个新的数据库实例，那么您将不得不忍受非常慢的测试。</p><p id="47a7" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">同样重要的是要记住，你应该少用TestContainers，多用mocks。例如，如果您正在对应用程序的服务层进行单元测试，您应该使用Mockito之类的模拟框架来模拟持久层，而不是使用Testcontainers。</p><p id="6348" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">当您想要专注于持久层测试或者想要一些真实的端到端测试时，Testcontainers是很棒的，但是对于其他任何事情，您最好模仿您的持久层以尽可能快地保持测试。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="cf5d" class="iu iv hi bd iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr bi translated">结论</h1><p id="c6f9" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">总而言之，Testcontainers是内存数据库测试的一个很好的替代品。尽管在测试执行时间方面有所取舍，但我认为为更紧密地符合您的生产设置的真实测试付出代价是合理的。</p><p id="41ab" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">这篇文章的示例代码可以在<a class="ae lh" href="https://github.com/reachansari/spring-boot-testcontainers-db-it" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="0b19" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">快乐编码..</p></div></div>    
</body>
</html>