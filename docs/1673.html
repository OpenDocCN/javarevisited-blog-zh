<html>
<head>
<title>Comparing Performance and Developer Experience of Migrating a Spring Boot Back-End to Vert.x</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Spring Boot后端迁移到Vert.x的性能和开发人员体验比较</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/comparing-performance-and-developer-experience-of-migrating-a-spring-boot-back-end-to-vert-x-8f3281b4814?source=collection_archive---------0-----------------------#2021-10-24">https://medium.com/javarevisited/comparing-performance-and-developer-experience-of-migrating-a-spring-boot-back-end-to-vert-x-8f3281b4814?source=collection_archive---------0-----------------------#2021-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8bda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">将现有的Sprint引导逻辑迁移到Vert.x的收益和缺陷的实例</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f30e0966d6ab53f0425d33e26fe029ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Eq5ttm_Qzbq9A29mOrF9A.jpeg"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">由<a class="ae ju" href="https://unsplash.com/@purzlbaum" rel="noopener ugc nofollow" target="_blank">克劳迪奥·施瓦茨</a>在<a class="ae ju" href="https://unsplash.com/photos/wMgW6bjjzZU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Vert.x是JVM的一个反应式框架，它使用一个非阻塞事件循环来响应类似Node.js的请求。这与web应用程序开发(包括Spring Boot)中更常见的为每个请求分配一个线程相反。这种方法的目的是最大限度地利用每个线程，同时最小化为每个请求创建一个线程的开销，特别是在请求线程主要用于等待(例如，等待数据库查询的结果)的情况下。在这些情况下，事件循环方法提高了应用程序的运行时效率和响应时间。</p><p id="9a35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以说，使用Vert.x和基于Spring Boot的web后端之间的权衡是开发人员角度的必要转变。一个典型的三层Spring Boot应用程序(web端点、服务、数据访问)的数量是已知的:逻辑通常很容易理解和调试，Spring和Hibernate堆栈非常受欢迎，有大量可用的资源和示例。鉴于Vert.x的异步特性，如果不需要它的效率和可伸缩性优势，它需要转换视角，这会使代码变得不必要的复杂。考虑到这一点，本文将Vert.x与Sprint Boot的性能和开发人员体验进行了比较，采用了一个Spring Boot项目，并将其改编为功能相当的Vert.x后端。</p><p id="8d1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个案例研究的灵感来自于我和我的朋友们在AuthentiGATE做的一个项目。他们提供了一个电子商务平台，用于销售和扫描加拿大一些大型活动的门票。特别是，他们的扫描系统处理来自手持扫描仪的票证和徽章，是评估Vert.x的理想候选:它处理大量需要快速响应的请求，其大部分响应时间都花在等待SQL查询结果上。AuthentiGATE scanner API是一个基于Spring Boot的应用程序，所以我们将使用它的玩具版本，并将其改编到Vert.x中进行比较。</p><h1 id="5c39" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">方案</h1><p id="6258" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">在本练习中，我们将简化域，仅查看票证的扫描。当扫描器登录时，它们被分配扫描特定位置。每个位置都有自己的规则集，如果满足其中任何一个规则，扫描就成功。否则，扫描将被拒绝。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ky"><img src="../Images/4b8f0627218ceb4ea42be0d2019b1776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cXYclD56O6G-NfGLxj4Pg.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">描述扫描票据现状的流程图。那些突出显示为黄色的步骤代表<em class="kz">阻塞操作。</em>图片作者。</p></figure><p id="98dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当前位置的所有配置都保存在内存中，以便快速访问(上图中的<em class="jd">位置配置</em>)。这包括配置如何解析扫描的条形码和所有可能的扫描规则(例如，在活动期间，X类型的门票可以每天扫描一次，最多扫描三次)。</p><p id="e284" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦为扫描的条形码确定了相关规则的列表，将对每个规则进行评估，直到一个规则成功为止。如果没有成功评估的规则，或者没有适用于该票据的规则，则该票据将被拒绝。每个规则评估都需要检索该票据的一组以前的扫描。由于规则之间存在一些微小的差异(例如，是考虑来自所有位置的扫描还是仅考虑当前位置的扫描)，因此每个规则负责查询数据库以获得它需要做出决策的先前扫描。</p><p id="1c3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现有的应用程序是在标准的三层Spring Boot项目中编写的，API通过Jersey和嵌入式Tomcat web服务器(Spring Boot的默认设置)提供服务，业务逻辑位于服务层，数据通过JDBC使用直接查询从PostgreSQL数据库获得。</p><h1 id="d4f2" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">调整Vert.x的架构</h1><p id="0d93" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">为了让我们的Spring应用程序在Vert.x中有效工作并利用它的优势，我们需要重构所有的阻塞代码。作为参考，上图中流程的阻塞部分以黄色突出显示。需要注意的一些最常见的阻塞情况是数据库查询、文件系统操作和API调用。在这个特定的场景中，我们只处理数据库查询。</p><p id="b8ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Spring Boot方法中，我们按顺序评估每个规则。当我们对每个请求都有一个可以阻塞的线程时，这种命令式逻辑很容易理解和调试；然而，对于像Vert.x这样的非阻塞异步框架，这种逻辑必须重构。相反，我们希望将所有的查询分派到JDBC池，并等待它们的响应。查询将被并行评估，处理web请求的线程(<em class="jd">scans article</em>)将让位于其他请求。一旦我们从所有被分派的查询中收到响应，web线程将在它再次可用时跳回。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es la"><img src="../Images/e7b7d75c54ef3d268a3806d890fc648b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsXlYfg9MxWPt1i2PbRgng.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">作者调整了Vert.x. Image的架构。</p></figure><h1 id="b521" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">比较实现</h1><p id="95b3" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">Spring Boot应用程序中的流程非常简单，可以通过下面来自web和服务层的简化的Kotlin片段来捕获。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="b4b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多细节都被删除了，但是所有的阻塞操作都被描述了。每个请求都在一个线程上运行，这使得代码对于第一次看代码的人来说非常简单易懂。</p><p id="c2fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如所料，Vert.x代码看起来有点不同。让我们从垂直扫描开始。如果您熟悉Node和Express，那么代码的结构可能看起来很熟悉。在<strong class="ih hj"> start() </strong>方法的顶部，我们组装HTTP路由器及其回调。在扫描端点的处理程序中，我们首先评估扫描的结果(接受/拒绝),然后保存结果。<strong class="ih hj"> start() </strong>方法以在端口8080上创建HTTP服务器所需的逻辑结束。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="51cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们看看消费逻辑，我们已经将其浓缩到下面的<strong class="ih hj">消费逻辑</strong>类中。<strong class="ih hj"> evaluateScan() </strong>方法为扫描票据的每个匹配规则调用<strong class="ih hj"> evaluateRule() </strong>方法。注意<strong class="ih hj"> evaluateRule() </strong>返回一个<strong class="ih hj"> Future </strong>(在概念上类似于Javascript中的一个承诺)，而<strong class="ih hj"> CompositeFuture.all() </strong>将等待所有这些Future解决后再决定下一步。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="b4bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们有了<strong class="ih hj"> main() </strong>方法，它创建了JDBC池并创建了<strong class="ih hj"> ScanningVerticle </strong>的一个实例。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="68f7" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">对实现进行基准测试</h1><p id="492c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们将使用JMeter在Spring Boot和Vert.x后端模拟相同的负载。以下测试计划将通过算法生成随机条形码，这种条形码在两种情况下扫描时都被接受。我们将在Spring Boot和Vert.x测试中模拟相同数量的并发线程(用户),一秒钟加速并循环五次。两个应用程序都运行在同一台PC上，以便比较两者之间的相对性能。我们将改变并发线程的数量并比较结果。请注意，这两种情况下的票证将始终只有一个规则需要评估，因为这也反映了现实中的典型情况。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/5739f174b03de1dbeeec2246b99732fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3SHgi2jOwhbyp-YblJBWw.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">JMeter基准测试的结果。</p></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es le"><img src="../Images/c805b9c70a7f5fb0994aef3fcbb065fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MrLaemjP6wsD46sAmyN4g.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">按并发线程(用户)数比较Spring Boot和Vert.x吞吐量(每秒请求数)。</p></figure><p id="f0ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，响应时间和吞吐量在大约50个线程时大致相同。然而，当我们接近100个线程时，我们就接近了两个后端的终端吞吐量:Spring Boot达到了大约295的最大请求/秒，而Vert.x为450(都是1000个线程)。Vert.x的吞吐量增加了50%以上，令人印象深刻。在负载情况下，Vert.x的响应速度始终更快，标准偏差也更小。我们看到，一旦我们在200个线程时达到两个实现的终端吞吐量，Vert.x能够继续以46%的速度响应请求，尽管这一优势会随着负载的增加而缩小。</p><p id="671f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们运行一个额外的负载测试，同时评估Spring Boot和Vert.x后端，那么我们可以在同一个图表中比较两者之间的相对响应时间。我们首先来看一个场景，在这个场景中，两个后端仍然低于50个线程的终端吞吐量。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lf"><img src="../Images/68226233d2770d8577d04fe90717e0a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*zHwvq5NUWTKj67Sg7xvo3w.png"/></div><p class="jq jr et er es js jt bd b be z dx translated">50个并发线程时Spring(蓝色)和Vert.x(红色)的响应时间比较。</p></figure><p id="43aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这与上表一致，上表中两者的响应时间(平均值和标准偏差)和吞吐量几乎相同。接下来，我们将在200个线程处两个后端都变得“紧张”时再次运行这个模拟。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lf"><img src="../Images/33aa766723ad7e0dbff72f517144d5e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*tW6_-zRfU0RJYCV6iBwPXg.png"/></div><p class="jq jr et er es js jt bd b be z dx translated">Vert.x(蓝色)和Spring(红色)在200个并发线程时的响应时间比较。</p></figure><p id="10e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在该测试中，Spring Boot的平均响应时间为593<strong class="ih hj"/>482毫秒，而Vert.x的平均响应时间为382 90.64毫秒。Spring Boot的吞吐量为239.1个请求/秒，而Vert.x为349.5个请求/秒(高出46%)。在这种情况下，Spring Boot的响应时间偏差非常突出(比Vert.x高出五倍以上),而Vert.x处理负载的一致性要高得多。您还可以看到，Vert.x能够在Spring Boot之前很好地处理积压的扫描。</p><h1 id="b8c9" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">讨论和结论</h1><p id="bb1c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">从开发者体验的角度来看，使用Vert.x是一个令人愉快的挑战。尤其是当与Kotlin结合使用时，这是一个非常现代和令人愉快的开发平台。它需要Spring Boot开发的思维方式的改变，但是文档和资源被很好地放在一起，并且框架的直观性和一致性使得它很容易使用。</p><p id="0bdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我担心把它介绍给一个没有完全入伙的团队，或者他们的经验更偏向于初级团队。跟上速度确实需要时间投入，考虑到它所处的特殊位置，找到能够适应所有技能水平的培训资源将更加困难。还有一个风险是，不正确实现的Vert.x代码可能比线程逻辑慢(例如，如果您不小心阻塞了Verticle的线程)。另一方面，来自需要在JVM上工作的节点生态系统的开发人员可能会发现过渡到Vert.x比Spring Boot更舒服。</p><p id="8b19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从基准测试中得到的最有趣的结果是，速度和吞吐量结果几乎相同，直到它们开始接近它们的终端吞吐量。即使在普通台式电脑上运行，Spring Boot也能一次轻松处理50个请求。如果我们假设普通人类扫描仪只能每三秒钟扫描一次条形码，那么这就意味着，从理论上讲，一台商用电脑可以处理150台活动扫描仪的扫描，并且仍然可以在不到40毫秒的时间内做出响应。因此，在这种情况下，对Spring Boot来说有一个强有力的理由:Spring Boot代码更容易遵守，需要维护的部件更少，而且由于Spring Boot达到其码头吞吐量的负载水平相当高，在这种情况下，合并Vert.x可能没有优势。</p><p id="fb93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，由于可以在同一个代码库中开发Vert.x端点和Spring Boot端点，所以可以根据需要将特定端点迁移到Vert.x。例如，我们可以使用Gradle为每个入口点(Spring Boot和Vert.x)生成一个单独的fat JAR，每个入口点运行在不同的容器上。事实上，上面基准测试的Spring Boot和Vert.x应用程序都是在同一个项目中完成的，只是运行了两个不同类的<strong class="ih hj"> main() </strong>。</p><p id="8166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于未来的工作，我有兴趣将Vert.x应用于需要处理大量数据点的情况(例如，物联网或分析事件流)。基于Vert.x如何优雅地处理重负载，以类似的方式对照其他选项来评估Vert.x会很有趣。特别是有了Vert.x也支持的<a class="ae ju" href="https://how-to.vertx.io/graal-native-image-howto/" rel="noopener ugc nofollow" target="_blank"> GraalVM做后盾。</a></p></div></div>    
</body>
</html>