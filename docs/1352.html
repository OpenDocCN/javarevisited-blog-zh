<html>
<head>
<title>A Generic way to write Excel files using Apache POI and Java Reflection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Apache POI和Java反射编写Excel文件的一般方法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/a-generic-approach-to-write-excel-using-apache-poi-17a1dfd4b98e?source=collection_archive---------1-----------------------#2021-06-29">https://medium.com/javarevisited/a-generic-approach-to-write-excel-using-apache-poi-17a1dfd4b98e?source=collection_archive---------1-----------------------#2021-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/db596bc6dac6855e7dbc97031d867baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcEuRSGlnOHIiBylY_Qe-g.jpeg"/></div></div></figure><p id="f1bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">简介</strong></p><p id="2187" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Excel文档是软件应用程序中经常使用的功能。</p><p id="93ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，通过使用Apache POI并在Java反射特性的支持下，实现了一种将任何类型的对象(包括单个和复合(数组)类型的字段)写入Excel文件的方法。编写每种类型的字段和行-列处理的定制代码的需求已经减少，只需最少的定制就可以了。</p><p id="502e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apache POI(Poor Obfuscation Implementation)是由Apache Software Foundation运行的一个流行的开源库，它是为读写Microsoft Office格式的文件而开发的，如Word、PowerPoint和Excel。</p><p id="cb2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://javarevisited.blogspot.com/2015/06/how-to-read-write-excel-file-java-poi-example.html" rel="noopener ugc nofollow" target="_blank"> Apache POI </a>的目标是设计一个跨平台的API，可以操作微软Office的各种文件格式，打开Office文档。由于我们专注于编写Excel文件，我们将使用以下Apache POI文件格式的电子表格。</p><blockquote class="jp jq jr"><p id="2eee" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">HSSF(糟糕的电子表格格式)-用于MS-Excel(97–2007)文件的xlsx文件格式。</p><p id="5f94" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">XSSF (XML电子表格格式)-用于MS-Excel (2007及更高版本)文件的xlsx文件格式。</p></blockquote><p id="c64d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个Apache POI库都专用于操作每种特定类型的文件。XSSF库包含处理xlsx Excel格式的类。下图显示了用于操作xlsx Excel文件的Apache POI相关接口和类。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><a href="https://www.java67.com/2014/09/how-to-read-write-xlsx-file-in-java-apache-poi-example.html"><div class="er es jw"><img src="../Images/049329ec44bceb92aee1c580496dd662.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*7n-ep8DljW5yAhbB5PZXMw.png"/></div></a></figure><p id="5e87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，它还为其他excel功能提供了出色的支持，如处理公式、通过填充颜色和边框、字体、页眉和页脚、数据验证、图像、超链接等来创建单元格样式。</p><p id="58e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们开始工作吧。</p><p id="9cb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实施时将遵循以下主要步骤:</p><ol class=""><li id="8e03" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><em class="js">使用Apache POI依赖项和其他必要的依赖项建立Spring Boot项目。</em></li><li id="f906" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><em class="js">创建一个API端点来发送一个下载Excel文件的HTTP请求。</em></li><li id="8fc1" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><em class="js">定义将用于动态类反射的Java注释接口。</em></li><li id="afb4" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><em class="js">定义Java POJO类，用于写入Excel表。并且建立一个POJO类来保存上面类的每个字段的元数据。</em></li><li id="a1b8" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><em class="js">使用动态类反射和POI电子表格数据填充实现通用Xlsx编写器到工作簿中。</em></li><li id="47b8" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><em class="js">获取POJO类对象列表并传递给编写器，以字节数组的形式获得响应。</em></li><li id="0ddb" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><em class="js">以数据字节数组的形式发送API响应，并将openxmlformats的相关头细节作为媒体类型</em></li></ol><p id="a32a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">建立具有Apache POI依赖项和其他必要依赖项的Spring Boot项目</strong></p><pre class="jx jy jz ka fd kp kq kr ks aw kt bi"><span id="4f57" class="ku kv hi kq b fi kw kx l ky kz">&lt;dependency&gt;<br/>   &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;<br/>   &lt;artifactId&gt;poi&lt;/artifactId&gt;<br/>   &lt;version&gt;4.1.2&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;<br/>   &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;<br/>   &lt;version&gt;4.1.2&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="1f79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">创建一个API端点来接收下载Excel文件的HTTP请求</strong></p><pre class="jx jy jz ka fd kp kq kr ks aw kt bi"><span id="73f2" class="ku kv hi kq b fi kw kx l ky kz">@RequestMapping(method = RequestMethod.<em class="js">POST</em>, value = "/download-users-excel")<br/>public ResponseEntity downloadUsersExcel() {<br/>    try {<br/>        final byte[] data = userService.getUserXlsData();<br/>        HttpHeaders header = new HttpHeaders();<br/>    header.setContentType(MediaType.<em class="js">parseMediaType</em>("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8"));<br/>        header.set(HttpHeaders.<em class="js">CONTENT_DISPOSITION</em>, "inline; filename= users.xlsx");<br/>        header.setContentLength(data.length);<br/>        return new ResponseEntity&lt;&gt;(data, header, HttpStatus.<em class="js">OK</em>);<br/>    } catch (Exception e) {<br/>        return new ResponseEntity&lt;&gt;(null, HttpStatus.<em class="js">INTERNAL_SERVER_ERROR</em>);<br/>    }<br/>}</span></pre><p id="801a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">定义将用于动态类反射的Java注释接口</strong></p><pre class="jx jy jz ka fd kp kq kr ks aw kt bi"><span id="cf4f" class="ku kv hi kq b fi kw kx l ky kz">@Documented<br/>@Target(ElementType.<em class="js">TYPE</em>)<br/>@Retention(RetentionPolicy.<em class="js">RUNTIME</em>)<br/>public @interface XlsxSheet {<br/>    String value();<br/>}</span><span id="7347" class="ku kv hi kq b fi la kx l ky kz">@Documented<br/>@Target(ElementType.<em class="js">FIELD</em>)<br/>@Retention(RetentionPolicy.<em class="js">RUNTIME</em>)<br/>public @interface XlsxSingleField {<br/>    int columnIndex();<br/>}</span><span id="e9d2" class="ku kv hi kq b fi la kx l ky kz">@Documented<br/>@Target(ElementType.<em class="js">FIELD</em>)<br/>@Retention(RetentionPolicy.<em class="js">RUNTIME</em>)<br/>public @interface XlsxCompositeField {<br/>    int from();<br/>    int to();<br/>}</span></pre><p id="8ddf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">定义Java POJO类，用于写入Excel表</strong></p><p id="e034" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里出于演示的目的，使用了一个POJO，它包括用户详细信息和一个DietPlan列表:</p><pre class="jx jy jz ka fd kp kq kr ks aw kt bi"><span id="698d" class="ku kv hi kq b fi kw kx l ky kz">@Getter<br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>@Setter<br/>@XlsxSheet(value = "Users")<br/>public class XlsxUser {<br/><br/>    @XlsxSingleField(columnIndex = 0)<br/>    private String name;<br/>    @XlsxSingleField(columnIndex = 1)<br/>    private String gender;<br/>    @XlsxSingleField(columnIndex = 2)<br/>    private Integer age;<br/>    @XlsxSingleField(columnIndex = 3)<br/>    private Double bmiValue;<br/>    @XlsxSingleField(columnIndex = 4)<br/>    private Boolean isOverweight;<br/>    @XlsxSingleField(columnIndex = 5)<br/>    private List&lt;String&gt; activities;<br/>    @XlsxCompositeField(from = 6, to = 7)<br/>    private List&lt;XlsxDietPlan&gt; plans;<br/><br/>    @Getter<br/>    @AllArgsConstructor<br/>    @NoArgsConstructor<br/>    @Setter<br/>    public static class XlsxDietPlan {<br/>        @XlsxSingleField(columnIndex = 6)<br/>        private String mealName;<br/>        @XlsxSingleField(columnIndex = 7)<br/>        private Double calories;<br/>    }<br/><br/>}</span></pre><p id="6e94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上所示，前面定义的注释用于为POJO类及其字段提供元数据。此元数据将在运行时针对POJO类反射进行评估，并在通用编写器中填充工作簿。</p><p id="781f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">设置一个POJO类来保存上述类的每个字段的元数据</strong></p><p id="0797" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们观察它，可能的数据集类很可能由以下数据结构组成。</p><ol class=""><li id="9536" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated">单字段(整数、字符串、浮点、双精度、布尔类型)</li><li id="73ba" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">数组字段(单个字段的列表)</li><li id="4105" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">复合字段(由单个字段组成的对象列表)</li></ol><p id="119b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，每个字段都被映射到一个XlsxField实例，该实例保存关于POJO类字段的元数据，这在以后会很有用。</p><pre class="jx jy jz ka fd kp kq kr ks aw kt bi"><span id="0b8c" class="ku kv hi kq b fi kw kx l ky kz">@Getter<br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>@Setter<br/>public class XlsxField {<br/>    private String fieldName;<br/>    private int cellIndex;<br/>    private int cellIndexFrom;<br/>    private int cellIndexTo;<br/>    private boolean isAnArray;<br/>    private boolean isComposite;<br/>}</span></pre><p id="f478" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用动态类反射实现通用Xlsx编写器，并将POI电子表格数据填充到工作簿中</strong></p><pre class="jx jy jz ka fd kp kq kr ks aw kt bi"><span id="d768" class="ku kv hi kq b fi kw kx l ky kz">@Service<br/>public class XlsxFileWriter implements XlsxWriter {<br/><br/><br/>   private static final Logger <em class="js">logger </em>= LoggerFactory.<em class="js">getLogger</em>(XlsxFileWriter.class);<br/><br/>    @Override<br/>    public &lt;T&gt; void write(List&lt;T&gt; data, ByteArrayOutputStream bos, String[] columnTitles, Workbook workbook) {<br/><br/>        if (data.isEmpty()) {<br/>            <em class="js">logger</em>.error("No data received to write Xls file..");<br/>            return;<br/>        }<br/><br/>        long start = System.<em class="js">currentTimeMillis</em>();<br/><br/>//      setting up the basic styles for the workbook<br/>        Font boldFont = getBoldFont(workbook);<br/>        Font genericFont = getGenericFont(workbook);<br/>        CellStyle headerStyle = getLeftAlignedCellStyle(workbook, boldFont);<br/>        CellStyle currencyStyle = setCurrencyCellStyle(workbook);<br/>        CellStyle centerAlignedStyle = getCenterAlignedCellStyle(workbook);<br/>        CellStyle genericStyle = getLeftAlignedCellStyle(workbook, genericFont);<br/><br/>   try {<br/>// using POJO class metadata for the sheet name<br/>    XlsxSheet annotation = data.get(0).getClass().getAnnotation(XlsxSheet.class);<br/>    String sheetName = annotation.value();<br/>    Sheet sheet = workbook.createSheet(sheetName);<br/><br/>//  get the metadata for each field of the POJO class into a list<br/>    List&lt;XlsxField&gt; xlsColumnFields = <em class="js">getFieldNamesForClass</em>(data.get(0).getClass());<br/><br/>      int tempRowNo = 0;<br/>      int recordBeginRowNo = 0;<br/>      int recordEndRowNo = 0;<br/><br/>//    set spreadsheet titles<br/>      Row mainRow = sheet.createRow(tempRowNo);<br/>      Cell columnTitleCell;<br/><br/>      for (int i = 0; i &lt; columnTitles.length; i++) {<br/>        columnTitleCell = mainRow.createCell(i);<br/>        columnTitleCell.setCellStyle(headerStyle);<br/>        columnTitleCell.setCellValue(columnTitles[i]);<br/>      }<br/>      recordEndRowNo++;<br/><br/>//    get class of the passed dataset<br/>      Class&lt;?&gt; clazz = data.get(0).getClass();</span><span id="6545" class="ku kv hi kq b fi la kx l ky kz">//    looping the past dataset<br/>      for (T record : data) {<br/>        tempRowNo = recordEndRowNo;<br/>        recordBeginRowNo = tempRowNo;<br/>        mainRow = sheet.createRow(tempRowNo++);<br/>        boolean isFirstValue;<br/>        boolean isFirstRow;<br/>        boolean isRowNoToDecrease = false;<br/>        Method xlsMethod;<br/>        Object xlsObjValue;<br/>        ArrayList&lt;Object&gt; objValueList;<br/>                <br/>//      get max size of the record if its multiple row<br/>        int maxListSize = getMaxListSize(record, xlsColumnFields, clazz);<br/>                <br/>                <br/>//      looping through the fields of the current record<br/>        for (XlsxField xlsColumnField : xlsColumnFields) {<br/>//       writing a single field<br/>         if (!xlsColumnField.isAnArray() &amp;&amp; !xlsColumnField.isComposite()) {<br/>            writeSingleFieldRow(mainRow, xlsColumnField, clazz, currencyStyle, centerAlignedStyle, genericStyle,<br/>                                record, workbook);<br/><br/>//       overlooking the next field and adjusting the starting row<br/>         if (isNextColumnAnArray(xlsColumnFields, xlsColumnField, clazz, record)) {<br/>             isRowNoToDecrease = true;<br/>             tempRowNo = recordBeginRowNo + 1;<br/>          }<br/><br/>//       writing an single array field<br/>         } else if (xlsColumnField.isAnArray() &amp;&amp; !xlsColumnField.isComposite()) {<br/>           xlsMethod = getMethod(clazz, xlsColumnField);<br/>           xlsObjValue = xlsMethod.invoke(record, (Object[]) null);<br/>           objValueList = (ArrayList&lt;Object&gt;) xlsObjValue;<br/>           isFirstValue = true;<br/><br/>//       looping through the items of the single array<br/>         for (Object objectValue : objValueList) {<br/>            Row childRow;<br/>            if (isFirstValue) {<br/>             childRow = mainRow;<br/>             writeArrayFieldRow(childRow, xlsColumnField, objectValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);<br/>             isFirstValue = false;<br/>            } else if (isRowNoToDecrease) {<br/>             childRow = getOrCreateNextRow(sheet, tempRowNo++);<br/>             writeArrayFieldRow(childRow, xlsColumnField, objectValue, currencyStyle, centerAlignedStyle,genericStyle, workbook);<br/>             isRowNoToDecrease = false;<br/>            } else {<br/>             childRow = getOrCreateNextRow(sheet, tempRowNo++);<br/>             writeArrayFieldRow(childRow, xlsColumnField, objectValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);<br/>            }<br/>          }<br/><br/> //      overlooking the next field and adjusting the starting row<br/>         if (isNextColumnAnArray(xlsColumnFields, xlsColumnField, clazz, record)) {<br/>            isRowNoToDecrease = true;<br/>            tempRowNo = recordBeginRowNo + 1;<br/>         }<br/><br/>//      writing a composite array field<br/>         } else if (xlsColumnField.isAnArray() &amp;&amp; xlsColumnField.isComposite()) {<br/>           xlsMethod = getMethod(clazz, xlsColumnField);<br/>           xlsObjValue = xlsMethod.invoke(record, (Object[]) null);<br/>           objValueList = (ArrayList&lt;Object&gt;) xlsObjValue;<br/>           isFirstRow = true;<br/><br/>//       looping through the items of the composite array<br/>           for (Object objectValue : objValueList) {<br/>             Row childRow;<br/>             List&lt;XlsxField&gt; xlsCompositeColumnFields = <em class="js">getFieldNamesForClass</em>(objectValue.getClass());<br/>             if (isFirstRow) {<br/>               childRow = mainRow;<br/>               for (XlsxField xlsCompositeColumnField : xlsCompositeColumnFields) {  <br/>                                                                  writeCompositeFieldRow(objectValue, xlsCompositeColumnField, childRow, currencyStyle,centerAlignedStyle, genericStyle, workbook);<br/>               }<br/>              isFirstRow = false;<br/>              } else if (isRowNoToDecrease) {<br/>               childRow = getOrCreateNextRow(sheet, tempRowNo++);<br/>               for (XlsxField xlsCompositeColumnField : xlsCompositeColumnFields) {<br/>                                    writeCompositeFieldRow(objectValue, xlsCompositeColumnField, childRow, currencyStyle, centerAlignedStyle, genericStyle, workbook);<br/>            }<br/>            isRowNoToDecrease = false;<br/>           } else {<br/>            childRow = getOrCreateNextRow(sheet, tempRowNo++);<br/>            for (XlsxField xlsCompositeColumnField : xlsCompositeColumnFields) {<br/>                                    writeCompositeFieldRow(objectValue, xlsCompositeColumnField, childRow, currencyStyle, centerAlignedStyle, genericStyle, workbook);<br/>           }<br/>          }<br/>         }<br/><br/>//       overlooking the next field and adjusting the starting row<br/>         if (isNextColumnAnArray(xlsColumnFields, xlsColumnField, clazz, record)) {<br/>            isRowNoToDecrease = true;<br/>            tempRowNo = recordBeginRowNo + 1;<br/>           }<br/>         }<br/>       }<br/><br/>//      adjusting the ending row number for the current record<br/>        recordEndRowNo = maxListSize + recordBeginRowNo;<br/>     }<br/><br/>// auto sizing the columns of the whole sheet<br/>   autoSizeColumns(sheet, xlsColumnFields.size());            <br/>   workbook.write(bos);<br/>   <em class="js">logger</em>.info("Xls file generated in [{}] seconds", processTime(start));<br/>  } catch (Exception e) {<br/>    <em class="js">logger</em>.info("Xls file write failed", e);<br/>  }<br/>}<br/><br/>  private void writeCompositeFieldRow(Object objectValue, XlsxField xlsCompositeColumnField, Row childRow,CellStyle currencyStyle, CellStyle centerAlignedStyle, CellStyle genericStyle, Workbook workbook) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {<br/><br/>        Method nestedCompositeXlsMethod = getMethod(objectValue.getClass(), xlsCompositeColumnField);<br/>        Object nestedCompositeValue = nestedCompositeXlsMethod.invoke(objectValue, (Object[]) null);<br/>        Cell compositeNewCell = childRow.createCell(xlsCompositeColumnField.getCellIndex());<br/>        setCellValue(compositeNewCell, nestedCompositeValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);<br/>    }<br/><br/>    private void writeArrayFieldRow(Row childRow, XlsxField xlsColumnField, Object objectValue,<br/>                                    CellStyle currencyStyle, CellStyle centerAlignedStyle, CellStyle genericStyle, Workbook workbook) {<br/>        Cell newCell = childRow.createCell(xlsColumnField.getCellIndex());<br/>        setCellValue(newCell, objectValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);<br/>    }<br/><br/>    private &lt;T&gt; void writeSingleFieldRow(Row mainRow, XlsxField xlsColumnField, Class&lt;?&gt; clazz, CellStyle currencyStyle,CellStyle centerAlignedStyle, CellStyle genericStyle, T record, Workbook workbook) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {<br/><br/>  Cell newCell = mainRow.createCell(xlsColumnField.getCellIndex());<br/>  Method xlsMethod = getMethod(clazz, xlsColumnField);<br/>  Object xlsObjValue = xlsMethod.invoke(record, (Object[]) null);<br/>  setCellValue(newCell, xlsObjValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);<br/>    }<br/><br/>    private &lt;T&gt; boolean isNextColumnAnArray(List&lt;XlsxField&gt; xlsColumnFields, XlsxField xlsColumnField,Class&lt;?&gt; clazz, T record)<br/>            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {<br/>  XlsxField nextXlsColumnField;<br/>  int fieldsSize = xlsColumnFields.size();<br/>  Method nestedXlsMethod;<br/>  Object nestedObjValue;<br/>  ArrayList&lt;Object&gt; nestedObjValueList;<br/>   if (xlsColumnFields.indexOf(xlsColumnField) &lt; (fieldsSize - 1)) {<br/>      nextXlsColumnField = xlsColumnFields.get(xlsColumnFields.indexOf(xlsColumnField) + 1);<br/>  if (nextXlsColumnField.isAnArray()) {<br/>   nestedXlsMethod = getMethod(clazz, nextXlsColumnField);<br/>   nestedObjValue = nestedXlsMethod.invoke(record, (Object[]) null);<br/>   nestedObjValueList = (ArrayList&lt;Object&gt;) nestedObjValue;<br/>                return nestedObjValueList.size() &gt; 1;<br/>            }<br/>        }<br/>        return xlsColumnFields.indexOf(xlsColumnField) == (fieldsSize - 1);<br/><br/>    }<br/><br/>    private void setCellValue(Cell cell, Object objValue, CellStyle currencyStyle, CellStyle centerAlignedStyle,<br/>                              CellStyle genericStyle, Workbook workbook) {<br/>        Hyperlink link = workbook.getCreationHelper().createHyperlink(HyperlinkType.<em class="js">URL</em>);<br/>          if (objValue != null) {<br/>            if (objValue instanceof String) {<br/>                String cellValue = (String) objValue;<br/>                cell.setCellStyle(genericStyle);<br/>                if (cellValue.contains("https://") || cellValue.contains("http://")) {<br/>                    link.setAddress(cellValue);<br/>                    cell.setCellValue(cellValue);<br/>                    cell.setHyperlink(link);<br/>                } else {<br/>                    cell.setCellValue(cellValue);<br/>                }<br/>            } else if (objValue instanceof Long) {<br/>                cell.setCellValue((Long) objValue);<br/>            } else if (objValue instanceof Integer) {<br/>                cell.setCellValue((Integer) objValue);<br/>            } else if (objValue instanceof Double) {<br/>                Double cellValue = (Double) objValue;<br/>                cell.setCellStyle(currencyStyle);<br/>                cell.setCellValue(cellValue);<br/>            } else if (objValue instanceof Boolean) {<br/>                cell.setCellStyle(centerAlignedStyle);<br/>                if (objValue.equals(true)) {<br/>                    cell.setCellValue(1);<br/>                } else {<br/>                    cell.setCellValue(0);<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/>    private static List&lt;XlsxField&gt; getFieldNamesForClass(Class&lt;?&gt; clazz) {<br/>        List&lt;XlsxField&gt; xlsColumnFields = new ArrayList();<br/>        Field[] fields = clazz.getDeclaredFields();<br/>        for (Field field : fields) {<br/>          XlsxField xlsColumnField = new XlsxField();<br/>           if (Collection.class.isAssignableFrom(field.getType())) {<br/>                xlsColumnField.setAnArray(true);<br/>                XlsxCompositeField xlsCompositeField = field.getAnnotation(XlsxCompositeField.class);<br/>                if (xlsCompositeField != null) {<br/>          xlsColumnField.setCellIndexFrom(xlsCompositeField.from());<br/>              xlsColumnField.setCellIndexTo(xlsCompositeField.to());<br/>                    xlsColumnField.setComposite(true);<br/>                } else {<br/>                    XlsxSingleField xlsField = field.getAnnotation(XlsxSingleField.class);<br/>                xlsColumnField.setCellIndex(xlsField.columnIndex());<br/>                }<br/>            } else {<br/>                XlsxSingleField xlsField = field.getAnnotation(XlsxSingleField.class);<br/>                xlsColumnField.setAnArray(false);<br/>                if (xlsField != null) {<br/>                xlsColumnField.setCellIndex(xlsField.columnIndex());<br/>                    xlsColumnField.setComposite(false);<br/>                }<br/>            }<br/>            xlsColumnField.setFieldName(field.getName());<br/>            xlsColumnFields.add(xlsColumnField);<br/>        }<br/>        return xlsColumnFields;<br/>    }<br/><br/>    private static String capitalize(String s) {<br/>        if (s.length() == 0)<br/>            return s;<br/>        return s.substring(0, 1).toUpperCase() + s.substring(1);<br/>    }<br/><br/><br/>    private &lt;T&gt; int getMaxListSize(T record, List&lt;XlsxField&gt; xlsColumnFields, Class&lt;? extends Object&gt; aClass)<br/>            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {<br/><br/>        List&lt;Integer&gt; listSizes = new ArrayList&lt;&gt;();<br/>        for (XlsxField xlsColumnField : xlsColumnFields) {<br/>          if (xlsColumnField.isAnArray()) {<br/>           Method method = getMethod(aClass, xlsColumnField);<br/>            Object value = method.invoke(record, (Object[]) null);<br/>             ArrayList&lt;Object&gt; objects = (ArrayList&lt;Object&gt;) value;<br/>                if (objects.size() &gt; 1) {<br/>                  listSizes.add(objects.size());<br/>                }<br/>            }<br/>        }<br/><br/>        if (listSizes.isEmpty()) {<br/>            return 1;<br/>        } else {<br/>            return Collections.<em class="js">max</em>(listSizes);<br/>        }<br/><br/>    }<br/><br/>    private Method getMethod(Class&lt;?&gt; clazz, XlsxField xlsColumnField) throws NoSuchMethodException {<br/>        Method method;<br/>        try {<br/>            method = clazz.getMethod("get" + <em class="js">capitalize</em>(xlsColumnField.getFieldName()));<br/>        } catch (NoSuchMethodException nme) {<br/>            method = clazz.getMethod(xlsColumnField.getFieldName());<br/>        }<br/><br/>        return method;<br/>    }<br/><br/>    private long processTime(long start) {<br/>        return (System.<em class="js">currentTimeMillis</em>() - start) / 1000;<br/>    }<br/><br/>    private void autoSizeColumns(Sheet sheet, int noOfColumns) {<br/>        for (int i = 0; i &lt; noOfColumns; i++) {<br/>            sheet.autoSizeColumn((short) i);<br/>        }<br/>    }<br/><br/>    private Row getOrCreateNextRow(Sheet sheet, int rowNo) {<br/>        Row row;<br/>        if (sheet.getRow(rowNo) != null) {<br/>            row = sheet.getRow(rowNo);<br/>        } else {<br/>            row = sheet.createRow(rowNo);<br/>        }<br/>        return row;<br/>    }<br/><br/>    private CellStyle setCurrencyCellStyle(Workbook workbook) {<br/>        CellStyle currencyStyle = workbook.createCellStyle();<br/>        currencyStyle.setWrapText(true);<br/>        DataFormat df = workbook.createDataFormat();<br/>        currencyStyle.setDataFormat(df.getFormat("#0.00"));<br/>        return currencyStyle;<br/>    }<br/><br/>    private Font getBoldFont(Workbook workbook) {<br/>        Font font = workbook.createFont();<br/>        font.setBold(true);<br/>        font.setFontHeight((short) (10 * 20));<br/>        font.setFontName("Calibri");<br/>        font.setColor(IndexedColors.<em class="js">BLACK</em>.getIndex());<br/>        return font;<br/>    }<br/><br/>    private Font getGenericFont(Workbook workbook) {<br/>        Font font = workbook.createFont();<br/>        font.setFontHeight((short) (10 * 20));<br/>        font.setFontName("Calibri");<br/>        font.setColor(IndexedColors.<em class="js">BLACK</em>.getIndex());<br/>        return font;<br/>    }<br/><br/>    private CellStyle getCenterAlignedCellStyle(Workbook workbook) {<br/>        CellStyle cellStyle = workbook.createCellStyle();<br/>        cellStyle.setAlignment(HorizontalAlignment.<em class="js">CENTER</em>);<br/>        cellStyle.setVerticalAlignment(VerticalAlignment.<em class="js">BOTTOM</em>);<br/>        cellStyle.setBorderTop(BorderStyle.<em class="js">NONE</em>);<br/>        cellStyle.setBorderBottom(BorderStyle.<em class="js">NONE</em>);<br/>        cellStyle.setBorderLeft(BorderStyle.<em class="js">NONE</em>);<br/>        cellStyle.setBorderRight(BorderStyle.<em class="js">NONE</em>);<br/>        return cellStyle;<br/>    }<br/><br/>    private CellStyle getLeftAlignedCellStyle(Workbook workbook, Font font) {<br/>        CellStyle cellStyle = workbook.createCellStyle();<br/>        cellStyle.setFont(font);<br/>        cellStyle.setAlignment(HorizontalAlignment.<em class="js">LEFT</em>);<br/>        cellStyle.setVerticalAlignment(VerticalAlignment.<em class="js">BOTTOM</em>);<br/>        cellStyle.setBorderTop(BorderStyle.<em class="js">NONE</em>);<br/>        cellStyle.setBorderBottom(BorderStyle.<em class="js">NONE</em>);<br/>        cellStyle.setBorderLeft(BorderStyle.<em class="js">NONE</em>);<br/>        cellStyle.setBorderRight(BorderStyle.<em class="js">NONE</em>);<br/>        return cellStyle;<br/>    }<br/>}</span></pre><p id="85db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">获取POJO类对象的列表并传递给编写器，以</strong> <a class="ae jo" href="https://javarevisited.blogspot.com/2020/04/7-examples-to-read-file-into-byte-array-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">字节数组</strong> </a>的形式获得响应</p><p id="c26b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于演示目的，将使用一些虚拟数据来创建样本POJO记录列表。</p><p id="20ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后创建<a class="ae jo" href="https://javarevisited.blogspot.com/2014/04/how-to-convert-byte-array-to-inputstream-outputstream-java-example.html" rel="noopener ugc nofollow" target="_blank"> ByteArrayOutputStream </a>和XSSFWorkbook的实例。电子表格的标题被定义为一个字符串数组。这些作为参数传递给编写器。ByteArrayOutputStream的传递实例包含在写入工作簿的数据的字节流中。在Finally子句中，ByteArrayOutputStream被关闭，并返回字节数组。</p><pre class="jx jy jz ka fd kp kq kr ks aw kt bi"><span id="d5fa" class="ku kv hi kq b fi kw kx l ky kz">@Service<br/>public class UserServiceImpl implements UserService {<br/><br/>    private final XlsxWriter xlsxWriter;<br/>    private static final Logger <em class="js">logger </em>= LoggerFactory.<em class="js">getLogger</em>(UserServiceImpl.class);<br/><br/>    public UserServiceImpl(XlsxWriter xlsxWriter) {<br/>        this.xlsxWriter = xlsxWriter;<br/>    }<br/><br/>    @Override<br/>    public byte[] getUserXlsData() throws IOException {<br/>        List&lt;XlsxUser&gt; xlsxUserList = new ArrayList&lt;&gt;();<br/>        for (int i = 0; i &lt; 10; i++) {<br/>            XlsxUser user = new XlsxUser();<br/>            List&lt;String&gt; activities = new ArrayList&lt;&gt;(Arrays.<em class="js">asList</em>("Running", "Working out", "Heavy Machinery", "Walking"));<br/>            List&lt;XlsxUser.XlsxDietPlan&gt; plans = new ArrayList&lt;&gt;(Arrays.<em class="js">asList</em>(new XlsxUser.XlsxDietPlan("Breakfast", 500.10),<br/>                    new XlsxUser.XlsxDietPlan("Lunch", 320.25), new XlsxUser.XlsxDietPlan("Dinner", 200.80)));<br/>            user.setName("John Doe");<br/>            user.setAge(25);<br/>            user.setBmiValue(25.36);<br/>            user.setGender("Male");<br/>            user.setIsOverweight(true);<br/>            user.setActivities(activities);<br/>            user.setPlans(plans);<br/>            xlsxUserList.add(user);<br/>        }<br/>        ByteArrayOutputStream bos = new ByteArrayOutputStream();<br/>        try (Workbook workbook = new XSSFWorkbook()) {<br/>            String[] columnTitles = new String[]{"Name", "Gender", "Age", "BMI value", "Is Overweight", "Activities", "Meal Name", "Calories"};<br/>            xlsxWriter.write(xlsxUserList, bos, columnTitles, workbook);<br/>        } catch (Exception e) {<br/>            <em class="js">logger</em>.error("Generating users xls file failed", e);<br/>        } finally {<br/>            bos.close();<br/>        }<br/>        return bos.toByteArray();<br/>     }<br/>}</span></pre><h2 id="69fb" class="ku kv hi bd lb lc ld le lf lg lh li lj jb lk ll lm jf ln lo lp jj lq lr ls lt bi translated">抽样输出</h2><figure class="jx jy jz ka fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/11/top-10-business-and-finance-courses.html#axzz6v6xLSPvq"><div class="er es lu"><img src="../Images/4770257314283fed18a70939c4620c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_BfykDo6CO9llGyrI-Jfw.png"/></div></a></figure><p id="c399" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">总结</strong></p><p id="7e19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">努力使用Apache POI和Java核心特性(如反射和注释)实现一个通用且健壮的Excel writer，它将使用HTTP请求下载一个Excel文件。当写入Excel表时，这将匹配POJO结构的大多数用例。希望这将有所帮助，也很容易定制。</p><p id="9d68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以在<a class="ae jo" href="https://github.com/jsb9009/generic-xlsx-writer" rel="noopener ugc nofollow" target="_blank">这里的</a>中找到该项目的存储库。</p><p id="8916" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">欢迎在下方留言评论。希望你喜欢这个故事..！:)</p></div></div>    
</body>
</html>