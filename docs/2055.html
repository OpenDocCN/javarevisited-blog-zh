<html>
<head>
<title>Scaling WebSockets in Spring services [Part 2]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Spring服务中扩展WebSockets第2部分]</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/scaling-websockets-in-spring-services-part-2-11f7f32ad05a?source=collection_archive---------0-----------------------#2022-04-12">https://medium.com/javarevisited/scaling-websockets-in-spring-services-part-2-11f7f32ad05a?source=collection_archive---------0-----------------------#2022-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/08b26b11cbde783e80b8a82e450d0a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZsOpTbPkkcVz3bpH"/></div></div><p class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cd30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上一篇文章的<a class="ae iu" rel="noopener" href="/javarevisited/scaling-websockets-in-spring-services-27023f59868c">中，我写了一篇关于</a><a class="ae iu" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Framework </a>中的代理中继的文章，它允许你横向扩展WebSockets连接。</p><p id="0a43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我没有用<strong class="ix hj"><em class="jt">@ subscribe mapping</em></strong>很好地覆盖这个问题。在这篇文章中，我想解决这个问题。</p><h1 id="2a8e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">@SubscribeMapping</h1><p id="456d" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">让我提醒你，问题是我们经常想在用户订阅主题时发送初始状态。</p><p id="2e84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，我们有一个主题<code class="du kx ky kz la b">/topic/charts/{charId}</code>，我们想在订阅时发送20条最新消息。</p><p id="54e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们声明应用前缀<code class="du kx ky kz la b">/app</code>和代理前缀<code class="du kx ky kz la b">/topic</code>，那么订阅消息将不会进入<a class="ae iu" href="https://www.java67.com/2021/10/3-ways-to-send-different-content-types.html" rel="noopener ugc nofollow" target="_blank"> Spring控制器</a>。它将被直接代理给代理。</p><p id="3eb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在前一篇文章中，我建议了两种方法来解决这个问题:</p><ol class=""><li id="7512" class="lb lc hi ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">创造我们自己的<code class="du kx ky kz la b">BeanPostProcessor</code></li><li id="5396" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">使用<a class="ae iu" href="https://javarevisited.blogspot.com/2021/10/difference-between-requestmapping-and..html" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="jt">@ get mapping</em></strong></a>请求初始数据</li></ol><p id="f924" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">幸运的是，有一个更简单的方法(剧透:我们可以在应用前缀和代理前缀上添加<code class="du kx ky kz la b">/topic</code>和<code class="du kx ky kz la b">/user</code>)。现在我将解释它是如何工作的。</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="e3f8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">WebSocket通道</h1><figure class="lp lq lr ls fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/03/top-5-courses-to-learn-websocket-for.html"><div class="er es lv"><img src="../Images/312f95f10027850ca50261b3be97d911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BiJXAbW8GQ-TdcpG"/></div></a></figure><p id="c1c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Spring框架中，我们有3个消息通道:</p><ol class=""><li id="f399" class="lb lc hi ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">入站—从客户端获取消息</li><li id="7930" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">代理—代理来自入站通道或应用程序本身的消息(例如，使用<code class="du kx ky kz la b">SimpMessagingTemplate</code>)</li><li id="3955" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">出站—向客户端发送消息</li></ol><p id="f4ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个通道都有一组消息处理程序。</p><h2 id="f1b6" class="lw jv hi bd jw lx ly lz ka ma mb mc ke jg md me ki jk mf mg km jo mh mi kq mj bi translated">WebSocketAnnotationMethodMessageHandler</h2><figure class="lp lq lr ls fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-online-courses-to-learn-web-development.html"><div class="er es lv"><img src="../Images/ae57d429defc0e65fd4d160f5326e91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W40yXtgqn0Sl7aTF"/></div></a></figure><p id="1eb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kx ky kz la b">WebSocketAnnonationMethodMessageHandler</code>从客户端接收消息，如果它们与应用前缀匹配，则尝试将它们的目的地与控制器匹配。</p><p id="18c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一个控制器方法返回一个值，它被直接<strong class="ix hj">发送</strong>到这个WebSocket连接的出站通道。因此，无论单个用户拥有多少个连接，都只会向一个订阅的连接发送响应。</p><h2 id="a134" class="lw jv hi bd jw lx ly lz ka ma mb mc ke jg md me ki jk mf mg km jo mh mi kq mj bi translated">UserDestinationMessageHandler</h2><figure class="lp lq lr ls fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/02/top-5-courses-to-learn-spring-batch-for.html"><div class="er es lv"><img src="../Images/0d9c7e186297e3ae316f00015bdf1fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YZ4nBVdtSLjLX28v"/></div></a></figure><p id="f994" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一个目的地与一个用户前缀匹配，<code class="du kx ky kz la b">UserDestinationMessageHandler</code>解析一个用户，并将这个带有另一个目的地的消息发送到代理通道。对于多个用户连接，它将发送多个消息。</p><h2 id="8b2e" class="lw jv hi bd jw lx ly lz ka ma mb mc ke jg md me ki jk mf mg km jo mh mi kq mj bi translated">StompBrokerRelayMessageHandler</h2><figure class="lp lq lr ls fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/03/spring-boot-kafka-example-single-and-multiple-consumers.html"><div class="er es lv"><img src="../Images/70ad45f1bac745e4009fc321b2955f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*orEE46IPQ6twIQUu"/></div></a></figure><p id="3309" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kx ky kz la b">StompBrokerRelayMessageHandler</code>将消息代理给外部代理。例如，在<code class="du kx ky kz la b">UserDestinationMessageHandler</code>解析用户后，它可以代理来自代理通道的消息。</p><p id="33a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个处理器独立工作。因此，我们可以很容易地将<code class="du kx ky kz la b">/topic</code>和<code class="du kx ky kz la b">/user</code>添加到应用前缀中。因此，消息将被发送到控制器，并将被代理到外部消息代理。</p><h1 id="5f77" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">用户解析</h1><p id="bc41" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">关于<code class="du kx ky kz la b">UserDestinationMessageHandler</code>如何工作还有一件事。用户可能连接到不同的应用程序实例，但他们仍然需要以某种方式解析用户。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><a href="https://medium.com/javarevisited/21-spring-mvc-rest-interview-questions-answers-for-beginners-and-experienced-developers-21ad3d4c9b82"><div class="er es mk"><img src="../Images/71333f13258445da036d10b52658057e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*VDN6vdbo0KKu5USl"/></div></a></figure><p id="de2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们可以使用<code class="du kx ky kz la b">MultiServerUserRegistry</code>。它定期向特定主题发送本地用户的快照，并订阅该主题以获取远程用户。</p><p id="f5f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一个处理程序需要解析一条消息，但是它还没有获得远程用户，那么它会向未解析的主题发送一条消息。因此，它将在另一个实例中解决。</p><p id="e301" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">春季经纪人接力赛到此结束。<br/>你可以在<a class="ae iu" href="https://github.com/wirtsleg/scaling-spring-boot-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> GitHub </strong> </a>上找到完整的代码(<code class="du kx ky kz la b">scalable</code>分支包含最终解决方案)。</p></div></div>    
</body>
</html>