<html>
<head>
<title>Java Compiler Optimization for String Concatenation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">针对字符串连接的Java编译器优化</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-compiler-optimization-for-string-concatenation-7f5237e5e6ed?source=collection_archive---------2-----------------------#2020-06-13">https://medium.com/javarevisited/java-compiler-optimization-for-string-concatenation-7f5237e5e6ed?source=collection_archive---------2-----------------------#2020-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d24d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在早期的Sun Java版本中(确切地说，直到JDK1.4)，字符串连接是一件代价很高的事情。尽管后来JDK使用StringBuilder带来了字符串连接的编译器优化，但字符串类(不仅仅是连接)仍然是Java开发人员在访谈或其他场合讨论最多的话题。</p><p id="dd4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在JDK 1.5中引入了<code class="du jd je jf jg b">StringBuilder </code>类，同时，编译器针对字符串连接进行了优化，在后台使用StringBuilder代替StringBuffer(可以使用<strong class="ih hj"> <em class="jh"> javap -c </em> </strong>来检查字节码)。所以使用+运算符连接字符串:</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="dd5b" class="jq jr hi jg b fi js jt l ju jv">String a = b + c + d;</span></pre><p id="f0bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">被转换成</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="9a9d" class="jq jr hi jg b fi js jt l ju jv">String a = new StringBuilder(b).append(c).append(d).toString();</span></pre><h2 id="38f6" class="jq jr hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">如果+运算符被自动转换成字符串生成器，为什么它还存在？</h2><p id="02df" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">让我们举一个例子，考虑下面的类:</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="05e7" class="jq jr hi jg b fi js jt l ju jv">public class StringConcatenation <br/>{<br/>    public static void main(String[] args) <br/>    {<br/>        String result = "";<br/>        for (int i = 0; i &lt; 1e6; i++) <br/>        {<br/>           <strong class="jg hj"> result += "some data";</strong><br/>        }<br/>        System.out.println(result);<br/>    }<br/>}</span></pre><p id="6216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直到<a class="ae ku" href="https://javarevisited.blogspot.com/2018/08/top-5-java-8-courses-to-learn-online.html" rel="noopener ugc nofollow" target="_blank"> JDK 8 </a>这实际上被编译器转换成如下:</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="fb6a" class="jq jr hi jg b fi js jt l ju jv">public class StringConcatenation <br/>{<br/>    public static void main(String[] args) <br/>    {<strong class="jg hj"><br/>      </strong>String result <strong class="jg hj">=</strong> ""<strong class="jg hj">;</strong><br/>      for (int i = 0; i &lt; 1e6; i++) <br/>      {<br/>        <strong class="jg hj">StringBuilder tmp = new StringBuilder();<br/>        tmp.append(result);<br/>        tmp.append("some more data");<br/>        result = tmp.toString();</strong><br/>      }<br/>      System.out.println(result);<br/>    }<br/>}</span></pre><p id="7ce3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于创建了100万个对象和可能的GC，所以性能很差。因此，建议避免编译器优化，直接使用字符串生成器类，如下所示:</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="ca01" class="jq jr hi jg b fi js jt l ju jv">public class StringConcatenation <br/>{<br/>    public static void main(String[] args) <br/>    {<br/>      <strong class="jg hj">StringBuilder result = new StringBuilder((int)1e6);</strong><br/>      for (int i = 0; i &lt; 1e6; i++) <br/>      {<br/>        <strong class="jg hj">result.append("some more data");</strong><br/>      }<br/>      System.out.println(result.toString());<br/>    }<br/>}</span></pre><h1 id="f27a" class="kv jr hi bd jw kw kx ky ka kz la lb ke lc ld le kh lf lg lh kk li lj lk kn ll bi translated"><strong class="ak"> Java 9带来另一项优化</strong></h1><p id="90bc" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><strong class="ih hj">从Java 9(</strong>Java Enhancement Proposal 280或<a class="ae ku" href="http://openjdk.java.net/jeps/280" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">JEP 280</strong></a><strong class="ih hj">)</strong>，整个StringBuilder append序列已经被一个简单的<strong class="ih hj"> invokedynamic ( </strong> <em class="jh">在下面的</em> <strong class="ih hj">下一节中对此有更多介绍)</strong>调用Java . lang . invoke . stringconcatfactory，它将接受需要串联的值。</p><blockquote class="lm"><p id="bba8" class="ln lo hi bd lp lq lr ls lt lu lv jc dx translated">在Java 7之前，JVM只有四种方法调用类型:<em class="lw"> invokevirtual </em>调用普通类方法，<em class="lw"> invokestatic </em>调用静态方法，<em class="lw"> invokeinterface </em>调用接口方法，<em class="lw"> invokespecial </em>调用构造函数或私有方法。</p></blockquote><h2 id="a9e9" class="jq jr hi bd jw jx lx jz ka kb ly kd ke iq lz kg kh iu ma kj kk iy mb km kn ko bi translated"><strong class="ak">为什么需要动态实现来代替StringBuilder？</strong></h2><p id="7c33" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这种变化背后的主要动机是在不改变字节码的情况下改变连接策略，从而避免重新编译。</p><h2 id="3e76" class="jq jr hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">什么是<strong class="ak"> InvokeDynamic </strong>(也叫Indy)？</h2><p id="d1cd" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在voke<strong class="ih hj">Dy</strong>namic<a class="ae ku" href="https://en.wikipedia.org/wiki/Opcode" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">opcode</strong></a>中添加了<strong class="ih hj">作为<a class="ae ku" href="https://jcp.org/en/jsr/detail?id=292" rel="noopener ugc nofollow" target="_blank">JSR 292</a>(Java 7的第一个真实版本)的一部分，以支持在没有静态类型信息的情况下高效灵活地执行方法调用。</strong></p><p id="bd90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JDK基本上是在编译时定义字节码规范，在运行时选择该规范的实现。让我们举个例子，假设我们想要连接“我是”和“格鲁特”。</p><ul class=""><li id="0b65" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc mh mi mj mk bi translated">创建一个函数签名，即concat <em class="jh"> (String，String) - &gt; String </em></li><li id="92ab" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">上述函数的自变量是“我是”和“格鲁特”</li><li id="5472" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">一个<a class="ae ku" href="https://github.com/openjdk/jdk14u/blob/8c9ab998b758a18e65e2a1cebcc608860ae43931/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L593" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jh">makeconcantwithconstants</em></strong></a><strong class="ih hj"/>bootstrap方法被调用，带有上述函数签名、自变量和动态性所需的一些其他参数(其中有一个是<strong class="ih hj">策略</strong>，在下一节将详细介绍)，它返回一个CallSite对象。</li><li id="9999" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">这个CallSite对象封装了一系列的<em class="jh"> MethodHandles </em>，它们指向该函数签名的实际目标实现。</li><li id="d450" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated">现在，这个生成的函数用于返回串联的字符串“我是格鲁特”</li></ul><figure class="ji jj jk jl fd mr er es paragraph-image"><a href="https://medium.com/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"><div class="er es mq"><img src="../Images/041b63d51c49b916ebb3576084511d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1pF65UZtgQWxfYx5mzz9A.png"/></div></a></figure><h1 id="3fb1" class="kv jr hi bd jw kw kx ky ka kz la lb ke lc ld le kh lf lg lh kk li lj lk kn ll bi translated">Java 9+字符串连接策略</h1><p id="3056" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><code class="du jd je jf jg b"><a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java" rel="noopener ugc nofollow" target="_blank">StringConcatFactory</a></code>提供不同的<a class="ae ku" href="https://github.com/openjdk/jdk/blob/687ce3e7bb6d45ef67037dd77acd58aa48bbd724/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L136" rel="noopener ugc nofollow" target="_blank">策略</a>来使用ASM和基于MethodHandle的方法生成在字节码生成器中划分的<code class="du jd je jf jg b">CallSite</code>。</p><ul class=""><li id="d16e" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc mh mi mj mk bi translated"><code class="du jd je jf jg b"><a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L137" rel="noopener ugc nofollow" target="_blank">BC_SB</a></code> : <a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L795" rel="noopener ugc nofollow" target="_blank">生成相当于Java 8中<code class="du jd je jf jg b">javac</code>生成的字节码</a>。</li><li id="d6f2" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><code class="du jd je jf jg b"><a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L143" rel="noopener ugc nofollow" target="_blank">BC_SB_SIZED</a></code> : <a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L795" rel="noopener ugc nofollow" target="_blank">生成与<code class="du jd je jf jg b">javac</code>等价的字节码</a>，但尝试估计<code class="du jd je jf jg b">StringBuilder</code>的初始大小。</li><li id="7212" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><code class="du jd je jf jg b"><a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L149" rel="noopener ugc nofollow" target="_blank">BC_SB_SIZED_EXACT</a></code> : <a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L795" rel="noopener ugc nofollow" target="_blank">生成等同于<code class="du jd je jf jg b">javac</code>的字节码</a>，但计算<code class="du jd je jf jg b">StringBuilder</code>的确切大小。</li><li id="805f" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><code class="du jd je jf jg b"><a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L155" rel="noopener ugc nofollow" target="_blank">MH_SB_SIZED</a></code> : <a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L1232" rel="noopener ugc nofollow" target="_blank">将调用<code class="du jd je jf jg b">StringBuilder</code>的方法句柄</a>与估计的初始大小结合起来。</li><li id="da52" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><code class="du jd je jf jg b"><a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L161" rel="noopener ugc nofollow" target="_blank">MH_SB_SIZED_EXACT</a></code> : <a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L1232" rel="noopener ugc nofollow" target="_blank">组合方法句柄</a>，最终调用具有精确大小的<code class="du jd je jf jg b">StringBuilder</code>。</li><li id="1a39" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><code class="du jd je jf jg b"><a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L167" rel="noopener ugc nofollow" target="_blank">MH_INLINE_SIZED_EXACT</a></code> : <a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L1467" rel="noopener ugc nofollow" target="_blank">结合了MethodHandles </a>，直接创建一个精确大小byte[]的字符串，不需要复制。</li></ul><p id="ea64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认且最具<a class="ae ku" href="http://cr.openjdk.java.net/~shade/8085796/notes.txt" rel="noopener ugc nofollow" target="_blank">性能的</a>是能够带来3到4倍性能提升的<code class="du jd je jf jg b">MH_INLINE_SIZED_EXACT</code>。您可以通过定义属性<code class="du jd je jf jg b">java.lang.invoke.stringConcat</code>来覆盖命令行上的<code class="du jd je jf jg b">Strategy</code>。</p><p id="ff81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得一看的是<code class="du jd je jf jg b"><a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L167" rel="noopener ugc nofollow" target="_blank">MH_INLINE_SIZED_EXACT</a></code> : <a class="ae ku" href="https://github.com/dmlloyd/openjdk/blob/jdk9/jdk9/jdk/src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java#L1467" rel="noopener ugc nofollow" target="_blank">结合了MethodHandle</a>，看看我们现在如何使用method handle来有效地替代代码生成。</p><p id="78ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><ul class=""><li id="c41e" class="mc md hi ih b ii ij im in iq me iu mf iy mg jc mh mi mj mk bi translated"><a class="ae ku" href="https://howtodoinjava.com/java9/compact-strings/" rel="noopener ugc nofollow" target="_blank">https://howtodoinjava.com/java9/compact-strings/</a></li><li id="de47" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><a class="ae ku" href="http://cr.openjdk.java.net/~ntv/talks/eclipseSummit16/indyunderTheHood.pdf" rel="noopener ugc nofollow" target="_blank">http://Cr . open JDK . Java . net/~ ntv/talks/eclipse summit 16/indyunderthehood . pdf</a></li><li id="3405" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><a class="ae ku" href="https://arnaudroger.github.io/blog/2017/06/14/CompactStrings.html" rel="noopener ugc nofollow" target="_blank">https://arnaud Roger . github . io/blog/2017/06/14/compact strings . html</a></li><li id="a4cf" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><a class="ae ku" rel="noopener" href="/better-programming/top-5-new-features-expected-in-java-14-82c0d85b295e">https://medium . com/better-programming/top-5-new-features-expected-in-Java-14-82c 0d 85 b 295 e</a></li><li id="7dac" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><a class="ae ku" href="https://www.baeldung.com/java-invoke-dynamic" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-invoke-dynamic</a></li><li id="71f3" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><a class="ae ku" href="https://www.baeldung.com/java-string-concatenation-invoke-dynamic" rel="noopener ugc nofollow" target="_blank">https://www . bael dung . com/Java-string-concatenation-invoke-dynamic</a></li></ul></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><p id="0daa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有问题吗？建议？评论？</p><p id="2b18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是什么？<a class="ae ku" rel="noopener" href="/@vaibhav0109"> <strong class="ih hj">在媒体上关注我</strong> </a>成为第一个阅读我的故事的人。</p></div></div>    
</body>
</html>