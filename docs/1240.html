<html>
<head>
<title>Stream API -most useful operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流API-最有用的操作</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/stream-api-most-useful-operations-28e3988002d0?source=collection_archive---------0-----------------------#2021-05-17">https://medium.com/javarevisited/stream-api-most-useful-operations-28e3988002d0?source=collection_archive---------0-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/00e7941b5bdf7936ef36ae18925ee903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*htBMZU6IxrBYBi_W.jpg"/></div></figure><p id="0e6d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi jk translated">tream API是Java 8的主要补充之一。可以将流定义为来自支持聚合操作的源的元素序列。源可以是向流提供数据的集合或数组。</p><p id="4aa3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">流本身不是数据结构。它是应用于源的一组操作。它基本上有两种类型的操作:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/04/top-5-courses-to-learn-java-collections-and-streams.html#axzz6nwXUSoGH"><div class="er es jt"><img src="../Images/a04146fb87561f0d15aa721e303490e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psPX6qYYbXR7j2BCouvSXw.png"/></div></a></figure><ul class=""><li id="2699" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj kd ke kf kg bi translated"><strong class="io hj">中级操作——</strong>这些方法不会产生任何结果。它们通常接受函数接口作为参数，并且总是返回一个新的流。中间操作的一些例子有<a class="ae kh" href="https://www.java67.com/2018/03/java-8-stream-find-first-and-filter-example.html" rel="noopener ugc nofollow" target="_blank"> filter() </a>、<a class="ae kh" href="https://www.java67.com/2015/01/java-8-map-function-examples.html" rel="noopener ugc nofollow" target="_blank"> map() </a>等。</li><li id="5794" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated"><strong class="io hj">终端操作- </strong>这些方法产生一些结果，例如<a class="ae kh" href="https://www.java67.com/2014/04/java-8-stream-examples-and-tutorial.html" rel="noopener ugc nofollow" target="_blank"> count() </a>，<a class="ae kh" href="https://javarevisited.blogspot.com/2014/03/2-examples-of-streams-with-Java8-collections.html#axzz6co28cbJC" rel="noopener ugc nofollow" target="_blank"> collect() </a>等。</li></ul><p id="ab7b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">流</strong>操作进一步分类:<br/>注意:我们将在整篇文章中使用这三个列表:<br/> <strong class="io hj"> employeeList </strong>包含雇员的姓名、年龄、工资和国家。<br/> <strong class="io hj"> intList </strong>有一些随机整数。<br/>T25】string list有一些大写和小写的字符串。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://www.java67.com/2016/03/how-to-get-arraylist-from-stream-in-java8-example.html"><div class="er es kn"><img src="../Images/6adf6cbde91ca43bcb0e3acd53a1c683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jlLrLn3xBq0UF9R2Rr8Vw.png"/></div></a></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es ko"><img src="../Images/e2e20482f9ece7106ba0d059e9d78e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bA7fYRVc6tAGPEx_d9he_Q.png"/></div></div></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kt"><img src="../Images/bab4c10a6ae960be2ba9f66f5a97b82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2ZMcR-4kqFdoJXNdrujDg.png"/></div></div></figure><ol class=""><li id="260e" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj ku ke kf kg bi translated"><strong class="io hj"> <em class="kv">过滤</em> </strong> <em class="kv"> - </em>过滤操作对给定的流进行过滤，并返回一个新的流，该流只包含下一个操作所需的那些元素。这是一个中间操作。</li></ol><ul class=""><li id="93f5" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj kd ke kf kg bi translated"><strong class="io hj"> <em class="kv">过滤出年龄大于30的员工:</em> </strong> <br/> <code class="du kw kx ky kz b">employeeList.stream().filter(emp -&gt; emp.getAge() &gt;30).ForEach(System.out::println);</code></li></ul><p id="6fe7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.S <strong class="io hj"> licing- </strong>切片操作是中间操作，顾名思义，是用来切片流的。它包括distinct()、limit()、skip()。以这个<strong class="io hj"> intList </strong>为例:</p><ul class=""><li id="a048" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj kd ke kf kg bi translated"><strong class="io hj"> <em class="kv">柜内不同值列表有重复项- </em> </strong> intList.stream()。独特()。forEach(system . out::println)；</li><li id="ca78" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated"><strong class="io hj">限制返回的流最多只返回n个值- </strong> intList.stream()。独特()。极限(3)。forEach(system . out::println)；</li><li id="933d" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated"><strong class="io hj"> <em class="kv">跳过第n(此处为其2)个值- </em> </strong> intList.stream()。独特()。跳过(2)。forEach(system . out::println)；</li></ul><p id="9f52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.<strong class="io hj">映射- </strong>映射操作是转换一个流的元素并返回一个包含转换后的元素的新流的操作。Map()和<a class="ae kh" href="http://www.java67.com/2016/03/how-to-use-flatmap-in-java-8-stream.html" rel="noopener ugc nofollow" target="_blank"> flatMap() </a>是最常用的方法。对于ex:取<strong class="io hj"> stringList </strong>它以String为输入，</p><ul class=""><li id="92ee" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj kd ke kf kg bi translated"><strong class="io hj"> <em class="kv">以大写形式打印列表中的名称—</em></strong><br/>string list . stream()。map(name - &gt; name.toUpperCase())。forEach(system . out::println)；</li><li id="c937" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated"><strong class="io hj"> <em class="kv">要得到单词的长度，输入是一个字符串，输出是一个整数，我们用mapToInt()方法代替map()，它将返回IntStream而不是Stream。</em></strong><br/>string list . stream()。mapToInt(name - &gt; name.length())。forEach(system . out::println)；</li></ul><p id="8821" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">4.<strong class="io hj">匹配</strong>——匹配操作是终端操作，用于检查流中是否存在符合特定标准的元素。大多使用匹配的三种运算:<a class="ae kh" href="https://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#axzz6ieZZarMY" rel="noopener ugc nofollow" target="_blank"><strong class="io hj">【any match()】</strong></a><strong class="io hj">、allMatch()、noneMatch()。考虑到employeeList，让我们看看不同的匹配操作:</strong></p><ul class=""><li id="a165" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj kd ke kf kg bi translated"><strong class="io hj">检查是否有人居住在特定国家:</strong><br/>boolean Canadian = employee list . stream()。anyMatch(p - &gt; p.getCountry()。equals("加拿大"))；</li><li id="837d" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated">T <strong class="io hj"> o检查所有人员是否都是特定国家的居民:</strong><br/>boolean allIndian = employee list . stream()。allMatch(p - &gt; p.getCountry()。equals("印度"))；</li><li id="5497" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated"><strong class="io hj">检查是否所有人都不是某个国家的居民:</strong><br/>boolean none Mexican = employee list . stream()。noneMatch(p - &gt; p.getCountry()。equals("墨西哥"))；</li></ul><p id="1aed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">5.<strong class="io hj">查找</strong> -查找操作是终端操作，用于获取匹配的元素，而不仅仅是验证它是否存在。流中有两个基本的查找操作，即findAny()，<a class="ae kh" href="https://javarevisited.blogspot.sg/2016/03/how-to-find-first-element-of-stream-in.html" rel="noopener ugc nofollow" target="_blank"> findFirst() </a>。例如:</p><ul class=""><li id="7477" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj kd ke kf kg bi translated"><strong class="io hj">筛选居住在印度的员工并获得第一个匹配项。</strong>T43【可选】员工&lt;员工&gt; person = employeeList.stream()。filter(p - &gt; p.getCountry()。等于(“印度”))。findFirst()；</li></ul><p id="1e80" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">findAny()的用法与findFirst()类似，但是在我们不关心返回哪个元素的情况下，比如并行流。如果我们在并行流中使用findFirst()方法，会非常慢。</p><p id="eab4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">6.<strong class="io hj">归约- </strong>归约流操作是将流归约为单个值的操作。当我们需要执行流缩减为单个值的操作时，例如，最大值、最小值、总和、乘积等。sum()，min()，max()，count()等。下面是一些归约运算的例子。<a class="ae kh" href="https://www.java67.com/2016/09/map-reduce-example-java8.html" rel="noopener ugc nofollow" target="_blank"> reduce() </a>明确要求您指定如何减少通过数据流的数据。</p><ul class=""><li id="08d5" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj kd ke kf kg bi translated"><strong class="io hj">计算所有员工工资的总和。<br/> </strong>可选&lt;整数&gt;合计薪资= employeeList.stream()。map(p - &gt; p.getSalary())。减少((a，b)-&gt;a+b)；</li><li id="fec6" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated">使用sum()也可以找到上面的sum，但是我们需要将流转换为IntStream，我们可以直接使用sum()。<br/>int total sal = employee list . stream()。mapToInt(p - &gt; p.getSalary())。sum()；</li><li id="fd8f" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated"><strong class="io hj">同样地，当我们需要任何流中的最大或最小元素时，我们也可以使用min()，max()。</strong> <br/>可选&lt;整数&gt; max = intList.stream()。max(comparator . natural order())；<br/> <em class="kv">注意:如果流是一个自定义对象，我们也可以提供一个自定义比较器。</em></li></ul><p id="c517" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">7.<strong class="io hj">收集</strong>——是终端法。我们可以创建自己的<strong class="io hj">收集器</strong>实现，也可以使用<a class="ae kh" href="https://www.java67.com/2018/11/10-examples-of-collectors-in-java-8.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">收集器</strong>类</a>提供的预定义实现。Collectors有各种方法，比如— toList()、toMap()、toSet()、CollectingAndThen()、<a class="ae kh" href="https://javarevisited.blogspot.com/2015/07/how-to-do-group-by-in-java-8.html" rel="noopener ugc nofollow" target="_blank"> groupingBy() </a>、partitioningBy()、minBy()、maxBy()等。我们将通过将这些分为三类来详细研究这些问题:</p><h1 id="26b0" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak"> <em class="ly">收藏操作:</em> </strong></h1><ol class=""><li id="b54a" class="jy jz hi io b ip lz it ma ix mb jb mc jf md jj ku ke kf kg bi translated"><strong class="io hj"> toList()- </strong>将流收集到列表中:<br/>List&lt;String&gt;empName = employee List . stream()。map(emp - &gt; emp.getName()。collect(collectors . to list())；</li><li id="d4fc" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj"> toSet() </strong> -将流收集到Set:<br/>Set&lt;String&gt;empName = employee list . stream()。map(emp - &gt; emp.getCountry())。collect(collectors . toset())；</li><li id="dfd5" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj"> toMap() </strong> -将流收集到Map: <br/> Map &lt; String，Integer&gt;name Map = list . stream()。collect(collectors . tomap(s-&gt;s，s - &gt; s.length()，(s1，S2)-&gt;S1))；<br/> <strong class="io hj">注意</strong> : toMap()在列表有重复元素的情况下抛出异常，为了避免这种情况，使用上面提到的带有附加参数的实现来选择第一个有重复的元素(比如s1，s2 - &gt; s1)。</li><li id="4c1e" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj">to Collection(Supplier&lt;C&gt;Collection factory)</strong>-将输入元素收集到新集合中:<br/>linked list&lt;String&gt;empName = employee list . stream()。map(emp - &gt; emp.getName())。collect(collectors . to collection(linked list::new))；</li><li id="9789" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj"> collectingAndThen() </strong> -这个方法返回一个收集器，它将输入元素累积到给定的收集器中，然后执行一个附加的完成功能。例如:在这里使列表不可修改:<br/>List&lt;Employee&gt;unmodified List = Employee List . stream()。收藏(收藏者。<em class="kv">收集然后</em>(收集者。<em class="kv"> toList </em>()、Collections:: <em class="kv">不可修改列表</em>)；</li></ol><h1 id="3637" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">聚合操作:</h1><ol class=""><li id="9bb1" class="jy jz hi io b ip lz it ma ix mb jb mc jf md jj ku ke kf kg bi translated"><strong class="io hj"> counting()- </strong>获取员工数:<strong class="io hj"><br/></strong>long count = employee list . stream()。过滤器(emp - &gt; emp.getAge() &gt; 30)。收藏(收藏者。<em class="kv">计数</em>())；</li><li id="aa21" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj"> minBy() </strong> -获取最低工资的员工:<br/>可选&lt;员工&gt; emp =employeeList.stream()。collect(collectors . min by(comparator . comparising(Employee::get salary)))；</li><li id="302e" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj"> maxBy()- </strong>获取最高工资的员工:<strong class="io hj"> <br/> </strong>可选&lt;员工&gt;Employee = Employee list . stream()。collect(collectors . max by(comparator . comparising(Employee::get salary)))；</li><li id="ba7c" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj">collectors . summingint(tointfunctionmapper)-</strong>获取所有员工的工资总和:<strong class="io hj"><br/></strong>int count = employee list . stream()。collect(collectors . summingint(EMP-&gt;EMP . getsalary()))；</li><li id="fc7a" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj">collectors . averaging int(tointfunctionmapper)-</strong>获取所有员工的平均工资:<strong class="io hj"><br/></strong>double avg = employee list . stream()。collect(collectors . averaging int(EMP-&gt;EMP . getsalary()))；</li><li id="bdf6" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj"> joining()- </strong>将所有字符串连接起来，中间留有空间。<br/>String joined String = stream . of(" welcome "，" to ""Java "，" world ")。collect(collectors . joining())；<br/> <strong class="io hj">注意</strong>:我们也可以使用其他重载版本的连接方法，它们允许我们提供分隔符以及前缀和后缀字符串。</li><li id="0e02" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj ku ke kf kg bi translated"><strong class="io hj">summary gint(tointfunctionmapper)-</strong>获取任意集合的汇总统计:<strong class="io hj"><br/></strong>IntSummaryStatistics summary gint = employee list . stream()。收藏(收藏者。<em class="kv">summary gint</em>(Employee::get salary))；<br/> <strong class="io hj">注意</strong>:输出将类似于—<br/>IntSummaryStatistics { count = 6，sum=248000，min=23000，average=41333.333333，max=67000}</li></ol><h1 id="496d" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">分组操作:</h1><p id="b7d8" class="pw-post-body-paragraph im in hi io b ip lz ir is it ma iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">分组操作是streams 最重要的<a class="ae kh" rel="noopener" href="/javarevisited/7-best-java-collections-and-stream-api-courses-for-beginners-in-2020-3ad18d52c38">特性之一，因为它们可以帮助您在2-3行内完成一项任务，否则将需要大量编码。</a></p><p id="5a5c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> groupingBy() </strong> -按国家对雇员进行分组:<br/> Map &lt; String，List&lt;Employee&gt;&gt;EMP Map = Employee List . stream()。<br/>collect(collectors . grouping by(Employee::get country))；</p><p id="b066" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意</strong>:该方法有更多的使用案例，例如:</p><ul class=""><li id="f117" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj kd ke kf kg bi translated"><strong class="io hj">如果我们需要得到一个映射，其中的关键字是国家的名称，值是该国所有雇员的工资总和:</strong> <br/> Map &lt; String，Integer&gt;EMP Map = employee list . stream()。collect(collectors . grouping by(Employee::get country，collectors . summingint(Employee::get salary)))；</li><li id="ece5" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated"><strong class="io hj">我们也可以用重载版本的grouping by():</strong><br/>Map&lt;String，set&lt;Employee&gt;&gt;EMP Map = Employee list . stream()将结果存储在Set而不是list中。collect(collectors . grouping by(Employee::get country，collectors . toset())；</li><li id="40ea" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated"><strong class="io hj">如果我们需要对多个条件进行分组。然后我们可以提供另一个groupingBy()作为下游的<em class="kv">，例如:</em>通过两次使用groupingBy()方法按照国家和年龄对雇员进行分组。<br/> </strong> Map &lt; String，Map &lt; Integer，List&lt;Employee&gt;&gt;&gt;empMap = Employee List . stream()。collect(collectors . grouping by(Employee::get country，collectors . grouping by(Employee::get age)))；</li><li id="088d" class="jy jz hi io b ip ki it kj ix kk jb kl jf km jj kd ke kf kg bi translated">如果我们需要得到一个映射，其中键是国家的名称，值是在那个国家有最高工资的雇员对象。 <br/>映射&lt;字符串，可选&lt;雇员&gt;&gt;EMP Map = Employee list . stream()。collect(collectors . grouping by(Employee::get country，collectors . max by(comparator . comparingint(Employee::get salary)))；</li></ul><p id="bdfb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> partitioningBy(): </strong>是<strong class="io hj"> </strong>用于根据给定的谓词对一个对象流(或一组元素)进行分区，并返回一个Map &lt; Boolean，List &lt; T &gt; &gt;。因为键是布尔值，所以它只接受真/假值。在true键下，我们将找到匹配给定谓词的元素。</p><ul class=""><li id="545e" class="jy jz hi io b ip iq it iu ix ka jb kb jf kc jj kd ke kf kg bi translated"><strong class="io hj">如果我们需要根据年龄对employeeList进行分区:</strong> <br/> Map &lt; Boolean，List&lt;Employee&gt;&gt;EMP Map = Employee List . stream()。collect(collectors . partitioning by(EMP-&gt;EMP . getage()&gt;30))；</li></ul><p id="8f44" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一些非常有用的流方法。这些只是快速检查，需要一些更详细的练习。<br/>参考:<a class="ae kh" href="https://www.educative.io/courses/java-8-lambdas-stream-api-beyond" rel="noopener ugc nofollow" target="_blank"> Java Stream Api </a></p><p id="b189" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谢谢！快乐学习:)</p></div></div>    
</body>
</html>