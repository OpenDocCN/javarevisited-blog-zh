<html>
<head>
<title>Avoid subclassing using Decorator pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免使用装饰模式的子类化</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/avoid-subclassing-using-decorator-pattern-841ad66be817?source=collection_archive---------1-----------------------#2022-11-29">https://medium.com/javarevisited/avoid-subclassing-using-decorator-pattern-841ad66be817?source=collection_archive---------1-----------------------#2022-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9179" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何使用decorator模式避免子类化，用一个文本格式化的例子来解释</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2013/07/decorator-design-pattern-in-java-real-life-example-tutorial.html"><div class="er es ix"><img src="../Images/9dd8d3a8b17ac275d4cc6309a999d887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evc2CD_YQR_T7N-lNL0zTw.png"/></div></a></figure><blockquote class="jf jg jh"><p id="d7b7" class="ji jj jk jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">装饰模式允许动态地将行为添加到一个单独的对象中，而不会影响同一类中其他对象的行为。</p></blockquote><p id="59ca" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">装饰模式经常被用来替代子类化。子类化在编译时添加行为，而在修饰时，行为可以在运行时添加。</p><p id="9408" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">在<a class="ae ki" href="https://javarevisited.blogspot.com/2015/01/adapter-vs-decorator-vs-facade-vs-proxy-pattern-java.html" rel="noopener ugc nofollow" target="_blank">装饰器模式</a>中，创建了一个包装原始对象的装饰器对象。装饰对象提供了与原始对象相同的接口，但是它也添加了自己的行为。</p><h2 id="3af4" class="kj kk hi bd kl km kn ko kp kq kr ks kt kf ku kv kw kg kx ky kz kh la lb lc ld bi translated"><strong class="ak">这里有一些例子</strong></h2><ol class=""><li id="b149" class="le lf hi jl b jm lg jp lh kf li kg lj kh lk ke ll lm ln lo bi translated"><strong class="jl hj">Java中的流类:</strong><a class="ae ki" href="https://javarevisited.blogspot.com/2014/04/difference-between-fileinputstream-and-filereader-in-java.html" rel="noopener ugc nofollow" target="_blank"><em class="jk">file inputstream</em></a>可以包装在<a class="ae ki" href="https://www.java67.com/2016/06/5-difference-between-bufferedreader-and-scanner-in-java.html" rel="noopener ugc nofollow" target="_blank"><em class="jk">BufferedInputStream</em></a>中，为文件输入流添加缓冲行为。它可以再次包装在<em class="jk"> LineNumberInputStream </em>中，以增加在读取数据时跟踪当前行号的能力。</li><li id="15fe" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke ll lm ln lo bi translated"><strong class="jl hj">日志</strong>:装饰对象可能会给现有对象添加日志功能。当在装饰对象上调用方法时，装饰对象将首先记录方法调用，然后在原始对象上调用相同的方法。</li><li id="8e13" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke ll lm ln lo bi translated"><strong class="jl hj">文件处理</strong>:文件可以直接写入磁盘，也可以先加密或压缩再写入磁盘。可以通过decorators添加加密和压缩功能。</li><li id="377f" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke ll lm ln lo bi translated"><strong class="jl hj">文本格式</strong>:我们可以添加粗体、斜体、下划线和删除线等。通过装饰器格式化。它们可以按照我们想要的任何组合来应用。</li></ol><p id="cd06" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">让我们通过一个基本文本编辑器的<a class="ae ki" href="https://www.java67.com/2016/12/7-examples-of-stringformat-and-printf.html" rel="noopener ugc nofollow" target="_blank">文本格式化</a>用例来理解这个概念。<br/>假设我们在后端有一个类<em class="jk"> SimpleText </em>来支持简单文本功能。</p><pre class="iy iz ja jb fd lu lv lw bn lx ly bi"><span id="7c47" class="lz kk hi lv b be ma mb l mc md">public class SimpleText {<br/>   protected final String text;<br/>  <br/>   public SimpleText(String text) {<br/>      this.text = text;<br/>   }<br/>  <br/>   public String getText() {<br/>      return text;<br/>   }<br/>}</span></pre><p id="90f7" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">现在，随着应用程序越来越受欢迎，我们希望添加对不同文本格式样式的支持，如粗体和斜体。</p><p id="2cb0" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">所以一种方法是使用继承/子类化来扩展简单文本的行为。我们将创建新的类来扩展<em class="jk"> SimpleText </em>类来添加额外的行为。</p><p id="6d79" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">因此，为了支持粗体和斜体格式，我们需要3个新类:</p><ul class=""><li id="f7e6" class="le lf hi jl b jm jn jp jq kf me kg mf kh mg ke mh lm ln lo bi translated"><em class="jk">粗体文本</em>(用于支持粗体格式)</li><li id="6e35" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke mh lm ln lo bi translated"><em class="jk">斜体文本</em>(用于支持斜体格式)</li><li id="a1cf" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke mh lm ln lo bi translated"><em class="jk"> BoldItalicText </em>(用于处理粗体和斜体的组合)。</li></ul><pre class="iy iz ja jb fd lu lv lw bn lx ly bi"><span id="51fc" class="lz kk hi lv b be ma mb l mc md">public class BoldText extends SimpleText {<br/>   public BoldText(String text) {<br/>      super(text);<br/>   }<br/>  <br/>   public String getText() {<br/>      return "&lt;b&gt;" + this.text + "&lt;/b&gt;";<br/>   }<br/>}</span></pre><pre class="mi lu lv lw bn lx ly bi"><span id="134e" class="lz kk hi lv b be ma mb l mc md">public class ItalicText extends SimpleText {<br/>   public ItalicText(String text) {<br/>      super(text);<br/>   }<br/>  <br/>   public String getText() {<br/>      return "&lt;i&gt;" + this.text + "&lt;/i&gt;";<br/>   }<br/>}</span></pre><pre class="mi lu lv lw bn lx ly bi"><span id="48bc" class="lz kk hi lv b be ma mb l mc md">public class BoldItalicText extends SimpleText {<br/>   public BoldItalicText(String text) {<br/>      super(text);<br/>   }<br/>  <br/>   public String getText() {<br/>      return "&lt;b&gt;&lt;i&gt;" + this.text + "&lt;/i&gt;&lt;/b&gt;";<br/>   }<br/>}</span></pre><p id="498d" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">现在，假设我们还想添加“下划线格式”。</p><p id="34bc" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">这意味着我们必须添加另外4个类来支持所有现有的粗体和斜体组合的下划线格式:<em class="jk"> UnderlineText </em>、<em class="jk"> UnderlineBoldText </em>、<em class="jk">underlinealictext</em>和<em class="jk">UnderlineBoldItalicText</em>。所以现在我们总共有7节课。</p><p id="007b" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">现在，假设我们还想添加删除线格式。现在我们需要再添加8个类来涵盖所有的可能性。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/02/23-object-oriented-design-patterns-gof-Java-programmers-developers.html"><div class="er es mj"><img src="../Images/6b007caf40c1de8cc9997cd43c356b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZoDrwfiPXBMO3A2MuRnYQ.png"/></div></a><p class="mk ml et er es mm mn bd b be z dx translated">班级爆炸</p></figure><p id="b70b" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">如果我们将来会有更多的格式类型出现呢？我们需要为每一种新的格式类型添加越来越多的类。那是一场维护的噩梦！</p><p id="502c" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated"><strong class="jl hj">上述方法的问题:</strong></p><ul class=""><li id="d6a1" class="le lf hi jl b jm jn jp jq kf me kg mf kh mg ke mh lm ln lo bi translated">对于每一种新的格式类型，类都呈指数级增长。</li><li id="4854" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke mh lm ln lo bi translated">如果我们想改变我们维护格式的方式，我们必须更新所有的类。</li></ul><p id="9069" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">我们可以清楚地看到，子类化并不是真正的出路。我们需要偏爱组合而不是继承。我们将使用composition把对象(我们想要添加新行为的对象)包装在decorators内部。</p><p id="9a65" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">让我们看看如何重构文本格式化用例来使用装饰模式。</p><ol class=""><li id="9493" class="le lf hi jl b jm jn jp jq kf me kg mf kh mg ke ll lm ln lo bi translated">我们将为我们的文本类定义一个接口，并为简单文本类实现接口。姑且称之为‘组件’吧。</li></ol><pre class="iy iz ja jb fd lu lv lw bn lx ly bi"><span id="8111" class="lz kk hi lv b be ma mb l mc md">// Component<br/>public interface Text {<br/>   String getText();<br/>}</span></pre><pre class="mi lu lv lw bn lx ly bi"><span id="edc4" class="lz kk hi lv b be ma mb l mc md">// Concrete component<br/>public class SimpleText implements Text {<br/>   private final String text;<br/>  <br/>   public SimpleText(String text) {<br/>    this.text = text;<br/>   }<br/>  <br/>   @Override<br/>   public String getText() {<br/>    return text;<br/>   }<br/>}</span></pre><p id="c1eb" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">2.现在我们将为所有的装饰者定义一个接口。这个接口应该扩展原始对象的接口，也就是说，它应该扩展组件。</p><ul class=""><li id="3a46" class="le lf hi jl b jm jn jp jq kf me kg mf kh mg ke mh lm ln lo bi translated">这将允许我们重用装饰器来代替原始对象。</li></ul><blockquote class="jf jg jh"><p id="ade9" class="ji jj jk jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Decorator应该实现与原始对象相同的接口。</p></blockquote><pre class="iy iz ja jb fd lu lv lw bn lx ly bi"><span id="11f8" class="lz kk hi lv b be ma mb l mc md">/*<br/>Common interface for all decorators.<br/>This should extend the component interface.<br/>*/<br/>public interface TextDecorator extends Text {<br/>}</span></pre><p id="766f" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">3.我们将实现我们希望作为具体装饰类的附加行为。在我们的例子中，我们将实现粗体、斜体和下划线格式作为装饰。</p><p id="358a" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">装饰者应该持有对组件的引用，并且应该使用该引用来扩展功能</p><blockquote class="jf jg jh"><p id="c742" class="ji jj jk jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">装饰者应该组合组件并使用它来扩展行为</p></blockquote><p id="bea6" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">这将允许我们将原始对象包装到一个装饰器中，并将一个装饰器包装到另一个装饰器中。</p><pre class="iy iz ja jb fd lu lv lw bn lx ly bi"><span id="3512" class="lz kk hi lv b be ma mb l mc md">/* <br/>Concrete decorator implements the decorator interface, which in<br/>turn extends the component.<br/>*/<br/>public class Bold implements TextDecorator {<br/>   private final Text text;<br/><br/>   //Decorator should hold a reference to the component<br/>   public Bold(Text text) {<br/>      this.text = text;<br/>   }<br/>   <br/>   //implement the methods using the component<br/>   @Override<br/>   public String getText() {<br/>      return "&lt;b&gt;" + this.text.getText() + "&lt;/b&gt;";<br/>   }<br/>}</span></pre><pre class="mi lu lv lw bn lx ly bi"><span id="cace" class="lz kk hi lv b be ma mb l mc md">public class Italic implements TextDecorator {<br/>   private final Text text;<br/><br/>   public Italic(Text text) {<br/>      this.text = text;<br/>   }<br/>  <br/>   @Override<br/>   public String getText() {<br/>      return "&lt;i&gt;" + this.text.getText() + "&lt;/i&gt;";<br/>   }<br/>}</span></pre><pre class="mi lu lv lw bn lx ly bi"><span id="1ee2" class="lz kk hi lv b be ma mb l mc md">public class Underline implements TextDecorator {<br/>   private final Text text;<br/><br/>   public Underline(Text text) {<br/>      this.text = text;<br/>   }<br/>  <br/>   @Override<br/>   public String getText() {<br/>      return "&lt;u&gt;" + this.text.getText() + "&lt;/u&gt;";<br/>   }<br/>}</span></pre><p id="edf4" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">现在，在未来，如果我们想添加新的格式类型，如删除线或链接等，我们只需添加一个新的装饰类。不需要接触任何现有的对象(打开用于扩展，关闭用于修改)。</p><p id="78cb" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">我们可以在运行时用任意多的装饰器包装原始对象。</p><pre class="iy iz ja jb fd lu lv lw bn lx ly bi"><span id="e48d" class="lz kk hi lv b be ma mb l mc md">public class Main {<br/>   public static void main(String[] args) {<br/>      Text formattedText = new Underline(new Italic(new Bold(new SimpleText("decorator pattern"))));<br/>      System.out.println(formattedText.getText()); <br/>      // Output: &lt;u&gt;&lt;i&gt;&lt;b&gt;decorator pattern&lt;/b&gt;&lt;/i&gt;&lt;/u&gt;<br/>   }<br/>}</span></pre><p id="6a95" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">下面是同一个例子的类图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-java-design-pattern-courses-for-developers.html"><div class="er es mo"><img src="../Images/ab6c9149307187546d60c8e1fce0464d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQex0SAkSBJbddfpA578gg.png"/></div></a><p class="mk ml et er es mm mn bd b be z dx translated">装饰模式的类图</p></figure><h2 id="6920" class="kj kk hi bd kl km kn ko kp kq kr ks kt kf ku kv kw kg kx ky kz kh la lb lc ld bi translated"><strong class="ak">点注意事项</strong></h2><ul class=""><li id="f5d6" class="le lf hi jl b jm lg jp lh kf li kg lj kh lk ke mh lm ln lo bi translated">装饰者应该扩展/实现组件。这是在代码中使用装饰器代替原始对象所需要的。</li><li id="6474" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke mh lm ln lo bi translated">装饰者也应该组成组件。这是在装饰器中包装原始对象以及在另一个装饰器中包装一个装饰器所需要的。</li></ul><h2 id="2378" class="kj kk hi bd kl km kn ko kp kq kr ks kt kf ku kv kw kg kx ky kz kh la lb lc ld bi translated"><strong class="ak">优势</strong></h2><ul class=""><li id="d23f" class="le lf hi jl b jm lg jp lh kf li kg lj kh lk ke mh lm ln lo bi translated"><strong class="jl hj">维护</strong> -这是子类化的一种灵活的替代方式。该模式允许在不改变原始代码的情况下将新行为添加到现有的类中。</li><li id="b89b" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke mh lm ln lo bi translated"><strong class="jl hj">遵循SRP- </strong>功能被封装在不同的装饰器类中。</li><li id="f461" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke mh lm ln lo bi translated"><strong class="jl hj">跟随OCP- </strong>新的行为可以添加到新的装饰器中。不需要更新现有的类。</li><li id="a95d" class="le lf hi jl b jm lp jp lq kf lr kg ls kh lt ke mh lm ln lo bi translated">关注点分离。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2022/03/top-5-free-courses-to-learn-design.html"><div class="er es mp"><img src="../Images/a971199783075ccf3829d7fed72cb507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I0VTJeOZPY96VkcTBcYKqA.png"/></div></a><p class="mk ml et er es mm mn bd b be z dx translated">总结装饰模式的思维导图</p></figure></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h2 id="08ff" class="kj kk hi bd kl km kn ko kp kq kr ks kt kf ku kv kw kg kx ky kz kh la lb lc ld bi translated">参考</h2><ul class=""><li id="02fd" class="le lf hi jl b jm lg jp lh kf li kg lj kh lk ke mh lm ln lo bi translated"><a class="ae ki" rel="noopener" href="/javarevisited/7-best-books-to-learn-design-patterns-for-java-programmers-5627b93eefdb">头先设计图案</a></li></ul><p id="a921" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">目前就这些。欢迎对这篇文章提出任何问题或分享任何意见。下一篇文章再见。</p><p id="570b" class="pw-post-body-paragraph ji jj hi jl b jm jn ij jo jp jq im jr kf jt ju jv kg jx jy jz kh kb kc kd ke hb bi translated">编码快乐！</p></div></div>    
</body>
</html>