<html>
<head>
<title>Hashcode and Equals Debugging, Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hashcode等于调试，性能</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/hashcode-and-equals-debugging-performance-a4763d02f0ce?source=collection_archive---------1-----------------------#2021-11-25">https://medium.com/javarevisited/hashcode-and-equals-debugging-performance-a4763d02f0ce?source=collection_archive---------1-----------------------#2021-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6a1251c0f6f54406ae5ec020fbe3f17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3wgfiCj26KcK9GQ2k7uYg.jpeg"/></div></div></figure><p id="ae72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几周前，我在Reddit 上看到了这个故事，讨论了在地图中使用URL类作为关键字的问题。这归结为<a class="ae jo" href="http://java.net.URL" rel="noopener ugc nofollow" target="_blank"> java.net.URL </a>中hashcode()方法的实现非常慢，这使得这个类在这种情况下无法使用。不幸的是，这是Java API规范的一部分，在不破坏向后兼容性的情况下不再能够修复。</p><p id="63b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们能做的是理解<a class="ae jo" href="https://www.java67.com/2012/11/difference-between-operator-and-equals-method-in.html" rel="noopener ugc nofollow" target="_blank">等于</a>和<a class="ae jo" href="https://javarevisited.blogspot.com/2013/08/10-equals-and-hashcode-interview.html#axzz7D1K8JL8x" rel="noopener ugc nofollow" target="_blank">哈希码</a>的问题。以后怎么才能避免这样的问题？</p><h1 id="770f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">URLs Hashcode和Equals有什么问题？</h1><p id="4f46" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了理解这一点，让我们来看看hashcode和equals的JavaDoc:</p><blockquote class="ks kt ku"><p id="30b4" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated"><em class="hi">比较此URL与另一个对象是否相等。</em></p><p id="68f4" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated"><em class="hi">如果给定的对象不是URL，那么这个方法立即返回false。</em></p><p id="eacf" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated"><em class="hi">两个URL对象如果有相同的协议，</em> <strong class="is hj"> <em class="hi">引用等价主机</em> </strong> <em class="hi">，在主机上有相同的端口号，以及相同的文件和文件的片段，则是相等的。</em></p><p id="6c02" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">如果两台主机的名称都可以解析成相同的IP地址，那么这两台主机就被认为是等价的；</em> </strong> <em class="hi">否则如果任一主机名无法解析，则主机名必须相等，不考虑大小写；或者两个主机名都等于空。</em></p><p id="a5dc" class="iq ir kv is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated"><em class="hi">因为主机比较需要名称解析，所以该操作是阻塞操作。</em></p></blockquote><p id="a114" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为主机比较需要名称解析，所以此操作是一个阻塞操作。"</p><p id="f91f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可能不清楚。让我们用一个简单的代码块来阐明它:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="1cd2" class="li jq hi le b fi lj lk l ll lm">System.out.println(new URL("http://localhost/").equals(new URL("http://127.0.0.1/")));<br/>System.out.println(new URL("http://localhost/").hashCode() == new URL("http://127.0.0.1/").hashCode());</span></pre><p id="c284" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将打印出:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="8ec5" class="li jq hi le b fi lj lk l ll lm">true<br/>true</span></pre><p id="3b6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于localhost来说，这可能很简单，但是如果我们比较域并且字符串不相同(通常不相同)，我们就需要进行DNS查找。我们需要做的只是一个hashcode()调用！</p><h1 id="d61f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">快速解决方法</h1><p id="dd05" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">对于这种情况，一个快速的解决方法是避免使用URL。Sun将该类深深嵌入到原始JVM代码中，但是我们可以使用URI来实现大多数目的。</p><p id="2521" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果我们将上面的hashcode和equal调用改为使用URI而不是URL，我们将得到以下结果:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="92f3" class="li jq hi le b fi lj lk l ll lm">System.out.println(new URI("http://localhost/").equals(new URI("http://127.0.0.1/")));<br/>System.out.println(new URI("http://localhost/").hashCode() == new URI("http://127.0.0.1/").hashCode());</span></pre><p id="2e44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两个语句都将为假。虽然对于某些用例来说这可能会有问题，但这在性能上是一个巨大的差异。</p><h1 id="4813" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一个更大的陷阱</h1><p id="3c24" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果我们只使用字符串作为映射键，那就没问题了。在我们使用这些方法的每一个地方，这种错误都会袭击我们:</p><ul class=""><li id="b5a9" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">设置</li><li id="fc72" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">地图</li><li id="ce9a" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">储存；储备</li><li id="040f" class="ln lo hi is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">业务逻辑</li></ul><p id="0600" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是会越来越深。当用我们自己的hashcode和equals逻辑编写我们自己的类时，我们经常会成为糟糕代码的牺牲品。hashcode方法或过于简单的版本上的一个小的性能损失会导致很难跟踪的大的性能损失。</p><p id="d591" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，因为hashcode方法慢或不正确而花费更长时间的流操作可能代表长期问题。</p><h1 id="b3a7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">最好的Hashcode实现</h1><p id="368c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">要理解最好的hashcode和equals方法，我们首先需要理解一些平庸的代码。现在我不会展示可怕的或旧的代码。这是很好的代码，但不是最好的:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5885" class="li jq hi le b fi lj lk l ll lm">public int hashCode() {<br/>    return Objects.hash(id, core, setting, values, sets);<br/>}</span></pre><p id="90f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码乍一看似乎还不错，但真的是这样吗？以下是理想的代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c8a5" class="li jq hi le b fi lj lk l ll lm">public int hashCode() {<br/>    return id;<br/>}</span></pre><p id="7e53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是快速的，100%唯一和正确的。实际上没有理由做任何超出这一范围的事情。id有一个例外，它是一个对象。在这种情况下，我们可能希望用Objects.hashCode(id)代替，这也适用于null，等等。</p><h1 id="f6cf" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Hashcode不等于</h1><p id="32dd" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">显然，这是你在编写hashcode实现时需要记住的最重要的事情之一。该方法必须快速执行，并且对于假情况必须与equals一致。这对于true的情况是不正确的。</p><p id="a7c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">澄清一下，hashcode必须始终遵守这条法则:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ff6b" class="li jq hi le b fi lj lk l ll lm">assert(obj1.hashCode() != obj2.hashCode() &amp;&amp; !obj1.equals(obj2));</span></pre><p id="7c8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着如果hashcode结果不同，那么对象也必须不同，并且必须从equals返回false。但反过来却不是这样:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7f25" class="li jq hi le b fi lj lk l ll lm">if(obj1.hashCode() == obj2.hashCode()) {<br/>    if(obj1.equals(obj2)) {<br/>       // this can be false...<br/>    }<br/>}</span></pre><p id="5337" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的价值在于性能。hashcode方法的执行速度应该比equals快得多。它应该让我们快速跳过潜在的昂贵的equals计算和索引元素。</p><h1 id="ca21" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">JPA的特殊情况</h1><p id="3cb5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">JPA开发人员通常只使用hashcode的硬编码值，或者使用Class对象来生成hashCode()。这似乎很奇怪，直到你想到这一点。</p><p id="f722" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果让数据库为您生成ID，您将保存一个对象，它将不再等于源对象…一个解决方案是使用<code class="du mb mc md le b">@NaturalId</code>注释和数据类型。但是这需要改变数据模型。不幸的是，对于实体类没有合适的解决方法。</p><p id="a679" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，我认为JPA开发人员在使用Lombok时遇到的很多问题都是因为它为您生成了hashcode和equals方法。这些可能会有问题。</p><h1 id="c12f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">这是一个关于调试的博客吗？</h1><p id="c5f1" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">很抱歉这么长时间，但确实是这样。所以我需要所有的序言，从更一般的调试角度来讨论这个问题。请注意，对于其他使用类似公共接口范例的语言来说也是如此。</p><p id="11b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇博客从一个性能问题开始，我想从调试的角度来讨论这个问题。在许多分析器中，hashcode方法的开销几乎不会被注意到。但是因为它被如此频繁地引用，并且有着广泛的影响，所以你最终可能会感受到它的影响，并把责任推给其他人。</p><p id="c6d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">膝跳反应将是实现一个“dummy”<a class="ae jo" href="https://javarevisited.blogspot.com/2011/02/how-to-write-equals-method-in-java.html" rel="noopener ugc nofollow" target="_blank">hashcode方法</a>，并看到由此产生的性能差异。只是返回一个硬编码的数字，而不是一个有效的数字。</p><p id="84aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在某些情况下是有价值的，甚至可以解决上面提到的hashcode方法表现不佳的问题。但是，它对地图没有帮助。如果hashcode将返回相同的值，那么将它用作map中的一个键实际上会使hashcode所能提供的所有性能优势失效。</p><p id="8258" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们如何知道一个hashcode方法是好的呢？</p><p id="3f08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯……我们可以用调试器来解决这个问题。只需检查一下您的地图，看看对象在不同存储桶之间的分布，就能感受到hashcode方法的真实价值。</p><p id="8730" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你有一个关于提交的代码验证过程，我强烈建议你在hashcode方法的复杂程度上定义一个规则。这应该设置得非常低，以防止缓慢的代码渗入。</p><p id="6d28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但问题是筑巢。例如，想想我们之前讨论过的代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="cd6b" class="li jq hi le b fi lj lk l ll lm">public int hashCode() {<br/>    return Objects.hash(id, core, setting, values, sets);<br/>}</span></pre><p id="aa03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它又短又简单。然而，这段代码的性能可以无处不在。该方法将调用所有内部对象的hashcode方法。这些方法在性能方面要差得多。我们需要对此保持警惕。即使对于JDK类，如URL，正如我们前面所讨论的，这是有问题的。</p><h1 id="3ef4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="45f0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们经常自动生成hashcode和equals方法。ide通常在这方面做得很好；它们为我们提供了选择想要比较的字段的选项。不幸的是，他们随后将这两组字段应用于hashcode和equals。</p><p id="ccd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有时候，这并不重要。通常我们不会“看到”重要的地方，因为这些方法太小了，不足以影响分析器。但是它们有着广泛的影响，我们应该为之进行优化。</p><p id="bfc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">调试让我们可以检查映射并查看存储桶分布，这样我们就可以了解hashcode方法的执行情况，以及我们是否应该调整它以从映射和类似的API中获得更一致的结果。</p></div></div>    
</body>
</html>