<html>
<head>
<title>Type Erasure in Java…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的类型擦除…</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/type-erasure-in-java-a07b1ffe4d6e?source=collection_archive---------1-----------------------#2021-07-28">https://medium.com/javarevisited/type-erasure-in-java-a07b1ffe4d6e?source=collection_archive---------1-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="90a3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一种缓解你的RAM的方法</h2></div></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/222ea8f345281a1a726816b34fb80476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CaKo1S2p0wLLMrxJ4gEumg.jpeg"/></div></div></figure><p id="3a9d" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在编译时施加类型约束并在运行时丢弃元素类型信息的过程。</p><p id="87e6" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">换句话说，编译器用<strong class="js hj">实际类</strong>或<strong class="js hj">桥方法</strong>替换泛型参数。此外，编译器确保<strong class="js hj">没有额外的类被创建</strong>并且<strong class="js hj">没有运行时开销。</strong></p><p id="8c57" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">事实上，<strong class="js hj">类型删除</strong>确保你的代码与旧版本的java兼容，旧版本的Java可能根本不包含泛型。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="4c59" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="ko">Flowers flower = sample . empty bucket()；</em></p><p id="91d4" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">编译器将以强制转换的方式转换上述代码。</p><p id="8cb6" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="ko">Flowers flower =(Object)sample . empty bucket()；</em></p><h2 id="c851" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jz la lb lc kd ld le lf kh lg lh li lj bi translated">键入擦除优点。</h2><ul class=""><li id="543a" class="lk ll hi js b jt lm jw ln jz lo kd lp kh lq kl lr ls lt lu bi translated">双向向后兼容</li><li id="648d" class="lk ll hi js b jt lv jw lw jz lx kd ly kh lz kl lr ls lt lu bi translated">更容易实现</li><li id="d684" class="lk ll hi js b jt lv jw lw jz lx kd ly kh lz kl lr ls lt lu bi translated">不需要改变字节码或<a class="ae ma" href="https://javarevisited.blogspot.com/2011/12/jre-jvm-jdk-jit-in-java-programming.html" rel="noopener ugc nofollow" target="_blank">虚拟机</a></li><li id="f6c1" class="lk ll hi js b jt lv jw lw jz lx kd ly kh lz kl lr ls lt lu bi translated"><a class="ae ma" href="https://www.java67.com/2013/02/difference-between-jit-and-jvm-in-java.html" rel="noopener ugc nofollow" target="_blank"> JIT </a>由于从所有通用实例的一个版本生成，编译器花费的时间更少，用于存储生成代码的RAM也更少。</li><li id="2d6b" class="lk ll hi js b jt lv jw lw jz lx kd ly kh lz kl lr ls lt lu bi translated">由于堆内存中的对象数量较少，因此性能更好。</li></ul><h2 id="1b18" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jz la lb lc kd ld le lf kh lg lh li lj bi translated">类型擦除的类型。</h2><ul class=""><li id="aec4" class="lk ll hi js b jt lm jw ln jz lo kd lp kh lq kl lr ls lt lu bi translated">类别级类型擦除</li><li id="ae84" class="lk ll hi js b jt lv jw lw jz lx kd ly kh lz kl lr ls lt lu bi translated">方法级类型擦除</li></ul><h2 id="6bef" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jz la lb lc kd ld le lf kh lg lh li lj bi translated">类类型擦除？</h2><p id="7fae" class="pw-post-body-paragraph jq jr hi js b jt lm ij jv jw ln im jy jz mb kb kc kd mc kf kg kh md kj kk kl hb bi translated">这里，编译器忽略了类的类型参数，并用第一次绑定替换它们。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="km kn l"/></div><p class="me mf et er es mg mh bd b be z dx translated">原始实现</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="km kn l"/></div><p class="me mf et er es mg mh bd b be z dx translated">编译器替换后</p></figure><p id="52f4" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">有时类型参数可以是有界的。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="km kn l"/></div><p class="me mf et er es mg mh bd b be z dx translated">有界类型参数</p></figure><p id="5a32" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">编译器用第一个绑定类替换绑定类型参数。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="km kn l"/></div><p class="me mf et er es mg mh bd b be z dx translated">编译器替换后</p></figure><h2 id="2900" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jz la lb lc kd ld le lf kh lg lh li lj bi translated">方法型擦除？</h2><p id="5968" class="pw-post-body-paragraph jq jr hi js b jt lm ij jv jw ln im jy jz mb kb kc kd mc kf kg kh md kj kk kl hb bi translated">为了便于理解，方法级擦除可以表述如下。</p><ul class=""><li id="0f96" class="lk ll hi js b jt ju jw jx jz mi kd mj kh mk kl lr ls lt lu bi translated">如果未绑定，方法的参数在未存储时会转换为其父类型<em class="ko">对象</em>。</li><li id="c11b" class="lk ll hi js b jt lv jw lw jz lx kd ly kh lz kl lr ls lt lu bi translated">如果是绑定的，该方法的参数将转换为它的第一个绑定类。</li></ul><p id="4060" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们通过一个实现来详细说明方法级类型擦除。</p><p id="7d05" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">下面的元素计数器示例显示了第一种情况，即未绑定。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="km kn l"/></div><p class="me mf et er es mg mh bd b be z dx translated">两个视点上的方法声明</p></figure><p id="47de" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">接下来，下面的示例方法声明将详细说明<a class="ae ma" href="https://javarevisited.blogspot.com/2012/04/what-is-bounded-and-unbounded-wildcards.html" rel="noopener ugc nofollow" target="_blank">有界声明</a>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="km kn l"/></div><p class="me mf et er es mg mh bd b be z dx translated">两个视点上的方法声明</p></figure><blockquote class="ml mm mn"><p id="c8d9" class="jq jr ko js b jt ju ij jv jw jx im jy mo ka kb kc mp ke kf kg mq ki kj kk kl hb bi translated">让我们熟悉一下合成方法和类…</p></blockquote><p id="58c8" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Java编译器引入了这些合成的<a class="ae ma" href="https://javarevisited.blogspot.com/2012/02/difference-between-instance-class-and.html" rel="noopener ugc nofollow" target="_blank">类</a>、<a class="ae ma" href="https://www.java67.com/2019/02/can-you-add-non-abstract-method-on-interface-in-java.html" rel="noopener ugc nofollow" target="_blank">方法</a>、字段以及任何其他类似的构造，它们在源代码中是不可见的。</p><p id="b698" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这些仅用于运行时的内部目的。作为一名程序员，你可能肯定遇到过bug。您可能有意或无意地浏览了堆栈跟踪，从中获得了一些有用的合成输出。</p><h2 id="186a" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jz la lb lc kd ld le lf kh lg lh li lj bi translated">边缘案例？</h2><p id="2bc9" class="pw-post-body-paragraph jq jr hi js b jt lm ij jv jw ln im jy jz mb kb kc kd mc kf kg kh md kj kk kl hb bi translated">在类型擦除过程中，编译器有时会在存在类似方法时创建合成方法。其实这主要是因为要区分一种方法和另一种方法。</p><p id="50b8" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">例如，让我们尝试一些实现来更好地理解这些概念。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="c7ec" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">打字前擦除。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mr"><img src="../Images/dc9421e991424aa449f9e99efdc85be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*Y6a-YFiW9-TR62Q1hdUixg.png"/></div></figure><p id="9532" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">类型擦除后。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mr"><img src="../Images/c20c080851982b2f209d25bc0d4fa1e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*Ex0giIRbffVRU8RjaeP-gA.png"/></div></figure><p id="013b" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">最后一行抛出一个异常。因为我们已经把一个字符串类型的对象放到了<em class="ko"> SampleChild </em>中，其中<em class="ko"> putItem(Object) </em>继承了<em class="ko"> sample &lt; Integer &gt; </em>类型。因此，最后一行抛出一个<a class="ae ma" href="https://javarevisited.blogspot.com/2012/12/how-to-solve-javalangclasscastexception-java.html#axzz6qVaG06bu" rel="noopener ugc nofollow" target="_blank"> ClastCastException </a>。</p><h2 id="13a0" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jz la lb lc kd ld le lf kh lg lh li lj bi translated">桥接方法。</h2><p id="71a5" class="pw-post-body-paragraph jq jr hi js b jt lm ij jv jw ln im jy jz mb kb kc kd mc kf kg kh md kj kk kl hb bi translated">扩展参数化类或由类或接口实现的参数化接口中的方法签名的模糊性创建了这些桥接方法。事实上，这些是<strong class="js hj">合成方法</strong>，用于解决我们在上一节中讨论的边缘情况，也适用于协变返回类型。</p><p id="da2d" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">通过确保两个类的下列方法之间没有冲突，编译器在类型擦除后执行泛型类型的多态性。</p><p id="fc4a" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">SampleChild类— → putItem(Integer)方法</p><p id="3511" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">示例类— →putItem(Object)方法</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="km kn l"/></div><p class="me mf et er es mg mh bd b be z dx translated">编译器桥方法</p></figure></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h2 id="c16a" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jz la lb lc kd ld le lf kh lg lh li lj bi translated">参考</h2><div class="ms mt ez fb mu mv"><a href="https://www.baeldung.com/java-type-erasure" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hj fi z dy na ea eb nb ed ef hh bi translated">Java中的类型擦除解释| Baeldung</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">在这篇简短的文章中，我们将讨论Java泛型中一个重要机制的基础知识，称为类型擦除…</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">www.baeldung.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jo mv"/></div></div></a></div><div class="ms mt ez fb mu mv"><a href="https://www.geeksforgeeks.org/type-erasure-java/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hj fi z dy na ea eb nb ed ef hh bi translated">Java中的类型擦除- GeeksforGeeks</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">先决条件:泛型泛型概念是在Java语言中引入的，用于在编译时提供更严格的类型检查…</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj jo mv"/></div></div></a></div><div class="ms mt ez fb mu mv"><a href="https://www.tutorialspoint.com/java_generics/java_generics_type_erasure.htm" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hj fi z dy na ea eb nb ed ef hh bi translated">Java泛型类型擦除</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">泛型用于在编译时进行更严格的类型检查，并提供泛型编程。要实现通用…</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="ne l"><div class="nl l ng nh ni ne nj jo mv"/></div></div></a></div></div></div>    
</body>
</html>