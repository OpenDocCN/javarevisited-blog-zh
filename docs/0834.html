<html>
<head>
<title>Basics of Non-Blocking IO — Buffers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非阻塞IO基础知识—缓冲区</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/basics-of-non-blocking-io-buffers-c65c1aecd781?source=collection_archive---------1-----------------------#2020-12-10">https://medium.com/javarevisited/basics-of-non-blocking-io-buffers-c65c1aecd781?source=collection_archive---------1-----------------------#2020-12-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5dc3841b122eb2090aef6165d355df5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ux8QawMMn_FZrP4NE90T_w.jpeg"/></div><p class="im in et er es io ip bd b be z dx translated">帕特里克·林登伯格在<a class="ae iq" href="https://unsplash.com/s/photos/hard-disk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="ir is it"><p id="bc76" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行I/O通常比在内存中对数据执行处理任务需要更长的时间。许多编码者专注于他们的对象对数据做了什么，而<strong class="ix hj">很少关注获取和存储数据所涉及的环境问题。</strong></p><p id="69f0" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">I/O通常是应用程序性能的限制因素，而不是处理速度<br/><strong class="ix hj">——Ron Hitchens在《Java NIO》一书中写道</strong></p></blockquote><p id="c4ef" class="pw-post-body-paragraph iu iv hi ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hb bi translated">Java NIO(非阻塞I/O)是一个用于可伸缩I/O的API集合</p><ul class=""><li id="a1f7" class="jw jx hi ix b iy iz jc jd jt jy ju jz jv ka js kb kc kd ke bi translated"><a class="ae iq" href="https://javarevisited.blogspot.com/2012/01/memorymapped-file-and-io-in-java.html" rel="noopener ugc nofollow" target="_blank">缓冲器</a></li><li id="5b89" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js kb kc kd ke bi translated">通道— <a class="ae iq" href="https://javarevisited.blogspot.com/2016/01/reading-writing-files-using-filechannel-bytebuffer-example.html#axzz6g8q23kRW" rel="noopener ugc nofollow" target="_blank">文件通道</a>和套接字通道</li><li id="0184" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js kb kc kd ke bi translated">选择器</li><li id="5f47" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js kb kc kd ke bi translated">字符集</li></ul><p id="629d" class="pw-post-body-paragraph iu iv hi ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hb bi translated"><strong class="ix hj"> NIO Buffers </strong>是非阻塞I/O整体实现的基本构建块。在这篇博客中，我将介绍缓冲区的行为。在后续的博客中，我将介绍如何有效地处理文件和网络I/O。</p><ul class=""><li id="aad3" class="jw jx hi ix b iy iz jc jd jt jy ju jz jv ka js kb kc kd ke bi translated">缓冲区是特定原始类型的线性有限元素序列。除了它的内容，缓冲区的基本属性是它的<strong class="ix hj">容量、限制和位置。</strong></li><li id="43ab" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js kb kc kd ke bi translated">一个缓冲区的容量是它包含的元素的数量。缓冲区的容量永远不会为负，也永远不会改变。</li><li id="a19f" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js kb kc kd ke bi translated">缓冲区的限制是不应该被读取或写入的第<strong class="ix hj">个元素的索引。缓冲区的限制永远不会是负的，也永远不会大于其容量。</strong></li><li id="62ad" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js kb kc kd ke bi translated">缓冲器的位置是下一个要被读取或写入的元素的<strong class="ix hj">的索引。缓冲区的位置永远不会是负的，也永远不会大于它的限制。</strong></li></ul><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kk"><img src="../Images/80eb017a77d2649c7663a17153213dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_sBF8jwqz7p37oH1wRI6cw.png"/></div></div><p class="im in et er es io ip bd b be z dx translated">缓冲等级</p></figure><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="kt ku l"/></div><p class="im in et er es io ip bd b be z dx translated">ByteBuffer基本示例</p></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/ef00ad3c263e43626c866eb75bcbb1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*lBJn1YWhBz47qKvkToqb_Q.png"/></div><p class="im in et er es io ip bd b be z dx translated">ByteBuffer基本示例输出</p></figure><p id="94ce" class="pw-post-body-paragraph iu iv hi ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hb bi translated">每个非布尔原始类型都有一个Buffer类的子类。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kw"><img src="../Images/9bf4c7febc43c9b2bb114483f5f64add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QU6uSNXQEGpQkDZkxIC7qQ.png"/></div></div><p class="im in et er es io ip bd b be z dx translated">缓冲类层次结构</p></figure></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><p id="354b" class="pw-post-body-paragraph iu iv hi ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hb bi translated"><a class="ae iq" href="https://www.java67.com/2015/06/how-to-convert-bytebuffer-to-string-in-java-example.html" rel="noopener ugc nofollow" target="_blank"> ByteBuffer </a>是所有可用的图元缓冲区中最直接、最有用的缓冲区。为了更好地理解，让我们考虑CharBuffer和CharBuffer到ByteBuffer的转换。</p><p id="b980" class="pw-post-body-paragraph iu iv hi ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hb bi translated">我们将使用以下字符序列</p><ul class=""><li id="013d" class="jw jx hi ix b iy iz jc jd jt jy ju jz jv ka js kb kc kd ke bi translated">ASCII字符。例如，你好</li><li id="c1a6" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js kb kc kd ke bi translated">Unicode字符。例如，வணக்கம்(泰米尔语中的Vaṇakkam是你好的意思)</li></ul><p id="82c7" class="pw-post-body-paragraph iu iv hi ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hb bi translated"><strong class="ix hj">需要注意的要点是</strong></p><ol class=""><li id="ee3a" class="jw jx hi ix b iy iz jc jd jt jy ju jz jv ka js le kc kd ke bi translated">字符序列在CharBuffer中每个字符占用1个元素。对于给定的例子，这些是5和7个字符</li><li id="5bb5" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js le kc kd ke bi translated">只有当我们指定编码的字符集时，CharBuffer中的内容才能转换为ByteArray。默认编码取决于底层操作系统的区域设置和字符集。我们可以通过使用<a class="ae iq" href="https://www.java67.com/2016/08/10-jvm-options-for-java-production-application.html" rel="noopener ugc nofollow" target="_blank"> JVM选项</a> flag -Dfile.encoding=UTF-8来显式设置字符集。</li><li id="4361" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js le kc kd ke bi translated">提供了编码集的完整列表<a class="ae iq" href="https://docs.oracle.com/en/java/javase/11/intl/supported-encodings.html#GUID-E20951E6-C420-4D2F-A6BE-1470B4D55B3B" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="b291" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js le kc kd ke bi translated"><a class="ae iq" href="https://javarevisited.blogspot.com/2015/02/difference-between-utf-8-utf-16-and-utf.html#axzz6g8q23kRW" rel="noopener ugc nofollow" target="_blank"> UTF-8 </a>被定义为编码一至四个字节的码点</li></ol><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kk"><img src="../Images/224ea9dd6dde34ff9129b03cb1e5e26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pd_TN8GsoPYrXSQVdjYasQ.png"/></div></div><p class="im in et er es io ip bd b be z dx translated">CharBuffer到ByteBuffer</p></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es lf"><img src="../Images/b45c9dcadd076343417f77f9c97ff154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*678tmSZmVxVyOrfqBTzxvg.png"/></div></div><p class="im in et er es io ip bd b be z dx translated"><a class="ae iq" href="https://en.wikipedia.org/wiki/UTF-8" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/UTF-8</a></p></figure><p id="b3ea" class="pw-post-body-paragraph iu iv hi ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hb bi translated">对于泰米尔文字வ，详情如下</p><ul class=""><li id="07f1" class="jw jx hi ix b iy iz jc jd jt jy ju jz jv ka js kb kc kd ke bi translated">UTF-8(二进制)1110<strong class="ix hj">0000</strong>:10<strong class="ix hj">101110</strong>:10<strong class="ix hj">110101</strong></li><li id="b41f" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js kb kc kd ke bi translated">Unicode 00001011 10110101(以上行中所有粗体二进制数字)产生Unicode字符\u0BB5</li></ul><p id="cf3c" class="pw-post-body-paragraph iu iv hi ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hb bi translated">关于Unicode的更多细节，请点击查看<a class="ae iq" href="https://www.fileformat.info/info/unicode/char/0bb5/index.htm" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="kt ku l"/></div><p class="im in et er es io ip bd b be z dx translated">CharBuffer到ByteBuffer</p></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/80abb3603567405a8adbe57cf942c25e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*Df9LMyfPKwlI-jPO_Nt_Dg.png"/></div><p class="im in et er es io ip bd b be z dx translated">CharBuffer基本示例</p></figure></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><p id="cca2" class="pw-post-body-paragraph iu iv hi ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hb bi translated"><strong class="ix hj">参考文献:</strong></p><ol class=""><li id="2fed" class="jw jx hi ix b iy iz jc jd jt jy ju jz jv ka js le kc kd ke bi translated"><a class="ae iq" href="https://stackoverflow.com/questions/24481238/bytebuffer-charbuffer-string-and-charset" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a></li><li id="4cb5" class="jw jx hi ix b iy kf jc kg jt kh ju ki jv kj js le kc kd ke bi translated">罗恩·希钦斯的《Java NIO》</li></ol></div></div>    
</body>
</html>