<html>
<head>
<title>Spring WebFlux tutorial: how to build a reactive web app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring WebFlux教程:如何构建一个反应式web应用程序</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-webflux-tutorial-how-to-build-a-reactive-web-app-1132e4255406?source=collection_archive---------1-----------------------#2021-03-05">https://medium.com/javarevisited/spring-webflux-tutorial-how-to-build-a-reactive-web-app-1132e4255406?source=collection_archive---------1-----------------------#2021-03-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://www.educative.io/courses/software-architecture-in-java-design-development?affiliate_id=5073518643380224"><div class="er es if"><img src="../Images/3c77025888528af515b96d8bcbae9ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDOARfszHD6MMwC5mxqb5A.png"/></div></a><p class="im in et er es io ip bd b be z dx translated">图片来源:作者</p></figure><p id="5d6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">反应式系统允许<strong class="is hj">无与伦比的响应性和可伸缩性</strong>，这是我们在高数据流世界中所需要的。然而，反应式系统需要经过专门训练的工具和开发人员来实现这些独特的程序架构。spring web flux with Project Reactor是一个专门为满足现代公司的反应需求而构建的框架。</p><p id="ea45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天，我们将帮助您开始使用<strong class="is hj"> WebFlux </strong>，向您解释它如何与其他反应式堆栈工具配合，有何不同，以及如何制作您的第一个应用。</p><p id="091f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">下面是我们今天要讲的内容:</strong></p><ul class=""><li id="d563" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">什么是反应式系统？</li><li id="8a26" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">什么是项目反应堆？</li><li id="c3d4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">什么是Spring WebFlux？</li><li id="4c3d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Spring WebFlux的显著特征</li><li id="f6b5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Spring WebFlux入门</li><li id="90cd" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">你学习的下一步</li></ul><h1 id="81a3" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是反应式系统？</h1><p id="3077" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">反应式系统是用反应式架构模式设计的系统，该模式优先使用松散耦合、灵活且可伸缩的组件。它们的设计还考虑到了<strong class="is hj">故障解决方案</strong>，以确保即使一个系统出现故障，大部分系统仍将运行。</p><p id="097d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">反应式系统关注:</strong></p><ul class=""><li id="ff48" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">最重要的是，反应式系统应该对任何用户输入做出快速响应。反应式系统的倡导者认为，反应性有助于优化系统的所有其他部分，从数据收集到用户体验。</li><li id="b6a3" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">弹性</strong>:反应式系统的设计应能预见系统故障。反应式系统预计组件最终会发生故障，并设计松散耦合的系统，即使几个单独的部分停止工作，这些系统也可以保持活动。</li><li id="7a9c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">弹性</strong>:反应式系统应该通过伸缩来适应工作负载的大小，以满足需求。许多反应式系统还将使用预测性缩放来预测和准备突然转变。实现弹性的关键是消除任何瓶颈，并构建可以按需共享或复制组件的系统。</li><li id="db73" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">消息驱动的通信</strong>:反应式系统的所有组件都是松散耦合的，每个组件之间都有严格的边界。您的系统应该通过显式消息传递跨越这些界限进行通信。这些消息让不同的组件了解失败，并帮助它们将工作流委托给可以处理它的组件。</li></ul><p id="926e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">反应式和其他web模式之间最显著的区别是反应式系统可以一次执行多个未阻塞的调用，而不是让一些调用等待其他调用。因此，反应式系统加快了性能和响应速度，因为web应用程序的每一部分都可以比等待另一部分更快地完成自己的工作。</p><blockquote class="lf lg lh"><p id="9adc" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><em class="hi">简而言之，反应式系统使用松散耦合、无阻塞的组件来提高性能、用户体验和错误处理。</em></p></blockquote><h1 id="28a0" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是项目反应堆？</h1><p id="cb5d" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">Project Reactor是一个由Pivotal构建的框架，由Spring提供动力。它实现了反应式API模式，最著名的是反应式流规范。</p><p id="af28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你熟悉<a class="ae lm" href="https://www.educative.io/courses/java-8-lambdas-stream-api-beyond?affiliate_id=5073518643380224" rel="noopener ugc nofollow" target="_blank"> Java 8 Streams </a>，你会很快发现Stream和Flux(或者它的单元素版本，Mono)之间有很多相似之处。它们之间的主要区别在于，Fluxes和Monos遵循一种<code class="du ln lo lp lq b">publisher-subscriber</code>模式并实现背压，而Stream API则不是。</p><blockquote class="lf lg lh"><p id="504a" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">背压</em> </strong> <em class="hi">是数据端点向数据生产者发出信号，告知其正在接收过多数据的一种方式。这允许更好的流量管理和分配，因为它防止单个组件超负荷工作。</em></p></blockquote><p id="3be3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用反应器的主要优点是您可以完全控制数据流。当订阅者准备好处理信息时，您可以依靠订阅者请求更多信息的能力，或者在发布者端缓冲一些结果，甚至使用无背压的完全推送方法。</p><p id="9a97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的反应堆中，它位于Spring Boot 2.0之下，WebFlux之上:</p><figure class="ls lt lu lv fd ij er es paragraph-image"><a href="https://www.java67.com/2018/06/5-best-courses-to-learn-spring-boot-in.html"><div class="er es lr"><img src="../Images/a4fecbbc586b1a9cce7e5210dca46eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*h_PBnIh1EmIpReMb.PNG"/></div></a><p class="im in et er es io ip bd b be z dx translated">图片来源:作者</p></figure><blockquote class="lf lg lh"><p id="5dbe" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><strong class="is hj"><em class="hi">Stack:</em></strong><em class="hi">tech Stack是由</em> <a class="ae lm" rel="noopener" href="/javarevisited/10-tools-and-libraries-every-software-developers-should-learn-e05e636a5577"> <em class="hi">软件工具</em> </a> <em class="hi">和</em> <a class="ae lm" rel="noopener" href="/javarevisited/top-5-programming-languages-for-web-development-in-2021-f6fd4f564eb6"> <em class="hi">编程语言</em> </a> <em class="hi">组合而成，用于创建web或移动应用程序。反应式堆栈是相同的，但用于创建反应式应用程序。</em></p></blockquote><h1 id="2156" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是Spring WebFlux？</h1><p id="5c7d" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">Spring WebFlux是一个完全非阻塞的、基于注释的web框架，构建在Project Reactor之上，使得在HTTP层上构建反应式应用成为可能。WebFlux使用一个新的<strong class="is hj">路由器功能</strong>特性来将函数式编程应用到web层，并绕过声明式控制器和RequestMappings。WebFlux要求您导入Reactor作为核心依赖项。</p><p id="899b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">WebFlux是在Spring 5中添加的，作为对Spring MVC<a class="ae lm" rel="noopener" href="/javarevisited/21-spring-mvc-rest-interview-questions-answers-for-beginners-and-experienced-developers-21ad3d4c9b82">的一种反应式替代，增加了对以下内容的支持:</a></p><ul class=""><li id="feea" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">非阻塞线程</strong>:完成指定任务而不等待前面任务完成的并发线程。</li><li id="b6bd" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">反应式流API </strong>:一个标准化的工具，包括了带有非阻塞背压的异步流处理选项。</li><li id="e6e9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">异步数据处理</strong>:在后台处理数据，用户可以继续使用正常的应用功能而不会中断。</li></ul><p id="045e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最终，WebFlux放弃了SpringMVCs的每请求线程模型，而是使用多事件循环无阻塞模型来实现反应式、可伸缩的应用。由于支持Netty、Undertow和Servlet 3.1+容器等流行的服务器，WebFlux已经成为反应式堆栈的关键部分。</p><h1 id="22be" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Spring WebFlux的显著特征</h1><h1 id="1302" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">路由器功能</h1><p id="daaf" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><code class="du ln lo lp lq b">RouterFunction</code>是标准Spring MVC中使用的<code class="du ln lo lp lq b">@RequestMapping</code>和<code class="du ln lo lp lq b">@Controller</code>注释样式的功能替代。</p><p id="0be2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用它将请求路由到处理函数:</p><pre class="ls lt lu lv fd lw lq lx ly aw lz bi"><span id="c2a5" class="ma kd hi lq b fi mb mc l md me">@RestController<br/>public class ProductController {<br/>    @RequestMapping("/product")<br/>    public List&lt;Product&gt; productListing() {<br/>        return ps.findAll();<br/>    }<br/>}</span><span id="756c" class="ma kd hi lq b fi mf mc l md me">@Bean<br/>public RouterFunction&lt;ServerResponse&gt; productListing(ProductService ps) {<br/>    return route().GET("/product", req -&gt; ok().body(ps.findAll()))<br/>      .build();<br/>}</span></pre><p id="900d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用<code class="du ln lo lp lq b">RouterFunctions.route()</code>来创建路由，而不是编写一个完整的路由器函数。路由被注册为Spring beans，因此可以在任何配置类中创建。</p><p id="3a2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">路由器功能避免了由请求映射的多步骤过程引起的潜在副作用，而是将其简化为直接的路由器/处理程序链。这允许反应式编程的函数式编程实现。</p><blockquote class="lf lg lh"><p id="426f" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><code class="du ln lo lp lq b"><em class="hi">RequestMapping</em></code> <em class="hi">和</em> <code class="du ln lo lp lq b"><em class="hi">Controller</em></code> <em class="hi">注释样式在WebFlux中仍然有效，如果你更习惯旧的样式，</em> <code class="du ln lo lp lq b"><em class="hi">RouterFunctions</em></code> <em class="hi">只是你的解决方案的一个新选项。</em></p></blockquote><h1 id="5f22" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">网络客户端</h1><p id="659a" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">WebClient是WebFlux的反应式web客户端，构建自众所周知的<code class="du ln lo lp lq b">RestTemplate</code>。它是一个接口，表示web请求的主要入口点，支持同步和异步操作。WebClient主要用于被动的后端到后端通信。</p><p id="a4e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以通过使用Maven导入标准WebFlux依赖项来构建和创建WebClient实例:</p><pre class="ls lt lu lv fd lw lq lx ly aw lz bi"><span id="7e46" class="ma kd hi lq b fi mb mc l md me">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span><span id="6d35" class="ma kd hi lq b fi mf mc l md me">WebClient client = WebClient.create();</span></pre><h1 id="2b13" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">活性蒸汽API</h1><p id="6a3f" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">反应流API是一个导入的函数集合，允许更智能的数据流。它具有对背压和异步处理的内置支持，确保应用程序最有效地利用计算机和组件资源。</p><p id="67cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">反应流API中有四个主要接口:</strong></p><ul class=""><li id="6eb2" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">发布者</strong>:根据链接<code class="du ln lo lp lq b">Subscribers</code>的需求向其发出事件。充当<code class="du ln lo lp lq b">subscribers</code>可以观察事件的中心链接点。</li><li id="2fad" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">订阅方</strong>:接收并处理<code class="du ln lo lp lq b">Publisher</code>发出的事件。多个<code class="du ln lo lp lq b">Subscribers</code>可以链接到单个<code class="du ln lo lp lq b">Publisher</code>，对同一事件做出不同的响应。可以将订户设置为做出反应:</li><li id="c401" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du ln lo lp lq b">onNext</code>，当它接收到下一个事件时。</li><li id="e65a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du ln lo lp lq b">onSubscribe</code>，当添加新用户时</li><li id="7b10" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du ln lo lp lq b">onError</code>，当另一个用户出现错误时</li><li id="815a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du ln lo lp lq b">onComplete</code>，当另一个用户完成其任务时</li><li id="a536" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">订阅</strong>:定义选中的<code class="du ln lo lp lq b">Publisher</code>和<code class="du ln lo lp lq b">Subscriber</code>之间的关系。每个<code class="du ln lo lp lq b">Subscriber</code>只能链接到一个<code class="du ln lo lp lq b">Publisher</code>。</li><li id="3481" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">处理器</strong>:表示<code class="du ln lo lp lq b">Subscriber</code>的加工阶段</li></ul><h1 id="c0d7" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">服务器</h1><p id="4596" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">Tomcat、Jetty、Servlet 3.1+容器以及Netty和Undertow等非Servlet运行时都支持WebFlux。Netty最常用于<strong class="is hj">异步和非阻塞设计</strong>，因此WebFlux将默认使用它。只需对你的<a class="ae lm" rel="noopener" href="/javarevisited/6-best-maven-courses-for-beginners-in-2020-23ea3cba89"> Maven </a>或<a class="ae lm" rel="noopener" href="/javarevisited/5-best-gradle-courses-and-books-to-learn-in-2021-93f49ce8ff8e"> Gradle </a>构建软件进行简单的改动，你就可以在这些服务器选项之间轻松切换。</p><p id="56c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这使得WebFlux在它可以使用的技术方面具有高度的通用性，并允许您在现有基础设施上轻松实现它。</p><h1 id="88a8" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">并发模型</h1><p id="8ef2" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">WebFlux是基于非阻塞思想构建的，因此使用了与Spring MVC不同的并发编程模型。</p><p id="38c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Spring MVC假设线程将被阻塞，并使用一个大的线程池在阻塞期间保持移动。这个更大的线程池使得MVC更加资源密集，因为计算机硬件必须同时保持更多的线程运行。</p><p id="dee8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">WebFlux使用一个小型线程池,因为它假设你永远不需要为了避免阻塞而放弃工作。这些被称为<strong class="is hj">事件循环工作线程</strong>的线程数量固定，循环处理传入请求的速度比MVC线程更快。这意味着WebFlux更有效地使用计算机资源，因为活动线程总是在工作。</p><h1 id="3e2f" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Spring WebFlux安全性</h1><p id="a896" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">WebFlux使用Spring Security来实现认证和授权协议。Spring Security使用<code class="du ln lo lp lq b">WebFilter</code>根据经过认证的用户列表检查请求，或者可以设置为自动拒绝符合标准(如来源或请求类型)的请求。</p><pre class="ls lt lu lv fd lw lq lx ly aw lz bi"><span id="adca" class="ma kd hi lq b fi mb mc l md me">@EnableWebFluxSecurity<br/>public class HelloWebFluxSecurityConfig {<br/>    @Bean<br/>    public MapReactiveUserDetailsService userDetailsService() {<br/>        UserDetails user = User.withDefaultPasswordEncoder()<br/>            .username("user")<br/>            .password("user")<br/>            .roles("USER")<br/>            .build();<br/>        return new MapReactiveUserDetailsService(user);<br/>    }<br/>}</span></pre><p id="630b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是将所有设置设置为默认值的最小实现。这里我们可以看到用户有一个<code class="du ln lo lp lq b">username</code>、一个<code class="du ln lo lp lq b">password</code>和一个或多个<code class="du ln lo lp lq b">roles</code>标签，这些标签允许他们进行一定级别的访问。</p><h1 id="787b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Spring WebFlux入门</h1><p id="0df8" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在让我们动手操作WebFlux。首先，我们需要建立一个项目。<br/>我们将使用<code class="du ln lo lp lq b">Spring Initializr</code>生成一个带有<code class="du ln lo lp lq b">Spring Reactive Web</code>依赖项的Maven构建。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><a href="https://www.educative.io/courses/software-architecture-in-java-design-development?affiliate_id=5073518643380224"><div class="er es mg"><img src="../Images/aff1df389ab7ddaa60a9966dbe526160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIu0ETmhU8ylS-sQPVU87Q.png"/></div></a><p class="im in et er es io ip bd b be z dx translated">图片来源:作者</p></figure><p id="a2fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将生成一个类似于以下内容的<code class="du ln lo lp lq b">pom.xml</code>文件:</p><pre class="ls lt lu lv fd lw lq lx ly aw lz bi"><span id="3b0f" class="ma kd hi lq b fi mb mc l md me">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;project  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br/>    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/>    &lt;parent&gt;<br/>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br/>        &lt;version&gt;2.4.2&lt;/version&gt;<br/>        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;<br/>    &lt;/parent&gt;<br/>    &lt;groupId&gt;com.example&lt;/groupId&gt;<br/>    &lt;artifactId&gt;reactive-rest-service&lt;/artifactId&gt;<br/>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br/>    &lt;name&gt;reactive-rest-service&lt;/name&gt;<br/>    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;<br/>    &lt;properties&gt;<br/>        &lt;java.version&gt;1.8&lt;/java.version&gt;<br/>    &lt;/properties&gt;<br/>    &lt;dependencies&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>            &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br/>            &lt;scope&gt;test&lt;/scope&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;<br/>            &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;<br/>            &lt;scope&gt;test&lt;/scope&gt;<br/>        &lt;/dependency&gt;<br/>    &lt;/dependencies&gt;<br/>    &lt;build&gt;<br/>        &lt;plugins&gt;<br/>            &lt;plugin&gt;<br/>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br/>            &lt;/plugin&gt;<br/>        &lt;/plugins&gt;<br/>    &lt;/build&gt;<br/>&lt;/project&gt;</span></pre><p id="0dc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您已经拥有了继续工作所需的一切！从这里我们将添加一些组件来制作一个<code class="du ln lo lp lq b">Hello-World</code>应用程序。我们将只添加一个路由器和一个处理器，这是创建我们的基本WebFlux应用程序的最低要求。</p><h1 id="f344" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">路由器</h1><p id="b192" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">首先，我们将创建一个示例路由器，在URL <code class="du ln lo lp lq b">http://localhost:8080/example</code>显示一次我们的文本。这定义了用户如何请求我们将在处理程序中定义的数据。</p><pre class="ls lt lu lv fd lw lq lx ly aw lz bi"><span id="0210" class="ma kd hi lq b fi mb mc l md me">@Configuration<br/>public class ExampleRouter {<br/>  @Bean<br/>  public RouterFunction&lt;ServerResponse&gt; routeExample (ExampleHandler exampleHandler) {<br/>    return RouterFunctions<br/>        .route(RequestPredicates.GET("/example").and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), exampleHandler::hello);<br/>  }<br/>}</span></pre><h1 id="b926" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">处理者</h1><p id="f06e" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在我们将添加一个处理程序来监听任何请求<code class="du ln lo lp lq b">/example</code>路由的用户。一旦路由器识别出请求的路径匹配，它就将用户发送给处理程序。我们的处理程序接收消息，并把用户带到一个带有我们问候的页面。</p><pre class="ls lt lu lv fd lw lq lx ly aw lz bi"><span id="da52" class="ma kd hi lq b fi mb mc l md me">@Component<br/>public class ExampleHandler {<br/>  public Mono&lt;ServerResponse&gt; hello(ServerRequest request) {<br/>    return ServerResponse.ok().contentType(MediaType.TEXT_PLAIN)<br/>         .body(BodyInserters.fromObject("Hello, Spring WebFlux Example!"));<br/>  }<br/>}</span></pre><h1 id="4fa8" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">运行应用程序</h1><p id="f159" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在我们将通过执行Maven目标<code class="du ln lo lp lq b">spring-boot:run</code>来运行我们的应用程序。您现在可以在浏览器中访问<code class="du ln lo lp lq b">http://localhost:8080/example</code>,找到:</p><pre class="ls lt lu lv fd lw lq lx ly aw lz bi"><span id="44b1" class="ma kd hi lq b fi mb mc l md me">Hello, Spring WebFlux Example!</span></pre><h1 id="748d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">你学习的下一步</h1><p id="9119" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在你已经完成了你的第一个基础应用，你已经准备好进入一些更高级的主题和应用。</p><p id="79a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">接下来要探讨的一些概念是:</strong></p><ul class=""><li id="fd47" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">反应控制器</li><li id="491a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">储存库层</li><li id="f4c5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae lm" href="https://www.educative.io/blog/angularjs-tutorial" rel="noopener ugc nofollow" target="_blank">带WebFlux的角度</a></li><li id="3a88" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">MongoDB 和WebFlux</li><li id="60f5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">经典和功能端点</li></ul><p id="ae62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="li">快乐学习！</em></p></div></div>    
</body>
</html>