<html>
<head>
<title>How to Make Event Sourcing in Java Easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使Java中的事件源更容易</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/developer-friendly-event-sourcing-fd87f99cdb0b?source=collection_archive---------3-----------------------#2022-01-15">https://medium.com/javarevisited/developer-friendly-event-sourcing-fd87f99cdb0b?source=collection_archive---------3-----------------------#2022-01-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f57db7b0ee770011d428e39bbdaf34c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCViBzgDOy13L4LLwclFxQ.jpeg"/></div></div></figure><p id="3d8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事件源是关于持久化事件，而不仅仅是当前状态。事件源有助于审计，以及分析或重建以前的系统状态以进行业务分析。</p><p id="646f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们更详细地看一下:每次您对应用程序状态进行更改时，您都将更改记录为一个事件。</p><p id="7736" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以回放从录像开始到特定时间的事件。那么您已经重新创建了当时应用程序的状态。通过将事件合并到不同的数据结构中，您可以提供特定于用户的状态视图(“查询模型”)。</p><p id="0386" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下购物车:典型的电子商务应用程序只会在用户结账时存储购物车的状态。如果您想知道用户删除了哪些购物车商品，以优化购买流程，该怎么办？这时存储每个事件就变得有用了，例如<em class="jo">shoppingcartitem removed</em>。</p><h1 id="3ae1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一个Hello World示例</h1><p id="c9f2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在本例中，用户向后端发送一个POST HTTP请求，其中包含一个<em class="jo"> CreateGreeting </em>命令的数据。这个命令包含要问候的人的名字。后端将命令转换成一个<em class="jo"> GreetingCreated </em>事件。这个事件包含来自命令的人名，以及一个默认的称呼(<em class="jo"> Hello，</em>):</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/f65b8baa467bee571f265fee09c9c8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OZd2O9GsXe5RLxME.PNG"/></div></div></figure><p id="7df1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事件还包含您在中间看到的实体的id:使用命令并产生事件的实体<code class="du kx ky kz la b">Greeting</code>。这样，这个实体的状态可以在以后重建。</p><p id="0137" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过产生事件，<code class="du kx ky kz la b">Greeting</code>实体已经接受了有效的命令，并且事件将其记录为事实。该事件现在存储在日志中，例如存储器中的关系数据库或NoSQL数据库。</p><p id="8c28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，<code class="du kx ky kz la b">Greeting</code>实体的状态还没有改变。<br/>为了改变状态，<code class="du kx ky kz la b">Greeting</code>将事件和当前状态作为输入，并产生state类的一个新实例:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/837d16557261798db9f80e824cea25cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pk9FsToSe0D3pmqr.png"/></div></div></figure><p id="0dcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kx ky kz la b">GreetingState</code>的对象是不可变的。<code class="du kx ky kz la b">Greeting</code>应用事件后，用新状态替换旧状态。</p><p id="9ddf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想稍后更改Jill的问候语的称呼，该怎么办？这可以通过一个<code class="du kx ky kz la b">ChangeSalutation</code>命令来完成。如果在请求URL中对Jill的<code class="du kx ky kz la b">Greeting</code>实体的id进行编码，命令处理如下所示:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/0ec242aff4b5cdd20ab973a87a22d7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*drKsqEkIBSjGm2gt.PNG"/></div></div></figure><p id="c81d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，该事件仅捕获与即将发生的变更相关的信息。它不需要捕获<code class="du kx ky kz la b">GreetingState</code>中的所有信息。</p><p id="6657" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用<code class="du kx ky kz la b">SalutationChanged</code>事件如下所示:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/14a199c8e8df1c7b7e3ffea11a91d5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*btCoCZajKZaCJoRg.PNG"/></div></div></figure><p id="4774" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有趣的是:<code class="du kx ky kz la b">Greeting</code>从事件中获取称呼，并将其与当前状态中的<code class="du kx ky kz la b">personName</code>相结合，产生新的状态。</p><h1 id="d83b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">实施问题</h1><p id="13cb" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我在这里看到的问题是。当构建基于事件的应用程序时，有一个陡峭的学习曲线。你不仅需要适应这种看待国家的新方式。您还需要了解事件源库/框架的详细信息。</p><p id="c13a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想改变这一切。我创建了存在图书馆。它旨在尽可能降低技术复杂性。可以在<a class="ae lb" href="https://github.com/bertilmuth/being" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。它处于发展的早期阶段，所以我非常感谢反馈。</p><h1 id="4c7d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">命令和事件处理代码</h1><p id="4529" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">当您使用Being时，您需要定义命令处理程序:实体使用哪种类型的命令，以及它产生哪个(哪些)事件作为对每个命令的反应。</p><p id="45b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还需要定义事件处理程序:对于每种事件类型，创建哪个新的实体状态作为对它的反应。</p><p id="3dcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面显示的<code class="du kx ky kz la b">Greeting</code>实体的行为有以下<a class="ae lb" href="https://github.com/bertilmuth/being-samples/blob/main/greetings/src/main/java/org/requirementsascode/being/samples/greeting/model/Greeting.java" rel="noopener ugc nofollow" target="_blank">代码</a>:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="2886" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了定义了<code class="du kx ky kz la b">Greeting</code>起始状态的<code class="du kx ky kz la b">initialState()</code>方法之外，这应该看起来很熟悉。</p><p id="26ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个命令处理程序使用一个包含要问候的人的名字的<code class="du kx ky kz la b">CreateGreeting</code>命令，并产生一个<code class="du kx ky kz la b">GreetingCreated</code>事件。</p><p id="411b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是用户也可以通过<code class="du kx ky kz la b">ChangeSalutation</code>命令改变称呼。此命令只包含称呼的新文本，不包含人名。人员由实体的id<code class="du kx ky kz la b">state.id</code>标识。</p><p id="9811" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">命令处理程序和事件处理程序都可以使用实体的当前状态。所以当应用一个<code class="du kx ky kz la b">SalutationChanged</code>事件时，人名不是取自事件，而是取自实体的当前状态:<code class="du kx ky kz la b">(event,state) -&gt; new GreetingState(state.id, event.salutation, state.personName)</code>。</p><h1 id="336a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问候语实体的状态代码</h1><p id="6e53" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">下面是代表实体状态的<code class="du kx ky kz la b">GreetingState</code>类的代码:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="ec32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，state类的对象是不可变的。</p><h1 id="c02c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">命令和事件的代码</h1><p id="7c97" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">命令是简单的POJOs，如下例所示:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="e799" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实体的命令实现了一个公共接口，如示例中的<code class="du kx ky kz la b">GreetingCommand</code>，它可能是空的:</p><pre class="kt ku kv kw fd le la lf lg aw lh bi"><span id="d0f4" class="li jq hi la b fi lj lk l ll lm">public interface GreetingCommand {<br/>}</span></pre><p id="9b93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为命令提供公共接口的原因是类型安全。使用这个命令接口作为实体类的第一个类型参数，如上所示。</p><p id="b46e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个事件类必须是<code class="du kx ky kz la b">IdentifiedDomainEvent</code>的子类:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="9827" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Being基于强大的<a class="ae lb" href="https://docs.vlingo.io/" rel="noopener ugc nofollow" target="_blank"> VLINGO XOOM </a>平台，该平台定义了<code class="du kx ky kz la b">IdentifiedDomainEvent</code>超类。</p><h1 id="4464" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="8b7f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">除了我上面展示的内容，您还需要定义HTTP请求处理程序。“T5”网站解释了如何做到这一点。</p><p id="fb68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你觉得这个话题有趣，我想邀请你去看一看。我非常感谢你的反馈。<br/>在评论中留言，访问<a class="ae lb" href="https://gitter.im/requirementsascode/community" rel="noopener ugc nofollow" target="_blank"> Gitter社区</a>或在Twitter上联系<a class="ae lb" href="https://twitter.com/BertilMuth" rel="noopener ugc nofollow" target="_blank"> me </a>。</p></div></div>    
</body>
</html>