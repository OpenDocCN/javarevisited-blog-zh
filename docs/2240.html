<html>
<head>
<title>Memory Leak in Java: How to Detect and Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的内存泄漏:如何检测和避免</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/memory-leak-in-java-how-to-detect-and-avoid-dea648fba770?source=collection_archive---------0-----------------------#2022-07-11">https://medium.com/javarevisited/memory-leak-in-java-how-to-detect-and-avoid-dea648fba770?source=collection_archive---------0-----------------------#2022-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="8ab0" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">问题类型和解决方法</h2><div class=""/><div class=""><h2 id="ce34" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">对Java中什么是内存泄漏、它们是如何引起的以及防止它们的可行策略的深入概述。</h2></div><p id="135a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Java为编程提供了广泛的可能性，选择使用Java是有充分理由的。这是一种排版的高级编程语言，由<a class="ae kc" href="https://ru.wikipedia.org/wiki/Sun_Microsystems" rel="noopener ugc nofollow" target="_blank"> Sun Microsystems </a>创建，后来被<a class="ae kc" href="https://www.oracle.com/index.html" rel="noopener ugc nofollow" target="_blank">甲骨文</a>赎回，具有相当灵活的语法。20多年来，Java一直保持着它的受欢迎程度，在世界技术市场上处于领先地位。</p><p id="8615" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">它的一个优势是在<a class="ae kc" href="https://jelvix.com/blog/php-vs-java" rel="noopener ugc nofollow" target="_blank"> Java </a>中的自动化内存管理，尤其是与<a class="ae kc" rel="noopener" href="/javarevisited/10-best-c-programming-courses-for-beginners-2c2c1f6bcb12"> C </a>和<a class="ae kc" rel="noopener" href="/javarevisited/10-advanced-c-books-and-courses-for-experienced-programmers-a90c3942471a"> C++语言</a>相比，后者没有这个功能。这是使用内置垃圾收集器技术<a class="ae kc" href="https://www.baeldung.com/jvm-garbage-collectors" rel="noopener ugc nofollow" target="_blank">垃圾收集器</a>或GC来执行的。为了解释这一重要特性，值得注意的是，系统在其内存中积累了占用内存但未被使用的对象。该工具极大地帮助消除了像<a class="ae kc" href="https://www.javatpoint.com/memory-leak-in-java" rel="noopener ugc nofollow" target="_blank">内存泄漏</a>这样的问题。</p><p id="3d0b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当然，<a class="ae kc" rel="noopener" href="/javarevisited/10-best-places-to-learn-java-online-for-free-ce5e713ab5b2"> Java </a>并不是唯一一个拥有垃圾收集器这种重要而有用功能的平台。但是除了它的其他特性，比如HotSpot optimizer或者优秀的向后兼容性，比较起来——<a class="ae kc" href="https://jelvix.com/blog/kotlin-vs-java" rel="noopener ugc nofollow" target="_blank">Java</a>当然在其他平台中脱颖而出。</p><p id="b21e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">那么如果<a class="ae kc" href="https://jelvix.com/blog/java-vs-net-comparison" rel="noopener ugc nofollow" target="_blank"> Java </a>有这么有用的分配和清除内存的功能又有什么问题呢？让我们看看。</p><h1 id="b109" class="kd ke hi bd kf kg kh ki kj kk kl km kn ix ko iy kp ja kq jb kr jd ks je kt ku bi translated">什么是内存泄漏及其原因？</h1><p id="7e48" class="pw-post-body-paragraph jg jh hi ji b jj kv is jl jm kw iv jo jp kx jr js jt ky jv jw jx kz jz ka kb hb bi translated">为了更好地理解直接示例的本质，您应该从Java内存结构开始。</p><p id="c534" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1。内存结构及其清理</strong></p><figure class="lb lc ld le fd lf er es paragraph-image"><a href="https://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html"><div class="er es la"><img src="../Images/27cf839c8974422531d123ab07584e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6GyQjio3VxJRcg44.png"/></div></a></figure><p id="411e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Java应用程序数据可以存储在空间块中，如堆栈或堆。</p><ul class=""><li id="2dbb" class="li lj hi ji b jj jk jm jn jp lk jt ll jx lm kb ln lo lp lq bi translated">存储器是存储对堆元素和原始值类型的引用的储存库；</li><li id="2964" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated"><a class="ae kc" href="https://javarevisited.blogspot.com/2011/05/java-heap-space-memory-size-jvm.html" rel="noopener ugc nofollow" target="_blank">堆</a>包含堆栈中变量引用的动态对象。</li></ul><figure class="lb lc ld le fd lf er es paragraph-image"><a href="https://javarevisited.blogspot.com/2016/10/how-to-increase-heap-size-of-eclipse-OutOfMemoryError.html"><div class="er es la"><img src="../Images/f1080d0f47cac466fe37620cd6590b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FQ8TL3NJnTMyyS7I.png"/></div></a></figure><p id="93d4" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">因此，在默认设置下，堆可以比堆栈占用更多的内存空间。但是，可以通过在增加堆大小后将其设置为低于堆栈值来手动更改这些设置。</p><p id="ba2f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">堆栈有<a class="ae kc" href="https://www.geeksforgeeks.org/lifo-last-in-first-out-approach-in-programming/" rel="noopener ugc nofollow" target="_blank">后进先出</a>原则(最后进入，先离开)。每当引用元素或基元值调用新方法时，都会在堆栈顶部释放一块内存:</p><figure class="lb lc ld le fd lf er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/02/-stack-and-queue-data-structure-interview-questions.html"><div class="er es lw"><img src="../Images/e840961122087c63ec7b491d0ec68418.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*mJWLsU_RUnObIPPv.gif"/></div></a></figure><p id="89c5" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">与堆栈不同，堆不会自行清理。所以，系统急需一个<a class="ae kc" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686">垃圾收集器函数</a>。没有它的存在，我们只能管理堆的大小:</p><figure class="lb lc ld le fd lf er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html"><div class="er es la"><img src="../Images/a1bb41c4db17a834480397ab626ed24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9VDaQ5_qYk5I-tQm.png"/></div></a></figure><p id="9480" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">随着时间的推移，对可能包含堆栈变量的堆中对象的引用成为垃圾收集器的合适目标，这取决于其类型。并且，当红色的项出现在堆内存中时，它们可以被收集器组装起来。</p><p id="00e1" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">内存中垃圾项的例子:</strong></p><figure class="lb lc ld le fd lf er es paragraph-image"><a href="https://www.java67.com/2019/08/best-books-to-learn-java-virtual-machine-in-depth.html"><div class="er es la"><img src="../Images/8e687142e52440725c964a92e38c2a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p4ssTguxkxZpZJ5m.png"/></div></a></figure><p id="a8c2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2。内存泄漏</strong></p><p id="7276" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><a class="ae kc" href="https://javarevisited.blogspot.com/2011/10/how-substring-in-java-works.html" rel="noopener ugc nofollow" target="_blank"> Java内存泄漏</a>是GC在系统中留下不使用的元素时的一种错误。这可能是因为无法移除堆栈中可能引用的一些垃圾项。</p><p id="849b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">典型的泄密例子:</strong></p><figure class="lb lc ld le fd lf er es paragraph-image"><a href="https://javarevisited.blogspot.com/2013/01/threadlocal-memory-leak-in-java-web.html"><div class="er es la"><img src="../Images/69764bc5511d9b0a662444529adf90a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4rp_NizVM-t5xie7.png"/></div></a></figure><p id="3a88" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这种泄漏对利用系统资源的能力及其整体生产率具有负面影响。如果忽略这个问题，系统会完全耗尽数据存储空间，并以一个不可逆的错误<a class="ae kc" href="https://javarevisited.blogspot.com/2011/09/javalangoutofmemoryerror-permgen-space.html" rel="noopener ugc nofollow" target="_blank"> Java内存不足错误</a>结束。</p><p id="145b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">最好使用内存管理工具来优化它。其中最相关的是:</p><ul class=""><li id="2961" class="li lj hi ji b jj jk jm jn jp lk jt ll jx lm kb ln lo lp lq bi translated">惠普<a class="ae kc" href="https://www.hpe.com/us/en/integrated-systems/software.html" rel="noopener ugc nofollow" target="_blank">OpenView Operations</a>(OVO)；</li><li id="53b6" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated"><a class="ae kc" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank"> JMETER </a>由阿帕奇；</li><li id="8395" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated"><a class="ae kc" href="https://www.ibm.com/docs/en/sapm/7.7.0.1?topic=SSATHD_7.7.0/com.ibm.itm.doc_6.3fp2/itm63fp2_qsg_en.htm" rel="noopener ugc nofollow" target="_blank"> IBM Tivoli </a>由IBM；</li><li id="a455" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated"><a class="ae kc" href="https://www.techrepublic.com/article/jprobe-profiler-the-perfect-profiling-tool/" rel="noopener ugc nofollow" target="_blank"> JProbe Profiler </a>由TechRepublic提供。</li></ul><p id="270c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 3。Java中内存泄漏的原因</strong></p><p id="5b93" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Java中的内存泄漏可能是由于代码中不可预见的错误造成的，这些错误将对不需要的对象的引用保存在云中。这些链接阻塞了GC函数。因此，不可能清理存储库，这些元素不会有效地使用它。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/9b9afe5275d696d527b082068099fa44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SZvKP1JpF8HHXk2d.png"/></div></div></figure><p id="ba44" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">Java内存泄漏的主要原因:</strong></p><ul class=""><li id="7df5" class="li lj hi ji b jj jk jm jn jp lk jt ll jx lm kb ln lo lp lq bi translated">无限缓存；</li><li id="9a4e" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">一个会话中文件溢出；</li><li id="ff5f" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">替换操作系统页面过多；</li><li id="345b" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">用户数据系统的缺陷；</li><li id="59ca" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">在集合中插入元素而不删除它们；</li><li id="2318" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">不可复制的聆听方式。</li></ul><h1 id="9db4" class="kd ke hi bd kf kg kh ki kj kk kl km kn ix ko iy kp ja kq jb kr jd ks je kt ku bi translated">Java中的内存泄漏及其类型</h1><p id="8524" class="pw-post-body-paragraph jg jh hi ji b jj kv is jl jm kw iv jo jp kx jr js jt ky jv jw jx kz jz ka kb hb bi translated">各种类型的泄漏都是可能的。它们的差异是基于它们是如何产生的以及是什么导致了它们。</p><p id="8b88" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">最常见的泄漏类型:</p><p id="045c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1。静态变量的过度使用</strong></p><p id="e569" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Java中静态字段的生命周期通常与应用程序会话时间相对应，没有考虑使用<a class="ae kc" href="https://www.baeldung.com/java-classloaders" rel="noopener ugc nofollow" target="_blank"> ClassLoader </a>功能的垃圾收集。在命令执行期间分析内存堆时，我们可以观察到控制点1和2之间的内存增加:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/2bbf40cc9b49a3ff189ab1a22c66cf87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4TkAjNns_nz4-iqU.png"/></div></div></figure><p id="5bdb" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">但是在VisualVM中的第3点停止方法populateList()，堆存储库仍然没有得到处理。但是如果不考虑第2行中的静态，它将改变内存值:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/5649fcc5a53d82ae069b3b9849d0a42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JrbmZHwTxLRlupme.png"/></div></div></figure><p id="60e7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在这种情况下，在使用populateList()方法进行操作后，收集器会清理堆内存，因为对对象的所有引用都被停用:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/400beb3678048d23b5595684b205511b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QpTbtmk4yEe_bjwN.png"/></div></div></figure><p id="8ce3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2。参考外部的内部类的可用性</strong></p><p id="c07e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">为了初始化静态类，你总是需要来自外部类的例子。每个非静态默认类都包含一个对保存它的类的隐藏引用。如果使用内部类对象，即使关闭外部类对象，它也不会被GC收集。</p><p id="0c2d" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">例如，假设一个类包含一个非静态值，并且引用了几个体积元素。在这种情况下，内部类对象的创建有这样的统计指标:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/6575ed75c24c6b277a07fe228b70797f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KI2WN1tilB4g_BlG.png"/></div></div></figure><p id="a047" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">将内部或匿名类的值变为静态时，内存值会彻底改变。这可能是因为内部类的内容引用了外部对象，从而阻塞了GC的主要功能。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/c05b60a512e4f6772673dd116839fe5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TorWSj7PBs9-Bm1v.png"/></div></div></figure><p id="21b6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 3。app中未关闭的资源</strong></p><p id="83c1" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">每当我们创建一个新的连接或打开一个线程时，JVM总是为新的线程或连接分配内存空间。这种连接可以具有带有综合数据库的会话对象。</p><p id="1f2c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果我们不关闭这些资源，就有可能导致存储被阻塞。这造成了垃圾收集器无法检测和移除这些对象的风险。而如果你忽略了维护资源的稳定和正确关闭，它们就会填满内存，最多出现一个Java内存不足的错误。</p><p id="91ac" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 4。使用finalize()方法</strong></p><p id="5a9a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在该方案中，当我们有一个具有重新定义的finalize()方法的类时，它的对象可能不会及时收集GC，而是会排队等待删除。此外，finalize()中被错误重写的代码及其与垃圾收集器的速度不匹配会导致错误OutOfMemoryError。</p><p id="b159" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">例如，以一个具有重定义方法finalize()的类为例，它需要时间。如果GC收集了大量的元素，那么就会形成这样一个堆分数:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/89bf3fd7fa428efeb1efd20f1f2c6a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OWNhy_f0llTEDX4K.png"/></div></div></figure><p id="7e60" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果您简单地删除一个重新定义的finalize()，您可以得到这个值:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/cdc2ada3e47c561557cec30ef18c23ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MZu8qonOKbPIYTrw.png"/></div></div></figure><p id="72bd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 5。使用实习字符串</strong></p><p id="c05f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在Java system version 6中，有必要小心使用体积字符串。版本7将字符串池的更改从PermGen移到了HeapSpace。如果您调用一个方法intern()来读取一个大的字符串，它将被保存到常量内存的字符串池中(<a class="ae kc" href="https://www.baeldung.com/java-permgen-metaspace" rel="noopener ugc nofollow" target="_blank"> PermGen </a>)。这个方法存储在PermGen中，直到会话结束，这会导致应用程序耗尽内存。</p><p id="a1c6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">永久内存的一个例子是当读取一个文件的字符串而没有它的国际:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/05da2466795efb802528518f7eb3d5ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TCcGBOlBRabD4qLt.png"/></div></div></figure><p id="f1cf" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 6。ThreadLocals接合</strong></p><p id="bc9f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><a class="ae kc" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html" rel="noopener ugc nofollow" target="_blank"> ThreadLocal </a> —通过关闭变量的值来创建流安全性的工具。同时，所有线程都有一个指向重复ThreadLocal变量的隐藏链接，并保存它们的副本，而不是使用所有线程中的资源。</p><p id="0b2d" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这个特性除了有用之外，还有一些错误。如果使用不当，它们会影响泄漏。</p><p id="4bfd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">ThreadLocal变量必须在删除包含它们的线程后由GC收集。但是，某些系统服务器可能无法正确使用此功能。发生这种情况的原因是，服务器不是为所有请求创建一个新线程，而是应用整个线程池。</p><p id="c40b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">服务器中的池重用线程，使垃圾收集器无法访问它们，并占用内存。</p><p id="e546" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 7。实现不正确的equals()和hashCode() </strong></p><p id="f842" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在创建新类时，我们经常会遇到equals()和hashCode()方法的覆盖错误。HashSet和HashMap通常使用这样的方法，如果它们包含覆盖错误，这可能会导致过多的内存消耗。</p><p id="7d7a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">例如，您可以使用<a class="ae kc" href="https://hibernate.org/orm/" rel="noopener ugc nofollow" target="_blank"> ORM Hibernate </a>，它采用equals()和hashCode()方法来处理项目并将它们存储在缓存中。如果这些方法没有被覆盖，Hibernate将不会分析这些项，缓存将填充它们的副本，从而导致内存泄漏。</p><h1 id="4995" class="kd ke hi bd kf kg kh ki kj kk kl km kn ix ko iy kp ja kq jb kr jd ks je kt ku bi translated">症状和Java内存泄漏检测</h1><p id="4f1a" class="pw-post-body-paragraph jg jh hi ji b jj kv is jl jm kw iv jo jp kx jr js jt ky jv jw jx kz jz ka kb hb bi translated"><strong class="ji hs"> 1。内存泄漏症状</strong></p><p id="df5b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">有几个可疑点可能表明存在泄漏:</p><ul class=""><li id="2798" class="li lj hi ji b jj jk jm jn jp lk jt ll jx lm kb ln lo lp lq bi translated">持续和不可预见的系统故障；</li><li id="1f9f" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">不稳定的应用程序功能支持；</li><li id="63fc" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">长会话期间出现错误Java . lang . out of memory error；</li><li id="a7d8" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">系统删除连接对象；</li><li id="c14b" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">整体系统性能显著降低。</li></ul><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/226df65333e19d7b6dc9bf28d3488828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y61cVNXlDdj1JMBG.png"/></div></div></figure><p id="1e76" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2。如何检测Java内存泄漏</strong></p><p id="f1e8" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">为了检测泄漏，需要几种工具和技术，以及它们的组合。有一个可信方法的列表:</p><p id="1bc0" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2.1。</strong> <a class="ae kc" href="https://developer.android.com/studio/profile/memory-profiler" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hs">内存概要分析器</strong> </a> —跟踪存储库中占用空间的文件和项目的工具。它们能够检测泄漏并分析系统中所用元素的正确分布。此外，估计处理时间。</p><p id="56dd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">分析Java内存最常用的工具:</p><ul class=""><li id="470a" class="li lj hi ji b jj jk jm jn jp lk jt ll jx lm kb ln lo lp lq bi translated">EJ技术公司的JProfiler</li><li id="c42e" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">甲骨文公司的Java VisualVM</li><li id="7ef2" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated">YourKit有限公司生产的Yourkit。</li></ul><p id="b3c3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2.2。订婚</strong> <a class="ae kc" href="https://stackoverflow.com/questions/407612/how-to-get-a-thread-and-heap-dump-of-a-java-process-on-windows-thats-not-runnin" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hs">堆垃圾场</strong> </a> <strong class="ji hs">。这是一个为Java内存存储中的堆创建即时快照的工具。需要这样的图像来控制所用对象的数量及其在内存中的权重。此外，该工具跟踪由系统创建的元素的数量以及可能影响泄漏的因素。</strong></p><p id="3580" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2.3。激活</strong> <a class="ae kc" href="https://www.ibm.com/docs/en/mon-diag-tools?topic=types-verbose-garbage-collection" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hs">详细垃圾收集</strong> </a> <strong class="ji hs">日志。</strong>这个工具能够演示对存储库和GC中的堆配置的更改。它提供了应用程序最精确的特性和性能。并通过识别堆中合适的元素、替代方法和JVM参数来优化收集器的性能。</p><p id="9a9a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">例如，使用JVM启动方法在app中激活详细收集:</p><p id="e37f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">-XX:+use serial GC-xms 1024m-xmx 1024m-verbose:GC</p><p id="f42d" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">-verbose:gc参数激活收集信息的记录。默认情况下，日志保存到stdout，并为所有GC生成行。还可以使用-XX: +UseSerialGC参数指定顺序GC，并设置堆大小。</p><p id="13a2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这有助于及时检测泄漏并配置应用程序健康指标。</p><p id="6fc3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">GC日志激活的例子可以在GitHub 服务中找到。</p><h1 id="58d1" class="kd ke hi bd kf kg kh ki kj kk kl km kn ix ko iy kp ja kq jb kr jd ks je kt ku bi translated">如何修复内存泄漏？纠错方法</h1><p id="1616" class="pw-post-body-paragraph jg jh hi ji b jj kv is jl jm kw iv jo jp kx jr js jt ky jv jw jx kz jz ka kb hb bi translated">为了解决这个问题，有必要首先考虑它出现的原因。因此，有必要确定泄漏的类型，并根据其种类来解决问题。对于每种类型，在Java中有不同的修复内存错误的方案:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es la"><img src="../Images/e51cff58797edafe64ab34513ca8392f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UAzaE2E7KXJlT2TX.png"/></div></div></figure><p id="f509" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1。如何解决内存错误？</strong></p><p id="ddc6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1.1。使用静态变量时:</strong></p><p id="78c1" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">尽量减少系统中静态字段的使用。在这种情况下，您可以使用延迟加载，而不是紧急加载对象。</p><p id="6745" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1.2。如果有内部类，参照外部:</strong></p><p id="0f68" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果不需要外部类元素，可以将内部类转换为静态类。</p><p id="e808" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1.3。如果应用的资源没有关闭:</strong></p><p id="2e97" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">最后应该及时激活完成资源的使用。</p><p id="8b4b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1.4。使用finalize()方法时:</strong></p><p id="5f96" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">应该减少到零与决赛选手的任何工作。</p><p id="f057" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1.5。使用实习字符串时</strong></p><p id="a5d0" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">尝试将Java应用程序升级到最新版本。在第6版之后，这可以通过将字符串池移动到堆的空闲位置来实现。为了避免错误<a class="ae kc" href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html#:~:text=OutOfMemoryError%20exception.,heap%20cannot%20be%20expanded%20further." rel="noopener ugc nofollow" target="_blank">内存不足错误</a>，在处理批量字符串时，您可以扩展PermGen的大小。</p><p id="cff9" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1.6。使用ThreadLocals </strong>时</p><p id="bb91" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在不需要ThreadLocal变量时对它们进行稳定的清理。具有remove()属性的ThreadLocal删除所有当前线程的变量值。必须在finally块中关闭它，以确保它被停用。</p><p id="b157" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 1.7。当实现不正确的equals()和hashCode() </strong></p><p id="78e4" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当创建新元素时，最好重写equals()和hashCode()路径。</p><p id="e951" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2。消除内存泄漏的其他方法</strong></p><p id="7bca" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当不清楚内存泄漏发生的原因时，您还可以应用其他方法来防止内存泄漏。</p><p id="0bcb" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2.1。使用基准测试:</strong></p><p id="0705" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">对于Java中代码性能的详细分析，您可以使用它的基准测试。这样，通过比较不同执行任务方式的效率，就很容易评估它们的效率。这将优先考虑最佳实践，从而避免不必要的内存消耗。</p><p id="4aaf" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2.2。参考对象app: </strong></p><p id="07c8" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在Java中应用特殊引用对象的选项，而不是直接引用应用程序中的元素。使用java.lang.ref包中包含的这种链接允许垃圾收集器简单地删除多余的对象。</p><p id="bd35" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2.3。代码审查:</strong></p><p id="cadd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">平庸，但在某些情况下同样有效的方法——检查代码。有时它有助于一次性消除内存泄漏。</p><p id="0bf6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2.4。启用分析:</strong></p><p id="be4b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">通过使用上述方法，您可以发现可用于存储应用程序资源的存储区域。</p><p id="54f5" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2.5。详细垃圾收集:</strong></p><p id="9261" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">前面提到的另一种方式。包括这种模式，我们可以密切监视GC的工作。</p><p id="3375" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">遵守这些存储空间的规则并合理使用它，可以帮助消除产生Java后备编程和Java后备语言的情况。这是整个系统正常运行的基础。</p><p id="18cf" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 3。移除工具时出错:</strong></p><ul class=""><li id="4f49" class="li lj hi ji b jj jk jm jn jp lk jt ll jx lm kb ln lo lp lq bi translated"><a class="ae kc" href="https://support.quest.com/technical-documents/foglight-for-java-ee-technologies/5.9.13/supported-platforms-and-servers" rel="noopener ugc nofollow" target="_blank"> Quest Foglight for Java </a>(用于堆监控)；</li><li id="beca" class="li lj hi ji b jj lr jm ls jp lt jt lu jx lv kb ln lo lp lq bi translated"><a class="ae kc" href="https://www.vogella.com/tutorials/EclipseMemoryAnalyzer/article.html" rel="noopener ugc nofollow" target="_blank"> MAT </a>(用于堆转储分析)。</li></ul><p id="cd51" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">正如研究Java的专家所报道的，在门户网站<a class="ae kc" href="https://habr.com/ru/post/324144/" rel="noopener ugc nofollow" target="_blank">Habr</a>——引用:</p><p id="bc77" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><em class="mb"> " </em> <em class="mb">在找到并修复漏洞后，将所有步骤重复一遍，分析内存，并向</em> <a class="ae kc" href="https://www.eclipse.org/mat/downloads.php" rel="noopener ugc nofollow" target="_blank"> <em class="mb">内存分析器</em> </a> <em class="mb">报告，以确保修复有所帮助，这不会是多余的。”</em></p><p id="9a56" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">要清楚地了解Java中的内存错误，可以在下面找到更多信息:</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="mc md l"/></div></figure><h1 id="1d30" class="kd ke hi bd kf kg kh ki kj kk kl km kn ix ko iy kp ja kq jb kr jd ks je kt ku bi translated">结论</h1><p id="bae8" class="pw-post-body-paragraph jg jh hi ji b jj kv is jl jm kw iv jo jp kx jr js jt ky jv jw jx kz jz ka kb hb bi translated">因此，分析这个问题——什么是Java中的内存泄漏，很明显它会像疾病一样影响系统并恶化其整体状况。如果不治疗，会导致不可挽回的后果。由于这是一个非常严重的问题，尽管乍一看并不明显，但需要及时识别和解决。</p><p id="01d2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果在问题存在的最初迹象出现后很久才被发现，这个问题就不容易解决。没有一种神奇的药丸可以一次性修复漏洞，即使是在Java编程领域，也是如此。</p><p id="aa8f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">但是，如果使用<a class="ae kc" href="https://jelvix.com/services/mobile-app-development" rel="noopener ugc nofollow" target="_blank">应用</a>始终包括使用经过验证的方法、概要分析、跟踪、Java内存管理和代码验证，那么这类问题的出现就可以减少到零。</p><p id="bea2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">还有你在Java里遇到过内存泄漏吗？请在评论中分享你识别问题类型的经验和解决问题的方法！</p><p id="ea8a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><a class="ae kc" href="https://jelvix.com/services/mobile-app-development" rel="noopener ugc nofollow" target="_blank">联系我们</a>获取更多关于Java中内存泄漏的信息以及防止内存泄漏的操作策略。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="0425" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><em class="mb">原载于</em><a class="ae kc" href="https://jelvix.com/blog/java-memory-leak" rel="noopener ugc nofollow" target="_blank"><em class="mb">https://jelvix.com</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>