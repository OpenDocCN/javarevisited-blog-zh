<html>
<head>
<title>Getting started with Java Collection Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java集合框架入门</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/getting-started-with-collection-framework-part-1-f2b546adcf29?source=collection_archive---------2-----------------------#2020-12-21">https://medium.com/javarevisited/getting-started-with-collection-framework-part-1-f2b546adcf29?source=collection_archive---------2-----------------------#2020-12-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5700" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将尝试从非常基础的角度来理解Java集合框架。这将是一系列的文章，将逐步涵盖收集的每个方面。让我们开始吧。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/97d514d7e2f9a4ac30fc88bf0b96fa83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fkvQN8pW9sD8bmkM"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">帕斯卡尔·布鲁克迈尔在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="21c3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">对集合框架的需求💡</strong></h1><p id="72e6" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">让我们假设，您想要表示大量的值，那么为每个值使用单独的变量不是一个好的编程实践。因此，为了克服这个问题，我们可以采用<a class="ae jt" href="https://www.java67.com/2015/07/array-concepts-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">阵列</strong>概念</a>。</p><p id="0695" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数组<br/> </strong>数组是固定数量的同质数据元素的索引集合。数组的主要优点是，我们可以用单个变量表示多个值。从而提高代码的可读性。</p><p id="8f63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数组⚠️的限制</strong></p><ol class=""><li id="5e8c" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated"><a class="ae jt" href="https://www.java67.com/2014/08/what-is-array-data-structure-in-java.html" rel="noopener ugc nofollow" target="_blank">数组的大小是固定的</a>，也就是说，一旦我们创建了一个数组，就没有机会根据我们的要求来增加或减少大小。因此，要使用数组的概念，我们必须事先知道数组的大小，但这并不总是可能的。</li><li id="a51d" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">数组只能保存同类数据类型元素。</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/1e2db6732434a3e7c25ef82097ea13f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MBZkaaoVvaAUT5_1OHAJg.png"/></div></div></figure><p id="b436" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我们可以通过使用<strong class="ih hj">对象</strong>类型数组来解决这个问题。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/d6a6022195d0460ebf67490b6f625ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTBIyJmIoKlrRFOofPs3aw.png"/></div></div></figure><p id="8105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.数组概念没有基于某些<a class="ae jt" href="https://www.java67.com/2013/08/ata-structures-in-java-programming-array-linked-list-map-set-stack-queue.html" rel="noopener ugc nofollow" target="_blank">标准数据结构</a>实现，因此没有现成的方法支持。对于每一个需求，我们必须显式地编写代码。这增加了编程的复杂性。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><blockquote class="lu lv lw"><p id="1d40" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated">要克服以上排列问题，我们应该去寻找“<strong class="ih hj">集合</strong>的概念。💡</p></blockquote><ol class=""><li id="a59c" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">系列本质上是可增长的，即根据我们的需求，我们可以增加/减少规模。</li><li id="d9c1" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">集合可以包含同类和异类元素。</li><li id="689c" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">每个集合类都是基于某种<a class="ae jt" rel="noopener" href="/javarevisited/7-best-courses-to-learn-data-structure-and-algorithms-d5379ae2588?source=---------18------------------">标准数据结构</a>实现的。因此，对于每个需求，现成的方法支持都是可用的。</li></ol><pre class="je jf jg jh fd mb mc md me aw mf bi"><span id="e045" class="mg jv hi mc b fi mh mi l mj mk"><em class="lx">Being a programmer, we are responsible to use those methods and we are not responsible to implement those methods.</em></span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><blockquote class="lu lv lw"><p id="b17e" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">阵列和集合❓ </em> </strong>有什么区别</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ml"><img src="../Images/47f20e9bb29d0cfd772651a76e12cb35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gYWR5yyYImDRmNGMSA-Sxw.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">数组和集合的区别</p></figure></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="d793" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated"><strong class="ak">收藏</strong></h2><p id="5a40" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果我们想将一组单独的对象表示为一个实体，那么我们应该选择“集合”。</p><h2 id="4860" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated"><strong class="ak">收藏框架</strong></h2><p id="c732" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">它包含几个类和接口，可用于将一组单独的对象表示为单个实体。</p><p id="0d05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该集合已有其他语言版本，但名称不同。下面以<a class="ae jt" rel="noopener" href="/javarevisited/top-10-courses-to-learn-c-for-beginners-best-and-free-4afc262a544e"> C++ </a>为例:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mz"><img src="../Images/122154842aa433e6b954d732b8352b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMMiAzArIlMNEKgmMTnIlA.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">C++中的集合替代项</p></figure><h1 id="b8c5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">收集框架的9个关键接口</h1><p id="7f5c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">1.收藏<br/> 2。列表<br/> 3。设置<br/> 4。已排序集合<br/> 5。可导航集<br/> 6。队列<br/> 7。地图<br/> 8。分类地图<br/> 9。导航地图</p><blockquote class="lu lv lw"><p id="7118" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated">接下来，我们将逐一讨论每个接口的用途。</p></blockquote><h2 id="2b0c" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated"><strong class="ak"> 1。</strong> <a class="ae jt" rel="noopener" href="/javarevisited/50-java-collections-interview-questions-for-beginners-and-experienced-programmers-4d2c224cc5ab"> <strong class="ak">收藏</strong> </a></h2><ul class=""><li id="0fa4" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc nd ld le lf bi translated">如果我们想把一组单独的对象表示为一个单独的实体，那么我们应该选择“<em class="lx">集合</em>”。</li><li id="0c2f" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">集合接口定义了适用于任何集合对象的最常见的方法。</li><li id="7955" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">一般来说，集合被认为是集合框架的根接口。</li><li id="e61f" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">没有直接实现集合的具体类。</li></ul></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><blockquote class="lu lv lw"><p id="4200" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">收藏有什么区别&amp;收藏❓ </em> </strong></p></blockquote><p id="725f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“<strong class="ih hj">集合</strong>”是一个接口。如果我们想将一组单独的对象表示为一个单独的实体，那么我们应该选择集合。</p><p id="320b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">"<strong class="ih hj"> Collections </strong>"是<code class="du ne nf ng mc b">java.util</code>包中的一个实用类，用于定义集合对象的几个实用方法(如排序、搜索等)。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="8c53" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">2.目录</h2><ul class=""><li id="ad0b" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc nd ld le lf bi translated">它是集合的子接口。</li><li id="1f9e" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">如果我们想将一组单独的对象表示为一个允许重复的实体，并且插入顺序必须保持不变，那么我们应该选择“<a class="ae jt" href="https://www.java67.com/2015/06/20-java-arraylist-interview-questions.html" rel="noopener ugc nofollow" target="_blank"> <em class="lx">列表</em> </a>”。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nh"><img src="../Images/036640eb78040e6a36adde54f3f6a38d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMGJ2gH0qLS_tP2_J4euCQ.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">列表接口的实现</p></figure><p id="e420" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ne nf ng mc b"><strong class="ih hj">Note:</strong></code> <strong class="ih hj"> </strong>在JDK 1.2中，Vector和Stack类被重新设计实现了List接口。</p><h2 id="da6a" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">3.一组</h2><ul class=""><li id="deed" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc nd ld le lf bi translated">它是集合的子接口。</li><li id="d769" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">如果我们想将一组单独的对象表示为一个不允许重复且不要求插入顺序的实体，那么我们应该选择“<a class="ae jt" href="https://javarevisited.blogspot.com/2012/04/difference-between-list-and-set-in-java.html#axzz6hX6XfwBD" rel="noopener ugc nofollow" target="_blank"> <em class="lx"> Set </em> </a>”。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nh"><img src="../Images/c89956a6463d97a494f9e8d263ca7e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGRLLrYtjWsB96Jfcb-c1Q.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">集合接口的实现</p></figure><h2 id="45e4" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">4.分类集合</h2><ul class=""><li id="da49" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc nd ld le lf bi translated">它是Set的子接口。</li><li id="7ffe" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">如果我们希望将一组单独的对象表示为一个单一的实体，其中不允许重复，并且所有对象都应该按照某种排序顺序插入，那么我们应该选择<a class="ae jt" href="https://javarevisited.blogspot.com/2012/11/difference-between-treeset-hashset-vs-linkedhashset-java.html" rel="noopener ugc nofollow" target="_blank"> " <em class="lx"> SortedSet </em> " </a>。</li></ul><h2 id="10e5" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">5.可导航集</h2><ul class=""><li id="ec98" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc nd ld le lf bi translated">它是SortedSet的子接口。</li><li id="6ee2" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">它包含几种用于导航的方法。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nh"><img src="../Images/2964ebea12bb0705960df0798e632b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5cNPcUmo-GWDp4jdtbQDw.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">SortedSet和NavigableSet接口的实现</p></figure></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><blockquote class="lu lv lw"><p id="6fc2" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><a class="ae jt" href="https://www.java67.com/2013/01/difference-between-set-list-and-map-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="hi">列表和集合</em></strong></a><strong class="ih hj"><em class="hi">【❓】</em></strong></p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ni"><img src="../Images/e464aa2e37b33e923183bef741db13cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqEZfYBpC_CnjQYbMxdpSA.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">列表和集合之间的差异</p></figure></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="0168" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">6.长队</h2><ul class=""><li id="adfd" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc nd ld le lf bi translated">它是集合的子接口。</li><li id="4b57" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">如果我们想在处理之前表示一组单独的对象，那么我们应该选择“<a class="ae jt" href="https://javarevisited.blogspot.com/2013/10/what-is-priorityqueue-data-structure-java-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">队列</a>”。</li><li id="b475" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">通常队列遵循“<strong class="ih hj">先进先出</strong>”(FIFO)，但是，基于我们的需求，我们也可以实现我们自己的优先级顺序。</li></ul><p id="7763" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="je jf jg jh fd mb mc md me aw mf bi"><span id="c2c2" class="mg jv hi mc b fi mh mi l mj mk"><em class="lx">Before sending a mail, all mail id’s we must store in some data structure. In which order we added mail id’s in same order only mail should be delivered. For this requirement “Queue” is best choice.</em></span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nh"><img src="../Images/c53dd2754d96b130ee72e6cd8daa68a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mP01SG2Hmt2LbpjScITlzg.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">队列接口的实现</p></figure><p id="0942" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ne nf ng mc b"><strong class="ih hj">Note:</strong></code></p><ul class=""><li id="2da3" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc nd ld le lf bi translated">所有上面的接口(集合、列表、集合、排序集合、可导航集合和队列)都是为了表示一组单独的对象。</li><li id="1257" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">如果我们想用键值对来表示一组对象，那么我们应该选择“Map”。</li></ul><h2 id="f5f3" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">7.地图</h2><ul class=""><li id="c9a8" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc nd ld le lf bi translated">地图是<strong class="ih hj">而不是</strong>子界面的集合。</li><li id="2b3b" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">如果我们想将一组对象表示为键值对，那么我们应该选择“<a class="ae jt" href="https://www.java67.com/2017/08/top-10-java-hashmap-interview-questions.html" rel="noopener ugc nofollow" target="_blank"> <em class="lx"> Map </em> </a>”。</li></ul><p id="4434" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nj"><img src="../Images/2d4338323be7fb9279926c86c98297aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iK9Jsij5CJ0jTWRJLvtQgw.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">按序列号和姓名存储的学生记录</p></figure><p id="135e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ne nf ng mc b"><strong class="ih hj">Note:</strong></code></p><ul class=""><li id="0151" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc nd ld le lf bi translated">键和值都只是对象。</li><li id="01fd" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">不允许重复键，但值可以重复。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/09/difference-hashmap-vs-hashset-java.html#axzz6hX6XfwBD"><div class="er es nh"><img src="../Images/0c0efb19c9d09c7747a4baf1108b71db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpqxWWQ6QLfsLRLukFqknw.png"/></div></a><p class="jp jq et er es jr js bd b be z dx translated">地图接口的实现</p></figure><h2 id="b7cc" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">8.分类地图</h2><ul class=""><li id="3db3" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc nd ld le lf bi translated">它是地图的子界面。</li><li id="c476" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">如果我们想根据键的排序顺序将一组对象表示为键-值对，那么我们应该选择“Map”。</li><li id="88c8" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">在SortedMap中，排序应该基于键，而不是基于值。</li></ul><h2 id="b4e7" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">9。导航地图</h2><ul class=""><li id="bc77" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc nd ld le lf bi translated">它是SortedMap的子接口。</li><li id="17bb" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc nd ld le lf bi translated">它定义了几种用于导航的方法。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nh"><img src="../Images/df4851906c38e9642b6ff39b987a9f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*012dNFwzfVYF4y0lEgFD9A.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">SortedMap和NavigableMap接口的实现</p></figure><h1 id="8d57" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">完整的集合层次结构</strong></h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nk"><img src="../Images/5a0bca23732df1c94f8221f765ba75d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4l9ByOJAl2aJgKHVIDWeHw.png"/></div><p class="jp jq et er es jr js bd b be z dx translated">集合框架层次结构</p></figure><p id="12a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ne nf ng mc b"><strong class="ih hj">Note:<br/></strong></code> <strong class="ih hj">以下是收藏框架中出现的遗留人物:<br/> </strong> 1。<br/>枚举(一)2。<br/>字典(AC)3。<br/>矢量(C)4。栈(C) <br/> 5。散列表(C) <br/> 6。属性(C)</p><h2 id="028d" class="mg jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated"><strong class="ak">与集合一起使用的可用助手接口和类:</strong></h2><ol class=""><li id="2ef3" class="kx ky hi ih b ii ks im kt iq na iu nb iy nc jc lc ld le lf bi translated"><strong class="ih hj">排序:<br/> </strong> -可比(一)<br/> -比较器(一)</li><li id="726b" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><strong class="ih hj">游标:<br/> </strong> -枚举(I) <br/> -迭代器(I) <br/> -列表迭代器(I)</li><li id="a652" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><strong class="ih hj">实用类:<br/> </strong> -集合<br/> -数组</li></ol><p id="02cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lx">在这篇文章中，我们讨论了下面几点——</em></strong></p><p id="c1e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-集合框架的需求<br/> -集合层次结构<br/> -集合框架中的关键接口</p><blockquote class="nl"><p id="5a2e" class="nm nn hi bd no np nq nr ns nt nu jc dx translated">第2部分即将推出。敬请期待！</p></blockquote><p id="288a" class="pw-post-body-paragraph if ig hi ih b ii nv ik il im nw io ip iq nx is it iu ny iw ix iy nz ja jb jc hb bi translated">感谢你阅读❤️</p></div></div>    
</body>
</html>