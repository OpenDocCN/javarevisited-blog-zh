<html>
<head>
<title>Let’s Learn Together Sessions: Java Stream API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们一起学习会话:Java流API</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/lets-learn-together-sessions-java-stream-api-3409122190a3?source=collection_archive---------1-----------------------#2020-11-24">https://medium.com/javarevisited/lets-learn-together-sessions-java-stream-api-3409122190a3?source=collection_archive---------1-----------------------#2020-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9496" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章将解释自Java 8以来Java发布历史中一个很酷很吸引人的特性。它使您的Java代码可读性更强，更简洁。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/27b812b6ce93a449e337dfdb45ab7812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YiPqUIuhZYV7_9yC"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="6916" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是Java Stream API？</h1><p id="a7aa" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Java Stream API是2014年3月发布的Java 8中的一个特性。流不是一个数据结构，而是一个抽象层，它可以被描述为来自单个资源的一系列元素。有序元素的源可以是Java <a class="ae jt" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" rel="noopener ugc nofollow" target="_blank">集合</a>接口、数组或I/O资源的任何数据结构的一部分。</p><p id="5722" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Stream API主要是通过开发带有有用操作符的查询，让<strong class="ih hj">数据处理</strong>在Java中更加强大。查询机制对于开发者来说并不是一个新概念。我们从数据库系统中知道这个术语。许多开发人员在开发API或用户交互应用程序时需要面向数据库的系统。</p><p id="275a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jt" rel="noopener" href="/javarevisited/review-of-courseras-java-programming-software-engineering-fundamentals-specialization-4dcfa0ed2de4"> Java </a>发布之前，我们遇到了LINQ(语言集成查询)。NET框架3.5在2007年11月。它的灵感来自函数式编程语言，如Haskell和ML。</p><p id="9fbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于其数据处理操作，Stream API在数据库查询机制中提供了类似的体验。</p><p id="da34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" rel="noopener" href="/javarevisited/7-best-java-collections-and-stream-api-courses-for-beginners-in-2020-3ad18d52c38"> Stream API </a>和LINQ一样，为Java增加了函数式编程的强大功能。总的来说，Java的目标是通过添加函数式编程和数据驱动设计以及不同编程范式的强大功能来对抗这些编程范式。</p><p id="0ef4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Stream API支持两种类型的流:流和并行流。虽然基本流按顺序处理数据，但并行流的顺序是不确定的。<a class="ae jt" href="https://javarevisited.blogspot.com/2014/03/2-examples-of-streams-with-Java8-collections.html" rel="noopener ugc nofollow" target="_blank">并行流</a>使用Java的多线程功能，在多个内核上处理数据。</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/05/java-8-stream-lambda-expression-d.html"><div class="er es kx"><img src="../Images/2338e588e431f66d7271907d1b2ae89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*usLpljOe9VkjsmrCGEQaFg.png"/></div></a><p class="jp jq et er es jr js bd b be z dx translated">图片鸣谢:<a class="ae jt" href="https://www.logicbig.com/tutorials/core-java-tutorial/java-util-stream/sequential-vs-parallel.html" rel="noopener ugc nofollow" target="_blank">https://www . logic big . com/tutorials/core-Java-tutorial/Java-util-Stream/sequential-vs-Parallel . html</a>::Stream vs Parallel Stream</p></figure><p id="ad3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选择了一张管道图片作为本文的标题图片。我强调了在处理数据时，<a class="ae jt" href="https://javarevisited.blogspot.com/2021/05/java-8-stream-lambda-expression-d.html" rel="noopener ugc nofollow" target="_blank"> Stream API像管道</a>一样工作的机制。简而言之，我们可以将流描述为功能的<strong class="ih hj">管道。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://www.java67.com/2018/10/java-8-stream-and-functional-programming-interview-questions-answers.html"><div class="er es ky"><img src="../Images/f1f10bf05258efa462cec4c9465ee5c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*LunizNB4Erc3kmCLDH_Z2Q.png"/></div></a><p class="jp jq et er es jr js bd b be z dx translated">图片来源:【http://innovationm.co/concept-of-stream-api-java1-8/】T4:::流水线机制</p></figure><p id="ebb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在流API中，我们将应用于数据的每个函数命名为操作符，并将所有这些操作符的名称集命名为<strong class="ih hj">聚合操作符</strong>。有两种类型的聚合运算符:</p><ul class=""><li id="4c89" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">中介运营商</li><li id="6816" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">码头操作员</li></ul><p id="73da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">中间操作符</strong>是通过流处理数据并返回新流作为响应的操作符。示例中介运算符有<a class="ae jt" href="https://www.java67.com/2015/01/java-8-map-function-examples.html" rel="noopener ugc nofollow" target="_blank">映射</a>、<a class="ae jt" href="https://www.java67.com/2016/08/java-8-stream-filter-method-example.html" rel="noopener ugc nofollow" target="_blank">过滤器</a>、<a class="ae jt" href="https://www.java67.com/2014/04/java-8-stream-examples-and-tutorial.html" rel="noopener ugc nofollow" target="_blank">排序</a>等等。</p><p id="4444" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，<strong class="ih hj">终端操作符</strong>被用作流流的结束，它返回流上处理的新数据。<a class="ae jt" href="https://www.java67.com/2018/06/java-8-streamcollect-example.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="ln">Collect</em></strong></a><em class="ln">，</em><a class="ae jt" href="https://www.java67.com/2016/01/how-to-use-foreach-method-in-java-8-examples.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="ln">foreach</em></strong></a><em class="ln">，</em><a class="ae jt" href="https://www.java67.com/2016/09/map-reduce-example-java8.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="ln">reduce</em></strong></a>等等运算符都是Stream API中使用最多的一些终端运算符。</p><p id="0334" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java Stream的一个伟大特性是<strong class="ih hj">它不修改源数据</strong>。因此，我们不仅保存了源数据，而且也不需要为流上的数据处理占用内存。因此，如果我们需要通过流处理数据，我们必须在单个或多个中间操作之后使用终端操作符。在流中没有通知终端操作符的情况下，流API不会启动与中间操作符的数据处理。</p><p id="f7dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了所有这些好的特性，Stream API减轻了开发人员的迭代管理负担。它提供了对集合的自动迭代。</p><h1 id="b232" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何使用Stream API？</h1><p id="c6cb" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Stream API提供了许多中间和终端操作符来处理您的数据。在这篇文章中，我用简单的使用示例来讨论使用最多、最有效的操作符。</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#axzz6ieZZarMY"><div class="er es lo"><img src="../Images/7bd16f764b0684a9abbbe5276aa4a50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*34kaZWpN9CGoV5s6IrRqLw.jpeg"/></div></a><p class="jp jq et er es jr js bd b be z dx translated">图片来源:【https://www.slideshare.net/mariofusco/java-8-workshop T2】::中间运营商vs终端运营商</p></figure><p id="01ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在集合对象上使用流操作符，需要从集合中生成一个流对象，如下所示:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="04f6" class="lu jv hi lq b fi lv lw l lx ly">List&lt;Product&gt; list = new ArrayList&lt;&gt;();</span><span id="490a" class="lu jv hi lq b fi lz lw l lx ly"><strong class="lq hj">list.stream();</strong> // Generate a stream object in sequential order</span><span id="64f1" class="lu jv hi lq b fi lz lw l lx ly"><strong class="lq hj">list.parallelStream(); </strong>//Generate a parallel stream in parallel order.</span></pre><h1 id="3255" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">中级操作:</strong></h1><h2 id="09fa" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated"><strong class="ak"> 1。独特的</strong></h2><p id="64bd" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj">distinct</strong>方法根据列表中对象的<a class="ae jt" href="https://www.java67.com/2012/11/difference-between-operator-and-equals-method-in.html" rel="noopener ugc nofollow" target="_blank"> equals()方法</a>返回列表的不同元素。</p><p id="9774" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的例子展示了<strong class="ih hj">“distinct”</strong>方法如何通过一次方法调用来解决列表的唯一性需求。</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="2406" class="lu jv hi lq b fi lv lw l lx ly">@Getter<br/>@Setter<br/>@Builder<br/>public class Product {<br/>    <br/>    private long id;<br/>    private String mainCategory;<br/>    private String name;<br/>    private int barcodeNumber;<br/><br/>    @Override<br/>    public boolean equals(Object o) {<br/>        if (this == o) return true;<br/>        if (o == null || getClass() != o.getClass()) return false;<br/>        Product that = (Product) o;<br/>        return id == that.id || <br/>                (mainCategory.equalsIgnoreCase(that.mainCategory) &amp;&amp; name.equalsIgnoreCase(that.name)) ||<br/>                barcodeNumber == that.barcodeNumber;<br/>    }<br/><br/>}</span><span id="6371" class="lu jv hi lq b fi lz lw l lx ly">public void findNumberOfUniqueProductsWithStreamDistinctAndCount(List&lt;Product&gt; products){<br/><br/>    int uniqueProductsCount = products.stream().distinct().count();<br/>   <br/>}</span></pre><p id="b3d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想在没有<a class="ae jt" href="https://javarevisited.blogspot.com/2020/04/top-5-courses-to-learn-java-collections-and-streams.html#axzz6nwXUSoGH" rel="noopener ugc nofollow" target="_blank">流API </a>的情况下使用相同的功能，我们需要更多的代码行来获得相同的结果。此外，我们需要一个新的集合对象来保存唯一的产品，这意味着应用程序需要更多的内存。for循环示例实现如下:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="2991" class="lu jv hi lq b fi lv lw l lx ly">public void findNumberOfUniqueProductsWithForLoop(List&lt;Product&gt; products){<br/><br/>    List&lt;Product&gt; uniqueProducts = new ArrayList&lt;&gt;();<br/>    for(Product product : products){<br/>        if(!uniqueProducts.contains(product)){<br/>            uniqueProducts.add(product);<br/>        }<br/>    }<br/>    int uniqueProductsCount = uniqueProducts.size();</span><span id="2b28" class="lu jv hi lq b fi lz lw l lx ly">}</span></pre><h2 id="7ff8" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">2.地图-平面地图</h2><p id="2a9c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><a class="ae jt" rel="noopener" href="/javarevisited/how-to-use-streams-map-filter-and-collect-methods-in-java-1e13609a318b"> <strong class="ih hj"> Map </strong> </a>方法提供了对每个集合对象应用相同的功能。</p><p id="fdde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个不含税的产品价格列表，您必须用含税的产品价格更新这个列表。在这种情况下，您必须将清单中的每个价格乘以税率。对于该功能，您可以使用一行代码流"<em class="ln">映射</em>。一个示例实现如下:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="63d6" class="lu jv hi lq b fi lv lw l lx ly">private static final double <em class="ln">TAX_RATE </em>= 1.18;<br/><br/>public void getPricesWithTaxesByStreamMap(List&lt;Double&gt; prices){<br/><br/>    prices.stream().map(price -&gt; price * <em class="ln">TAX_RATE</em>).collect(Collectors.<em class="ln">toList</em>());<br/><br/>   <br/>}</span></pre><p id="f9f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Stream API中的另一个map操作符是<a class="ae jt" href="http://www.java67.com/2016/03/how-to-use-flatmap-in-java-8-stream.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> FlatMap </strong> </a>。FlatMap将集合流转换为单个流。</p><p id="5f76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了用一个简单的例子来解释，让我们考虑一下我们有不止一个产品价格列表，我们想在另一个列表中列出我们所有的价格。在这种情况下，我们必须收集所有产品价格表中的所有价格，并将它们合并到一个价格表中。在这一点上，<a class="ae jt" href="https://javarevisited.blogspot.com/2016/03/difference-between-map-and-flatmap-in-java8.html" rel="noopener ugc nofollow" target="_blank">流平面图方法</a>成为救命稻草。您可以在下面看到如何使用FlatMap在单个平面列表上合并不同的集合。</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="3889" class="lu jv hi lq b fi lv lw l lx ly">public void mergeAllPricesFromDifferentSourcesWithStreamFlatMap(List&lt;List&lt;Double&gt;&gt; prices){<br/><br/><br/>    List&lt;Double&gt; collect = prices.stream().flatMap(Collection::stream).collect(Collectors.<em class="ln">toList</em>());<br/><br/>}</span></pre><h2 id="04aa" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated"><strong class="ak"> 3。极限排序</strong></h2><p id="37bb" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">顾名思义，<strong class="ih hj">限制</strong>操作符的目的是用指定的限制数来减小流的大小。它从集合中获取前n个元素。n是您希望在自己的收藏中看到多少元素。</p><p id="98f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Stream API中另一个最常用的操作符是<strong class="ih hj"> Sorted。sorted </strong>操作符用于按升序或降序对流进行排序。默认顺序是升序。如果你想使用降序，你必须在排序的操作符中传递参数<a class="ae jt" href="https://www.java67.com/2019/06/top-5-sorting-examples-of-comparator-and-comparable-in-java.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">. reverse order()</strong></a><strong class="ih hj"/>。</p><p id="fccb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经使用FlatMap操作符收集了所有价格。假设我们想知道价目表中的10个最高价格。为此，我们可以将极限运算符和排序运算符一起使用，如下所示:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="2630" class="lu jv hi lq b fi lv lw l lx ly">public void getTopTenPricesWithStreamLimitAndSorted(List&lt;Double&gt; prices){<br/><br/>    List&lt;Double&gt; topTenPriceList = prices.stream().sorted().limit(10).collect(Collectors.<em class="ln">toList</em>());<br/><br/>}</span></pre><p id="8785" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在这个例子中看到的，我们可以在一行代码中完成对集合的排序和限制。</p><h2 id="7415" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">4.过滤器</h2><p id="f76d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"/><a class="ae jt" href="https://javarevisited.blogspot.com/2018/05/java-8-filter-map-collect-stream-example.html#axzz6RfpUEkHC" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">过滤器</strong>操作符</a>用于根据传递给操作符的谓词参数检索集合中匹配的元素。可以在谓词上使用单个或多个条件。</p><p id="bd1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们需要列出某个类别中的项目。我们可以创建一个谓词来检查列表中的每个元素是否都在搜索的类别中。下面的代码显示了该功能的一个示例实现:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="a27d" class="lu jv hi lq b fi lv lw l lx ly">public void findSpecificCategoryProductsWithStreamFilter(List&lt;Product&gt; products,String categoryName){<br/><br/>    products.stream().filter(product -&gt; product.getMainCategory().equalsIgnoreCase(categoryName));<br/>  <br/>}</span></pre><h2 id="efba" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">5.偷看</h2><p id="501b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">假设我们调用了一个流操作符，但是我们遇到了一个意外的结果。在这种情况下，我们必须调试我们的代码来分析什么是错误的。Peek通常使用这个目标来调试流。从形式上来说，<a class="ae jt" href="https://www.java67.com/2016/09/java-8-streampeek-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Peek </strong>返回一个新的流</a>，该流由原始流中的所有内容组成，应用了传递给Peek操作者的客户操作。</p><p id="1fa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们需要调试上面的过滤器功能，并在控制台日志中看到所有被过滤的产品。我们可以将上面的代码修改如下:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="7f5a" class="lu jv hi lq b fi lv lw l lx ly">public void findSpecificCategoryProductsWithStreamFilter(List&lt;Product&gt; products,String categoryName){<br/><br/>    products.stream().filter(product -&gt; product.getMainCategory().equalsIgnoreCase(categoryName)).peek(System.out::println);<br/>  <br/>}</span></pre><p id="d655" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">* * *不要忘记peek操作不适合prod环境，所以不要在生产中使用它们。</strong></p><p id="4591" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">中间操作符不会在流上运行，直到它以一个终端操作符结束。总之，没有终端运营商，中间运营商什么都不干。所以让我们学习如何用终端操作符完成一个流管道。</p><h1 id="7efa" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">终端操作:</h1><p id="a342" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">流管道必须以终端操作结束。终端操作处理任何流管道的输出。该目标的终端操作是流管道中的最后一个操作。</p><p id="2bd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">终端操作的输出可以是以下三种选择之一:原始值(long或boolean)、可选的具体对象类型(可选的<list>&gt;)或无响应(void方法)。</list></p><p id="e5d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个流管道可以有许多中间操作符，但只有一个终端操作。</p><p id="38a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面我们就来逐一看看Stream API上使用最多的终端操作。</p><h2 id="defe" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">1.收集</h2><p id="c5fc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"> Collect </strong>操作符组合集合中处理过的元素的结果，并将逻辑应用于输出数据(如字符串连接)。流API通过<a class="ae jt" href="https://www.java67.com/2018/11/10-examples-of-collectors-in-java-8.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">收集器</strong>库</a>提供收集功能。通过使用这个库，您可以将流元素收集到一个列表、集合或映射中。</p><p id="abbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比方说，我们需要像在过滤器示例中那样使用指定的类别过滤列表中的产品，然后从匹配的产品中返回一个新的列表。我们可以这样做:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="e9dd" class="lu jv hi lq b fi lv lw l lx ly">public List&lt;Product&gt; findSpecificCategoryProductsWithStreamFilter(List&lt;Product&gt; products,String categoryName){<br/><br/>    return products.stream().filter(product -&gt;   product.getMainCategory().equalsIgnoreCase(categoryName)).<strong class="lq hj">collect(Collectors.toList())</strong>;<br/>  <br/>}</span></pre><p id="66fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Java 10中，您还可以使用收集器实现的不可修改版本。分别是<strong class="ih hj"> <em class="ln">不可修改列表</em> </strong>、<strong class="ih hj"> <em class="ln">不可修改集合</em> </strong>、<strong class="ih hj"> <em class="ln">不可修改映射</em> </strong>。您可以在这些数据类型上收集流元素，但不能在以后修改它们。要使用一个<a class="ae jt" href="https://javarevisited.blogspot.com/2018/02/java-9-example-factory-methods-for-collections-immutable-list-set-map.html" rel="noopener ugc nofollow" target="_blank">不可修改列表</a>而不是一个简单列表，您只需要将收集操作符的参数更改为<strong class="ih hj">收集器。<em class="ln">toUnmodifiableList</em>()</strong>。</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="2d3b" class="lu jv hi lq b fi lv lw l lx ly">public List&lt;Product&gt; findSpecificCategoryProductsWithStreamFilter(List&lt;Product&gt; products,String categoryName){<br/><br/>    return products.stream().filter(product -&gt;   product.getMainCategory().equalsIgnoreCase(categoryName)).<strong class="lq hj">collect(Collectors.<em class="ln">toUnmodifiableList</em>())</strong>;<br/>  <br/>}</span></pre><p id="6440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，你可以从一个<strong class="ih hj">流&lt;字符串&gt; </strong>类型化的流对象返回一个字符串对象结果。为此，必须使用<a class="ae jt" href="https://www.java67.com/2018/11/10-examples-of-collectors-in-java-8.html" rel="noopener ugc nofollow" target="_blank">连接<strong class="ih hj">收集器</strong>和</a>。</p><p id="a629" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您正在开发一种搜索方法。算法将搜索文本作为参数，并返回包含匹配文本的单个字符串。这个字符串用逗号分隔每个匹配的文本。在下面的代码片段中，您可以看到这个用例的连接收集器的示例用法:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="c458" class="lu jv hi lq b fi lv lw l lx ly">public String searchTextWithStreamFilter(List&lt;String&gt; texts, String textToSearched){<br/><br/>   return texts.stream().filter(text -&gt; text.contains(textToSearched)).<strong class="lq hj">collect(Collectors.<em class="ln">joining</em>(", "))</strong>;<br/><br/>  <br/>}</span></pre><p id="2486" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多不同的收集器实现可供使用。此外，您可以通过使用收集器接口来实现您的自定义收集器。</p><blockquote class="mn mo mp"><p id="3412" class="if ig ln ih b ii ij ik il im in io ip mq ir is it mr iv iw ix ms iz ja jb jc hb bi translated">公共接口收集器<t a="" r=""> {…}</t></p></blockquote><h2 id="1f6e" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">2.为每一个</h2><p id="2f0c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><a class="ae jt" href="https://javarevisited.blogspot.sg/2015/09/java-8-foreach-loop-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> forEach </strong>操作符</a>看起来像集合库中的forEach方法。它用于迭代流中的每个元素。</p><p id="8833" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，您想对价目表上的价格进行折扣，但不想对低于50美元的价格应用这些折扣。您可以使用<a class="ae jt" href="https://javarevisited.blogspot.sg/2015/08/java-8-journey-of-for-loop-in-java.html" rel="noopener ugc nofollow" target="_blank">流API <strong class="ih hj"> forEach </strong>操作符</a>来完成，如下所示:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="5a4a" class="lu jv hi lq b fi lv lw l lx ly">@Getter<br/>@Setter<br/>@Builder<br/>public class Product {<br/>    <br/>    private long id;<br/>    private String mainCategory;<br/>    private String name;<br/>    private int barcodeNumber;<br/>    private double price;<br/>    <br/><br/>}<br/>public List&lt;Product&gt; applyDiscountsWithStreamForEach(List&lt;Product&gt; products,String categoryName){<br/><br/>    return products.stream().forEach(product -&gt; {</span><span id="92c8" class="lu jv hi lq b fi lz lw l lx ly">          if(product.getPrice() &gt; 50){ <br/>             product.setPrice(product.getPrice()*(1- SALE_RATE))<br/>          }</span><span id="0a59" class="lu jv hi lq b fi lz lw l lx ly">    });<br/>  <br/>}</span></pre><h2 id="a168" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated"><strong class="ak"> 3。计数</strong></h2><p id="b2f2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"> Count </strong>简单地返回流中元素的数量。您可以在计数操作之前应用过滤操作。在这种情况下，它返回筛选结果中的元素数。计数操作返回一个<strong class="ih hj">长型</strong>响应。</p><p id="0439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在下面的代码片段中看到带有过滤器的计数操作的示例用法。</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="70f1" class="lu jv hi lq b fi lv lw l lx ly">public long getNumberOfSearchedTextWithStreamFilter(List&lt;String&gt; texts, String textToSearched){<br/><br/>   return texts.stream().filter(text -&gt; text.contains(textToSearched)).<strong class="lq hj">count()</strong>;<br/><br/>}</span></pre><h2 id="9b49" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">4.最小-最大</h2><p id="37f5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"> Min </strong>和<strong class="ih hj"> max </strong>运算符是Stream API中的其他终端操作。您可以在数字流、字符串流和具有一般类型对象的流上使用它。对于后一种类型的流，您必须向这些操作传递一个比较器来查找对象的最小值或最大值，否则，它将根据从类上的<a class="ae jt" href="https://javarevisited.blogspot.com/2011/06/comparator-and-comparable-in-java.html#axzz6d6JZB400" rel="noopener ugc nofollow" target="_blank"> Comparable </a>接口重写的<a class="ae jt" href="https://javarevisited.blogspot.com/2011/11/how-to-override-compareto-method-in.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> compareTo </strong>方法</a>来比较项目。</p><p id="4471" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住上面的价目表示例。如果我们希望达到价目表中的最高和最低价格，我们可以使用最小和最大运算，如下所示:</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="4880" class="lu jv hi lq b fi lv lw l lx ly">public void getMinAndMaxPrice(List&lt;Double&gt; prices){<br/><br/>    Optional&lt;Double&gt; minPrice = prices.stream().<strong class="lq hj">min(Double::compareTo)</strong>;<br/><br/>    Optional&lt;Double&gt; maxPrice = prices.stream().<strong class="lq hj">max(Double::compareTo)</strong>;<br/><br/>   <br/>}</span></pre><h2 id="77ae" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">5.减少</h2><p id="4a28" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"> Reduce </strong>操作用于从一系列元素中得到一个结果。它组合元素序列，并返回重复组合操作的结果。</p><p id="d67f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">归约操作需要三个参数。</p><ul class=""><li id="c50c" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><strong class="ih hj">恒等式:</strong>是运算的初始值。</li><li id="6913" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><strong class="ih hj">累加器:</strong>是一个有两个参数的函数。第一个是操作的部分结果，第二个是流中的下一个元素。</li><li id="f1f4" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><strong class="ih hj">合并器:</strong>这是另一个功能，用于在并行化简操作时合并子流的结果。</li></ul><p id="04b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，使用Reduce操作，我们可以获得包含价格序列的价目表中的价格总和。</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="082f" class="lu jv hi lq b fi lv lw l lx ly">public Double getSumOfPricesWithStreamReduce(List&lt;Double&gt; prices){<br/><br/><br/>    Double sumOfPrices = prices.stream().<strong class="lq hj">reduce(0.0, (a, b) -&gt; a + b)</strong>;<br/><br/>}</span></pre><p id="2b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，恒等式中，<strong class="ih hj"> <em class="ln">减少</em> </strong>操作的初始值为0.0。(a，b) - &gt; a+b是累加器。它涉及到归约操作，在本例中是求和操作。这只是一个普通的流，不是并行的，所以没有组合器函数作为<strong class="ih hj"><em class="ln"/></strong>的操作参数。</p><h2 id="0542" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">6.findFirst-orElse</h2><p id="8bc4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"> FindFirst </strong>用于从流中检索第一个元素。如果流不为空，此方法将流中的第一个元素作为可选对象类型的形式返回。如果不想处理Optional，必须在findFirst之后使用<strong class="ih hj"> orElse </strong>操作。因此，该管道的结果将是集合中类型为的单个对象。</p><p id="b2e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的例子试图找出列表中的最大数字。我们可以用最大运算来做，但这个也可以。流不是空的，但是我们通过使用findFirst和orElse操作来保证结果是单个对象或null。</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="e328" class="lu jv hi lq b fi lv lw l lx ly">public void findTheMaxNumberInTheListWithStream(){<br/><br/>  Stream numberList = Stream.<em class="ln">of</em>(2,50,-3,120,1,0,78,111);<br/><br/> numberList.sorted(Comparator.<em class="ln">reverseOrder</em>()).<strong class="lq hj">findFirst().orElse(null)</strong>;<br/><br/>  <br/>}</span></pre><h2 id="da68" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">7.全匹配-任意匹配-无匹配</h2><p id="83e3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"> allMatch </strong>以一个谓词为参数，检查流中的所有元素是否实现了谓词上的条件。<strong class="ih hj"> anyMatch </strong>用于检查流中是否有提供条件的元素。另一方面，另一个操作，<strong class="ih hj"> noneMatch，</strong>检查没有一个元素匹配谓词条件。</p><p id="630d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们正在开发一个学生管理系统，我们需要知道是否所有学生的GPA都超过3.0，并检查没有一个学生的GPA低于2.0，并检查是否有任何学生的专业是计算机工程，其GPA超过3.0。那么下面就用<strong class="ih hj"> <em class="ln"> allMatch </em> </strong>，<strong class="ih hj"> <em class="ln"> noneMatch，</em> </strong>和<strong class="ih hj"> <em class="ln"> anyMatch </em> </strong>来回答我们的问题吧。</p><pre class="je jf jg jh fd lp lq lr ls aw lt bi"><span id="6cc4" class="lu jv hi lq b fi lv lw l lx ly">@Builder<br/>@Value<br/>public class Student {<br/><br/>    private int id;<br/>    private String name;<br/>    private String major;<br/>    private double gpa;<br/>}</span><span id="59b4" class="lu jv hi lq b fi lz lw l lx ly">public void checkStudentList(List&lt;Student&gt; studentList){<br/><br/><br/>    boolean check = studentList.stream().<strong class="lq hj">allMatch(student -&gt; student.getGpa() &gt; 3.0)</strong>;<br/><br/>  boolean check = studentList.stream().<strong class="lq hj">noneMatch(student -&gt; student.getGpa() &lt; 2.0)</strong>;</span><span id="7578" class="lu jv hi lq b fi lz lw l lx ly">boolean check = studentList.stream().anyMatch(student -&gt;<br/>        student.getMajor().equalsIgnoreCase("Computer Engineering") &amp;&amp;<br/>                student.getGpa() &gt; 3.0);<br/>}</span></pre><p id="2a45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有中间和终端操作都适用于单流和并行流。当您使用单个流时，它会按顺序遍历该流。另一方面，如果您喜欢并行流，那么顺序是不确定的。所以如果你想在流操作之后保持顺序，你就不要使用并行流。</p><p id="7806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在并行流中，流并行执行，以提高大量元素的运行时性能。它使用ForkJoinPool机制。池的大小可以增加到最多5个线程，但这因设备而异，具体取决于设备中的内核数量。</p><p id="b6ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在下图中看到两个核心并行流上的中间过滤器操作的运行机制。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mt"><img src="../Images/1cb1b1152b58ce3703cfb398c76d8254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPEWXGmZexlSrN54eYqgyQ.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">图片鸣谢:<a class="ae jt" href="https://blog.oio.de/2016/01/22/parallel-stream-processing-in-java-8-performance-of-sequential-vs-parallel-stream-processing/" rel="noopener ugc nofollow" target="_blank">https://blog . oio . de/2016/01/22/parallel-stream-processing-in-Java-8-performance-of-sequential-vs-parallel-stream-processing/</a>:::对并行流的过滤操作</p></figure><h1 id="ab7a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">结论</strong></h1><p id="5582" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有了Java 8，我们遇到了流API的概念。Stream API及其数据处理能力使Java开发人员的生活稍微轻松了一些，并且它为数据库系统的查询机制提供了类似的体验。</p><p id="ce66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么已经熟悉数据库系统的开发人员很容易适应这种新的数据处理API。</p><p id="1855" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Java 8的更高版本之后，Java团队为API添加了新的功能，并提供了性能改进。它将日益成为Java开发人员不可或缺的工具。</p><p id="3cf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了Stream API，Java开发人员可以给他们未来的同事留下更干净的代码。这使得应用程序对于变化和改进更加敏捷。</p><p id="9326" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我强烈推荐在您的项目中尽可能多地使用它，并努力在您的算法中应用流操作的最佳实践。</p><p id="a450" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码示例可以在<a class="ae jt" href="https://github.com/justayar/SpringBootTemplates/tree/master/java8streams" rel="noopener ugc nofollow" target="_blank"> Github库</a>获得。</p></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><h2 id="c982" class="lu jv hi bd jw ma mb mc ka md me mf ke iq mg mh ki iu mi mj km iy mk ml kq mm bi translated">感谢您的阅读。随时给我反馈:)</h2></div></div>    
</body>
</html>