<html>
<head>
<title>Building a simple rest API with SpringBoot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SpringBoot构建简单的rest API</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/building-a-simple-rest-api-with-springboot-3f2e4b123ebb?source=collection_archive---------2-----------------------#2021-02-18">https://medium.com/javarevisited/building-a-simple-rest-api-with-springboot-3f2e4b123ebb?source=collection_archive---------2-----------------------#2021-02-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e1b1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">卡米诺之旅——建筑休息API教程</h2></div></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/059e9cedd55b00a638abd921b2a3fcda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdaqZyyNnqBBlJSFOizR8A.jpeg"/></div></figure><p id="c1f8" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果你读过我以前的文章，你可能知道我喜欢用一个象征人类的对象作为例子，所以我将在本教程中继续讲述用<a class="ae ki" rel="noopener" href="/hackernoon/top-5-spring-boot-and-spring-cloud-books-for-java-developers-75df155dcedc"> Spring Boot </a>构建REST API，但为了让它不那么学者化，更有趣，我将使用星球大战参考(因为我是这个电影系列的极客和粉丝)。<br/>欢迎来到卡米诺。</p></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h1 id="5339" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">你需要什么</h1><p id="c276" class="pw-post-body-paragraph jm jn hi jo b jp lb ij jr js lc im ju jv ld jx jy jz le kb kc kd lf kf kg kh hb bi translated">首先，您必须选择初始化您的项目:<br/>-<a class="ae ki" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">Spring initializr</a><br/>-从您的IDE <br/>因为我们将使用<a class="ae ki" rel="noopener" href="/javarevisited/10-advanced-spring-boot-courses-for-experienced-java-developers-5e57606816bd?source=collection_home---4------0-----------------------"> Spring Boot </a>，您需要将以下依赖项添加到您的项目中，以便它能够工作。</p><ul class=""><li id="d387" class="lg lh hi jo b jp jq js jt jv li jz lj kd lk kh ll lm ln lo bi translated"><strong class="jo hj"> Spring Web </strong>:使用Apache Tomcat作为默认的嵌入式容器。</li><li id="7d3d" class="lg lh hi jo b jp lp js lq jv lr jz ls kd lt kh ll lm ln lo bi translated"><strong class="jo hj"> Spring Data JPA </strong>:使用<a class="ae ki" href="https://www.java67.com/2021/01/spring-data-jpa-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"> Spring Data </a>和<a class="ae ki" rel="noopener" href="/javarevisited/top-5-hibernate-online-training-courses-for-beginners-and-advance-java-programmers-469460596b2b"> Hibernate </a>的Java持久性API。</li><li id="15a5" class="lg lh hi jo b jp lp js lq jv lr jz ls kd lt kh ll lm ln lo bi translated"><strong class="jo hj"> H2数据库</strong>:嵌入内存数据库。</li></ul><h1 id="7379" class="kj kk hi bd kl km lu ko kp kq lv ks kt io lw ip kv ir lx is kx iu ly iv kz la bi translated">它会是什么样子</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://www.java67.com/2018/06/5-best-courses-to-learn-spring-boot-in.html"><div class="er es lz"><img src="../Images/936dda4b3083a4e8cff9b2efe962ddbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcV-CFgELE3mcnCqEtJ2pQ.png"/></div></a><p class="ma mb et er es mc md bd b be z dx translated">UML表示</p></figure><h1 id="6d99" class="kj kk hi bd kl km lu ko kp kq lv ks kt io lw ip kv ir lx is kx iu ly iv kz la bi translated">三，二，一…开始</h1><h2 id="532f" class="me kk hi bd kl mf mg mh kp mi mj mk kt jv ml mm kv jz mn mo kx kd mp mq kz mr bi translated">实体</h2><p id="bd7c" class="pw-post-body-paragraph jm jn hi jo b jp lb ij jr js lc im ju jv ld jx jy jz le kb kc kd lf kf kg kh hb bi translated">首先，我们需要声明我们将在本例的其余部分使用的对象，克隆人士兵的定义:<em class="ms"> Clone。</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="ecbf" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">为了在<a class="ae ki" rel="noopener" href="/hackernoon/top-5-sql-and-database-courses-to-learn-online-48424533ac61">数据库</a>中保存我们的对象，它需要一个Id，这个Id将在我们保存它时自动生成。</p><h2 id="9020" class="me kk hi bd kl mf mg mh kp mi mj mk kt jv ml mm kv jz mn mo kx kd mp mq kz mr bi translated">仓库</h2><p id="aebc" class="pw-post-body-paragraph jm jn hi jo b jp lb ij jr js lc im ju jv ld jx jy jz le kb kc kd lf kf kg kh hb bi translated">为了操作数据库中的对象，我们需要一个存储库</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="2205" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">我们的<em class="ms"> CloneRepository </em>扩展<em class="ms">jpare repository</em>谁扩展<em class="ms">PagingAndSortingRepository</em>允许使用分页请求，谁扩展<em class="ms"> CrudRepository </em> (CRUD是创建、读取、更新、删除的缩写)。</p><p id="80a3" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">对于ou存储库，我们可以使用类似于<em class="ms"> save </em>、<em class="ms"> findById </em>、<em class="ms"> findAll </em>的方法(有或没有分页)。</p><h2 id="e3a7" class="me kk hi bd kl mf mg mh kp mi mj mk kt jv ml mm kv jz mn mo kx kd mp mq kz mr bi translated">控制器</h2><p id="64d2" class="pw-post-body-paragraph jm jn hi jo b jp lb ij jr js lc im ju jv ld jx jy jz le kb kc kd lf kf kg kh hb bi translated">现在我们有了对象，以及保存和检索它的存储库，我们需要操作的入口点:创建、查找、删除…</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="e085" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">正如您所看到的，即使ou repository类中没有任何代码，我们也可以自由地使用里面的方法。</p><p id="000b" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">让我们看看这里有什么:</p><ul class=""><li id="14a6" class="lg lh hi jo b jp jq js jt jv li jz lj kd lk kh ll lm ln lo bi translated"><a class="ae ki" href="https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html#ixzz6OYNB9oii" rel="noopener ugc nofollow" target="_blank"> <strong class="jo hj"> @RestController </strong> : </a>表示我们的数据将在响应的主体中返回，而不是在模板中</li><li id="6140" class="lg lh hi jo b jp lp js lq jv lr jz ls kd lt kh ll lm ln lo bi translated">我们有<strong class="jo hj">@ get mapping</strong><strong class="jo hj">@ post mapping</strong>和<strong class="jo hj"> @DeleteMapping </strong>，它们表示链接到我们方法的Http方法。</li><li id="3d16" class="lg lh hi jo b jp lp js lq jv lr jz ls kd lt kh ll lm ln lo bi translated">我们的方法有一个<strong class="jo hj"> BeanNotFound </strong> throw(我们将在后面看到如何使用它)。</li></ul><h2 id="7cc1" class="me kk hi bd kl mf mg mh kp mi mj mk kt jv ml mm kv jz mn mo kx kd mp mq kz mr bi translated">处理异常</h2><p id="2cda" class="pw-post-body-paragraph jm jn hi jo b jp lb ij jr js lc im ju jv ld jx jy jz le kb kc kd lf kf kg kh hb bi translated">处理异常的正确方法是什么，是每个方法中的try/catch块，还是以特定的方式拦截它们，然后以统一的方式使用它们？</p><p id="86a9" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">第二种方法更干净，因为我们可以将所有的异常放在同一个地方，并以同样的方式对待它们。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="162c" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如您所见，我们的<strong class="jo hj"> BeanNotFound </strong>被<strong class="jo hj">异常处理程序</strong>拦截，然后我们返回我们的异常消息作为<a class="ae ki" href="https://en.wikipedia.org/wiki/HTTP_404" rel="noopener ugc nofollow" target="_blank"> 404错误</a>。</p><h1 id="2ae6" class="kj kk hi bd kl km lu ko kp kq lv ks kt io lw ip kv ir lx is kx iu ly iv kz la bi translated">测试我们的API</h1><p id="444c" class="pw-post-body-paragraph jm jn hi jo b jp lb ij jr js lc im ju jv ld jx jy jz le kb kc kd lf kf kg kh hb bi translated">为了测试我们的API，我们需要首先启动我们的应用程序。<br/>然后我们可以尝试使用<a class="ae ki" rel="noopener" href="/javarevisited/7-best-courses-to-learn-postman-tool-for-web-service-and-api-testing-f225c138fa5a?source=---------13------------------"> postman </a>或任何其他允许您进行HTTP调用的工具来连接到我们在控制器中创建的入口点。</p><h2 id="4a12" class="me kk hi bd kl mf mg mh kp mi mj mk kt jv ml mm kv jz mn mo kx kd mp mq kz mr bi translated">创建克隆</h2><p id="a8f5" class="pw-post-body-paragraph jm jn hi jo b jp lb ij jr js lc im ju jv ld jx jy jz le kb kc kd lf kf kg kh hb bi translated">正如控制器中所描述的，我们需要使用HTTP POST方法在它的主体中传递我们的克隆体的信息。</p><pre class="jf jg jh ji fd mv mw mx my aw mz bi"><span id="0848" class="me kk hi mw b fi na nb l nc nd">HTTP POST <a class="ae ki" href="http://localhost:8080/kamino/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/kamino/</a></span><span id="41d4" class="me kk hi mw b fi ne nb l nc nd">{<br/>  "codeName": "CT-7567 REX",<br/>  "type": "gunner",<br/>  "platoon": 501<br/>}</span></pre><p id="d077" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">会给我们这个回复</p><pre class="jf jg jh ji fd mv mw mx my aw mz bi"><span id="b42c" class="me kk hi mw b fi na nb l nc nd">{<br/>  "id": 1,<br/>  "birthPlace": "Kamino",<br/>  "codeName": "CT-7567 REX",<br/>  "type": "gunner",<br/>  "platoon": 501,<br/>  "affiliation": "Galactic Republic"<br/>}</span></pre><p id="c288" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Id是自动生成的，所以如果我们创建另一个克隆，值将会是2，然后是3，并且会一直递增。</p><h2 id="3022" class="me kk hi bd kl mf mg mh kp mi mj mk kt jv ml mm kv jz mn mo kx kd mp mq kz mr bi translated">查找所有创建的克隆体</h2><p id="6caa" class="pw-post-body-paragraph jm jn hi jo b jp lb ij jr js lc im ju jv ld jx jy jz le kb kc kd lf kf kg kh hb bi translated">为了找到创建的克隆，我们将调用GET "/"端点，它将返回我们所有创建的克隆的列表</p><pre class="jf jg jh ji fd mv mw mx my aw mz bi"><span id="073f" class="me kk hi mw b fi na nb l nc nd">HTTP GET http://localhost:8080/kamino/</span></pre><p id="8454" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">威尔给了我们这样的回答:</p><pre class="jf jg jh ji fd mv mw mx my aw mz bi"><span id="179e" class="me kk hi mw b fi na nb l nc nd">[<br/>  {<br/>    "id": 1,<br/>    "birthPlace": "Kamino",<br/>    "codeName": "CT-7567 REX",<br/>    "type": "gunner",<br/>    "platoon": 501,<br/>    "affiliation": "Galactic Republic"<br/>  },<br/>  {<br/>    "id": 2,<br/>    "birthPlace": "Kamino",<br/>    "codeName": "CC-3636 WOLFFE",<br/>    "type": "gunner",<br/>    "platoon": 501,<br/>    "affiliation": "Galactic Republic"<br/>  }<br/>]</span></pre><h2 id="877d" class="me kk hi bd kl mf mg mh kp mi mj mk kt jv ml mm kv jz mn mo kx kd mp mq kz mr bi translated">删除克隆</h2><p id="c082" class="pw-post-body-paragraph jm jn hi jo b jp lb ij jr js lc im ju jv ld jx jy jz le kb kc kd lf kf kg kh hb bi translated">要删除数据库中的克隆，我们将调用删除端点</p><pre class="jf jg jh ji fd mv mw mx my aw mz bi"><span id="0764" class="me kk hi mw b fi na nb l nc nd">HTTP DELETE http://localhost:8080/kamino/1</span></pre><p id="9376" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">将1作为参数传递，我们将删除id为1的克隆。因此，如果我们再次调用find方法，我们将只剩下一个克隆。</p><pre class="jf jg jh ji fd mv mw mx my aw mz bi"><span id="f649" class="me kk hi mw b fi na nb l nc nd">{<br/>  "id": 2,<br/>  "birthPlace": "Kamino",<br/>  "codeName": "CC-3636 WOLFFE",<br/>  "type": "gunner",<br/>  "platoon": 501,<br/>  "affiliation": "Galactic Republic"<br/>}</span></pre></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><p id="e39c" class="pw-post-body-paragraph jm jn hi jo b jp jq ij jr js jt im ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">感谢您的时间，您可以在Github资源库中找到与那篇文章<a class="ae ki" href="https://github.com/ErwanLT/HumanCloningFacilities" rel="noopener ugc nofollow" target="_blank">相关的所有源代码。</a></p></div></div>    
</body>
</html>