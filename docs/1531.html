<html>
<head>
<title>Spring Boot Guide for Beginner: CRUD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot初学者指南:CRUD</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-boot-guide-for-beginner-crud-c682d5437a0e?source=collection_archive---------1-----------------------#2021-09-05">https://medium.com/javarevisited/spring-boot-guide-for-beginner-crud-c682d5437a0e?source=collection_archive---------1-----------------------#2021-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="422b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">处理许多HTTP请求的指南:GET、POST、PUT、DELETE</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/58b35772df929e394bc3e046aafb9996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*ukqD-sZ54EgwgdjhuOCDPQ.png"/></div><p class="jf jg et er es jh ji bd b be z dx translated">标题图像</p></figure><p id="4d66" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">许多项目有时会将后端和前端服务分开。由于每个服务的安全性和可维护性，进行关注点分离是一个很好的实践。</p><p id="faed" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，这种方法带来的问题是如何连接这些服务并让它们说话。前端需要从后端访问资源，而只使用后端会让用户感到沮丧。</p><p id="0298" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这种情况就是HTTP请求发挥作用的地方。互联网工程任务组(IETF)制定了RFC 2616，该标准将与主机服务的通信标准化。该文档为每个典型的web事务定义了HTTP请求方法。</p><p id="434f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这些web事务统称为CRUD操作，是创建、读取、更新和删除的缩写。CRUD操作和HTTP请求之间的关系描述如下:</p><ul class=""><li id="7d1b" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">要创建信息，请使用HTTP POST方法。</li><li id="a824" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">要读取信息，请使用HTTP GET方法。</li><li id="fafc" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">要更新信息，请使用HTTP PUT方法。</li><li id="106f" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">若要删除信息，请使用HTTP DELETE方法。</li></ul><p id="3f99" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">本文将是在Spring Boot实现CRUD操作的指南。使用<a class="ae kt" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e"> Spring Boot </a>的好处之一是它的<a class="ae kt" href="https://javarevisited.blogspot.com/2018/11/top-5-spring-boot-features-java.html#axzz6i534L5Aj" rel="noopener ugc nofollow" target="_blank">自动配置</a>。所以，除了你的商业逻辑，你什么都不用担心。本文的目标是我们想要在一个<code class="du ku kv kw kx b">Guest</code>实体/模型上进行创建、读取、更新和删除操作。</p><h1 id="b5e2" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">先决条件</h1><p id="68fb" class="pw-post-body-paragraph jj jk hi jl b jm lq ij jo jp lr im jr js ls ju jv jw lt jy jz ka lu kc kd ke hb bi translated">在这个指令中，需要的依赖项很少，本文不会涉及。尽管如此，下面还是提供了安装说明的外部链接作为超链接:</p><ul class=""><li id="326e" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated"><a class="ae kt" href="https://javarevisited.blogspot.com/2013/02/how-to-install-jdk-7-on-windows-8-java-32bit-64.html" rel="noopener ugc nofollow" target="_blank"> JDK 1.8 </a></li><li id="8abb" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" rel="noopener" href="/javarevisited/7-best-courses-to-learn-intellij-idea-for-beginners-and-experienced-java-programmers-2e9aa9bb0c05?source=---------16------------------"> IntelliJ IDEA </a></li><li id="2309" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" rel="noopener" href="/javarevisited/7-best-courses-to-learn-postman-tool-for-web-service-and-api-testing-f225c138fa5a"> Postman </a>或任何API测试工具</li></ul><h1 id="5192" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">实践学习</h1><p id="cd1b" class="pw-post-body-paragraph jj jk hi jl b jm lq ij jo jp lr im jr js ls ju jv jw lt jy jz ka lu kc kd ke hb bi translated">这里的<a class="ae kt" href="https://github.com/andhikayusup/springboot-startercode" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj"> <em class="lv">链接提供了启动程序代码</em></strong></a><strong class="jl hj"><em class="lv"/></strong><em class="lv">以方便启动和运行</em> <strong class="jl hj"> <em class="lv">。</em> </strong>不过，这是可选的。您可以使用<a class="ae kt" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initialzr </a>自行生成启动代码。此外，如果您喜欢使用其他Java版本或添加额外的依赖项，可以开发自己的起始代码。我有一篇报道这件事的文章；拜托，去看看。</p><div class="lw lx ez fb ly lz"><a rel="noopener follow" target="_blank" href="/@andhikayusup/spring-boot-guide-for-beginner-hello-world-64e248eec793"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">Spring Boot初学者指南:你好，世界</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">通过这种简单的设置，让您的Spring Boot项目正常运行</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn jd lz"/></div></div></a></div><h2 id="c09a" class="mo kz hi bd la mp mq mr le ms mt mu li js mv mw lk jw mx my lm ka mz na lo nb bi translated">制作新文档</h2><p id="a4ed" class="pw-post-body-paragraph jj jk hi jl b jm lq ij jo jp lr im jr js ls ju jv jw lt jy jz ka lu kc kd ke hb bi translated">在克隆存储库(或者生成你自己的启动代码)之后，使用IntelliJ IDEA或者你选择的任何IDE打开源代码。然后，导航到<code class="du ku kv kw kx b">src/main/java/com/andhikayusup/learncrud</code>文件夹，那里是你做大部分工作的地方。右键单击父文件夹，然后导航到<code class="du ku kv kw kx b">new -&gt; Package</code>，使用IntelliJ IDEA创建一个新的包/文件夹。你可以通过下面的gif按照前面的说明去做。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/09/top-5-courses-to-learn-intellij-idea-java-and-android-development.html"><div class="er es nc"><img src="../Images/df62d02bc903fa9aa2bec4f58c50d389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*DJRm1fHZTDdCpxN-piLV4A.gif"/></div></a><p class="jf jg et er es jh ji bd b be z dx translated">使用IntelliJ IDEA创建新的包/文件夹</p></figure><p id="9cec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在生成了<code class="du ku kv kw kx b">guest</code>文件夹之后，您将需要创建额外的文件来跟进这篇文章。IntelliJ IDEA通过右键单击<code class="du ku kv kw kx b">guest</code>文件夹并导航到<code class="du ku kv kw kx b">new -&gt; Java Class</code>来轻松生成Java类。该操作将生成Java类，并准备好一些预填充的模板代码。你可以通过下面的gif按照前面的说明去做。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2018/08/top-10-free-java-courses-for-beginners-experienced-developers.html"><div class="er es nc"><img src="../Images/a618676596415affcac668e2aeba77b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*2SpB2xyd25OBVxTuobrEEw.gif"/></div></a><p class="jf jg et er es jh ji bd b be z dx translated">使用IntelliJ IDEA创建新的Java类</p></figure><p id="902c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了交付更好的代码，我们需要将生产代码分发到单独的文件中，以便每个文件都有自己的集体功能。我们可以将CRUD操作的实现分成三个文件:<code class="du ku kv kw kx b">Guest</code>、<code class="du ku kv kw kx b">GuestService</code>和<code class="du ku kv kw kx b">GuestController</code>。</p><p id="164f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kt" rel="noopener" href="/javarevisited/my-favorite-courses-to-learn-object-oriented-programming-and-design-in-2019-197bab351733"> OOP范例</a>中，我们将世界建模为对象的交互。类是我们对象的模板，它定义了默认的属性和方法。我们创建的第一个文件是<code class="du ku kv kw kx b">Guest.java</code>，它作为我们问题的一个类。对于这种情况，我们有一个带有几个属性和方法的<code class="du ku kv kw kx b">Guest</code>类。这个类的属性有<code class="du ku kv kw kx b">ID</code>、<code class="du ku kv kw kx b">full name</code>、<code class="du ku kv kw kx b">age</code>；同时，这些方法是每个属性的setter和getter。该文件的最终代码应该如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="er es nd"><img src="../Images/da91b8d6746f18d23b687e137554141d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CC0_ZSNUjaPK_v7bReQxg.png"/></div></div><p class="jf jg et er es jh ji bd b be z dx translated">Guest.java</p></figure><p id="d4c3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们生成的第二个文件是<code class="du ku kv kw kx b">GuestService</code>。这个文件应该是我们业务逻辑的实现。我们现在不使用像<a class="ae kt" rel="noopener" href="/javarevisited/7-best-free-postgresql-courses-for-beginners-to-learn-in-2021-3bf369d73794"> PostgreSQL </a>这样的存储数据库；我们将把<code class="du ku kv kw kx b">Guest</code>对象作为数组列表保存在我们的服务器内存中。因此，这个文件将实现创建、检索、更新和删除这些对象到我们定义的<a class="ae kt" href="https://javarevisited.blogspot.com/2011/05/example-of-arraylist-in-java-tutorial.html#axzz6qVaG06bu" rel="noopener ugc nofollow" target="_blank"> ArrayList </a>中的业务逻辑。</p><p id="3073" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的代码为我们的<code class="du ku kv kw kx b">GuestService</code>类添加了<code class="du ku kv kw kx b">@Component</code>注释。这个注释告诉<a class="ae kt" rel="noopener" href="/javarevisited/10-advanced-spring-boot-courses-for-experienced-java-developers-5e57606816bd?source=collection_home---4------0-----------------------"> Spring Boot </a>在我们进行依赖注入的地方实例化它们。依赖注入是Spring Boot的优势之一，因为它消除了类之间的解耦。Amigoscode在他的视频<a class="ae kt" href="https://www.youtube.com/watch?v=oqYRl06DNHQ" rel="noopener ugc nofollow" target="_blank">上有一个很棒的视频来解释这件事。</a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="er es nd"><img src="../Images/c0a2d023857a5245e6ae94c6f1e73931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1p70vYRp2kKj_Vot25RSIA.png"/></div></div><p class="jf jg et er es jh ji bd b be z dx translated">GuestService.java</p></figure><h2 id="2b1a" class="mo kz hi bd la mp mq mr le ms mt mu li js mv mw lk jw mx my lm ka mz na lo nb bi translated">休息控制器</h2><p id="d411" class="pw-post-body-paragraph jj jk hi jl b jm lq ij jo jp lr im jr js ls ju jv jw lt jy jz ka lu kc kd ke hb bi translated">我们应该实现的第三个文件是<code class="du ku kv kw kx b">GuestController</code>。在这个类上使用的注释告诉Spring Boot，这个类将是REST控制器，是我们服务的入口点。另外，<code class="du ku kv kw kx b">@RequestMapping(&lt;path&gt;)</code>用于映射所述REST控制器控制请求的路径。这个REST控制器类将在<code class="du ku kv kw kx b">api/v1/guest</code>路径接受这个问题的请求。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="er es nd"><img src="../Images/393d50b646089bb4f9e0ad21f77b8263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZwpIVAKhQWEcQEtqpUk2A.png"/></div></div><p class="jf jg et er es jh ji bd b be z dx translated">GuestController.java</p></figure><p id="bc32" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">还记得我们在<code class="du ku kv kw kx b">GuestService.java</code>上声明的<code class="du ku kv kw kx b"><a class="ae kt" href="https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html" rel="noopener ugc nofollow" target="_blank">@Component</a></code>注释吗？我们将在这个类上使用<a class="ae kt" href="https://javarevisited.blogspot.com/2012/12/inversion-of-control-dependency-injection-design-pattern-spring-example-tutorial.html#axzz6u4HTHz4Z" rel="noopener ugc nofollow" target="_blank">依赖注入</a>实例化<code class="du ku kv kw kx b">GuestService</code>。要执行这个动作，首先，我们需要实现<code class="du ku kv kw kx b">GuestController</code>类的构造函数，用<code class="du ku kv kw kx b">GuestService</code>对象作为它的参数。然后，我们使用<code class="du ku kv kw kx b">@Autowired</code>注释向Spring Boot表明我们使用了依赖注入。</p><h2 id="0906" class="mo kz hi bd la mp mq mr le ms mt mu li js mv mw lk jw mx my lm ka mz na lo nb bi translated">处理GET请求</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="er es ni"><img src="../Images/5126f35e459b3080fd9c9a3b0e4401a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dk0LX5jAQAuiqlLDTxHF2A.png"/></div></div></figure><p id="d8b9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">HTTP GET方法通常用于从托管服务读取数据。<code class="du ku kv kw kx b">@GetMapping</code>用于表示所述方法是GET请求方法的处理程序。</p><p id="2869" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个处理程序的实现非常简单。我们只需要返回我们在<code class="du ku kv kw kx b">GuestService</code>类中定义的<code class="du ku kv kw kx b">getGuests</code>方法的输出。</p><h2 id="0f2c" class="mo kz hi bd la mp mq mr le ms mt mu li js mv mw lk jw mx my lm ka mz na lo nb bi translated">处理发布请求</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2017/11/top-5-free-core-spring-mvc-courses-learn-online.html"><div class="er es nj"><img src="../Images/b018cb83b3f45848c7dea7c2cf953c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvCYh2WMXh7wVcIn3hOu3A.png"/></div></a></figure><p id="19bf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个方法必须使用<code class="du ku kv kw kx b">@PostMapping</code>注释，这样Spring Boot就可以知道这个方法是<a class="ae kt" href="https://javarevisited.blogspot.com/2015/10/how-to-send-http-request-from-unix-or-linux-curl-wget-example.html" rel="noopener ugc nofollow" target="_blank"> POST请求</a>的处理程序。</p><p id="3f2a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该方法的目标是将用户的客人信息保存到系统中。我们决定要求用户将他们的数据放在请求体中。<a class="ae kt" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25"> Spring Boot </a>很容易将用户在请求体<strong class="jl hj">中提供的所有信息直接</strong>提取到<code class="du ku kv kw kx b">Guest</code>类的一个实例中。</p><p id="ee99" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这可以通过在参数中附加<code class="du ku kv kw kx b">@RequestBody</code>注释来实现。然后，调用<code class="du ku kv kw kx b">GuestService</code>类中的<code class="du ku kv kw kx b">addGuest</code>方法，将这些数据插入到我们的(内存)数据库中。最后，我们需要将该实例返回给用户，由前端服务进一步处理。</p><h2 id="303d" class="mo kz hi bd la mp mq mr le ms mt mu li js mv mw lk jw mx my lm ka mz na lo nb bi translated">处理删除请求</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="er es nd"><img src="../Images/cd363e6b300922f708ba1455eb267508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P97Hl8ImTWS68J93qzQddQ.png"/></div></div><p class="jf jg et er es jh ji bd b be z dx translated">HTTP删除处理程序</p></figure><p id="6be0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们想指示删除服务上的一条信息，HTTP DELETE请求方法是执行的合适方法。一个方法使用了<code class="du ku kv kw kx b">@DeleteMapping(&lt;Path&gt;)</code>注释，这样<a class="ae kt" rel="noopener" href="/hackernoon/top-5-spring-boot-and-spring-cloud-books-for-java-developers-75df155dcedc"> Spring Boot </a>就可以知道这个方法是删除请求的处理程序。我们设计了API路径，以便包含目标<code class="du ku kv kw kx b">guest</code> ID号的附加信息。在该API路径中检索信息很容易。我们只需要将<code class="du ku kv kw kx b">@PathVariable(&lt;var&gt;)</code>方法放入函数参数中。</p><p id="eb48" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，我们将这些<code class="du ku kv kw kx b">guest</code> ID作为参数传递给<code class="du ku kv kw kx b">GuestService</code>类中的<code class="du ku kv kw kx b">deleteGuest</code>方法来执行信息删除。这个函数不返回任何数据，所以最佳实践是告诉我们的用户一个<code class="du ku kv kw kx b">204 No Content</code>响应状态。</p><h2 id="e3db" class="mo kz hi bd la mp mq mr le ms mt mu li js mv mw lk jw mx my lm ka mz na lo nb bi translated">处理PUT请求</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="er es nd"><img src="../Images/f5af42129e7655ef5237cb4a44cbad5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77pBGDJWKt7X3QgbYxLo_A.png"/></div></div><p class="jf jg et er es jh ji bd b be z dx translated">HTTP上传处理程序</p></figure><p id="57f9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个方法必须使用<code class="du ku kv kw kx b">@PutMapping</code>注释，这样Spring Boot就可以知道这个方法是用于<a class="ae kt" href="https://javarevisited.blogspot.com/2016/10/difference-between-put-and-post-in-restful-web-service.html" rel="noopener ugc nofollow" target="_blank"> HTTP PUT请求</a> s的处理程序。此外，我们还需要path变量的其他信息作为请求参数。为了能够做到这一点，我们应该给目标参数加上<code class="du ku kv kw kx b">@RequestParams(required=false)</code>注释。请求参数和路径变量的区别在于我们可以将请求参数设置为可选的。</p></div><div class="ab cl nk nl gp nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="hb hc hd he hf"><p id="3001" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然最终的结果肯定是不一样的，但是如果你按照本文的说明去做，最终的<code class="du ku kv kw kx b">GuestController.java</code>代码应该是下图这样的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="er es nd"><img src="../Images/378ba9bf272461a117ccb0ff3b6c2429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmZ3Zgp8vGTy6gm6NCUsFw.png"/></div></div><p class="jf jg et er es jh ji bd b be z dx translated">GuestController.java全面实施</p></figure><h1 id="6258" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">结果</h1><p id="010a" class="pw-post-body-paragraph jj jk hi jl b jm lq ij jo jp lr im jr js ls ju jv jw lt jy jz ka lu kc kd ke hb bi translated">如果你按照这个指南读到了这一节，那么恭喜你！您只需要运行应用程序，这样我们就可以测试我们的服务。我们将使用<a class="ae kt" rel="noopener" href="/javarevisited/6-best-rest-api-tools-for-testing-design-and-development-1c5f69ed1f22"> Postman </a>对服务执行CRUD操作。我分享了API集合，所以你可以通过下面的链接导入到Postman。</p><pre class="iy iz ja jb fd nr kx ns nt aw nu bi"><span id="0e71" class="mo kz hi kx b fi nv nw l nx ny"><a class="ae kt" href="https://www.getpostman.com/collections/14480a416e8c1e3d9963" rel="noopener ugc nofollow" target="_blank">https://www.getpostman.com/collections/14480a416e8c1e3d9963</a></span></pre><p id="0d88" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">按照下面的GIF使用Postman API测试工具测试我们的web应用程序:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/02/top-5-postman-tutorials-and-courses-for-web-developers.html"><div class="er es nc"><img src="../Images/ea0cdf44d115361cc50c1ef8060e3759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*S8qOG7S1wTNTTR4COoLYvg.gif"/></div></a><p class="jf jg et er es jh ji bd b be z dx translated">CRUD API测试</p></figure><h1 id="9ce1" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">进一步阅读</h1><p id="43da" class="pw-post-body-paragraph jj jk hi jl b jm lq ij jo jp lr im jr js ls ju jv jw lt jy jz ka lu kc kd ke hb bi translated">这是在Spring Boot上开发CRUD操作的简单指南。你应该做很多改进。我在下面放了外部链接，供您了解Spring Boot的其他改进和组件:</p><ul class=""><li id="096b" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">Ignacio Oliveto与JWT Spring Boot公司合作保护应用程序</li><li id="d121" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" rel="noopener" href="/clover-platform-blog/building-a-microservice-with-spring-boot-and-spring-cloud-1c8275d7d229">用Spring Boot和春云搭建微服务</a> bt三叶草平台</li><li id="fa7a" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated"><a class="ae kt" href="https://tiagoamp.medium.com/graphql-with-java-and-spring-boot-a081839122ad" rel="noopener"> GraphQL与Java和Spring Boot </a>由Tiago Albuquerque开发</li></ul><p id="3972" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">特别向<a class="ae kt" href="https://www.youtube.com/user/djdjalas" rel="noopener ugc nofollow" target="_blank">朋友们喊出</a>。他的伟大和通俗易懂的内容真的帮助我了解Spring Boot。请去看看他的Youtube频道，别忘了订阅。</p></div></div>    
</body>
</html>