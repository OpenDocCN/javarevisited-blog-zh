# 调试 RAM: Java 垃圾收集— Java 堆深度探讨，第 1 部分

> 原文：<https://medium.com/javarevisited/debugging-ram-java-garbage-collection-java-heap-deep-dive-part-1-8c140b716cc9?source=collection_archive---------1----------------------->

[![](img/2e65dbb3a16d8d5c291136ad0d3583e9.png)](https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html)

有许多关于 Java 垃圾收集、Java 内存使用和一般 Java 堆的优秀文章。不幸的是，他们到处都是。他们将架构、概念和问题解决作为独立的部分混合在一起。许多材料已经过时，或者不包含解决垃圾收集器问题的实用信息。例如暂停时间、堆空间使用等。

在这篇文章中，我不会讨论内存泄漏。它们很重要，但这是一个不同的主题，我想在一篇文章中单独讨论。

# 垃圾收集器权衡

GC 是惊人的，未被引用的对象在一个自动的过程中被收集。但是垃圾收集仍然要做一些权衡:

*   内存占用
*   暂停
*   表演

挑两个吧。垃圾收集器可以权衡 RAM 以提供更快的性能和更少的 GC 延迟。在这篇文章中，我将讨论挑选和调优 GC 的策略。

通常，当我们想要选择一个库时，我们只需要做一个基准测试。但是对 GC 进行基准测试要困难得多。如果我们让一个 GC 过载，我们可能最终得到一个可以很好地处理压力的 GC，但是对于典型的内存分配来说不是最佳的。理解垃圾收集器是如何工作的，以及我们用“真实世界”的工作负载来分析 GC 是至关重要的。

# 不是你的父亲阻止了世界大扫荡

自从 Java 1.0 终结了世界 GC 以来，Java GC 已经走过了漫长的道路。虽然有许多类型的垃圾收集器，但大多数新的垃圾收集器都是分代的、并行/并发的。当在我们的本地机器上工作时，这似乎并不重要。但是当 GCing 非常大的堆时，这种差异是非常明显的。

GCs“无缝地”检测未使用的对象以回收堆空间。但是也有权衡。何时将一个对象视为“未使用的对象”是核心内存管理权衡。

# 分代垃圾收集

大多数现代 GCs 假设对象生命周期符合世代范式。老一代空间物体寿命很长，很少被收集。他们不需要频繁扫描。年轻一代对象生老病死很快。经常在一起。

分代垃圾收集(通常)更频繁地遍历年轻一代，并特别注意各代之间的联系。这一点很重要，因为在较小的垃圾收集周期中需要扫描的区域较少。相对于完整的 GC 周期，较短周期的术语是增量 GC。GC 通常会尽量减少完整的 GC 周期。

# 并发与并行垃圾收集器

并行 GC 经常与并发 GC 混淆。更令人困惑的是，一个 GC 既可以是并行 GC，也可以是并发 GC(例如 G1)。

不过区别很简单:

*   并行 GC 有多个 GC 线程。GC 线程执行实际的垃圾回收。它们对于大规模收集至关重要
*   并发 GC 允许 JVM 在标记阶段或者其他阶段做其他事情

直觉上，我们大多数人都希望一直拥有这两者，并充分利用应用程序线程。但这并不总是正确的选择。并发性和多个应用程序线程会产生开销。此外，这些 GC 经常做出权衡，错过一些不可到达的对象，并使一些堆内存在更长的时间内不被回收。明确地说，他们会在一个完整的 GC 周期中找到所有未使用的内存，但是他们会尽量避免这样的周期，这样您可能会付出代价。

以下是截至 JDK 17 年的大型 GC。

# 串行收集器

这是一个单线程垃圾收集器。这意味着它比大多数 GC 稍快，但会导致更多的停顿。如果您正在进行性能基准测试，那么打开这个 GC 来减少差异是有意义的。因为几乎所有的 CPU 都是多核的，所以这种 GC 对于大多数真实世界的部署来说并不有用，但是它使得调试一些行为变得更加容易。

在一种情况下，串行收集器可能会给生产带来很大好处，那就是无服务器工作负载(例如 lambdas 等。).在这些情况下，最小/最快的解决方案胜出，这可能是在单核虚拟机上使用有限物理内存的正确解决方案。

注意，尽管串行收集器相对简单，但它是一个分代的 GC。因此，它比旧的 Java GCs 要现代得多。

您可以使用`-XX:+UseSerialGC`明确地打开这个 GC。

# 并行收集器又名吞吐量收集器

相当于串行收集器的多线程。这是一个很好的收集器，可以用于生产，但还有更好的。串行收集器更适合基准测试，ZGC/G1 通常提供更好的性能。

您可以使用`-XX:+UseParallelGC`选项明确地打开这个 GC。

并行 GC 的一大好处是它的可配置性。您可以使用以下 JVM 选项来优化它:

*   `-XX:ParallelGCThreads=ThreadCount` -收集器使用的 GC 线程数量
*   `-XX:MaxGCPauseMillis=MaxDurationMilliseconds` -以毫秒为单位限制 GC 暂停。这默认为无限制
*   `-XX:GCTimeRatio=ratio` -在`1/(ratio + 1)`中设置专用于 GC 的时间，因此`9`的值意味着`1 / (9 + 1)`或`10%`。所以`10%`的 CPU 时间会花在 GC 上。默认值为`99`，即`1%`

# G1 垃圾收集器

G1 垃圾收集器是一个重型 GC，设计用于具有大堆大小(大约 6GB 或更高)的机器上的大工作负载。它试图适应给定机器中的工作条件。您可以使用 JVM 选项`-XX:+UseG1GC`显式地启用它。

G1 是一个并发 GC，它在后台工作，最大限度地减少暂停。它的一个更酷的特性是字符串重复数据删除，这减少了 RAM 中字符串的开销。您可以使用`-XX:+UseStringDeduplication`激活该功能。

# z 垃圾收集器(ZGC)

在 JVM 的最新版本之前，ZGC 一直是试验性的。它是为比 G1 更大的堆大小而设计的，也是一个并发 GC。它支持较小的环境，可用于从 8mb 到 16TB 的堆大小！

它最大的特点之一是它不会暂停应用程序超过 10 毫秒。代价是吞吐量的降低。

可以使用`-XX:+UseZGC` JVM 选项启用 ZGC。

# 挑选和调试垃圾收集器

Java 8 使用了`-verbose:gc`标志来生成 GC 日志和`-XX:+PrintGCDetails`标志。

较新的 JDK 使用`-Xlog:gc:file.log`,它将 GC 细节打印到给定的文件中。通过启用这些特性并正常运行您的应用程序，您可以跟踪 GC 行为并适当地调优您的代码/部署。

不久前，我遇到了 GCeasy，这是一个非常好地分析 GC 日志的网站。还有几个类似的工具，它们可以为你提供一些有趣的信息。然而，日志文件也是可以直接阅读的，您可以从阅读它中学到很多东西。

此外，您可以使用 JVM 选项获得更详细的 GC 信息:

```
-Xlog:gc*=debug:file=gc-verbose.log
```

注意，在 Linux/Unix 上，您需要用引号将这个命令括起来，这样 shell 就不会试图展开它。

使用详细输出，您可以更深入地了解 GC 的内部工作方式，并且可以继续调优 JVM 堆。事实上，我建议任何 JVM 开发人员至少尝试一次这个标志，以了解 Java 堆空间的内部工作方式。

# 基准/测量

正如我之前提到的，对于应用程序性能基准来说，GC 很糟糕。如果我们只是使用常规基准测试，串行 GC 通常会胜出，尽管它不应该是我们大多数人的首选。诀窍是使用真实的负载，然后查看 GC 日志。

然后，我们可以根据每个 GC 提供的统计数据，决定我们愿意接受的折衷方案。注意，我们也可以将自己限制在外部指标上，比如 CPU 和 RAM 的使用情况。这可能是一个非常好的方法。然而，进行重负载测试可能不是 GC 性能的最佳表现。要明确的是，你仍然应该做一个重负荷测试。

# GC 调优

几乎所有 Java 开发人员在调优内存时做的第一件事就是定义最大大小和最小大小。使用已经存在了几十年的 JVM 参数`-Xmx`和- `Xms`很容易确定初始堆大小。

一种常见的方法是将两者设置为相同的大小。这不一定是坏事。它简化了 GC 中的内存管理逻辑，现在只关注一个值。不过，这确实会带来风险。这意味着没有犯错的余地。

您可以通过应用程序代码实现最重要的性能提升。性能问题落到 GC 标志调优上的情况非常罕见(尽管这种情况可能会发生)。

# 减少 RAM 的使用

大多数开发人员喜欢减少垃圾收集时间，但是对于一些人来说，内存消耗是一个更大的问题。如果您在受限环境中运行，例如微服务或无服务器容器。您可以使用以下 Java 标志来解决内存不足的问题:

*   减小默认为`70%`的`-XX:MaxHeapFreeRatio`和默认为`40%`的`-XX:MinHeapFreeRatio`的值。最大值可以减少到`10%`
*   您可以使用`-XX:-ShrinkHeapInSteps`,这将更频繁地触发 GC，并以牺牲性能为代价降低内存使用

# 世代优化

通常，当您添加 RAM 时，大多数 Java 应用程序的性能会更好。但是有时大量的 RAM 会触发很长时间的 GC 暂停，有时甚至会触发超时。

停滞的一个重要来源是完整的 GC 周期，如果 GC 无法为年轻/幸存代构建正确的内存池，就会发生这种情况。例如，如果你有一个快速创建和丢弃对象的应用程序，你可能需要比老一代更年轻的一代。你可以使用`-XX:NewRatio`来调整它，让你定义老一代和年轻一代之间的比例。这默认为 2，这意味着新一代的大小是老一代的两倍。

您还可以调整-XX:NewSize 值，该值指定专用于新一代的 RAM 数量。

# 元空间、永久生成、堆栈大小等。

从技术上讲，这些不是 GC 的一部分，但是它们经常与 Java 堆内存相关的问题混淆在一起，所以这是讨论它们的好地方。

如果您有一个线程繁重的应用程序，您可能要考虑减少堆栈大小(如果适用)。通常栈的大小被调整为允许更大的大小，这让我们支持深度递归算法。

用 Java 8 PermGen(又名永久一代)终于被干掉了。PermGen 是一个存储类文件和元数据的特殊内存空间。我们偶尔不得不为动态生成字节码的应用程序调整它，因为如果有太多的类文件，它会触发内存错误。新的 Metaspace 具有自动内存管理功能，解决了 PermGen 中的大部分问题。

我们仍然可以使用提示`-XX:MaxMetaspaceSize`来设置元空间的大小。

将应用程序适当地调优到 GC 是很重要的。减少本机代码(和终结器)、弱引用、软引用和幻像引用的使用。所有这些特性都会增加 GC 的开销。虽然公平地说，在服务器上的大多数情况下，这些都不是决定性因素。

# 瓦尔哈拉的未来

GC 是惊人的，但是在 Java 堆内存性能方面存在一些边缘情况。

例如，如果我们用 C 和 Java 编写本机内存处理，我们可以获得与本机代码大致相当的性能，如下所示:

```
int[] myArray = new int[2000];
```

在某些情况下，由于 Javas 快速分配器代码和原语支持，这比 C 执行得更快。

这种情况不适用于:

```
Integer myArray = new Integer[2000];
```

或用于:

```
Point[] myPointArray = new Point[2000];
```

在 C++中，我们可以定义一个堆栈对象，它的内存直接连接到它的父对象。无论是堆栈框架还是包含它的对象。这有它的缺点，因为数据需要被复制，它不再只是一个指针。但是数据位于相同的页面甚至寄存器中，因此不存在内存碎片，开销也非常低。

这是瓦尔哈拉试图解决的巨大问题的一部分。它将增加将对象定义为值或原语的能力，这将让我们将它们定义为其他东西的一部分。这将有效地消除`Optional`和原始包装器的开销。这也将使可空性变得更加微妙。

对 GC 的影响也将是巨大的。想象一个由 2000 个点对象组成的数组作为一个单一的操作…

这是 Java SE 在语言和虚拟机方面的一个巨大变化。因此，我过去对此一直持观望态度。但是在阅读了一些与项目相关的[材料后，我持谨慎乐观的态度。](https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2021-December/001747.html)

# TL；速度三角形定位法(dead reckoning)

垃圾收集器线程很少是你的应用程序性能差甚至内存不足的原因。对于`99.9%`的情况，原因可能在应用程序代码中。不要指望命令行选项会神奇地修复问题。

然而，这些工具允许您从 GC 的角度跟踪应用程序的内部工作。当您在 JVM 进程中遇到内存问题时，您可以使用这些工具来缩小范围。

尽管如此，GC 暂停是一个真正的问题，可能会导致生产失败。尤其是在非常大的堆中。同样，您需要首先检查内存中的对象，但是理解虚拟机对内存的权衡是至关重要的。

## 了解更多信息

在 [Twitter](https://twitter.com/debugagent/) 上关注我，了解更多信息并获取未来帖子的更新。