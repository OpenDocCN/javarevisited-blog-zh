<html>
<head>
<title>Spring Boot — Power of Value Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot——价值对象的力量</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-boot-power-of-value-objects-a98831cfe4b8?source=collection_archive---------0-----------------------#2022-12-05">https://medium.com/javarevisited/spring-boot-power-of-value-objects-a98831cfe4b8?source=collection_archive---------0-----------------------#2022-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4d70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我告诉你:</p><ol class=""><li id="f6b4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">什么是价值对象，为什么它们如此重要？</li><li id="fb6f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如何在Spring Boot控制器中应用这些模式，使代码更安全、更易于维护。</li></ol><p id="fc76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我从这个库的<a class="ae jr" href="https://github.com/SimonHarmonicMinor/spring-boot-value-objects-example" rel="noopener ugc nofollow" target="_blank">中获取代码示例。您可以克隆它来查看整个项目的运行情况。</a></p><figure class="jt ju jv jw fd jx er es paragraph-image"><a href="https://www.java67.com/2021/02/spring-boot-actuator-interview-questions-answers-java.html"><div class="er es js"><img src="../Images/9afb50276e7b92a70b559c0023763c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*DwAYdw7gqRnU4vuC.jpg"/></div></a><p class="ka kb et er es kc kd bd b be z dx translated">迷因封面</p></figure><h1 id="01b9" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">领域</h1><p id="330e" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">这个领域相当简单。我们只有一个实体。无论如何，你会看到即使一个类也可能产生歧义和数据损坏。</p><blockquote class="lh li lj"><p id="8df3" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">我使用Hibernate作为持久性框架。因此，域实体</em> <code class="du lo lp lq lr b"><em class="hi">User</em></code> <em class="hi">也是一个Hibernate实体。但是，即使您根本不使用Hibernate，我向您提出的想法也是一样的。</em></p></blockquote><p id="6c62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们从数据库模式开始。有一张桌子。所以，不会很难。</p><p id="3508" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们想要存储用户的电话号码。下面是SQL表的定义:</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="3ef2" class="lw kf hi lr b be lx ly l lz ma">CREATE TABLE users<br/>(<br/>    id           UUID   PRIMARY KEY,<br/>    phone_number VARCHAR(200) NOT NULL UNIQUE<br/>);</span></pre><p id="5ec4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些类型非常简单。现在让我们定义相应的Hibernate实体。请看下面的代码示例。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="1385" class="lw kf hi lr b be lx ly l lz ma">@Entity<br/>@Table(name = "users")<br/>@Getter<br/>public class User {<br/>    @Id<br/>    private UUID id;<br/><br/>    @Column(name = "phone_number")<br/>    private String phoneNumber;<br/>}</span></pre><p id="9e0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来不错，不是吗？电话号码是<code class="du lo lp lq lr b">String</code>类型。这些字段直接映射到数据库列。什么会出错？你很快就会看到，很多事情。</p><h1 id="2b0d" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">电话号码完整性问题</h1><p id="cb30" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">每个可能的<code class="du lo lp lq lr b">String</code>值都是有效的电话号码吗？当然不是。这就是问题所在。用户可以将<code class="du lo lp lq lr b">0</code>、负值、甚至<code class="du lo lp lq lr b">some-unknown-value-string</code>作为电话号码。</p><p id="d77f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设在注册过程中，某个用户将其电话号码设置为<code class="du lo lp lq lr b">-78005553535</code>。很明显，有一个错别字，应该是<code class="du lo lp lq lr b">+</code>符号，而不是<code class="du lo lp lq lr b">-</code>符号。反正用户还没注意到错误，应用了设置。稍后，另一个用户想要找到之前的人，并向该群发送邀请。他或她只知道电话号码。突然<code class="du lo lp lq lr b">+78005553535</code>搜索没有返回结果。尽管查询输入绝对正确。现在假设您的应用程序服务于成千上万的人。即使1%的人在他们的电话号码中犯了一个错误，在数据库中修复这些值也将是乏味的。</p><p id="3a6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你如何克服这个问题？答案是<a class="ae jr" href="https://martinfowler.com/bliki/ValueObject.html" rel="noopener ugc nofollow" target="_blank">值对象</a>。这个想法很简单:</p><ol class=""><li id="28d4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">值对象必须是不可变的。</li><li id="3710" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">值对象应该是可比较的(即实现<code class="du lo lp lq lr b">equals/hashCode</code>)。</li><li id="0f02" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">值对象保证它总是保存正确的值。</li></ol><p id="46f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看下面<code class="du lo lp lq lr b">PhoneNumber</code>宣言的第一次尝试。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="bb35" class="lw kf hi lr b be lx ly l lz ma">@Value<br/>public class PhoneNumber {<br/>    String value;<br/><br/>    public PhoneNumber(String value) {<br/>        this.value = value;<br/>    }<br/>}</span></pre><blockquote class="lh li lj"><p id="92d1" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">将</em> <code class="du lo lp lq lr b"><a class="ae jr" href="https://projectlombok.org/features/Value" rel="noopener ugc nofollow" target="_blank"><em class="hi">@Value</em></a></code> <a class="ae jr" href="https://projectlombok.org/features/Value" rel="noopener ugc nofollow" target="_blank"> <em class="hi">龙目标注</em> </a> <em class="hi">生成</em><code class="du lo lp lq lr b"><em class="hi">equals</em></code><em class="hi"/><code class="du lo lp lq lr b"><em class="hi">hashCode</em></code><em class="hi"/><code class="du lo lp lq lr b"><em class="hi">toString</em></code><em class="hi">方法，并将所有字段定义为</em> <code class="du lo lp lq lr b"><em class="hi">private final</em></code> <em class="hi">。</em></p></blockquote><p id="0302" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">PhoneNumber</code>类解决了我们定义的第一个和第二个需求。但是，您仍然可以用无效的电话号码构造类(例如，<code class="du lo lp lq lr b">0</code>、<code class="du lo lp lq lr b">-123</code>、<code class="du lo lp lq lr b">abc</code>)。这意味着我们应该在构造函数内部继续验证过程。看看下面固定的代码片段。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="e04e" class="lw kf hi lr b be lx ly l lz ma">@Value<br/>public class PhoneNumber {<br/>    private static final PhoneNumberUtil PHONE_NUMBER_UTIL = PhoneNumberUtil.getInstance();<br/><br/>    String value;<br/><br/>    public PhoneNumber(String value) {<br/>        this.value = value;<br/>        validatePhoneNumber(value);<br/>    }<br/><br/>    private static void validatePhoneNumber(String value) {<br/>        try {<br/>            if (Long.parseLong(value) &lt;= 0) {<br/>                throw new PhoneNumberParsingException("The phone number must be positive: " + value);<br/>            }<br/>            PHONE_NUMBER_UTIL.parse(String.valueOf(value), "RU");<br/>        } catch (NumberParseException | NumberFormatException e) {<br/>            throw new PhoneNumberParsingException("The phone number isn't valid: " + value, e);<br/>        }<br/>    }<br/>}</span></pre><blockquote class="lh li lj"><p id="e55b" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">我正在使用</em><a class="ae jr" href="https://github.com/google/libphonenumber" rel="noopener ugc nofollow" target="_blank"><em class="hi">Google Libphonenumber</em></a><em class="hi">库来验证输入。</em></p></blockquote><p id="a838" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">似乎我们解决了问题。我们总是在对象构造期间验证该值。然而，一个微小的细节仍然没有被触及。而且叫<em class="lk">数据规范化</em>。</p><p id="485b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果用户<code class="du lo lp lq lr b">A</code>将他们的电话号码设置为<code class="du lo lp lq lr b">88005553535</code>，用户<code class="du lo lp lq lr b">B</code>将不会在搜索栏中找到他或她键入的<code class="du lo lp lq lr b">+78005553535</code>值。尽管俄罗斯人对这些电话号码一视同仁。</p><blockquote class="lh li lj"><p id="8583" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">这仅适用于本地电话。无论如何，一些用户可以基于此做出假设。</em></p></blockquote><p id="73a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，我们应该始终将从业务角度来看相等的有效输入值转换为相同的输出结果，以消除可能的歧义。看看下面最后的<code class="du lo lp lq lr b">PhoneNumber</code>类声明。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="8c9a" class="lw kf hi lr b be lx ly l lz ma">@Value<br/>public class PhoneNumber {<br/>    private static final PhoneNumberUtil PHONE_NUMBER_UTIL = PhoneNumberUtil.getInstance();<br/><br/>    String value;<br/><br/>    public PhoneNumber(String value) {<br/>        this.value = validateAndNormalizePhoneNumber(value);<br/>    }<br/><br/>    private static String validateAndNormalizePhoneNumber(String value) {<br/>        try {<br/>            if (Long.parseLong(value) &lt;= 0) {<br/>                throw new PhoneNumberParsingException("The phone number cannot be negative: " + value);<br/>            }<br/>            final var phoneNumber = PHONE_NUMBER_UTIL.parse(value, "RU");<br/>            final String formattedPhoneNumber = PHONE_NUMBER_UTIL.format(phoneNumber, E164);<br/>            // E164 format returns phone number with + character<br/>            return formattedPhoneNumber.substring(1);<br/>        } catch (NumberParseException | NumberFormatException e) {<br/>            throw new PhoneNumberParsingException("The phone number isn't valid: " + value, e);<br/>        }<br/>    }<br/>}</span></pre><p id="c3d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们也写一些单元测试来验证行为。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="df65" class="lw kf hi lr b be lx ly l lz ma">class PhoneNumberTest {<br/>    @ParameterizedTest<br/>    @CsvSource({<br/>        "78005553535,78005553535",<br/>        "88005553535,78005553535",<br/>    })<br/>    void shouldParsePhoneNumbersSuccessfully(String input, String expectedOutput) {<br/>        final var phoneNumber = assertDoesNotThrow(<br/>            () -&gt; new PhoneNumber(input)<br/>        );<br/>        assertEquals(expectedOutput, phoneNumber.getValue());<br/>    }<br/><br/>    @ParameterizedTest<br/>    @ValueSource(strings = {<br/>        "0", "-1", "-56"<br/>    })<br/>    void shouldThrowExceptionIfPhoneNumberIsNotValid(String input) {<br/>        assertThrows(<br/>            PhoneNumberParsingException.class,<br/>            () -&gt; new PhoneNumber(input)<br/>        );<br/>    }<br/>}</span></pre><p id="35cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是执行结果。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><a href="https://www.java67.com/2020/04/how-to-validate-phone-number-in-java.html"><div class="er es mb"><img src="../Images/c25e8e1635bd7987575c26f77554dd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c977wW631r69nvGY.png"/></div></a><p class="ka kb et er es kc kd bd b be z dx translated">测试执行结果</p></figure><p id="e1c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一步是将值对象放到<code class="du lo lp lq lr b">User</code> Hibernate实体中。在这种情况下，<a class="ae jr" href="https://www.baeldung.com/jpa-attribute-converters" rel="noopener ugc nofollow" target="_blank">属性转换器</a>就派上了用场。请看下面的代码块。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="bc80" class="lw kf hi lr b be lx ly l lz ma">@Converter<br/>public class PhoneNumberConverter implements AttributeConverter&lt;PhoneNumber, String&gt; {<br/>    @Override<br/>    public String convertToDatabaseColumn(PhoneNumber attribute) {<br/>        return attribute.getValue();<br/>    }<br/><br/>    @Override<br/>    public PhoneNumber convertToEntityAttribute(String dbData) {<br/>        return new PhoneNumber(dbData);<br/>    }<br/>}<br/><br/>@Entity<br/>@Table(name = "users")<br/>@Getter<br/>public class User {<br/>    @Id<br/>    private UUID id;<br/><br/>    @Column(name = "phone_number")<br/>    @Convert(converter = PhoneNumberConverter.class)<br/>    @NotNull<br/>    private PhoneNumber phoneNumber;<br/>}</span></pre><p id="3b56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与使用原始类型相比，值对象有什么好处？他们在这里:</p><ol class=""><li id="d8c4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">如果您收到了<code class="du lo lp lq lr b">PhoneNumber</code>实例，那么您肯定知道它是有效的，并且您不需要重复验证。</li><li id="2e0d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">快速失效模式。如果电话号码无效，您很快就会得到一个异常。</li><li id="8c32" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">代码更安全。如果您根本不使用原始类型作为业务值，那么您可以保证所有的输入值都通过了定义的检查。</li><li id="8b0b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果你是Hibernate用户，那么<a class="ae jr" href="https://thorben-janssen.com/jpql/" rel="noopener ugc nofollow" target="_blank"> JPQL </a>查询将返回<code class="du lo lp lq lr b">PhoneNumber</code>值对象，而不仅仅是上下文无关的<code class="du lo lp lq lr b">String</code>属性。</li><li id="58e2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">您将所有检查封装在一个类中。如果必须根据新的业务需求对它们进行调整，应该只在一个地方进行。</li></ol><h1 id="9225" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">类型化实体的id</h1><p id="2c40" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">您的项目中可能会有不止一个实体。并且它们中的大多数很有可能共享相同类型的ID(在本例中，是<code class="du lo lp lq lr b">UUID</code>类型)。</p><p id="6ecc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那有什么问题？假设您有一个将<code class="du lo lp lq lr b">User</code>分配给某个<code class="du lo lp lq lr b">UserGroup</code>的服务。它接受两个id作为输入参数。请看下面的代码示例。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="734e" class="lw kf hi lr b be lx ly l lz ma">public void assignUserToGroup(UUID userId, UUID userGroupId) { ... }</span></pre><p id="03b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我打赌你已经看过很多类似的片段了。无论如何，让我们假设有人写了这行代码。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="24ff" class="lw kf hi lr b be lx ly l lz ma">assignUserToGroup(userGroup.getId(), user.getId());</span></pre><p id="7355" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你能发现这里有窃听器吗？我们不小心交换了身份。如果您犯了这样的错误，那么您将很幸运在语句执行时得到<a class="ae jr" href="https://www.w3schools.com/sql/sql_foreignkey.asp" rel="noopener ugc nofollow" target="_blank">外键</a>违例。但是如果表上没有外键，或者赋值已经成功进行，而业务操作结果不正确，那么您就有大麻烦了。</p><p id="4183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对<code class="du lo lp lq lr b">assignUserToGroup</code>方法声明做了一点小小的改动。看下面的固定选项。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="a3de" class="lw kf hi lr b be lx ly l lz ma">public void assignUserToGroup(User.ID userId, UserGroup.ID userGroupId) { ... }</span></pre><p id="a079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在交换IDs bug是不可能的了。因为这会导致编译时错误。更好的是，您可以轻松地实现Hibernate实体的方法。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="4fb5" class="lw kf hi lr b be lx ly l lz ma">@Entity<br/>@Table(name = "users")<br/>@Getter<br/>public class User {<br/>    @EmbeddedId<br/>    private User.ID id;<br/><br/>    @Column(name = "phone_number")<br/>    @Convert(converter = PhoneNumberConverter.class)<br/>    @NotNull<br/>    private PhoneNumber phoneNumber;<br/><br/>    @Data<br/>    @Setter(PRIVATE)<br/>    @Embeddable<br/>    @AllArgsConstructor<br/>    @NoArgsConstructor(access = PROTECTED)<br/>    public static class ID implements Serializable {<br/>        @Column(updatable = false)<br/>        @NotNull<br/>        private UUID id;<br/>    }<br/>}</span></pre><p id="a62f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的<code class="du lo lp lq lr b">findBy</code> Spring数据查询，所有的定制JPQL语句都与<code class="du lo lp lq lr b">User.ID</code>一起工作，但不是原始的<code class="du lo lp lq lr b">UUID</code>类型。此外，它还有助于方法重载。如果您是一个原始的IDs用户，并且您需要相同的方法来接受不同实体的id，那么您必须用不同的方式命名它们。但是对于类型化的id，情况就不一样了。看看下面的例子。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="c537" class="lw kf hi lr b be lx ly l lz ma">public class RoleOperations {<br/><br/>    // doesn't compile<br/>    public boolean hasAnyRole(UUID userId, Role... role) {...}<br/><br/>    public boolean hasAnyRole(UUID userGroupId, Role... role) {...}<br/>}<br/><br/>public class RoleOperations {<br/><br/>    // compiles successfully<br/>    public boolean hasAnyRole(User.ID userId, Role... role) {...}<br/><br/>    public boolean hasAnyRole(UserGroup.ID userGroupId, Role... role) {...}<br/>}</span></pre><blockquote class="lh li lj"><p id="dbe7" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi">不幸的是，您不能用值对象平滑地包装基于序列的id。有解决办法，但是比较繁琐。我把</em> <a class="ae jr" href="https://github.com/vladmihalcea/hibernate-types/issues/522" rel="noopener ugc nofollow" target="_blank"> <em class="hi">留了下来，建议给Hibernate types项目的</em> </a> <em class="hi">增加对这个特性的支持。您已经看到了用户定义类型的好处。所以，你可以评价我的问题，让它更受欢迎。但是，您仍然可以在客户端生成号码id。例如，</em> <a class="ae jr" href="https://github.com/f4b6a3/tsid-creator" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> TSID库</em> </a> <em class="hi">就做了这项工作。</em></p></blockquote><h1 id="3653" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">REST端点参数</h1><p id="5f62" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我已经指出，在所有应用程序级别使用值对象降低了代码的复杂性，并使其更加安全。然而，当涉及到REST端点时，事情就没那么简单了。假设我们需要两个操作:</p><ol class=""><li id="5988" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">用给定的<code class="du lo lp lq lr b">PhoneNumber</code>创建新的<code class="du lo lp lq lr b">User</code>。</li><li id="6cd5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">通过提供的<code class="du lo lp lq lr b">PhoneNumber</code>搜索已有的<code class="du lo lp lq lr b">User</code>。</li></ol><p id="53b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看下面可能的实现。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="ef0d" class="lw kf hi lr b be lx ly l lz ma">@RestController<br/>class UserController {<br/><br/>    @PostMapping("/api/user")<br/>    void createUser(@RequestParam String phoneNumber) {<br/>        ...<br/>    }<br/><br/>    @GetMapping("/api/user")<br/>    UserResponse getUserByPhoneNumber(@RequestParam String phoneNumber) {<br/>        ...<br/>    }<br/><br/>    record UserResponse(UUID id, String phoneNumber) {<br/>    }<br/>}</span></pre><p id="b386" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，我们又回到了原始类型用法(例如，<code class="du lo lp lq lr b">UUID</code>作为id，<code class="du lo lp lq lr b">String</code>作为电话号码)。如果我们简单地将<code class="du lo lp lq lr b">@RequestParam</code>类型替换为<code class="du lo lp lq lr b">PhoneNumber</code>，我们将在运行时得到一个异常。<code class="du lo lp lq lr b">UserResponse</code>序列化可能不会产生任何错误，但是客户端将接收到意外格式的数据。因为<a class="ae jr" href="https://www.baeldung.com/jackson" rel="noopener ugc nofollow" target="_blank">Jackson</a>(Spring Boot默认的序列化库)不知道如何处理自定义类型。</p><p id="90f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢天谢地，有一个解决方案。首先，让我们定义一个<code class="du lo lp lq lr b">SerdeProvider</code>接口。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="d274" class="lw kf hi lr b be lx ly l lz ma">public interface SerdeProvider&lt;T&gt; {<br/>    JsonDeserializer&lt;T&gt; getJsonDeserializer();<br/>    JsonSerializer&lt;T&gt; getJsonSerializer();<br/>    Formatter&lt;T&gt; getTypedFieldFormatter();<br/>    Class&lt;T&gt; getType();<br/>}</span></pre><p id="8118" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们需要两个注册为Spring beans的实现。<code class="du lo lp lq lr b">PhoneNumberSerdeProvider</code>和<code class="du lo lp lq lr b">UserIdSerdeProvider</code>。看下面的宣言。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="1876" class="lw kf hi lr b be lx ly l lz ma">@Component<br/>class PhoneNumberSerdeProvider implements SerdeProvider&lt;PhoneNumber&gt; {<br/>    @Override<br/>    public JsonDeserializer&lt;PhoneNumber&gt; getJsonDeserializer() {<br/>        return new JsonDeserializer&lt;&gt;() {<br/>            @Override<br/>            public PhoneNumber deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {<br/>                final var value = p.getValueAsString();<br/>                if (value == null) {<br/>                    return null;<br/>                }<br/>                return new PhoneNumber(value);<br/>            }<br/>        };<br/>    }<br/><br/>    @Override<br/>    public JsonSerializer&lt;PhoneNumber&gt; getJsonSerializer() {<br/>        return new JsonSerializer&lt;&gt;() {<br/>            @Override<br/>            public void serialize(PhoneNumber value, JsonGenerator gen, SerializerProvider serializers) throws IOException {<br/>                if (value == null) {<br/>                    gen.writeNull();<br/>                } else {<br/>                    gen.writeString(value.getValue());<br/>                }<br/>            }<br/>        };<br/>    }<br/><br/>    @Override<br/>    public Formatter&lt;PhoneNumber&gt; getTypedFieldFormatter() {<br/>        return new Formatter&lt;&gt;() {<br/>            @Override<br/>            public PhoneNumber parse(String text, Locale locale) {<br/>                return new PhoneNumber(text);<br/>            }<br/><br/>            @Override<br/>            public String print(PhoneNumber object, Locale locale) {<br/>                return object.getValue();<br/>            }<br/>        };<br/>    }<br/><br/>    @Override<br/>    public Class&lt;PhoneNumber&gt; getType() {<br/>        return PhoneNumber.class;<br/>    }<br/>}</span></pre><blockquote class="lh li lj"><p id="b9c3" class="if ig lk ih b ii ij ik il im in io ip ll ir is it lm iv iw ix ln iz ja jb jc hb bi translated"><em class="hi"/><code class="du lo lp lq lr b"><em class="hi">UserIdSerdeProvider</em></code><em class="hi">实现类似。可以在</em>  <em class="hi">资源库中找到</em> <a class="ae jr" href="https://github.com/SimonHarmonicMinor/spring-boot-value-objects-example/blob/master/src/main/java/com/example/config/UserIdSerdeProvider.java" rel="noopener ugc nofollow" target="_blank"> <em class="hi">源代码。</em></a></p></blockquote><p id="9491" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们只需要将这些定制提供者注册到<code class="du lo lp lq lr b">ObjectMapper</code>实例中。看下面的弹簧<code class="du lo lp lq lr b">@Configuration</code>。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="7dc6" class="lw kf hi lr b be lx ly l lz ma">@Slf4j<br/>@Configuration<br/>@RequiredArgsConstructor<br/>@SuppressWarnings({"unchecked", "rawtypes"})<br/>class WebMvcConfig implements WebMvcConfigurer {<br/>    private final List&lt;SerdeProvider&lt;?&gt;&gt; serdeProviders;<br/><br/>    @Override<br/>    public void addFormatters(FormatterRegistry registry) {<br/>        for (SerdeProvider&lt;?&gt; provider : serdeProviders) {<br/>            log.info("Add custom formatter for field type '{}'", provider.getType());<br/>            registry.addFormatterForFieldType(provider.getType(), provider.getTypedFieldFormatter());<br/>        }<br/>    }<br/><br/>    @Bean<br/>    public ObjectMapper objectMapper() {<br/>        return new ObjectMapper()<br/>            .registerModule(new Jdk8Module())<br/>            .registerModule(new JavaTimeModule())<br/>            .registerModule(customSerDeModule())<br/>            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br/>    }<br/><br/>    public com.fasterxml.jackson.databind.Module customSerDeModule() {<br/>        final var module = new SimpleModule("Custom SerDe module");<br/>        for (SerdeProvider provider : serdeProviders) {<br/>            log.info("Add custom serde for type '{}'", provider.getType());<br/>            module.addSerializer(provider.getType(), provider.getJsonSerializer());<br/>            module.addDeserializer(provider.getType(), provider.getJsonDeserializer());<br/>        }<br/>        return module;<br/>    }<br/>}</span></pre><p id="6ba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们可以重构初始的REST控制器。看看下面的最终版本。</p><pre class="jt ju jv jw fd ls lr lt bn lu lv bi"><span id="86bc" class="lw kf hi lr b be lx ly l lz ma">@RestController<br/>class UserController {<br/><br/>    @PostMapping("/api/user")<br/>    void createUser(@RequestParam PhoneNumber phoneNumber) {<br/>        ...<br/>    }<br/><br/>    @GetMapping("/api/user")<br/>    UserResponse getUserByPhoneNumber(@RequestParam PhoneNumber phoneNumber) {<br/>        ...<br/>    }<br/><br/>    record UserResponse(User.ID id, PhoneNumber phoneNumber) {<br/>    }<br/>}</span></pre><p id="4974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们不必再在应用程序中处理原始类型。框架将输入值转换成相应的值对象，反之亦然。因此，Spring会在值对象创建期间自动对其进行验证。因此，如果输入无效，您可以在不触及业务逻辑的情况下尽早获得异常。太神奇了！</p><h1 id="a3a4" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">结论</h1><p id="a36a" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">值对象非常强大。一方面，它使代码更容易维护，并有助于阅读它几乎像一个简单的英语文本。此外，这也使它更安全，因为您总是在值对象实例化上验证输入。我还可以推荐你阅读<a class="ae jr" href="https://www.amazon.com/Secure-Design-Daniel-Deogun/dp/1617294357" rel="noopener ugc nofollow" target="_blank">这本关于价值对象和领域原语的精彩书籍</a>。通过阅读这篇文章，我获得了写这篇文章的灵感。</p><p id="239d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有任何问题或建议，请在下面留下您的评论。感谢阅读！</p><h1 id="aefb" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">资源</h1><ol class=""><li id="f96b" class="jd je hi ih b ii lc im ld iq mc iu md iy me jc ji jj jk jl bi translated"><a class="ae jr" href="https://github.com/SimonHarmonicMinor/spring-boot-value-objects-example" rel="noopener ugc nofollow" target="_blank">带有代码示例的知识库</a></li><li id="dca8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://martinfowler.com/bliki/ValueObject.html" rel="noopener ugc nofollow" target="_blank">值对象定义</a></li><li id="1ba9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lo lp lq lr b"><a class="ae jr" href="https://projectlombok.org/features/Value" rel="noopener ugc nofollow" target="_blank">@Value</a></code> <a class="ae jr" href="https://projectlombok.org/features/Value" rel="noopener ugc nofollow" target="_blank">龙目标注</a></li><li id="a49a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://github.com/google/libphonenumber" rel="noopener ugc nofollow" target="_blank">谷歌Libphonenumber库</a></li><li id="7030" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://www.baeldung.com/jpa-attribute-converters" rel="noopener ugc nofollow" target="_blank"> JPA属性转换器</a></li><li id="e24e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://thorben-janssen.com/jpql/" rel="noopener ugc nofollow" target="_blank"> JPQL </a></li><li id="6909" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://www.w3schools.com/sql/sql_foreignkey.asp" rel="noopener ugc nofollow" target="_blank">数据库外键定义</a></li><li id="f2a4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://github.com/vladmihalcea/hibernate-types/issues/522" rel="noopener ugc nofollow" target="_blank">我提议在Hibernate types项目中实现类型化序列id</a></li><li id="7dfd" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://www.baeldung.com/jackson" rel="noopener ugc nofollow" target="_blank">杰克森库</a></li><li id="f0a8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://www.amazon.com/Secure-Design-Daniel-Deogun/dp/1617294357" rel="noopener ugc nofollow" target="_blank">由设计书保护</a></li><li id="7932" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://github.com/f4b6a3/tsid-creator" rel="noopener ugc nofollow" target="_blank"> TSID图书馆</a></li></ol></div></div>    
</body>
</html>