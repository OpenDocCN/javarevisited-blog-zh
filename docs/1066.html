<html>
<head>
<title>Bootstrapping a Quarkus App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启动Quarkus应用程序</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/bootstrapping-a-quarkus-app-a87dbec0b7e5?source=collection_archive---------1-----------------------#2021-03-14">https://medium.com/javarevisited/bootstrapping-a-quarkus-app-a87dbec0b7e5?source=collection_archive---------1-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/90c9a78d9a8b2120bdbfbb02cf3a76e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMMmnOAY9rIRpuQ9dZJ3pw.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">Quarkus:超音速亚原子Java</p></figure><h2 id="4e13" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">概观</h2><p id="b912" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">微服务现在是每个软件开发工作区的常用术语。让我提醒您，微服务的最简单定义是:</p><blockquote class="kn ko kp"><p id="7dfa" class="js jt kq ju b jv kr jx jy jz ks kb kc kt ku ke kf kv kw kh ki kx ky kk kl km hb bi translated">微服务是一种将大型软件项目分解为松散耦合的模块的方式，这些模块通过简单的应用编程接口(API)相互通信。</p></blockquote><p id="fa73" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">Java生态系统始终是技术如何以新的方式和框架重塑自身的一个令人惊叹的例子。例如，思考一下<a class="ae kz" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>如何带来Java社区特性，使这种语言成为世界上大多数新项目中最广泛使用的语言，是很有趣的。</p><p id="76c3" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">但是现在，我们有如此多的创新项目，它们都是为了在云上运行并采用微服务架构而全新设计的。</p><p id="d4d6" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated"><a class="ae kz" rel="noopener" href="/javarevisited/10-books-java-developers-should-read-in-2020-e6222f25cc72"> Java </a>被证明是一项拥有活跃社区的神奇技术，但在许多项目中已经失去了阵地，在这些项目中<a class="ae kz" rel="noopener" href="/javarevisited/top-10-courses-to-learn-python-for-web-development-in-2020-best-of-lot-efe11fb6d212"> Python </a>或<a class="ae kz" rel="noopener" href="/javarevisited/7-free-courses-to-learn-node-js-in-2020-2f1dd6722b49"> NodeJS </a>由于其更低的CPU、启动时间和内存消耗，使得云成本更低。</p><p id="9ee4" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">想着让Java在云原生应用中变得相关和强大，于是推出了<a class="ae kz" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj"> Quarkus </strong> </a>项目。</p><h2 id="c6f6" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">夸库斯</h2><p id="8df3" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated"><a class="ae kz" rel="noopener" href="/javarevisited/10-best-free-dropwizard-vert-x-micronaut-and-quarkus-online-courses-for-java-developers-9c2b4161f17"> Quarkus </a>是一个Red Hat计划，它以云原生、容器优先、微服务就绪框架为特色，用于编写基于您今天已经在使用的标准和框架的Java应用程序(<a class="ae kz" rel="noopener" href="/javarevisited/top-5-hibernate-online-training-courses-for-beginners-and-advance-java-programmers-469460596b2b"> Hibernate </a>、RESTEasy、Camel、Vert)。x等)。</p><p id="87e6" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">这是什么意思？</p><ul class=""><li id="a9a2" class="la lb hi ju b jv kr jz ks jf lc jj ld jn le km lf lg lh li bi translated"><strong class="ju hj">容器优先</strong>:最小占用空间的Java应用程序，最适合在容器中运行。</li><li id="1509" class="la lb hi ju b jv lj jz lk jf ll jj lm jn ln km lf lg lh li bi translated"><strong class="ju hj">原生云</strong>:在Kubernetes这样的环境中采用12要素架构。</li><li id="2de0" class="la lb hi ju b jv lj jz lk jf ll jj lm jn ln km lf lg lh li bi translated"><strong class="ju hj">微服务第一</strong>:为Java应用带来闪电般的启动时间和代码周转。</li></ul><p id="0be0" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">我想现在我们对为什么要用夸库进行实验有了一个大概的了解。在这篇博客中，我们将创建一个简单的quarkus应用程序，并使用<a class="ae kz" rel="noopener" href="/javarevisited/6-best-maven-courses-for-beginners-in-2020-23ea3cba89"> maven工具</a>运行它。</p><h2 id="83e5" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">1.我们的第一个应用</h2><p id="0eb9" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">构建Quarkus Java应用程序的要求:</p><ul class=""><li id="5dd0" class="la lb hi ju b jv kr jz ks jf lc jj ld jn le km lf lg lh li bi translated">JDK 8或11+安装有适当配置的<code class="du lo lp lq lr b">JAVA_HOME</code></li><li id="89ac" class="la lb hi ju b jv lj jz lk jf ll jj lm jn ln km lf lg lh li bi translated">Apache Maven 3.6.2以上</li><li id="6252" class="la lb hi ju b jv lj jz lk jf ll jj lm jn ln km lf lg lh li bi translated">GraalVM(如果需要本地应用)</li></ul><p id="b09d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">Quarkus应用程序可以使用<a class="ae kz" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-maven-jenkins-and-docker-for-java-developers-51fa7a1e66f6"> Maven </a>或<a class="ae kz" rel="noopener" href="/javarevisited/5-best-gradle-courses-and-books-to-learn-in-2021-93f49ce8ff8e"> Gradle </a>插件快速启动。该插件将生成一个最小的项目结构，配置文件中包含一个样本REST端点和Quarkus的Maven依赖项。</p><p id="bcc7" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">如果您喜欢交互式图形用户界面，您可以导航到<a class="ae kz" href="https://code.quarkus.io/" rel="noopener ugc nofollow" target="_blank"> code.quarkus.io </a>下载一个符合您特定需求的引导项目。</p><p id="4375" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">假设您已经安装了maven，在终端上运行下面的命令:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="bc19" class="iu iv hi lr b fi ma mb l mc md">mvn io.quarkus:quarkus-maven-plugin:<!-- -->1.12.2.Final<!-- -->:create \<br/>    -DprojectGroupId=com.praveen.samples.quarkus \<br/>    -DprojectArtifactId=sample-quarkus-app \<br/>    -DclassName="com.praveen.samples.quarkus.HelloResource" \<br/>    -Dpath="helloworld"</span></pre><p id="5bad" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">这将生成项目框架，一个暴露了<em class="kq"> /helloworld </em>端点的<em class="kq"> HelloResource </em>，配置，Maven项目和docker文件。</p><p id="1045" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">一旦导入到IDE中，我们将得到一个类似于下图所示的结构:</p><figure class="ls lt lu lv fd ij er es paragraph-image"><a href="https://www.java67.com/2018/02/5-free-docker-courses-for-java-and-DevOps-engineers.html"><div class="er es me"><img src="../Images/8ed1798eab4b0bcc548d1bac9a7cb59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QrjD5XwvUH6YnNz9BDj5g.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">项目树结构</p></figure><p id="5721" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">一旦导入成功，检查我们的资源文件<code class="du lo lp lq lr b">HelloResource</code>的内容:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="adee" class="iu iv hi lr b fi ma mb l mc md">@Path("/helloworld")<br/>public class HelloResource {<br/><br/>    @GET<br/>    @Produces(MediaType.<em class="kq">TEXT_PLAIN</em>)<br/>    public String hello() {<br/>        return "Hello RESTEasy";<br/>    }<br/>}</span></pre><p id="7ccb" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">目前看来不错。现在我们有了一个简单的qurakus应用程序，带有一个RESTEasy JAX-RS端点。您可以在根目录中找到关于生成的自述文件的更多详细信息。让我们打开一个终端并运行以下命令来测试它:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="3070" class="iu iv hi lr b fi ma mb l mc md">mvn compile quarkus:dev</span></pre><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/9ef55ba01deaca2a009ae274a233a08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhcptTh9_Mdv8wBgZ9CQEQ.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">启动控制台日志。</p></figure><p id="27bc" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">我们的REST端点应该在<a class="ae kz" href="http://localhost:8080/q/dev/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/hello world</a>公开。你可以用浏览器点击网址或者<a class="ae kz" href="https://javarevisited.blogspot.com/2017/03/10-examples-of-curl-command-in-unix-and-Linux.html" rel="noopener ugc nofollow" target="_blank"> <em class="kq">卷曲</em>命令</a>，&amp;你会看到:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="4fea" class="iu iv hi lr b fi ma mb l mc md">Hello RESTEasy</span></pre><p id="a760" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">你会看到Quarkus现在附带了一个开发用户界面，它只在<a class="ae kz" href="http://localhost:8080/q/dev/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/q/Dev/</a>的开发模式下可用。它允许您快速可视化当前加载的所有扩展，查看它们的状态并直接进入它们的文档。更多详情请访问<a class="ae kz" href="https://quarkus.io/guides/dev-ui" rel="noopener ugc nofollow" target="_blank">开发界面</a>。</p><h2 id="4625" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">2.依赖注入</h2><p id="d1b1" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated"><a class="ae kz" href="https://javarevisited.blogspot.com/2020/09/top-5-courses-to-learn-dropwizard-Micronaut-Quarkus-Java-Microservices.html" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>在开发模式下运行时提供热重装能力(<em class="kq"> mvn编译quarkus:dev </em>)。我们不需要重新启动或明确保存更改。让我们创建一个服务并注入到我们的示例应用程序中，看看热重载和DI是如何工作的。</p><p id="8b5c" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">首先，我们将创建一个<em class="kq"> HelloService </em>类:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="e96b" class="iu iv hi lr b fi ma mb l mc md">@ApplicationScoped <br/>public class HelloService{<br/>     <br/>  public String sayHello(String name){         <br/>      return "Hello " + name;     <br/>  } <br/>}</span></pre><p id="7f25" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">现在，我们将修改<em class="kq"> HelloResource </em>类，注入<em class="kq"> HelloService </em>并添加一个新方法:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="b2d9" class="iu iv hi lr b fi ma mb l mc md">@Inject <br/>HelloService helloService;  </span><span id="0382" class="iu iv hi lr b fi mg mb l mc md">@GET <br/>@Produces(MediaType.APPLICATION_JSON) <br/>@Path("/hello/{name}") <br/>public String greet(@PathParam("name") String name) {     <br/>    return helloService.sayHello(name); <br/>}</span></pre><p id="679e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">接下来，让我们测试我们的新端点:<a class="ae kz" href="http://localhost:8080/helloworld/hello/praveen" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/hello world/hello/jasmine</a></p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="5a4b" class="iu iv hi lr b fi ma mb l mc md">Hello jasmine</span></pre><p id="185b" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">我们将再做一个更改，以证明同样的情况也可以应用到属性文件。让我们编辑<em class="kq"> application.properties </em>文件，并再添加一个键:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="6799" class="iu iv hi lr b fi ma mb l mc md">greet-message=Good day</span></pre><p id="67e2" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">之后，我们将修改<em class="kq"> HelloService </em>来使用我们的新属性:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="0b30" class="iu iv hi lr b fi ma mb l mc md">@ConfigProperty(name = "greet-<!-- -->message<!-- -->") <br/>private String greetMessage;</span><span id="2889" class="iu iv hi lr b fi mg mb l mc md">public String sayHello(String name) {     <br/>    return greetMessage + " " + name; <br/>}</span></pre><p id="d002" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">如果我们再次点击相同的url，我们现在应该会看到:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="abcd" class="iu iv hi lr b fi ma mb l mc md">Good day jasmine</span></pre><h2 id="cec3" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">3.包装应用</h2><p id="b822" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">现在我们已经尝试了一些特性，是时候使用<a class="ae kz" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686"> JVM </a>打包应用程序了。您可以运行下面的命令来打包应用程序。</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="9c1c" class="iu iv hi lr b fi ma mb l mc md">mvn package</span></pre><p id="bcd9" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">这将在<em class="kq">目标</em>目录中生成2个jar文件:</p><ul class=""><li id="ad6e" class="la lb hi ju b jv kr jz ks jf lc jj ld jn le km lf lg lh li bi translated"><em class="kq">/quar kus-app/quar kus-run . jar</em>—一个可执行的jar，其依赖项被复制到<em class="kq"> target/lib。</em></li><li id="17f3" class="la lb hi ju b jv lj jz lk jf ll jj lm jn ln km lf lg lh li bi translated"><em class="kq">/sample-quar kus-app-1.0-snapshot . jar</em>—包含类和资源文件。</li></ul><p id="4dc6" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">运行打包的应用程序:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="c0e5" class="iu iv hi lr b fi ma mb l mc md">java -jar target/quarkus-app/quarkus-run.jar</span></pre><p id="06f0" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">Wohoo！！我们刚刚在JVM模式下启动了一个Quarkus应用程序。</p><h2 id="c768" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">4.GraalVM和本机应用程序</h2><p id="5c8d" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">接下来，我们将生成应用程序的本机映像。本机映像将缩短启动时间和首次响应时间。换句话说，它包含了运行所需的一切，包括运行应用程序所需的最小JVM。</p><blockquote class="kn ko kp"><p id="0190" class="js jt kq ju b jv kr jx jy jz ks kb kc kt ku ke kf kv kw kh ki kx ky kk kl km hb bi translated">正在安装GraalVM</p></blockquote><p id="da88" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">首先，我们需要安装<a class="ae kz" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank"> GraalVM </a>，这是一个高性能、可嵌入、多语言的虚拟机，用于运行用<a class="ae kz" rel="noopener" href="/javarevisited/top-10-javascript-courses-from-pluralsight-to-learn-in-2021-26352abe4fcd"> JavaScript </a>、<a class="ae kz" rel="noopener" href="/javarevisited/10-best-python-certification-courses-from-coursera-4576890eb6b3"> Python </a>、<a class="ae kz" rel="noopener" href="/javarevisited/10-best-ruby-on-rails-courses-for-beginners-dca4d66e9f7b"> Ruby </a>、<a class="ae kz" rel="noopener" href="/javarevisited/10-best-r-programming-courses-for-data-science-and-statistics-8f84ebec4974"> R </a>、基于JVM的语言如<a class="ae kz" rel="noopener" href="/javarevisited/10-best-places-to-learn-java-online-for-free-ce5e713ab5b2"> Java </a>、<a class="ae kz" rel="noopener" href="/javarevisited/10-best-scala-and-functional-programming-online-courses-for-beginners-b6461b27bf"> Scala </a>、<a class="ae kz" rel="noopener" href="/javarevisited/top-5-courses-to-learn-kotlin-in-2020-dfc3fa7706d8"> Kotlin </a>和基于LLVM的语言如<a class="ae kz" rel="noopener" href="/javarevisited/10-best-c-programming-courses-for-beginners-2c2c1f6bcb12"> C编写的应用程序</a></p><p id="28e4" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">GraalVM版本可在https://github.com/graalvm/graalvm-ce-builds/releases<a class="ae kz" href="https://github.com/graalvm/graalvm-ce-builds/releases" rel="noopener ugc nofollow" target="_blank">获得</a></p><p id="8de8" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">对于Quarkus版本<strong class="ju hj"> 1.12.2.Final </strong>，建议安装带有<strong class="ju hj"> JDK 11 </strong>支架的<strong class="ju hj">GraalVM 21</strong>(<strong class="ju hj">GraalVM-ce-Java 11–21 . 0 . 0)</strong>。</p><p id="e20e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">下载<strong class="ju hj"> GraalVM </strong>并解压到你喜欢的文件夹中。在GraalVM包中，您会发现:</p><ul class=""><li id="d49f" class="la lb hi ju b jv kr jz ks jf lc jj ld jn le km lf lg lh li bi translated">一个JVM</li><li id="b6f2" class="la lb hi ju b jv lj jz lk jf ll jj lm jn ln km lf lg lh li bi translated">JavaScript引擎&amp; node.js运行时</li><li id="14e4" class="la lb hi ju b jv lj jz lk jf ll jj lm jn ln km lf lg lh li bi translated">LLVM引擎</li></ul><p id="caed" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">现在导出<strong class="ju hj"> GRAALVM_HOME </strong>，其中包含GRAALVM的安装路径:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="1fdd" class="iu iv hi lr b fi ma mb l mc md">export GRAALVM_HOME=/path/to/graal</span></pre><p id="0ce5" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">接下来，我们需要<strong class="ju hj">本机映像</strong>工具，它允许您提前将Java代码编译成独立的可执行文件。您可以按如下方式安装本机映像工具:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="82d7" class="iu iv hi lr b fi ma mb l mc md">${GRAALVM_HOME}/bin/gu install native-image</span></pre><p id="486e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">有关GraalVM安装的更多详细信息，请访问<a class="ae kz" href="https://www.graalvm.org/docs/getting-started/#install-graalvm" rel="noopener ugc nofollow" target="_blank"> install-graalvm </a>。</p><blockquote class="kn ko kp"><p id="9c60" class="js jt kq ju b jv kr jx jy jz ks kb kc kt ku ke kf kv kw kh ki kx ky kk kl km hb bi translated">构建本机可执行文件</p></blockquote><p id="6d62" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">现在我们已经配置了graalvm，我们可以对我们的应用程序进行本地打包了。我们已经在pom.xml中定义了<code class="du lo lp lq lr b">native</code>概要文件。我们现在将停止应用程序(Ctrl + C ),如果还没有停止的话，并运行命令:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="562f" class="iu iv hi lr b fi ma mb l mc md">mvn package -Pnative</span></pre><p id="23ec" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">这可能需要几秒钟才能完成。因为本机映像试图(提前)创建所有代码AOT以加快启动速度，所以我们的构建时间会稍长一些。</p><p id="66fd" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">运行下面的命令来验证我们的本机工件是否被正确构造。</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="9239" class="iu iv hi lr b fi ma mb l mc md">mvn verify -Pnative</span></pre><p id="73fd" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">如果结果是成功的，那么你的工件就是好的。在package and verify命令之后，您会在目标文件夹中看到一个本机可执行运行程序文件。要直接运行本地可执行文件，只需在终端中执行以下命令。</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="e524" class="iu iv hi lr b fi ma mb l mc md">./sample-quarkus-app-1.0.0-SNAPSHOT-runner</span></pre><figure class="ls lt lu lv fd ij er es paragraph-image"><a href="https://medium.com/javarevisited/top-10-courses-to-learn-linux-command-line-in-2020-best-and-free-f3ee4a78d0c0?source=collection_home---4------0-----------------------"><div class="er es mh"><img src="../Images/e42db142c1f675223f9ee3ba8a4be129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l204vFvOHlJL5mgTNsNn7g.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">本机应用已启动。</p></figure><p id="fcf0" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">答对了。！我们的Quarkus原生应用刚刚开始。现在看看之前的JVM应用启动时间和原生应用启动时间的区别。</p><p id="1234" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated"><strong class="ju hj"> JVM模式启动</strong>:1.219秒</p><p id="0fe2" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated"><strong class="ju hj">本机模式启动</strong>:0.015秒</p><p id="62f2" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated"><strong class="ju hj"> ~98% </strong>启动时间缩短。这难道不令人印象深刻吗！！！</p><h2 id="6b59" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">5.码头工人建造</h2><p id="dceb" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">现在我们已经准备好了我们的本机工件，我们将使用我们的本机工件创建一个图像。为此，我们必须在我们的机器上运行一个容器运行时(即<a class="ae kz" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker </a>)。</p><p id="1d8c" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">为了构建Quarkus应用程序的本地容器映像，首先使用本地概要文件和容器构建来构建应用程序，如下所示:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="3dee" class="iu iv hi lr b fi ma mb l mc md">mvn package -Pnative -Dquarkus.native.container-build=true</span></pre></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="8c0d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">以上命令需要一些时间才能完成...</p><p id="2cd7" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">现在，如果你看到当我们创建项目时，它为我们创建了一个docker文件<em class="kq"> Dockerfile.native，</em>这是运行应用程序的最低要求。如果你想改变基本操作系统，你可以根据需要修改<a class="ae kz" rel="noopener" href="/javarevisited/top-5-free-courses-to-learn-docker-for-beginners-best-of-lot-b2b1ad2b98ad?source=collection_home---4------2-----------------------"> docker文件</a>。</p><blockquote class="kn ko kp"><p id="6c8a" class="js jt kq ju b jv kr jx jy jz ks kb kc kt ku ke kf kv kw kh ki kx ky kk kl km hb bi translated">提供的<code class="du lo lp lq lr b">Dockerfiles</code>使用<a class="ae kz" href="https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi" rel="noopener ugc nofollow" target="_blank"> UBI </a>(通用基础映像)作为父映像。这个基本图像已经被裁剪为在容器中完美地工作。<code class="du lo lp lq lr b">Dockerfiles</code>使用基础图像的<a class="ae kz" href="https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal" rel="noopener ugc nofollow" target="_blank"> <em class="hi">最小</em>版本</a>来缩小生成图像的尺寸。欲了解更多详情，请点击这里。</p></blockquote><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="2964" class="iu iv hi lr b fi ma mb l mc md">FROM registry.access.redhat.com/ubi8/ubi-minimal:8.3<br/>WORKDIR /work/<br/>RUN chown 1001 /work \<br/>    &amp;&amp; chmod "g+rwX" /work \<br/>    &amp;&amp; chown 1001:root /work<br/>COPY --chown=1001:root target/*-runner /work/application<br/><br/>EXPOSE 8080<br/>USER 1001<br/><br/>CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]</span></pre><p id="aee6" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">现在运行下面的cmd来构建docker映像:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="8fb3" class="iu iv hi lr b fi ma mb l mc md">docker build -f src/main/docker/Dockerfile.native -t quarkus/sample-quarkus-app .</span></pre><p id="01da" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">这会产生图像。运行<em class="kq"> docker图像</em>进行确认。现在使用下面的代码运行容器:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="03dc" class="iu iv hi lr b fi ma mb l mc md">docker run -i --rm -p 8080:8080 quarkus/sample-quarkus-app</span></pre><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/e1157d05daf6a9693b33809b749f1aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipfCmLn3AhySG6_AQx01hQ.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">码头运行</p></figure><p id="8478" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">容器在<strong class="ju hj">0.041秒</strong>的极低时间启动。</p><p id="53b6" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">现在我们知道这是夸库的优势之一。现在我们的图像可以被运送到任何地方<a class="ae kz" rel="noopener" href="/javarevisited/6-best-openshift-courses-for-beginners-and-experienced-developers-d124edd2baff"> Openshift </a>，<a class="ae kz" rel="noopener" href="/javarevisited/10-best-kubernetes-courses-for-developers-and-devops-engineers-94c35cd3a2fd"> Kubernetes </a>等等。</p><p id="d439" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">最后，我们可以测试我们的REST端点来验证我们的应用程序。点击<a class="ae kz" href="http://localhost:8080/helloworld/hello/praveen" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/hello world/hello/jasmine</a></p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="2511" class="iu iv hi lr b fi ma mb l mc md">Good day jasmine</span></pre><h2 id="ea15" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">摘要</h2><p id="0c38" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">在这篇博客中，我们已经看到Quarkus是一个很好的补充，它可以更有效地将Java带到云中，最重要的是，我们不需要学习任何新东西，毕竟它都是Java！！Quarkus每天都有很多新功能加入，所以你可以在Quarkus GitHub库<a class="ae kz" href="https://github.com/quarkusio/quarkus-quickstarts" rel="noopener ugc nofollow" target="_blank">上尝试并关注它们。</a></p><p id="2a5e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">我已经在这里分享了上面我们尝试过的<a class="ae kz" href="https://github.com/PraveenGNair/sample-quarkus-app" rel="noopener ugc nofollow" target="_blank">示例应用程序的代码。快乐学习！！</a></p><p id="cb22" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated">参考资料:</p><p id="8388" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated"><a class="ae kz" href="https://quarkus.io/guides/" rel="noopener ugc nofollow" target="_blank">https://quarkus.io/guides/</a></p><p id="1a49" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km hb bi translated"><a class="ae kz" href="https://www.graalvm.org/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">https://www.graalvm.org/docs/getting-started/</a></p></div></div>    
</body>
</html>