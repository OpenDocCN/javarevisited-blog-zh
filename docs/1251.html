<html>
<head>
<title>Role of Declaration Files in the Implementation of TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">声明文件在TypeScript实现中的作用</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/role-of-declaration-files-in-the-implementation-of-typescript-3a0108633c10?source=collection_archive---------4-----------------------#2021-05-20">https://medium.com/javarevisited/role-of-declaration-files-in-the-implementation-of-typescript-3a0108633c10?source=collection_archive---------4-----------------------#2021-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3b06" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在本文中，我们将研究如何增强JavaScript库并通过声明文件添加语法糖。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0793dfc098803bc09f26ef9f9d231472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gd7CqojdkuCTEpqSWjv7oQ.jpeg"/></div></div></figure><p id="af45" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> JavaScript </strong>开发最吸引人的一个方面是已经发布的、经过测试的、可供重用的大量外部JavaScript库。</p><blockquote class="kf kg kh"><p id="3ef6" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">本文摘自Nathan Rozentals所著的《掌握打字稿，第四版 》一书，该书是理解打字稿语言及其最新特性的综合指南。</p></blockquote><h1 id="e8c8" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">申报文件</h1><p id="80ae" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">声明文件是TypeScript编译器使用的一种特殊类型的文件。它只在编译阶段使用，作为一种参考文件来描述JavaScript。声明文件类似于<a class="ae km" rel="noopener" href="/javarevisited/10-best-c-programming-courses-for-beginners-2c2c1f6bcb12"> C </a>或者<a class="ae km" rel="noopener" href="/javarevisited/top-10-courses-to-learn-c-for-beginners-best-and-free-4afc262a544e"> C++ </a>中使用的头文件或者<a class="ae km" rel="noopener" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"> Java </a>中使用的接口。它们只是描述了可用函数和属性的结构，但没有提供实现。在本章的这一节，我们将看看这些声明文件，它们是什么，以及如何编写它们。</p><h1 id="9bf0" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">声明文件类型</h1><p id="faf3" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">我们知道，声明文件使用<em class="ki">声明</em>和<em class="ki">模块</em>关键字来定义对象和名称空间。我们还看到，为了定义变量的自定义类型，我们可以像在<a class="ae km" rel="noopener" href="/javarevisited/top-10-free-typescript-courses-to-learn-online-best-of-lot-44bce9da41d1"> TypeScript </a>中一样使用接口。声明文件允许我们使用与在TypeScript中相同的语法来描述类型。这些类型可以在普通TypeScript中使用类型的任何地方使用，包括函数重载、类型联合、类和可选属性。让我们快速地看一下这些技术，用几个简单的代码示例来进一步说明这个特性。本节将涵盖:</p><ul class=""><li id="10c7" class="lk ll hi jl b jm jn jp jq js lm jw ln ka lo ke lp lq lr ls bi translated">函数重载</li><li id="233a" class="lk ll hi jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls bi translated">嵌套命名空间</li><li id="261c" class="lk ll hi jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls bi translated">班级</li><li id="ae65" class="lk ll hi jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls bi translated">静态属性和函数</li><li id="509d" class="lk ll hi jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls bi translated">抽象类</li><li id="d544" class="lk ll hi jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls bi translated">无商标消费品</li><li id="9aa2" class="lk ll hi jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls bi translated">条件类型和推理</li></ul><p id="78d8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将从函数重载开始。</p><h1 id="3448" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">函数重载</h1><p id="0db7" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">声明文件允许函数重载，其中同一函数可以用不同的参数声明，如下所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="8528" class="md ko hi lz b fi me mf l mg mh">declare function trace(arg: string | number | boolean);<br/>declare function trace(arg: { id: number; name: string });</span></pre><p id="5ee9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们有一个名为trace的函数，它被声明了两次:一次是用一个名为arg的参数，类型为string、number或boolean，另一次是用同一个arg参数，这是一个自定义类型。该重载声明允许以下所有有效代码:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="27b6" class="md ko hi lz b fi me mf l mg mh">trace(“trace with string”);<br/>trace(true);<br/>trace(1);<br/>trace({ id: 1, name: “test” });</span></pre><p id="5f80" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们练习了函数覆盖所允许的各种参数组合。</p><h1 id="171c" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">嵌套命名空间</h1><p id="b055" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">声明文件允许嵌套模块名。这又转化为嵌套的名称空间，如下所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="65fe" class="md ko hi lz b fi me mf l mg mh">declare module FirstNamespace {<br/>   module SecondNamespace {<br/>      module ThirdNamespace {<br/>          function log(msg: string);<br/>      }<br/>   }<br/>}</span></pre><p id="2edd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们声明了一个名为<code class="du mi mj mk lz b">FirstNamespace</code>的模块，它公开了一个名为<code class="du mi mj mk lz b">SecondNamespace</code>的模块，后者又公开了第三个名为<code class="du mi mj mk lz b">ThirdNamespace</code>的模块。<code class="du mi mj mk lz b">ThirdNamespace</code>模块定义了一个名为log的函数。该声明将导致需要引用所有三个名称空间来调用日志函数，如下所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="858b" class="md ko hi lz b fi me mf l mg mh">FirstNamespace.SecondNamespace.ThirdNamespace.log(“test”);</span></pre><p id="3d25" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们显式引用每个命名空间，以便调用<code class="du mi mj mk lz b">ThirdNamespace</code>模块中的<code class="du mi mj mk lz b">log</code>函数。</p><h1 id="5092" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">班级</h1><p id="af69" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">类定义是在模块定义中使用Class关键字指定的，就像在普通的TypeScript文件中一样，如下所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="55d8" class="md ko hi lz b fi me mf l mg mh">declare class MyModuleClass {<br/>   public print(): void;<br/>}</span></pre><p id="d3c5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们声明了一个名为<code class="du mi mj mk lz b">MyModuleClass</code>的类，它有一个返回<code class="du mi mj mk lz b">void</code>的公共<code class="du mi mj mk lz b">print</code>函数。该类定义可以如下使用:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="54d9" class="md ko hi lz b fi me mf l mg mh">let myClass = new MyModuleClass();<br/>myClass.print();</span></pre><p id="ec4c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们正在创建一个已经在声明文件中声明的<code class="du mi mj mk lz b">MyModuleClass</code>类的实例。然后我们调用名为<code class="du mi mj mk lz b">myClass</code>的类实例的<code class="du mi mj mk lz b">print</code>函数。</p><p id="ef72" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在声明文件中声明一个类非常类似于为它定义一个接口。我们不提供函数的任何实现，我们只是向TypeScript编译器声明该类的存在以及它可以使用哪些属性和函数。</p><h1 id="97e1" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">静态属性和函数</h1><p id="fc34" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">与我们可以在<a class="ae km" rel="noopener" href="/javarevisited/7-best-courses-to-learn-typescript-in-depth-58439e1ce729">类型脚本</a>中将属性或函数标记为静态的方式相同，我们可以在声明文件中使用相同的语法，如下所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="59cc" class="md ko hi lz b fi me mf l mg mh">declare class MyModuleStatic {<br/>    static print(): void;<br/>    static id: number;<br/>}</span></pre><p id="ef65" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们声明了一个名为<code class="du mi mj mk lz b">MyModuleStatic</code>的类，它有一个静态<code class="du mi mj mk lz b">print</code>函数和一个静态<code class="du mi mj mk lz b">id</code>属性。我们可以如下使用这些静态属性和函数:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="674f" class="md ko hi lz b fi me mf l mg mh">MyModuleStatic.id = 10;<br/>MyModuleStatic.print();</span></pre><p id="2a99" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们可以看到静态函数或属性的声明遵循相同的使用规则，就好像我们已经在<a class="ae km" href="https://javarevisited.blogspot.com/2018/07/top-5-courses-to-learn-typescript.html#axzz5QyVwWVg3" rel="noopener ugc nofollow" target="_blank">类型脚本</a>中定义了它一样。</p><h1 id="77d6" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">抽象类</h1><p id="4c32" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">声明文件可以定义<a class="ae km" href="https://javarevisited.blogspot.com/2013/05/difference-between-abstract-class-vs-interface-java-when-prefer-over-design-oops.html" rel="noopener ugc nofollow" target="_blank">抽象类</a>和函数如下:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="e8ef" class="md ko hi lz b fi me mf l mg mh">declare abstract class MyModuleAbstract {<br/>    abstract print(): void<br/>}</span></pre><p id="3d53" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们定义了一个名为<code class="du mi mj mk lz b">MyModuleAbstract</code>的抽象类，它有一个名为<code class="du mi mj mk lz b">print</code>的函数，这个函数也被标记为抽象的。我们可以在TypeScript文件中使用这个抽象类声明，如下所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="062d" class="md ko hi lz b fi me mf l mg mh">class DerivedFromAbstract extends MyModuleAbstract {<br/>    print() { }<br/>}</span></pre><p id="2c4e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们定义了一个名为<code class="du mi mj mk lz b">DerivedFromAbstract</code>的类，它扩展了声明文件中的<code class="du mi mj mk lz b">MyModuleAbstract</code>类。</p><blockquote class="kf kg kh"><p id="f00d" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">注意，我们还需要在这个类定义中提供一个<code class="du mi mj mk lz b">print</code>函数的实现，因为print函数在类声明中被标记为抽象函数。</p></blockquote><h1 id="be2b" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">无商标消费品</h1><p id="4efd" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">声明文件允许使用通用语法，如下所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="4313" class="md ko hi lz b fi me mf l mg mh">declare function sort&lt;T extends number | string&gt;<br/>    (input: Array&lt;T&gt;): Array&lt;T&gt; { }</span></pre><p id="7b9a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们声明了一个名为<code class="du mi mj mk lz b">sort</code>的函数，它使用通用语法将<code class="du mi mj mk lz b">T</code>的类型指定为<code class="du mi mj mk lz b">number</code>或<code class="du mi mj mk lz b">string</code>，或者两者都是。这个<code class="du mi mj mk lz b">sort</code>函数有一个名为<code class="du mi mj mk lz b">input</code>的参数，它是一个类型为<code class="du mi mj mk lz b">T</code>的数组，并返回一个类型为<code class="du mi mj mk lz b">T</code>的数组。该声明将允许以下用法:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="16a0" class="md ko hi lz b fi me mf l mg mh">let sortedStringArray = sort([“first”, “second”]);<br/>let sortedNumericArray = sort([1, 2, 3]);</span></pre><p id="5473" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们定义了一个名为<code class="du mi mj mk lz b">sortedStringArray</code>的变量来保存对排序函数的调用的返回值，在这里我们将一个字符串数组作为唯一的参数传入。<code class="du mi mj mk lz b">sortedStringArray</code>变量的类型将是<code class="du mi mj mk lz b">Array&lt;string&gt;</code>。接下来，我们定义一个名为<code class="du mi mj mk lz b">sortedNumericArray</code>的变量来保存对sort函数的另一个调用的返回值，在这里我们传递一个数字数组作为唯一的参数。<code class="du mi mj mk lz b">sortedNumericArray</code>变量将属于<code class="du mi mj mk lz b">Array&lt;number&gt;</code>类型。</p><h1 id="c568" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">条件类型</h1><p id="dfb7" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">声明文件还可以定义条件类型和分布式条件类型，如下所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="0721" class="md ko hi lz b fi me mf l mg mh">declare type stringOrNumberOrBoolean&lt;T&gt; =<br/>    T extends string ? string :<br/>    T extends number ? number :<br/>    T extends boolean ? boolean : never;</span></pre><p id="768c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们声明了一个名为<code class="du mi mj mk lz b">stringOrNumberOrBoolean</code>的类型，它使用通用语法定义了一个类型<code class="du mi mj mk lz b">T</code>。如果<code class="du mi mj mk lz b">T</code>扩展了<code class="du mi mj mk lz b">string</code>，那么类型将是<code class="du mi mj mk lz b">string</code>。如果<code class="du mi mj mk lz b">T</code>扩展了<code class="du mi mj mk lz b">number</code>，那么类型就是<code class="du mi mj mk lz b">number</code>。如果<code class="du mi mj mk lz b">T</code>的类型扩展了<code class="du mi mj mk lz b">boolean</code>，那么类型就是<code class="du mi mj mk lz b">boolean</code>。如果<code class="du mi mj mk lz b">T</code>没有扩展这些类型中的任何一个，那么类型将是never。</p><p id="c3a5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们现在可以使用这种分布式条件类型，如下所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="2849" class="md ko hi lz b fi me mf l mg mh">type myNever = stringOrNumberOrBoolean&lt;[string,number]&gt;;</span></pre><p id="91af" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们定义了一个名为<code class="du mi mj mk lz b">myNever</code>的类型，它是名为<code class="du mi mj mk lz b">stringOrNumberOrBoolean</code>的分布式条件类型的结果，并且定义了一个类型<code class="du mi mj mk lz b">T</code>作为<code class="du mi mj mk lz b">string</code>和<code class="du mi mj mk lz b">number</code>的元组。由于这个元组与我们正在检查的任何类型都不匹配，<code class="du mi mj mk lz b">myNever</code>变量的类型将是never。</p><h1 id="a4ce" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">条件类型推理</h1><p id="5824" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">声明文件允许条件类型推断，如以下示例所示:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="815b" class="md ko hi lz b fi me mf l mg mh">declare type inferFromPropertyType&lt;T&gt; =<br/>    T extends { id: infer U } ? U : never;</span></pre><p id="efb7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们有一个名为<code class="du mi mj mk lz b">inferFromPropertyType</code>的类型，它将从类型<code class="du mi mj mk lz b">T</code>的名为<code class="du mi mj mk lz b">id</code>的属性中推断出名为<code class="du mi mj mk lz b">U</code>的类型。如果<code class="du mi mj mk lz b">id</code>属性不存在，则类型为<code class="du mi mj mk lz b">never</code>。我们现在可以如下使用这种类型:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="8d94" class="md ko hi lz b fi me mf l mg mh">type myString = inferFromPropertyType&lt;{ id: string }&gt;;<br/>type myNumber = inferFromPropertyType&lt;{ id: number }&gt;;</span></pre><p id="1da7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里，我们定义了两个类型，名为<code class="du mi mj mk lz b">myString</code>和<code class="du mi mj mk lz b">myNumber</code>，它们使用了名为<code class="du mi mj mk lz b">inferFromPropertyType</code>的推断条件类型。由于<code class="du mi mj mk lz b">id</code>属性的类型是第一行中的<code class="du mi mj mk lz b">string</code>，那么<code class="du mi mj mk lz b">myString</code>将是类型<code class="du mi mj mk lz b">string</code>。第二行代码中的<code class="du mi mj mk lz b">id</code>属性的类型是<code class="du mi mj mk lz b">number</code>，因此<code class="du mi mj mk lz b">myNumber</code>将是<code class="du mi mj mk lz b">number</code>类型。</p><h1 id="7a53" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">申报文件摘要</h1><p id="98d5" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">我们在本文中看到的是，TypeScript提供的类型规则和类型技术都可以在声明文件中使用。声明文件的目的是提前告诉TypeScript编译器JavaScript库的结构是什么样子。我们已经看到，我们可以在声明文件中使用所有的TypeScript关键字和语言特性。</p><h1 id="fc28" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">关于作者</h1><p id="ce5d" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated"><strong class="jl hj"> Nathan Rozentals </strong>已经用<a class="ae km" rel="noopener" href="/javarevisited/9-free-c-programming-courses-for-beginners-2486dff74065"> C </a>、<a class="ae km" rel="noopener" href="/javarevisited/10-best-c-and-c-programming-books-for-beginners-and-experienced-programmers-eb5ee8dbdc5a"> C++ </a>、<a class="ae km" rel="noopener" href="/javarevisited/10-free-courses-to-learn-java-in-2019-22d1f33a3915"> Java </a>和<a class="ae km" rel="noopener" href="/javarevisited/9-free-c-c-sharp-courses-and-tutorials-for-beginners-and-intermediate-programmers-best-of-lot-dc8c793aab31?source=---------16------------------"> C# </a>编写商业软件超过30年。他在2012年10月首次发布TypeScript后的一周内就开始使用它，并意识到在编写JavaScript时TypeScript可以提供多大的帮助。</p><p id="c506" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Nathan的TypeScript解决方案现在控制物联网设备中的用户界面，作为销售点解决方案的独立应用程序运行，提供复杂的应用程序配置网站，并用于任务关键型服务器API。</p><blockquote class="kf kg kh"><p id="1fd6" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">本文摘自Nathan Rozentals所著的《掌握TypeScript，第四版 》一书，该书是理解TypeScript语言及其最新特性的综合指南。如果你喜欢这篇文章，那么你也会喜欢这本书。</p></blockquote></div></div>    
</body>
</html>