<html>
<head>
<title>My personal note for your next Java interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我对您下一次Java面试的个人意见</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/my-personal-note-for-your-next-java-interview-ecbf9b6e14d4?source=collection_archive---------1-----------------------#2020-07-09">https://medium.com/javarevisited/my-personal-note-for-your-next-java-interview-ecbf9b6e14d4?source=collection_archive---------1-----------------------#2020-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="44da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分享我的个人笔记，帮助你准备下一次Java面试。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/dfe0ba2d33f2dee3809acf7470043b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZOi7pGuIT4zMk7Zmvc2Kg.jpeg"/></div></div></figure><h1 id="9872" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍</h1><p id="7518" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我在和你分享我用来准备面试的个人笔记。Java面试并不容易，涉及的话题很多，可以问的问题也很多。我的方法很简单，包括问自己一些问题(面试官经常问的)，这些问题涵盖了基本概念和高级概念。</p><blockquote class="kt ku kv"><p id="f094" class="if ig kw ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated"><strong class="ih hj">免责声明:</strong>请把我的回答当作是对你<strong class="ih hj">已经</strong>知道的事情的<strong class="ih hj">记忆刷新</strong>。如果不是这样，请搜索特定主题的专用教程，并尝试自己多练习。</p></blockquote><h1 id="8703" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">创建Java程序</h1><h2 id="4cf4" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">如果我们将main方法设置为private会发生什么？</h2><p id="2755" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">代码将被编译，主私有函数将被视为普通的静态函数。但是，程序不会运行，因为缺少公共main函数。</p><h2 id="017c" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">如果我们用一个java文件执行这个命令会发生什么？</h2><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="bbe0" class="la jq hi lp b fi lt lu l lv lw">java HelloWorld.java</span></pre><p id="e45e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kw"> java </em>用于运行编译后的文件。然而，在这种情况下，它会在内存中编译给定的java类并立即运行它。</p><h1 id="851e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">决策和循环</h1><h2 id="9a8c" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">循环中的中断和继续有什么区别？</h2><p id="d363" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">一个'<em class="kw"> break </em>语句导致它所应用的语句终止<em class="kw"> (switch、for、do或while) </em>。</p><p id="4860" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">'<em class="kw"> continue </em>'语句用于结束当前循环迭代，并将控制返回给循环语句。</p><h2 id="b213" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">while {..}做和做{..}而？</h2><p id="d0c1" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">While循环执行零次或多次，因为它在给定条件为真时开始循环。然而，do-while循环至少执行一次，因为在执行循环体之后检查了条件。</p><h1 id="25e8" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用Java核心API</h1><h2 id="10cc" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">以下代码的结果是什么？你能解释一下吗？</h2><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="288b" class="la jq hi lp b fi lt lu l lv lw">String a = "Hello world";        <br/>String b = "Hello world";                <br/>System.out.println(a == b);</span></pre><p id="3e19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果会是真的。对于对象，运算符==用于比较引用。但是，对于这段代码，第一个字符串将存储在字符串池中。第二个字符串也将具有对从字符串池中拉回的对象的相同引用，以使<strong class="ih hj"> <em class="kw"> a </em> </strong>和<strong class="ih hj"> <em class="kw"> b </em> </strong>两个变量具有相同的引用。</p><h2 id="19ae" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">什么是自动装箱？</h2><p id="43fc" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">自动装箱是Java编译器在基本类型和它们对应的对象包装类之间进行的自动转换。比如将一个'<em class="kw"> int </em>转换成一个'<em class="kw"> Integer </em>'，一个'<em class="kw"> float </em>'转换成一个'<em class="kw"> Float </em>'，等等。如果转换以另一种方式进行，这称为取消装箱。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="04fc" class="la jq hi lp b fi lt lu l lv lw">Float f1 = new Float(6.f); // Boxing<br/>float f2 = (float)f;       // Unboxing<br/>Float f3 = 6.f;            // AutoBoxing</span></pre><h2 id="1142" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">自动装箱的目的是什么？</h2><p id="cbfa" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">它允许我们在原语和对象类型之间轻松切换，而不需要强制转换或包装。此外，它允许我们使用泛型类型，因为java中的泛型不支持基本类型。</p><h2 id="00fd" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">StringBuilder/StringBuffer有什么区别？</h2><p id="b4be" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">StringBuffer是线程安全和同步的，而StringBuilder不是。这解释了为什么StringBuilder比StringBuffer快。</p><h2 id="274d" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">描述一下JAVA流API？</h2><p id="f3cf" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">流API用于处理对象集合。流是支持各种方法的对象序列，这些方法可以被流水线化以产生期望的结果，并且它支持并行执行。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="8cdb" class="la jq hi lp b fi lt lu l lv lw">List&lt;String&gt; greetings =<br/>       Arrays.asList("Hello", "Hola", "Bonjour", "Hallo");<br/>        <br/>greetings<br/>    .stream()<br/>    .map(String::toUpperCase)<br/>    .sorted()<br/>    .forEach(System.out::println);<br/>// BONJOUR<br/>// HALLO<br/>// HELLO<br/>// HOLA</span></pre><h1 id="afaf" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">序列化</h1><h2 id="9893" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">序列化是什么意思？</h2><p id="e062" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">序列化是一种将对象状态转换为字节流的机制。</p><h2 id="9538" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">什么是SerialVersionUID？</h2><p id="0da7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">SerialVersionUID在反序列化过程中用于验证序列化对象的发送方和接收方是否兼容。</p><h2 id="86fc" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">什么是“瞬时”关键词？</h2><p id="1cfb" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">“transient”关键字用于标记属性，而不是序列化。</p><h1 id="a2d1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">理解方法和封装</h1><h2 id="6b2c" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">能否解释一下Java中的访问级别？</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lx"><img src="../Images/3c5701e8e53a5515ed8fd878a3fcbac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*6u9LHHawVY83Szjafuy0cA.png"/></div></figure><h2 id="ad82" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">封装的目的是什么？</h2><p id="7f64" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">数据封装的主要目的是对其他类隐藏类或方法的实现细节。此外，它可以帮助我们使用getters和setters为封装的属性设置验证规则。</p><h2 id="d488" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">方法重写和方法重载有什么区别？</h2><p id="0cbc" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">覆盖一个方法就是在子类中创建一个具有相同签名(名称和参数)的方法。覆盖也称为动态多态，因为它发生在运行时。</p><p id="6721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重载一个方法就是在一个类中声明两个或多个方法，它们具有相同的方法名但不同的参数。重载也称为静态多态，因为它发生在编译时。</p><h1 id="3e98" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">班级设计</h1><h2 id="a7a6" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">静态方法和实例方法有什么区别？</h2><p id="f3ca" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">静态方法属于类。它与整个类相关联，而不是与特定的实例相关联。每个对象将共享静态方法的一个公共副本。每个类只有一个副本，不管从它创建了多少个对象。但是，实例方法是与对象相关联的。它要求在使用之前创建一个实例对象。实例方法可以访问实例和静态(字段/方法)，而静态方法只能访问静态(字段/方法)。</p><h2 id="187f" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">当一个类实现两个具有相同默认方法名的接口时会发生什么？</h2><p id="b456" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">由于每个接口都有自己的默认实现，java编译器会要求为该方法设置一个新的实现。</p><h2 id="e478" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">为什么我们需要实现“hashcode”和“equals”方法？</h2><p id="e660" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">未被覆盖的'<em class="kw"> hashCode </em>()'和<em class="kw"> 'equals()' </em>会阻止对象在基于散列的集合中正常工作。“<em class="kw">等于</em>()”和“<em class="kw">哈希码</em>()”之间的契约为:</p><ol class=""><li id="b8a6" class="ly lz hi ih b ii ij im in iq ma iu mb iy mc jc md me mf mg bi translated">如果两个对象相等，那么它们必须有相同的哈希代码。</li><li id="abd1" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated">如果两个对象具有相同的哈希码，它们可能相等，也可能不相等。</li></ol><h1 id="0461" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">泛型和集合</h1><h2 id="7642" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">什么是泛型，我们为什么要使用它们？</h2><p id="bf5a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">泛型用于创建类、接口和方法，这些类、接口和方法具有它们所使用的类型的占位符。它支持通用解决方案的实现，这些解决方案可以在多种类型中重用，而无需强制转换。</p><h2 id="5eba" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">Vector/ArrayList的区别？</h2><p id="8b85" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Vector和ArrayList都是可调整大小的数组。主要区别是Vector的方法是同步的，而ArrayList的方法不是。</p><h2 id="25fd" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">HashMap内部是如何工作的？</h2><p id="2b36" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">HashMap包含一个内部数组(缺省情况下有16个元素),这个数组由称为Buckets的链表组成，用来存储节点。对于每个元素，hashmap将hashcode除以数组大小，并将其余部分作为桶中的位置，如果不存在，则将值添加到链表中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mm"><img src="../Images/85ffbc11d5fbcec207c446ee56e8fc9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*TUPGIPKnTCn4eicXZ-eu_w.png"/></div></figure><h1 id="386f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">处理异常</h1><h2 id="f0b4" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">解释JAVA中异常的类型？</h2><p id="faa5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在Java中，我们有两种类型的异常:</p><ol class=""><li id="777d" class="ly lz hi ih b ii ij im in iq ma iu mb iy mc jc md me mf mg bi translated"><strong class="ih hj">检查异常:</strong>是一个异常，必须由抛出它的应用程序代码声明或处理。它是“<em class="kw">异常</em>的子类。</li><li id="58f6" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><strong class="ih hj">未检查的异常:</strong>Is Exception是任何不需要被抛出的应用程序代码声明或处理的异常。它是'<em class="kw"> RuntimeException </em>'的子类。</li></ol><h1 id="b0ed" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">并发和多线程</h1><h2 id="8d8d" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">进程和线程的区别是什么？</h2><p id="d631" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><strong class="ih hj">进程</strong> <br/>一个进程，称为一个任务，由多个线程组成。每个进程由一个单独的线程启动，通常称为主线程，但是可以从它的任何线程创建额外的线程。</p><p id="7fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">线程</strong> <br/>线程是进程的子集，共享其地址空间。该线程可以使用“wait()”、“<em class="kw"> notify() </em>”和“<em class="kw"> notifyAll() </em>”方法轻松地与同一进程中的其他线程进行通信。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mn"><img src="../Images/8468c39399133223f390fccf4b69fbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*Jd0LECF6fRCKfgdNUzfvvg.png"/></div></figure><h2 id="e856" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">在java中运行一个线程的不同方法？</h2><ul class=""><li id="0ee8" class="ly lz hi ih b ii kn im ko iq mo iu mp iy mq jc mr me mf mg bi translated">从'<em class="kw"> Thread </em>'类继承并覆盖'<em class="kw"> run()' </em></li><li id="cf28" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mr me mf mg bi translated">实现'<em class="kw"> Runnable </em>接口</li></ul><h2 id="335a" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">什么是“同步”关键字？</h2><p id="a6db" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">它用于一次只允许一个线程进入特定的代码段，从而允许我们保护，例如，变量或数据不被不同线程的同时修改所破坏。</p><h2 id="9b27" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">同步的缺点是什么？</h2><p id="51f5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">同步关键字的主要缺点是增加了线程的等待时间，影响了系统的性能。如果没有具体要求，不建议使用它。</p><h2 id="ce64" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">线程run()和start()有什么区别？</h2><p id="71a8" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">如果你只是直接调用'<em class="kw"> run()' </em>，它会在调用线程上执行，就像任何其他方法调用一样。需要Thread.start()' 来实际创建一个新线程，以便并行执行runnable的run方法。</p><h2 id="dbe5" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">解释线程生命周期？</h2><ol class=""><li id="6a28" class="ly lz hi ih b ii kn im ko iq mo iu mp iy mq jc md me mf mg bi translated"><strong class="ih hj"> New: </strong> New是已创建但尚未启动的线程的线程状态。</li><li id="1e5a" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><strong class="ih hj"> Runnable: </strong>线程当前正在执行。</li><li id="c7bf" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><strong class="ih hj">阻塞:</strong>线程正在等待监控锁处于这种状态。</li><li id="53fe" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><strong class="ih hj"> TimedWaiting: </strong>线程正在等待指定的时间。</li><li id="1eac" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><strong class="ih hj">等待:</strong>线程正在等待未指定的时间。</li><li id="18dd" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><strong class="ih hj">终止:</strong>线程执行完<em class="kw"> 'run()' </em>方法后，转入终止状态。</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ms"><img src="../Images/c24c7bd1f8102deb9a27b5bf509f0f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CzGYuSBSzx33Df7f9TmFAQ.png"/></div></div></figure><h1 id="c2b6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">垃圾收集工</h1><h2 id="da4e" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated"><strong class="ak">什么是垃圾收集器？</strong></h2><p id="9670" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Java垃圾收集是Java程序执行自动内存管理的过程。垃圾收集是一个自动的过程。它实现了分代垃圾收集策略，根据年龄对对象进行分类。</p><h2 id="e5de" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">JVM内存中有哪些不同的代？</h2><p id="7176" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">有三代人:</p><ol class=""><li id="cf03" class="ly lz hi ih b ii ij im in iq ma iu mb iy mc jc md me mf mg bi translated">年轻(伊甸园，幸存者1和幸存者2)一代:新创建的对象。它们是在次要收集事件中收集的。</li><li id="c4de" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated">老一代:年轻一代遗留下来的对象。它们是大型收藏活动中的收藏品。</li><li id="0b41" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated">Perm代(针对java老版本)。从Java 8开始，它被元空间所取代:当元空间达到最大值时，对象被清理。</li></ol><h2 id="5913" class="la jq hi bd jr lb lc ld jv le lf lg jz iq lh li kd iu lj lk kh iy ll lm kl ln bi translated">有哪些不同类型的GC算法？</h2><ul class=""><li id="4427" class="ly lz hi ih b ii kn im ko iq mo iu mp iy mq jc mr me mf mg bi translated"><strong class="ih hj">串行:</strong>所有垃圾收集事件在一个线程中串行进行。压缩在每次垃圾收集后执行。</li><li id="4926" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mr me mf mg bi translated"><strong class="ih hj">并行:</strong>多线程用于少量垃圾收集。单个线程用于主要的垃圾收集和旧代压缩。</li><li id="4149" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mr me mf mg bi translated"><strong class="ih hj"> CMS(并发标记清除):</strong>多线程用于较小的垃圾收集，使用与并行相同的算法。主要的垃圾收集是多线程的。(在JDK 9中已被否决)</li><li id="17a8" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mr me mf mg bi translated"><strong class="ih hj">【垃圾第一】:</strong><strong class="ih hj"/>替换为CMS。它像CMS一样是并行和并发的，但是它的工作方式却完全不同。</li><li id="4f11" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mr me mf mg bi translated">Z垃圾收集器(ZGC):  ZGC同时执行所有昂贵的工作，不停止应用程序线程的执行。(可从JDK 11获得)</li></ul><h1 id="5396" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论:</h1><p id="156d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在这篇文章中，我们用简单的答案探究了面试官经常问的多个问题。我希望这篇文章能成为你准备下一次Java面试的一部分资产。祝你好运！</p><h1 id="836d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">参考资料:</h1><p id="b9a9" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><a class="ae ks" href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/Java/javaOO/access control . html</a></p><p id="fb39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ks" href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/collections/streams/index . html</a></p><p id="50dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ks" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/essential/concurrency/proc thread . html</a></p><p id="deea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://docs.oracle.com/javase/8/docs/api/java/lang/Thread. T4】State.html</p><p id="d51f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ks" href="https://docs.oracle.com/en/java/javase/11/gctuning/available-collectors.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/en/Java/Java se/11/GC tuning/available-collectors . html</a></p></div></div>    
</body>
</html>