<html>
<head>
<title>A Glimpse of Functional Programming with Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java函数式编程一瞥</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/a-beginners-guide-to-functional-programming-with-java-5987101b3713?source=collection_archive---------1-----------------------#2020-12-21">https://medium.com/javarevisited/a-beginners-guide-to-functional-programming-with-java-5987101b3713?source=collection_archive---------1-----------------------#2020-12-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><a href="https://www.java67.com/2018/10/java-8-stream-and-functional-programming-interview-questions-answers.html"><div class="er es hg"><img src="../Images/0c0c3fd2c006e1be7e7a878ee074bf22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sT87eCvMvLWxriyQm7ktqw.jpeg"/></div></a></figure><div class=""/><p id="a34c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从<a class="ae jk" rel="noopener" href="/hackernoon/top-5-java-8-courses-to-learn-online-2db57d9dfb8d"> Java 8 </a>开始，我们可以用函数方法增强我们的Java代码解决方案。酪Java到底提供了什么？让我们来看看。</p><h1 id="e0b1" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">什么是函数式编程？</h1><p id="a5b2" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">函数式编程是一种编程范式，其焦点是<em class="ko">“解决什么”</em>，与此相反，过程式编程范式的主要焦点是<em class="ko">“如何解决”</em>换句话说，函数式编程是一种<strong class="io hq">声明性范例</strong>。函数式编程的核心是解决作为<strong class="io hq">数学函数求值的计算问题。</strong>是的，函数，这些关系将集合中的元素<em class="ko"> X(输入)</em>关联到集合中的单个元素<em class="ko"> Y(输出)</em>。在函数式编程中，<strong class="io hq">函数无处不在</strong>。函数可以存储在变量中。函数可以作为参数传递。函数可以接收函数作为参数，甚至返回一个函数作为结果。此外，函数可以是表达式(方法内部的指令，比如2+2，这是一个算术表达式)👀。</p><h2 id="4cb8" class="kp jm hp bd jn kq kr ks jr kt ku kv jv ix kw kx jz jb ky kz kd jf la lb kh lc bi translated">作为方法的函数</h2><p id="eac8" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">等等，我们在Java中称之为方法的，在其他语言中叫做函数，比如在<a class="ae jk" rel="noopener" href="/javarevisited/10-best-c-programming-courses-for-beginners-2c2c1f6bcb12"> C </a>中。它们在使用Java 的<a class="ae jk" rel="noopener" href="/javarevisited/8-best-lambdas-stream-and-functional-programming-courses-for-java-developers-3d1836a97a1d">函数式编程的上下文中起作用吗？是的，他们是。但他们不是唯一的。</a></p><h2 id="d470" class="kp jm hp bd jn kq kr ks jr kt ku kv jv ix kw kx jz jb ky kz kd jf la lb kh lc bi translated">作为对象的功能</h2><p id="fc55" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">我们提到存储在变量中，作为参数传递，作为结果返回。只有变量和对象可以被存储、传递和返回。函数在Java中是用对象表示的吗？是的，他们是。我们有什么叫做<a class="ae jk" href="https://javarevisited.blogspot.com/2018/01/what-is-functional-interface-in-java-8.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq">功能界面</strong> </a> <strong class="io hq">。我们从函数接口实现类。然后，我们可以创建对象。这些对象被称为<strong class="io hq">一级函数。</strong>为什么？据说是因为职能终于被当做<em class="ko">一等公民</em>🙂。当封装在对象中时，它们最终可以被存储、返回并用作其他函数的参数。</strong></p><h2 id="431c" class="kp jm hp bd jn kq kr ks jr kt ku kv jv ix kw kx jz jb ky kz kd jf la lb kh lc bi translated">用作表达式</h2><p id="5bb3" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">进一步，我们提到函数可以是表达式；因此，它们可以存在于方法内部，就像我们结合运算符和值创建的表达式一样，对吗？是的，他们可以。我们将需要一种新的表达式(我稍后会解释)，称为<a class="ae jk" rel="noopener" href="/javarevisited/7-best-java-tutorials-and-books-to-learn-lambda-expression-and-stream-api-and-other-features-3083e6038e14"><strong class="io hq"/></a>。它们也是函数。</p><p id="f804" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们回顾一下实现——函数接口、高阶函数和Lambda表达式。</p><h1 id="d733" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">功能界面</h1><p id="2543" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">函数接口也叫<a class="ae jk" href="http://www.java67.com/2017/06/10-points-about-lambda-expressions-in-java-8.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq">单一抽象方法接口</strong> </a>。顾名思义，它们是只允许一个抽象(未实现)方法的接口。可以实现函数接口，实现的类可以用来创建表示函数的对象——记住，它们被称为<strong class="io hq">一级函数。这允许语言支持将函数作为参数传递给其他函数，将它们作为其他函数的值返回，并将它们分配给变量或存储在数据结构中。</strong></p><p id="8127" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Java API包含一组为常见用例设计的功能接口，因此您不必为每个小用例创建自己的功能接口。它们位于<strong class="io hq"><em class="ko">Java . util . Function</em></strong>包中，包括:<strong class="io hq"> <em class="ko">函数</em> </strong>，<strong class="io hq"> <em class="ko">谓词</em> </strong>，<strong class="io hq"> <em class="ko">一元运算符</em> </strong>，<strong class="io hq"> <em class="ko">二元运算符</em> </strong>，<strong class="io hq"> <em class="ko">供应商，</em> </strong> <strong class="io hq"> <em class="ko">消费者，比较器</em>让我们看看其中的两个例子来了解一下这个想法。</strong></p><h2 id="4487" class="kp jm hp bd jn kq kr ks jr kt ku kv jv ix kw kx jz jb ky kz kd jf la lb kh lc bi translated">java.util.function .函数</h2><p id="8de4" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated"><strong class="io hq"> <em class="ko">函数</em> </strong>接口表示接受单个参数并返回单个值的函数。函数名为<strong class="io hq"> <em class="ko"> apply() </em> </strong> <em class="ko">，</em>，参数类型为参数化类型。下面是一个实现<strong class="io hq"> <em class="ko">函数</em> </strong>并使<em class="ko"> apply() </em>方法将一个<em class="ko">整数</em>作为参数并返回一个<em class="ko">整数</em>的例子。图1显示了一个例子。</p><figure class="ld le lf lg fd hk"><div class="bz dy l di"><div class="lh li l"/></div><p class="lj lk et er es ll lm bd b be z dx translated">图一。PlusOne.java—Java . util . function . function接口实现示例</p></figure><h2 id="a9b2" class="kp jm hp bd jn kq kr ks jr kt ku kv jv ix kw kx jz jb ky kz kd jf la lb kh lc bi translated">java.util.function .谓词</h2><p id="4e6d" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated"><a class="ae jk" href="https://javarevisited.blogspot.com/2015/02/how-to-filter-collections-in-java-8.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq"> <em class="ko">谓词</em> </strong> </a>接口表示一个简单的函数，以单个值作为参数，返回true或false。函数名为<strong class="io hq"> <em class="ko"> test() </em> </strong> <em class="ko">。</em>您可以使用一个类来实现<strong class="io hq"> <em class="ko">谓词</em> </strong>接口，如图2所示。</p><figure class="ld le lf lg fd hk"><div class="bz dy l di"><div class="lh li l"/></div><p class="lj lk et er es ll lm bd b be z dx translated">图二。AreHappy.java—Java . util . function . predicate接口实现的示例</p></figure><p id="7aa4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我们可以使用这些实现来创建我们的类<em class="ko"> PlusOne </em>和<em class="ko"> AreHappy，</em>的实例，如图3所示。</p><figure class="ld le lf lg fd hk"><div class="bz dy l di"><div class="lh li l"/></div><p class="lj lk et er es ll lm bd b be z dx translated">图3。Main.java——函数和谓词接口用法示例</p></figure><p id="86fe" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">至此，你有了想法:接口封装了一个要在类中实现的方法；从类中，我们可以创建对象，然后对象可以被存储、作为参数传递或返回。请不要绝望，这是一块积木，我们接下来将进入核心部分。</p><h1 id="48cd" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">高阶函数</h1><p id="e652" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">高阶函数是:(1)以一个或多个<em class="ko">函数</em>为参数的函数；或者(2)返回一个<em class="ko">函数</em>作为结果的函数。例如，<em class="ko"> Collections.sort() </em>方法将一个<em class="ko">比较器</em>作为参数。是的，那个<a class="ae jk" href="https://www.java67.com/2019/06/top-5-sorting-examples-of-comparator-and-comparable-in-java.html" rel="noopener ugc nofollow" target="_blank"> <em class="ko">比较器</em> </a>是一个<em class="ko">函数</em>——一个封装在类中的方法，实现一个只有一个(未实现的)方法的接口🙂。看一下图4中的代码。</p><figure class="ld le lf lg fd hk"><div class="bz dy l di"><div class="lh li l"/></div><p class="lj lk et er es ll lm bd b be z dx translated">图4。MyComparator.java-将其用作Collection.sort()方法的参数</p></figure><p id="67b8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，<em class="ko"> Collection.sort() </em>的第一个参数是一个<em class="ko">列表，</em>，第二个参数是一个函数。第二个参数是使<em class="ko"> Collections.sort() </em>成为高阶函数的原因。有点令人兴奋，但仍然不像函数式编程。</p><h1 id="34a6" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">λ表达式</strong></h1><p id="78d9" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">你有没有注意到在上面的例子中，我们有多少次创建了一个类来承载一个方法(函数)？我们只使用一次的功能！</p><p id="53a2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">lambda表达式是一小段代码，用于替换方法声明</strong>。它接受参数并返回一个值。但是，它不需要名字，它可以在另一个方法体中实现。此外，<a class="ae jk" href="https://javarevisited.blogspot.com/2018/07/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" rel="noopener ugc nofollow" target="_blank">λ表达式</a>可用于直接从函数接口实现单个方法。lambda表达式如下所示:</p><p id="3bda" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du ln lo lp lq b">(parameters inside parenthesis) <strong class="io hq">-&gt;</strong> {body inside curly brackets}</code></p><p id="e3f9" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们可以删除图1和图2中的代码，重写图3，如图5所示。正如您所注意到的，<em class="ko">函数</em>接口实现现在内联在plusOne lambda变量的声明中，而不是在一个单独的类中。这个比较短。那么，一个表达式(一行)能代替一个新类的创建(用它的实现指令)和一个方法体的覆盖吗？是的，没错。</p><figure class="ld le lf lg fd hk"><div class="bz dy l di"><div class="lh li l"/></div><p class="lj lk et er es ll lm bd b be z dx translated">图5。Main.java—Lambda表达式取代了函数接口的显式实现</p></figure><p id="2a56" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">值得扩展我们对高阶函数的定义，并声明高阶函数可以是以一个或多个lambda表达式作为参数或返回lambda表达式的函数。例如，在<a class="ae jk" href="https://javarevisited.blogspot.com/2017/09/java-8-sorting-hashmap-by-values-in.html" rel="noopener ugc nofollow" target="_blank"><em class="ko">collections . sort()</em></a><em class="ko"/>中，第一个参数仍然是一个<em class="ko">列表</em>，第二个参数是一个lambda表达式。</p><h1 id="c434" class="jl jm hp bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">连接点:流API</h1><p id="53d9" class="pw-post-body-paragraph im in hp io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">更好地利用函数式编程特性的Java部分之一是<a class="ae jk" rel="noopener" href="/javarevisited/7-best-java-collections-and-stream-api-courses-for-beginners-in-2020-3ad18d52c38"> <strong class="io hq">流API </strong> </a>，它提供了一种函数式方法来处理对象的<strong class="io hq">集合。流API与包<em class="ko"> InputStream </em>或<em class="ko"> OutputStream — t </em>无关，而<em class="ko"> InputStream </em>和<em class="ko"> OutputStream </em>与<strong class="io hq">字节流</strong>相关。请看图6中的例子。他们展示了如何:</strong></p><ol class=""><li id="88a7" class="lr ls hp io b ip iq it iu ix lt jb lu jf lv jj lw lx ly lz bi translated">创建一个元素流—method<strong class="io hq">of()</strong>和items作为参数。</li><li id="bca5" class="lr ls hp io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated">使用Fluent-Builder样式将元素直接添加到流中。</li><li id="7191" class="lr ls hp io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated">从我们已有的收藏中创建一个流。</li><li id="299b" class="lr ls hp io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated">对流的元素执行操作—对每个元素执行相同的操作。因此，N个元素产生N个结果。注意例子中的<a class="ae jk" rel="noopener" href="/javarevisited/how-to-use-streams-map-filter-and-collect-methods-in-java-1e13609a318b"><strong class="io hq"><em class="ko"/></strong>方法</a>。</li><li id="6437" class="lr ls hp io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated">创建一个流管道——一系列流源、中间操作和终端操作。注意示例中的<strong class="io hq"> <em class="ko"> map() </em> </strong>和<strong class="io hq"> <em class="ko"> sort() </em> </strong>方法的组合。</li><li id="4e99" class="lr ls hp io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated">简化流，即通过某种方式组合(使用)流中的所有元素来获得值。因此，N个元素产生1个结果。注意例子中的<strong class="io hq"> <em class="ko"> reduce() </em> </strong>方法。</li><li id="52aa" class="lr ls hp io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated">应用并行化。Java 8引入了一种以函数风格实现并行的方式<strong class="io hq">。流API允许创建并行流，以并行模式执行操作。注意<strong class="io hq"><em class="ko">parallels stream()</em></strong>方法。</strong></li></ol><figure class="ld le lf lg fd hk"><div class="bz dy l di"><div class="lh li l"/></div><p class="lj lk et er es ll lm bd b be z dx translated">图6。StreamsExamples.java—利用函数式编程方法的例子</p></figure><p id="1365" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，流本身可以迭代它的元素。不需要Java迭代器、for-each循环或任何类型迭代的显式实现。此外，请注意对<a class="ae jk" href="https://mscjaviergs.medium.com/design-patterns-101-factory-vs-builder-vs-fluent-builder-da2babf42113" rel="noopener"> <strong class="io hq"> Fluent-Builder设计模式</strong> </a> <strong class="io hq"> </strong>的大量使用——所有那些<code class="du ln lo lp lq b">object<em class="ko">.foo().bar().more() </em></code> <em class="ko"> … </em></p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="f388" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以用上面描述的元素做什么？如何将它们与面向对象的元素结合起来？例如，从文件中读取数据、将数据存储在数据结构(集合)中、进行排序或搜索、迭代数据以进行打印、计算统计数据等。让我们在另一个故事中回顾一下。</p></div></div>    
</body>
</html>