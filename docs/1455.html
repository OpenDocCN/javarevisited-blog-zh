<html>
<head>
<title>Modern Clean Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代清洁建筑</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/modern-clean-architecture-c1765f8f3fc1?source=collection_archive---------0-----------------------#2021-08-10">https://medium.com/javarevisited/modern-clean-architecture-c1765f8f3fc1?source=collection_archive---------0-----------------------#2021-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/ffad69b968cc7c39d500d04ae186eeb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Jbe_k-KkGGHzVqmE0hZxsA.jpeg"/></div></figure><p id="fed9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">干净的建筑是罗伯特·c·马丁创造的一个术语。主要思想:<br/>实体和用例独立于框架、UI、数据库和外部服务。</p><p id="5b88" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">干净的架构风格对可维护性有积极的影响:</p><ul class=""><li id="540b" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">我们可以在没有框架、UI和基础设施的情况下测试领域实体和用例。</li><li id="adcb" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">技术决策可以在不影响领域代码的情况下改变。反之亦然。甚至有可能不费吹灰之力就切换到新的框架。</li></ul><p id="e28d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我的目标是使学习曲线变平，减少实现一个干净架构的工作量。这就是为什么我创建了<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture" rel="noopener ugc nofollow" target="_blank">现代清洁建筑</a> <em class="jz"> </em>图书馆。</p><p id="2d84" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我将向您展示如何创建一个具有现代干净架构的应用程序。从一个<a class="ae jk" rel="noopener" href="/javarevisited/10-best-html-and-css-courses-for-beginners-in-2021-6757eec00032"> HTML </a> / <a class="ae jk" rel="noopener" href="/javarevisited/my-favorite-free-tutorials-and-courses-to-learn-javascript-8f4d0a71faf2"> JavaScript </a>前端到一个<a class="ae jk" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e"> Spring Boot后端</a>。重点将放在后端。</p><p id="8537" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们从示例应用程序的概述开始。永恒的经典。</p><h2 id="4055" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated">待办事项列表应用程序示例</h2><p id="9d51" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">一个<em class="jz">待办事项列表</em>是一个<em class="jz">任务</em>的集合。一个任务有一个<em class="jz">名称</em>，并且或者<em class="jz">完成或者</em>未完成。作为用户，您可以:</p><ul class=""><li id="d450" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">创建一个单一的待办事项列表，并坚持下去</li><li id="1ca0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">添加任务</li><li id="01e3" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">完成一项任务，或“不完成”它</li><li id="8b28" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">删除任务</li><li id="72a0" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">列出所有任务</li><li id="9eb2" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">过滤已完成/未完成的任务</li></ul><p id="7b1e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是包含1个未完成任务和2个已完成任务的待办事项列表:</p><figure class="lb lc ld le fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/05/5-projects-you-can-do-to-learn-react-native.html#axzz6vs8zuM8M"><div class="er es la"><img src="../Images/9872bf870aaab50e82b0eb3de2dee460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8FZgCcZc54tJuD9q9dhBQ.png"/></div></a></figure><p id="5c5e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们从应用程序的核心领域实体开始。然后我们向外走到<a class="ae jk" rel="noopener" href="/javarevisited/6-best-frontend-development-courses-for-beginners-to-learn-in-2021-f2772157864">前端。</a></p><h2 id="b8e7" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated">域实体</h2><p id="3d37" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">中心域实体是<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/domain/TodoList.java" rel="noopener ugc nofollow" target="_blank"> TodoList </a>和<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/domain/Task.java" rel="noopener ugc nofollow" target="_blank"> Task </a>。</p><p id="c69f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jz">待分解</em>实体包含:</p><ul class=""><li id="56bc" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">唯一的id，</li><li id="b251" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">任务列表，</li><li id="d5ab" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">添加、完成、删除任务的域方法…</li></ul><p id="b9d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jz"> TodoList </em>实体不包含公共setters。Setters会破坏正确的封装。</p><p id="472d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/domain/TodoList.java" rel="noopener ugc nofollow" target="_blank"> TodoList </a>实体的一部分。<a class="ae jk" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank">龙目岛</a>标注缩短代码。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="ea80" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jz"> AggregateRoot </em>接口有什么用？聚合根是Eric Evans在<a class="ae jk" rel="noopener" href="/javarevisited/7-best-books-to-learn-design-patterns-for-java-programmers-5627b93eefdb">领域驱动设计</a> (DDD)中提出的一个术语:</p><blockquote class="lh li lj"><p id="1680" class="im in jz io b ip iq ir is it iu iv iw lk iy iz ja ll jc jd je lm jg jh ji jj hb bi translated">聚合是一组相关联的对象，出于数据更改的目的，我们将它们视为一个单元。每个集合都有一个根和一个边界。边界定义了集合内部的内容。根是聚合中包含的单个特定实体。</p></blockquote><p id="5cd4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们只能通过聚合根来更改聚合的状态。在我们的例子中，这意味着:我们总是必须使用<em class="jz"> TodoList </em>来添加、删除或更改任务。</p><p id="4c31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这允许<em class="jz"> TodoList </em>执行约束。例如，我们不能将名称为空的任务添加到列表中。</p><p id="0224" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jz"> AggregateRoot </em>接口是<a class="ae jk" href="https://github.com/xmolecules/jmolecules" rel="noopener ugc nofollow" target="_blank"> jMolecules </a>库的一部分。该库使得DDD概念在域代码中显而易见。在构建过程中，<a class="ae jk" href="https://github.com/xmolecules/jmolecules-integrations/tree/main/jmolecules-bytebuddy" rel="noopener ugc nofollow" target="_blank">byte buddy插件</a>将注释映射到<a class="ae jk" href="https://www.java67.com/2021/01/spring-data-jpa-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"> Spring数据注释</a>。</p><p id="7abf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以我们只有一个模型。用于表示领域概念和持久性。尽管如此，我们在域代码中没有任何特定于持久性的注释。我们不把自己绑在任何框架上。</p><p id="4866" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/domain/Task.java" rel="noopener ugc nofollow" target="_blank"> <em class="jz">任务</em> </a> <em class="jz"> </em>类类似，但它实现了jMolecules <em class="jz">实体</em>接口代替:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="29cd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">任务的构造函数是包私有的。所以我们不能从<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/tree/main/samples/todolist/src/main/java/com/example/todolist/domain" rel="noopener ugc nofollow" target="_blank">域包</a>之外创建<em class="jz">任务</em>的实例。而<em class="jz">任务</em>类是<a class="ae jk" rel="noopener" href="/javarevisited/how-to-create-an-immutable-list-list-and-map-in-java-5ac1254c128?source=---------31------------------">不可变</a>。在聚合的边界之外，不可能对其状态进行任何更改。</p><p id="0912" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们需要一个存储库来存储<em class="jz"> TodoList。</em>在领域代码中坚持领域术语，称为<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/domain/TodoLists.java" rel="noopener ugc nofollow" target="_blank"><em class="jz"/></a>:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="6776" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">代码再次使用了jMolecues注释:<em class="jz"> Repository </em>。在构建期间，ByteBuddy插件将其翻译成一个<a class="ae jk" href="https://javarevisited.blogspot.com/2021/08/top-5-spring-data-jpa-courses-for-java.html" rel="noopener ugc nofollow" target="_blank"> Spring数据仓库</a>。</p><p id="e388" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将跳过域异常，因为它们没有什么特别的。这就是完整的<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/tree/main/samples/todolist/src/main/java/com/example/todolist/domain" rel="noopener ugc nofollow" target="_blank">域包</a>。</p><h2 id="e2c1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated">行为(即用例)</h2><p id="8cb8" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">接下来，我们定义对最终用户可见的应用程序的行为。用户与应用程序的任何交互如下进行:</p><ol class=""><li id="30a8" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj ln jr js jt bi translated">用户界面发送<em class="jz">请求</em>。</li><li id="5628" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj ln jr js jt bi translated">后端通过执行一个<em class="jz">请求处理程序来做出反应。</em>请求处理器完成完成请求所需的一切:<br/> -访问数据库<br/> -调用外部服务<br/> -调用域实体方法</li><li id="4c4d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj ln jr js jt bi translated">请求处理器<strong class="io hj">可以</strong>返回一个<em class="jz">响应</em>。</li></ol><p id="d3b1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们用Java 8函数接口实现了一个<em class="jz">请求处理器</em>。</p><p id="e9ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">返回<em class="jz">响应</em>的处理程序实现<em class="jz"> java.util.Function </em>接口。下面是<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/behavior/AddTask.java" rel="noopener ugc nofollow" target="_blank"><em class="jz">add task</em></a><em class="jz"/>处理程序的代码。这个处理程序</p><ul class=""><li id="e2c8" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">从<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/behavior/request/AddTaskRequest.java" rel="noopener ugc nofollow" target="_blank"><em class="jz">AddTaskRequest</em></a><em class="jz">，</em>中提取待办事项列表id和任务名称</li><li id="6b93" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">在存储库中查找待办事项列表(或者抛出异常)，</li><li id="b73b" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">将请求中名称为的任务添加到列表中，</li><li id="78db" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">返回一个带有添加的任务id的<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/behavior/response/AddTaskResponse.java" rel="noopener ugc nofollow" target="_blank"><em class="jz">AddTaskResponse</em></a><em class="jz"/>。</li></ul><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="a396" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Lombok使用<em class="jz"> TodoLists </em>存储库接口创建一个构造函数作为构造函数参数。我们将任何外部依赖作为<a class="ae jk" href="https://javarevisited.blogspot.com/2013/04/10-abstract-class-and-interface-interview-question-java-answers.html#axzz4pk4W5ie3" rel="noopener ugc nofollow" target="_blank">接口</a>传递给处理程序的构造函数。</p><p id="5214" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请求和响应是不可变的对象:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="02d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现代干净架构库<a class="ae jk" href="https://www.java67.com/2017/05/how-to-convert-java-object-to-json-using-Gson-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">(反)序列化JSON </a>。</p><p id="a16d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，是一个不返回响应的处理程序的例子。<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/behavior/DeleteTask.java" rel="noopener ugc nofollow" target="_blank"> <em class="jz">删除任务</em> </a>处理程序接收一个<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/behavior/request/DeleteTaskRequest.java" rel="noopener ugc nofollow" target="_blank"> <em class="jz">删除任务请求</em> </a>。因为处理程序没有返回响应，所以它实现了<em class="jz">消费者</em>接口。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="d2bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有一个问题:谁创建了这些处理程序？</p><p id="5cfd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">答案:实现<a class="ae jk" href="https://github.com/bertilmuth/requirementsascode/blob/master/requirementsascodecore/src/main/java/org/requirementsascode/BehaviorModel.java" rel="noopener ugc nofollow" target="_blank"> <em class="jz">行为模型</em> </a> <em class="jz"> </em>接口的类。对于这种请求，行为模型将每个<em class="jz">请求</em>类映射到<em class="jz">请求处理程序</em>。</p><p id="704a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/behavior/TodoListBehaviorModel.java" rel="noopener ugc nofollow" target="_blank"><em class="jz">TodoListBehaviorModel</em></a>的一部分:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="2a54" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lo lp lq lr b">user(...)</code>语句定义了请求类别。对于返回<em class="jz">响应</em>的处理程序，我们使用<code class="du lo lp lq lr b">systemPublish(...)</code>。而<code class="du lo lp lq lr b">system(...)</code>则是针对那些没有。</p><p id="1ba5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jz">行为模型</em>有一个外部依赖作为接口传入的构造函数。它创建所有的处理程序，并将适当的依赖项注入其中。</p><p id="c35d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过配置<em class="jz">行为模型</em>的依赖关系，我们配置了所有的处理程序。这正是我们想要的:一个我们可以改变或转换对技术的依赖的中心。这就是技术决策如何在不影响领域代码的情况下改变。</p><h2 id="666f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated">web层(即适配器)</h2><p id="75d6" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">现代<a class="ae jk" rel="noopener" href="/javarevisited/clean-architecture-a-must-read-software-design-book-for-developers-41189b8ca122">清洁架构</a>中的web层可以非常薄。在其最简单的形式中，它只包含两个类:</p><ul class=""><li id="cb44" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">一个用于依赖项配置的类</li><li id="d480" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">一个用于异常处理的类</li></ul><p id="32cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/adapter/spring/TodoListConfiguration.java" rel="noopener ugc nofollow" target="_blank"><em class="jz">TodoListConfiguration</em></a><em class="jz"/>类:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="b50f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Spring将<em class="jz"> TodoLists </em> repository接口的实现注入到<em class="jz"> behaviorModel(…) </em>方法中。该方法创建了一个作为bean的<em class="jz">行为模型</em>实现。</p><p id="b2cc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果应用程序使用外部服务，configuration类是将具体实例创建为beans的地方。并将它们注入<em class="jz">行为模型</em>。</p><p id="7835" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么，<a class="ae jk" href="https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html" rel="noopener ugc nofollow" target="_blank">控制器</a>都在哪里呢？</p><p id="9473" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好吧。不需要你去创造任何东西。至少如果你只处理POST请求的话。(关于GET请求的处理，请参见后面的问答。)</p><p id="b4dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/tree/main/spring-behavior-web" rel="noopener ugc nofollow" target="_blank"><em class="jz">spring-behavior-web</em></a><em class="jz"/>库是<em class="jz">现代洁净建筑</em>库的一部分。我们为POST请求定义了一个端点。我们在<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/resources/application.properties" rel="noopener ugc nofollow" target="_blank"> <em class="jz">应用程序中指定该端点的URL。</em></a></p><p id="6768" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lo lp lq lr b">behavior.endpoint = /todolist</code></p><p id="b059" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果该属性存在，spring-behavior-web将在后台为端点设置一个控制器。该控制器接收POST请求。</p><p id="7ed1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们不需要编写特定于Spring的代码来添加新的行为。我们不需要添加或更换控制器。</p><p id="d096" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当端点接收到POST请求时，会发生以下情况:</p><ol class=""><li id="8239" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj ln jr js jt bi translated">spring-behavior-web反序列化请求，</li><li id="f84e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj ln jr js jt bi translated">spring-behavior-web将请求传递给由行为模型配置的行为，</li><li id="0110" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj ln jr js jt bi translated">该行为将请求传递给适当的请求处理器(如果有的话)，</li><li id="17df" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj ln jr js jt bi translated">spring-behavior-web序列化响应并将其传递回端点(如果有端点的话)。</li></ol><p id="1fd7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">默认情况下，spring-behavior-web将每个对请求处理程序的调用包装在一个事务中。</p><h2 id="9445" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated">发送发布请求</h2><p id="0395" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">一旦我们启动了<a class="ae jk" href="https://www.java67.com/2018/05/difference-between-springbootapplication-vs-EnableAutoConfiguration-annotations-Spring-Boot.html" rel="noopener ugc nofollow" target="_blank"> Spring Boot应用程序</a>，我们就可以向端点发送<a class="ae jk" href="https://www.java67.com/2019/03/7-examples-of-httpurlconnection-in-java.html" rel="noopener ugc nofollow" target="_blank"> POST请求</a>。</p><p id="edd3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们在JSON内容中包含了一个<code class="du lo lp lq lr b">@type</code>属性。以便spring-behavior-web可以在反序列化期间确定正确的请求类。</p><p id="d2fa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，这是待办事项应用程序的一个有效的<code class="du lo lp lq lr b">curl</code>命令。它向端点发送一个<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/behavior/request/FindOrCreateListRequest.java" rel="noopener ugc nofollow" target="_blank"><em class="jz">FindOrCreateListRequest</em></a><em class="jz"/>。</p><p id="82eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lo lp lq lr b">curl -H "Content-Type: application/json" -X POST -d '{"@type": "FindOrCreateListRequest"}' <a class="ae jk" href="http://localhost:8080/todolist" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/todolist</a></code></p><p id="ebf6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是在Windows PowerShell中使用的相应语法:</p><p id="3233" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lo lp lq lr b">iwr http://localhost:8080/todolist -Method 'POST' -Headers @{'Content-Type' = 'application/json'} -Body '{"@type": "FindOrCreateListRequest"}'</code></p><h2 id="e71b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated">异常处理</h2><p id="bacd" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">spring-behavior-web的异常处理与“普通”spring应用程序没有什么不同。我们创建一个用<code class="du lo lp lq lr b">@ControllerAdvice</code>注释的类。我们将带有<code class="du lo lp lq lr b">@ExceptionHandler</code>的方法注释放在其中。</p><p id="a2b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">参见<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/adapter/spring/TodoListExceptionHandling.java" rel="noopener ugc nofollow" target="_blank"><em class="jz">TodoListExceptionHandling</em></a>示例:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="567d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，在实际应用中，不同的异常类型需要不同的处理。</p><h2 id="4767" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ix kl km kn jb ko kp kq jf kr ks kt ku bi translated">前端</h2><p id="04e3" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">待办事项列表应用程序的前端包括:</p><ul class=""><li id="3e7b" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">一个<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/resources/static/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="jz"> HTML页面</em> </a>，</li><li id="16f3" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">一个<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/resources/static/styles.css" rel="noopener ugc nofollow" target="_blank"> <em class="jz"> CSS文件</em> </a> <em class="jz"> </em>用于格式化、</li><li id="3c03" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">还有一个<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/resources/static/main.js" rel="noopener ugc nofollow" target="_blank"> <em class="jz"> main.js JavaScript文件</em> </a></li></ul><p id="f464" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们这里重点关注<em class="jz"> main.js </em>。它发送请求并更新网页。</p><p id="0578" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下是它的部分内容:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="5f50" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，这是一个<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/blob/main/samples/todolist/src/main/java/com/example/todolist/behavior/request/ListTasksRequest.java" rel="noopener ugc nofollow" target="_blank"><em class="jz">listtaksrequest</em></a>的JSON对象:</p><blockquote class="lh li lj"><p id="612b" class="im in jz io b ip iq ir is it iu iv iw lk iy iz ja ll jc jd je lm jg jh ji jj hb bi translated">const request = { " @ type ":" listasksrequest "，" todoListUuid ":todoListUuid }；</p></blockquote><p id="d982" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jz"> post(…) </em>方法将<em class="jz">请求</em>发送到后端，并将<em class="jz">响应</em>传递给<em class="jz">响应处理程序</em>。(您作为第二个参数传入的回调函数。)</p><p id="a255" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是待办事项列表应用程序的全部内容。</p><h1 id="e856" class="ls kb hi bd kc lt lu lv kg lw lx ly kk lz ma mb kn mc md me kq mf mg mh kt mi bi translated">问题与答案</h1><p id="e56a" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">如果…会怎样</p><p id="288f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">…我想发送GET请求而不是POST请求？</p><p id="6f48" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">…我希望web层与行为分开发展？</p><p id="43c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">…我想使用与<a class="ae jk" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring </a>不同的框架？</p><p id="3e08" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">…我有一个比待办事项列表示例大得多的应用程序。我如何构建它？</p><p id="bc11" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/wiki/Questions-&amp;-Answers" rel="noopener ugc nofollow" target="_blank">这里的</a>是anwers。</p><h1 id="e5d9" class="ls kb hi bd kc lt lu lv kg lw lx ly kk lz ma mb kn mc md me kq mf mg mh kt mi bi translated">结论</h1><p id="b54f" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">在本文中，我向您展示了一种实现干净架构的特殊方法。还有很多其他的方法。</p><p id="622c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我的目标是减少构建干净架构的工作量。并拉平学习曲线。</p><p id="0a67" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了实现这一点，现代干净架构库提供了以下特性:</p><ul class=""><li id="729d" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><strong class="io hj">不可变请求和响应的序列化</strong>没有序列化特定注释。</li><li id="3485" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><strong class="io hj">不需要dto。</strong>您可以在web层和用例中为请求/响应使用相同的不可变对象。</li><li id="e97b" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><strong class="io hj">接收和转发POST请求的通用端点</strong>。可以添加和使用新的行为和域逻辑，而无需编写特定于框架的代码。</li></ul><p id="8933" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我的下一篇文章中，我将描述如何测试一个现代的干净的架构。</p><p id="3af9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我邀请你访问<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/" rel="noopener ugc nofollow" target="_blank">现代清洁建筑</a> GitHub页面。</p><p id="adea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">参见<a class="ae jk" href="https://github.com/bertilmuth/modern-clean-architecture/tree/main/samples/todolist" rel="noopener ugc nofollow" target="_blank">待办事项示例应用</a>。</p><p id="f271" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请在评论中给我反馈。你怎么想？</p><p id="387e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你想了解我正在做的事情或给我留言，请在<a class="ae jk" href="https://www.linkedin.com/in/bertilmuth/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae jk" href="https://twitter.com/BertilMuth" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p><h1 id="784b" class="ls kb hi bd kc lt lu lv kg lw lx ly kk lz ma mb kn mc md me kq mf mg mh kt mi bi translated">承认</h1><p id="48d6" class="pw-post-body-paragraph im in hi io b ip kv ir is it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj hb bi translated">感谢Surya Shakti发布原创前端only <a class="ae jk" href="https://suryashakti1999.medium.com/to-do-list-app-using-javascript-for-absolute-beginners-13ea9e38a033" rel="noopener">待办事项代码</a>。</p><p id="5164" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢Oliver Drotbohm为我指出了令人敬畏的jMolecules图书馆。</p></div></div>    
</body>
</html>