<html>
<head>
<title>Count the number of Trailing Zeros in the Factorial of a Given Number.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算给定数字的阶乘中尾随零的个数。</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/count-the-number-of-trailing-zeros-in-the-factorial-of-a-given-number-953f569d4c9d?source=collection_archive---------1-----------------------#2022-09-15">https://medium.com/javarevisited/count-the-number-of-trailing-zeros-in-the-factorial-of-a-given-number-953f569d4c9d?source=collection_archive---------1-----------------------#2022-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://www.java67.com/2015/09/factorial-in-java-using-recursion-and-loop.html"><div class="er es if"><img src="../Images/3c77e4d7a4754f2d43a85164b7ed9297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*G61IbE895_lMPBTsUNfz9g.png"/></div></a></figure><h1 id="d62b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">问题陈述</strong></h1><p id="7491" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">给定一个数，找出它的阶乘的尾随零的个数。</p><h1 id="9bc8" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">例子:</strong></h1><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="697b" class="kr in hi kn b fi ks kt l ku kv"><strong class="kn hj">Input:</strong> n = 5</span><span id="a272" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Output:</strong> 1</span><span id="00a7" class="kr in hi kn b fi kw kt l ku kv">Factorial of 5 is 120 which has one trailing 0.</span><span id="701c" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Input: </strong>n = 20</span><span id="5cd2" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Output:</strong> 4</span><span id="3752" class="kr in hi kn b fi kw kt l ku kv">Factorial of 20 is 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 which has 4 trailing zeroes.</span><span id="8e22" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Input:</strong> n = 100</span><span id="0850" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Output:</strong> 24</span><span id="280c" class="kr in hi kn b fi kw kt l ku kv">Factorial of 20 is 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 which has 24 trailing zeroes.</span></pre><p id="3ffc" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">在这篇博客中，我们将讨论两种方法来计算这些尾随零的数量。</p><h1 id="417b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">蛮力逼近</strong></h1><p id="9e93" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">强力方法是我们想到的第一种方法，在我们的例子中，我们想到的第一种方法是首先<a class="ae lc" href="https://javarevisited.blogspot.com/2012/04/java-program-to-find-factorial-of.html" rel="noopener ugc nofollow" target="_blank">找到给定数字</a>的阶乘，然后计算尾随零的数量。</p><p id="b836" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">正如我们已经知道的，简单的迭代和递归方法对于<a class="ae lc" href="https://javarevisited.blogspot.com/2015/08/how-to-calculate-large-factorials-using-BigInteger-Java-Example.html" rel="noopener ugc nofollow" target="_blank">寻找100 </a>这样的大数的阶乘没有用，所以我们将从一开始就使用结转方法，这样我们就可以计算每个正数的尾随零。</p><h1 id="e2a1" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">算法</strong></h1><ol class=""><li id="0104" class="ld le hi jm b jn jo jr js jv lf jz lg kd lh kh li lj lk ll bi translated">用进位法求给定数字的阶乘。</li><li id="6ac1" class="ld le hi jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">将计数变量初始化为0。</li><li id="087b" class="ld le hi jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">使用reverse for loop来检查数字是否为0，方法是取10的模。</li><li id="77c2" class="ld le hi jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">如果数字为零，则将计数加1。</li><li id="0a68" class="ld le hi jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">打印该计数。</li></ol><p id="5210" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">下面是上述方法的实现</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h1 id="9392" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">输出</strong></h1><p id="908c" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">尾随零的数量— 24</p><p id="6c83" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><strong class="jm hj">时间复杂度</strong> : O(N log N！)</p><p id="f03a" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><strong class="jm hj">辅助空间:</strong> O(n)</p><h1 id="04f2" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">高效方法</strong></h1><p id="15d1" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">我们知道，一个数的阶乘是该数与小于该数且大于0的其他自然数的乘积，在大多数情况下，该数有一些尾随零。这背后的原因是数字10或它的因子2和5的存在。</p><p id="f989" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">如果我们对阶乘进行<a class="ae lc" href="http://javarevisited.blogspot.sg/2015/03/how-to-find-largest-prime-factor-of.html" rel="noopener ugc nofollow" target="_blank">质因数分解</a>，我们将得到2和5的计数，我们可以用它来找到尾随零的数量。</p><p id="395c" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">我们举个例子来了解一下</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7b6c" class="kr in hi kn b fi ks kt l ku kv"><strong class="kn hj">Input:</strong> n = 5</span><span id="2e88" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Prime Factors — </strong>2x2x2x3x5</span><span id="50fa" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Output:</strong> 1 — we have only 1 factor of 5</span><span id="1597" class="kr in hi kn b fi kw kt l ku kv">Factorial of 5 is 120 which has only 1 trailing zero.</span><span id="4c93" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Input: </strong>n = 11</span><span id="f8eb" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Prime Factors — </strong>28x34x52x7</span><span id="0e42" class="kr in hi kn b fi kw kt l ku kv"><strong class="kn hj">Output:</strong> 2–2 factors of 5</span><span id="f369" class="kr in hi kn b fi kw kt l ku kv">Factorial of 20 is 39916800 which has 2 trailing zeroes.</span></pre><p id="635e" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">从上面的例子中可以清楚地看到，在一个数的<a class="ae lc" href="https://www.java67.com/2015/09/how-to-use-biginteger-class-in-java.html" rel="noopener ugc nofollow" target="_blank">阶乘中找到因子5将会给出这个数的阶乘中尾随零的确切数目。下面是我们必须编码以找到尾随零的数量的步骤。</a></p><h1 id="5a2f" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">算法</strong></h1><ol class=""><li id="ccce" class="ld le hi jm b jn jo jr js jv lf jz lg kd lh kh li lj lk ll bi translated">将计数变量初始化为0</li><li id="a25a" class="ld le hi jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">使用for循环将数字除以5的幂，如5、25、125等</li><li id="d25b" class="ld le hi jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">如果除法的结果大于1，则按该数增加计数值。</li><li id="59d3" class="ld le hi jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">打印或返回计数，因为这将是我们的答案或尾随零的数量</li></ol><p id="7688" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">这种方法的美妙之处在于，我们不必先找到数字的阶乘来计算尾随零。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h1 id="066b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated"><strong class="ak">输出</strong></h1><p id="5d44" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">尾随零的数量是24</p><p id="45c2" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><strong class="jm hj">时间复杂度</strong> : O(log n)</p><p id="843b" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><strong class="jm hj">辅助空格</strong> : O(1)</p><p id="b9ca" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">很明显，就时间和空间复杂度而言，第二种方法在寻找尾随零的数量方面取得了明显的胜利。其中强力方法需要N log N的时间和O(n)的空间复杂度，另一种方法仅需要log N的时间和线性空间来寻找给定数字的阶乘的尾随零的数量。</p><p id="325f" class="pw-post-body-paragraph jk jl hi jm b jn kx jp jq jr ky jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">你也可以看看我的其他项目</p><ol class=""><li id="8f2f" class="ld le hi jm b jn kx jr ky jv lt jz lu kd lv kh li lj lk ll bi translated"><a class="ae lc" href="https://tekolio.com/how-to-calculate-the-factorial-of-a-given-number/" rel="noopener ugc nofollow" target="_blank">计算给定数字的阶乘</a></li><li id="e41b" class="ld le hi jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><a class="ae lc" href="https://tekolio.com/how-to-merge-two-sorted-arrays/" rel="noopener ugc nofollow" target="_blank">合并两个排序后的数组</a></li><li id="a724" class="ld le hi jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><a class="ae lc" href="https://tekolio.com/how-to-rotate-an-array-in-java/" rel="noopener ugc nofollow" target="_blank">如何旋转数组</a></li></ol></div></div>    
</body>
</html>