<html>
<head>
<title>A key to clean code — small methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清理代码的关键——小方法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/a-key-to-clean-code-small-methods-cff120538eba?source=collection_archive---------0-----------------------#2021-03-25">https://medium.com/javarevisited/a-key-to-clean-code-small-methods-cff120538eba?source=collection_archive---------0-----------------------#2021-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8af90ebf768a79a260acc698c8ead2c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtbLIfJ6KELkGYeVCnzSFg.jpeg"/></div></div></figure><p id="f468" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么我们需要把方法变小？一个方法应该有多小？如何使我们的方法变小以保持代码有条理和易读？我们将回答这个问题和许多其他问题，让我们开始吧。</p><p id="4910" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章是名为<a class="ae jo" href="https://rebrand.ly/spcc-medium-small-methods" rel="noopener ugc nofollow" target="_blank">“软件实践和编写干净代码”</a>的干净代码深入课程的一部分，你可以去看看。它目前以87%的折扣出售。</p><figure class="jq jr js jt fd ij er es paragraph-image"><a href="https://rebrand.ly/spcc-medium-small-methods"><div class="er es jp"><img src="../Images/dc9c4358d48d8c1502f7fa18c29da201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*yDVe-HZhy4OdzzOSYdnP6A.png"/></div></a></figure><p id="4bb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你应该记住的主要事情是:<strong class="is hj">把方法变小</strong>。一个方法应该只做一件事。但这意味着什么呢？让我们看一个例子:</p><figure class="jq jr js jt fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/10/clean-code-by-uncle-bob-book-review.html#axzz5jSEI4IYE"><div class="er es ju"><img src="../Images/0e3b3b0bf3363b50930cda3eebdb6a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_h_TpHv2aiOzwCqhgoMCCQ.png"/></div></a></figure><p id="fc38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个方法叫做<strong class="is hj">救</strong>。它将DTO对象映射到实体对象，然后保存它。</p><p id="bc80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个方法做一件事吗？它救了一个雇主，所以这是一回事，对不对？没有。其实有两件事。我们将DTO映射到一个实体，然后保存它。好吧，这很明显。您应该尽可能地拆分方法，这样做是合乎逻辑的。所以让我们重构它:</p><figure class="jq jr js jt fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/07/top-5-websites-to-learn-coding-in-java.html"><div class="er es jv"><img src="../Images/c5c29734031e18d1e5d328f184cb1cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmOUzkkixKradolCQUkF6g.png"/></div></a></figure><p id="9f75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那更好。你看，每个方法都有不同的职责。但是代码可以更好。为了更加灵活，我们可以有一个包装器方法来连接<strong class="is hj"> save </strong>和<strong class="is hj"> toEmployer </strong>方法。在这种情况下，我们将创建另一个保存方法来扮演这个角色。所以让我们再次重构代码:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jv"><img src="../Images/9d9b0e9ee4aa1f3533d207b6334bb6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1Pmpmz0QJlnUsJTBwyfCA.png"/></div></div></figure><p id="b955" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有三种方法。一个<strong class="is hj">保存</strong>方法，我们可以传递一个DTO参数，它将映射并保存它。一个<strong class="is hj">保存</strong>方法，我们可以直接传递雇主参数。和一个用于映射的<strong class="is hj"> toEmployer </strong>方法。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jw"><img src="../Images/750c38719edb321d61e33538541f0f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-o0tf-AeGie52uLpmRiyOA.jpeg"/></div></div></figure><p id="25d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我觉得很明显有些东西不在它该在的地方。即使你没有想过，你也会对这些事情有感觉，你只需要练习。</p><p id="a45b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">答案是:toEmployer方法不再属于Repository类。因为我们将它从方法中分离出来，所以现在是免费的，我们可以将它移到一个单独的类中，如下所示:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/2c9b99260299749a3dfa4177163df95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmQKVg3IE7Xj50aokMyglw.png"/></div></div></figure><p id="0ddf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你看，当我们分离方法时，我们不仅得到更小的方法，也得到更小的类。我们只需要将方法分离成逻辑上更小的方法，然后架构“自己”构建。多酷啊。</p><p id="38b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我知道这没什么不同，有人可能会说这毫无意义。但这并不完全正确。这里有三个原因</p><ol class=""><li id="c011" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">有了这种结构，我们有了更多的代码分离——这总是好的。记住——分离应该是有意义的。一会儿，我们会看到一个分离没有意义的例子。</li><li id="1272" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">这里我们有更多的灵活性，因为我们可以保存实体或DTO。</li><li id="9c59" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">这将更容易测试，因为我们可以分别测试实体的保存、DTO的保存和映射。</li></ol><p id="1850" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会说:“你真笨。DTO保存方法又做了两件事，它映射到雇主并进行保存。”。你将是正确的…对于第一个声明。是的，我是个哑巴。但你在第二个陈述上大错特错。你需要知道做多件事的方法和<strong class="is hj">包装方法</strong>之间的区别。</p><h1 id="8a80" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">包装方法</h1><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/cb9a7393aa1a4baae1269bfa65067ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1Upr6Q09IxV55S8HInhTw.jpeg"/></div></div></figure><p id="338d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包装器方法调用两个或更多的方法，并以某种方式组装它们。让所有的方法只做一件事是不可能的，你需要包装方法。您需要编排和管理其他方法的方法。包装方法的一个例子是DTO保存方法。仔细想想，这个方法做了两件事:将DTO映射到一个实体，然后保存它。但这是一个包装方法。它实际上并没有实现这些动作。它只是调用正确的方法来完成工作。它控制着其他人。在模型-视图-控制器设计模式中，这一层称为控制器。控制器的想法是连接模型和视图。这里也一样。</p><p id="d5f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">做多件事的方法是最初的保存方法。请并排查看这两种方法。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/fa89a9886bb1ccbf2fbe5b5e869e0374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6JWOSfBoUOwqDFDnp-dpA.png"/></div></div></figure><p id="be00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看出区别了吗？top方法实现到实体的映射和保存。底层只调用实现这些动作的方法。这两者之间只有一线之隔，知道这一点很重要。</p><h1 id="accf" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我们不应该总是分开</h1><p id="1980" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">现在，我们来看一个没有意义的分离方法。我会用之前的例子，我知道这个例子很愚蠢，就像我的大多数例子一样，但这真的没什么难理解的。我甚至在想我是否应该添加这个，但是你最好知道<strong class="is hj">更小的方法并不意味着更好的方法</strong>:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/72d3cc3c16be5823bbdbfb81ba41b034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiazPbEDIO_UAoA1yM1VyA.png"/></div></div></figure><p id="58de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有和以前一样的保存方法，但是我们把不同的setters分成不同的方法。这太愚蠢了。不要这样。不要以为很多小方法总是更好。动动脑筋。我知道你明白我的意思，但我只是想提一下，以防万一。</p><h1 id="6eaa" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">自我记录的代码</h1><p id="fbc1" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">这种分离的一个非常大的优点是它有助于代码的可读性和文档化。你用不同的方法分离代码片段，并给它们命名。在更高层次的代码中，这使得它看起来更像文档而不是代码。如果你想看这个“文档”的细节，你可以进入内部方法。让我们看一个例子:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/4ba30dda85f5e06fbccf574d473ff139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUYJDmZhBbOTAk9IEAtOGw.png"/></div></div></figure><p id="1895" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一盘棋。方法<strong class="is hj"> startGame </strong>，你可能猜到了，开始游戏。让我们试着阅读代码:</p><p id="37a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们正在打印一些线条。然后我们得到FROM位置，并打印一些消息，之后，我们得到“to位置”。然后我们创建一个新的移动对象，并检查它是否有效。如果是，我们进行移动，如果不是，我们打印一个错误消息。</p><p id="53d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，从一个方法中可以读出很多信息。尤其是第一次看的话。有对方法的调用，打印消息，创建实例，一切都很混乱。乱七八糟。让我们看一个更好的版本:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/78e5cef87e35f276d2564748b5d33e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQdpFeBM9BNAWqsbE6mNsA.png"/></div></div></figure><p id="50ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你看到最上面的方法，你会发现我们没有任何细节。我们对游戏如何运作只有抽象的概念。这甚至可以被非程序员阅读。我们来读一下。</p><p id="4119" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在gameIsRunning、printPlayerTurnMessage和printChoosingFigureMessage时，在读取人物的输入位置和printFigureNewDestinationMessage之后，获取新目的地的位置并将人物移动到新目的地。</p><p id="f081" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了。读起来很好。现在，如果你想看到一些抽象动作的细节，你可以进入方法内部。注意，我们越深入，实现细节就越多。假设我们想看看<strong class="is hj"> move </strong>方法是如何工作的。我们进入它，我们看到——我们创建了一个新的移动对象，然后我们检查它是否有效，如果是，我们就移动，如果不是，我们打印InvalidMoveMessage。你想深入了解吗？我们可以进入<strong class="is hj"> makeMove </strong>方法内部。诸如此类。</p><p id="9398" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，慢慢来，看看最顶级方法之间的区别。你可以挑衅地看看哪个更好。我还强烈建议您比较这两个实现，看看我是如何提取方法的，并研究它们。这将帮助你理解这个想法，并使你的代码更容易阅读和维护。</p><p id="862a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在你离开之前——我们惊人的干净代码课程</strong></p><p id="01bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢这篇文章，你会喜欢我们关于<a class="ae jo" rel="noopener" href="/javarevisited/clean-code-a-must-read-coding-book-for-programmers-9dc80494d27c">干净代码</a>的课程</p><ul class=""><li id="4e36" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn ly ke kf kg bi translated">46场讲座</li><li id="ad05" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn ly ke kf kg bi translated">3小时的内容</li><li id="f50a" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn ly ke kf kg bi translated">做一个真实的项目来测试你的知识</li><li id="1e15" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn ly ke kf kg bi translated">27个可下载资源</li><li id="4a83" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn ly ke kf kg bi translated">30天退款保证</li></ul><p id="477b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在这里注册课程— <a class="ae jo" href="https://rebrand.ly/spcc-medium-small-methods" rel="noopener ugc nofollow" target="_blank">干净的代码:在7天内让你的编程生涯扶摇直上</a></p><figure class="jq jr js jt fd ij er es paragraph-image"><a href="https://rebrand.ly/spcc-medium-small-methods"><div class="er es jp"><img src="../Images/dc9c4358d48d8c1502f7fa18c29da201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*yDVe-HZhy4OdzzOSYdnP6A.png"/></div></a></figure></div></div>    
</body>
</html>