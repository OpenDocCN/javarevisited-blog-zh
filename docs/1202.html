<html>
<head>
<title>Generics in Java explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的泛型解释</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/generics-in-java-explained-10bd559b3a94?source=collection_archive---------1-----------------------#2021-05-01">https://medium.com/javarevisited/generics-in-java-explained-10bd559b3a94?source=collection_archive---------1-----------------------#2021-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a0ca" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">到底什么是泛型？</h2></div><p id="e455" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近，我不得不解释什么是泛型，以及它们在Java语言中是如何使用的。简单地说。几分钟之内。</p><p id="b6e7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我最后说，泛型是一种机制，它允许我们编写不关心它所处理的对象类型的代码，同时给编译器提供足够的信息来保护类型安全。类似于给编译器留下的注释。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/a4ea1b90dcd5329358186bca2217c467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xvlVnWm5Ff0a0ELCMcvGA.jpeg"/></div></div><p class="kf kg et er es kh ki bd b be z dx translated">凯利·西克玛在<a class="ae kj" href="https://unsplash.com/s/photos/placeholder?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="5dac" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">我们不能总是用对象来表示任何类型</h2><p id="49b3" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">让我们从列表的经典例子开始。暂时忘记了<a class="ae kj" href="https://javarevisited.blogspot.com/2016/01/9-difference-between-array-vs-arraylist-in-java.html#axzz6rDtB0US0" rel="noopener ugc nofollow" target="_blank"> List </a>和<a class="ae kj" href="https://javarevisited.blogspot.com/2012/02/difference-between-linkedlist-vs.html#axzz5hP3QBNdL" rel="noopener ugc nofollow" target="_blank"> LinkedList </a>是泛型类型，下面是合法的Java并创建一个包含任何对象类型的列表。</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="e964" class="kk kl hi ll b fi lp lq l lr ls">List myList = new LinkedList();</span></pre><p id="749e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着这是合法的:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="70e4" class="kk kl hi ll b fi lp lq l lr ls">myList.add(“Hello”);</span></pre><p id="cc09" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也是合法的:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="0cfd" class="kk kl hi ll b fi lp lq l lr ls">myList.add(1);</span></pre><p id="091b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种类型的混合感觉可疑。我们还可以写下面的循环吗？</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="951f" class="kk kl hi ll b fi lp lq l lr ls">for (Integer i : myList) System.out.println(i);</span></pre><p id="0720" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不。因为列表没有携带关于它的元素的类型信息，编译器不能验证变量I的每个赋值是否有效。相反，我们必须写:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="0974" class="kk kl hi ll b fi lp lq l lr ls">for (Object i : myList) System.out.println(i);</span></pre><p id="e188" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们打算将每个列表元素作为一个整数来处理，以执行一些算术运算，这就变得很难看:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="8c80" class="kk kl hi ll b fi lp lq l lr ls">for (Object i : myList) System.out.println(((Integer) i) * 2);</span></pre><p id="5f81" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事实上，它变得如此丑陋，以至于任何不是整数的元素都会用一个<a class="ae kj" href="https://javarevisited.blogspot.com/2012/12/how-to-solve-javalangclasscastexception-java.html#axzz6qVaG06bu" rel="noopener ugc nofollow" target="_blank"> ClassCastException </a>使应用程序崩溃。当使用Object来表示某个未知类型时，这就是问题所在:当假设该类型表示什么时，代码会变得脆弱。</p><h2 id="ca28" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">通过使用类型参数修复问题</h2><p id="05be" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">当我们利用<a class="ae kj" href="https://www.java67.com/2019/07/top-50-java-generics-and-collection-interview-questions.html" rel="noopener ugc nofollow" target="_blank">泛型类型</a>并编写以下代码时，这个问题就解决了，因为编译器现在可以为我们做所有的检查:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="f3c6" class="kk kl hi ll b fi lp lq l lr ls">List&lt;Integer&gt; myList = new LinkedList&lt;Integer&gt;()</span><span id="210b" class="kk kl hi ll b fi lt lq l lr ls">myList.add(1);</span><span id="ddf0" class="kk kl hi ll b fi lt lq l lr ls">myList.add(“Hello”); // compiler error: now it is illegal.</span><span id="ca36" class="kk kl hi ll b fi lt lq l lr ls">for (Integer i : myList) System.out.println(i * 2); // beautiful.</span></pre><p id="9409" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以确定这个列表只包含整数。</p><p id="aedc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类型参数首先是编译器的指令。人类同胞排第二。</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="31f3" class="kk kl hi ll b fi lp lq l lr ls">interface SomeCollection&lt;T&gt; {</span><span id="77ad" class="kk kl hi ll b fi lt lq l lr ls">  void add(T element);</span><span id="537a" class="kk kl hi ll b fi lt lq l lr ls">}</span></pre><p id="d299" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们声明一个像上面这样的接口时，我们告诉编译器它必须确保add()方法的参数总是用户代码(T)指定的类型。不管它是什么类型，我们都不在乎，只要它总是一样的！</p><p id="fae7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae kj" href="https://javarevisited.blogspot.com/2012/08/how-to-write-parametrized-class-method-Generic-example.html#axzz6tWnd7QYO" rel="noopener ugc nofollow" target="_blank">泛型类型</a>也可以在方法级别使用。假设我们在某个类中声明了这个函数:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="75e9" class="kk kl hi ll b fi lp lq l lr ls">public &lt;T,R&gt; Optional&lt;R&gt; process(T input, Predicate&lt;T&gt; validator, Function&lt;T,R&gt; processor) {</span><span id="38ea" class="kk kl hi ll b fi lt lq l lr ls">  return validator.test(input)</span><span id="d258" class="kk kl hi ll b fi lt lq l lr ls">    ? Optional.ofNullable(processor.apply(input));</span><span id="0295" class="kk kl hi ll b fi lt lq l lr ls">    : Optional.empty();</span><span id="0577" class="kk kl hi ll b fi lt lq l lr ls">}</span></pre><p id="ac82" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个函数有点复杂，但它仍然是一个合适的例子。这里，我们使用泛型类型告诉编译器两件事:</p><ol class=""><li id="7b1b" class="lu lv hi iz b ja jb jd je jg lw jk lx jo ly js lz ma mb mc bi translated">验证器和处理器必须处理兼容的类型，用t表示。</li><li id="a769" class="lu lv hi iz b ja md jd me jg mf jk mg jo mh js lz ma mb mc bi translated">我们的函数返回一个<a class="ae kj" href="https://javarevisited.blogspot.com/2017/04/10-examples-of-optional-in-java-8.html#axzz6ccm5KWKs" rel="noopener ugc nofollow" target="_blank">可选</a>的实例，包装处理器的返回值，用r表示</li></ol><p id="0b22" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，我们不关心这些是什么类型。我们只想确保它们是兼容的。</p><h2 id="23f8" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">当泛型类型必须有一些标准语义时</h2><p id="f6bc" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">可以使用extends关键字对泛型类型声明进行限制，以公开已知的接口。这样，泛型类型在方法或类中变得有意义和可用。然而，基本概念仍然存在。任何类型都可以用来代替泛型类型，只要它实现指定的接口。</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="ad79" class="kk kl hi ll b fi lp lq l lr ls">class MyWrapper&lt;T extends MyOtherInterface&gt; {</span><span id="0614" class="kk kl hi ll b fi lt lq l lr ls">  // use T in some manner</span><span id="5f8a" class="kk kl hi ll b fi lt lq l lr ls">}</span></pre><h2 id="cf43" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">结论</h2><p id="90fb" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">Java中的泛型类型允许我们编写可以处理不同对象类型的高级代码，而无需知道确切的类型，同时保持类型安全。</p></div></div>    
</body>
</html>