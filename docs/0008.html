<html>
<head>
<title>Zip Symmetry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拉链对称</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/zip-symmetry-a857a934ee26?source=collection_archive---------7-----------------------#2017-10-13">https://medium.com/javarevisited/zip-symmetry-a857a934ee26?source=collection_archive---------7-----------------------#2017-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个关于<a class="ae jd" rel="noopener" href="/@donraab/symmetric-sympathy-2c59d4541d60">对称同情</a>的故事发生在物品和原始收藏品的土地上。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/fffdc9cdacab35e533ea869f9ced1b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjrl-yuxEoiHXVvVj8sNqg.jpeg"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">克里特岛巴洛斯岛</p></figure><p id="67c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今年，我在JavaOne大会上做了一个题为<strong class="ih hj"> <em class="ju"> API Deep Dive:与Nikhil Nanivadekar一起设计Eclipse集合</em></strong>【con 6133】的演讲。我真的很喜欢这次演讲，因为我在45分钟内回顾了12年多的发展历程。这些幻灯片现已在网上<a class="ae jd" href="https://static.rainfocus.com/oracle/oow17/sess/1494212572063001UbJA/PF/JavaOne2017_CON6133_12_1507248789169001TA3b.pptx" rel="noopener ugc nofollow" target="_blank">这里</a>提供。</p><p id="1ec4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对称性继续驱动着<a class="ae jd" href="https://www.eclipse.org/collections/" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>中新特性的设计和实现。在演示的第36张幻灯片上(见下文)，我指出了我们目前在对象集合和基本集合之间缺少一些对称性的地方。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jv"><img src="../Images/bd3eca675493bf4bc5d840953d2393fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5NXdHfz7VnM3WyT-ZZ83IQ.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">原始渴望zip在哪里？</p></figure><p id="5057" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从JavaOne回家后，我决定在哥伦布日为Eclipse集合中的原始渴望列表实现<code class="du jw jx jy jz b">zip</code>。</p><h2 id="b45e" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated">zip是什么？</h2><p id="726c" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">根据<a class="ae jd" href="https://en.wikipedia.org/wiki/Convolution_(computer_science)" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="la lb lc"><p id="e77f" class="if ig ju ih b ii ij ik il im in io ip ld ir is it le iv iw ix lf iz ja jb jc hb bi translated">在计算机科学中，特别是在形式语言中，卷积(有时称为zip)是一种将序列元组映射成元组序列的函数。</p></blockquote><p id="f087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，如果您有两个对象列表，并且您将它们压缩在一起，您将得到一个对象对的列表。</p><p id="18f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个例子，说明如何在Eclipse Collections (EC)中使用<code class="du jw jx jy jz b"><a class="ae jd" href="https://www.eclipse.org/collections/javadoc/9.0.0/org/eclipse/collections/api/list/ListIterable.html#zip-java.lang.Iterable-" rel="noopener ugc nofollow" target="_blank">zip</a></code>进行对象收集。</p><pre class="jf jg jh ji fd lg jz lh li aw lj bi"><span id="9f08" class="ka kb hi jz b fi lk ll l lm ln">MutableList&lt;String&gt; one = Lists.<strong class="jz hj"><em class="ju">mutable</em></strong>.with(<strong class="jz hj">"1"</strong>, <strong class="jz hj">"2"</strong>, <strong class="jz hj">"3"</strong>);<br/>ImmutableList&lt;String&gt; two = Lists.<strong class="jz hj"><em class="ju">immutable</em></strong>.with(<strong class="jz hj">"one"</strong>, <strong class="jz hj">"two"</strong>, <strong class="jz hj">"three"</strong>);<br/>MutableList&lt;Pair&lt;String, String&gt;&gt; zipOneAndTwo = one.zip(two);<br/>ImmutableList&lt;Pair&lt;String, String&gt;&gt; zipTwoAndOne = two.zip(one);</span></pre><p id="d088" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们输出<code class="du jw jx jy jz b">zipOneAndTwo</code>和<code class="du jw jx jy jz b">zipTwoAndOne</code>，它们看起来如下:</p><pre class="jf jg jh ji fd lg jz lh li aw lj bi"><span id="d1f6" class="ka kb hi jz b fi lk ll l lm ln">[1:one, 2:two, 3:three]<br/>[one:1, two:2, three:3]</span></pre><p id="3629" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以把第一个列表改成像这样的<code class="du jw jx jy jz b">Integer</code>对象。</p><pre class="jf jg jh ji fd lg jz lh li aw lj bi"><span id="2e2a" class="ka kb hi jz b fi lk ll l lm ln">MutableList&lt;Integer&gt; one = Lists.<strong class="jz hj"><em class="ju">mutable</em></strong>.with(1, 2, 3);<br/>ImmutableList&lt;String&gt; two = Lists.<strong class="jz hj"><em class="ju">immutable</em></strong>.with(<strong class="jz hj">"one"</strong>, <strong class="jz hj">"two"</strong>, <strong class="jz hj">"three"</strong>);<br/>MutableList&lt;Pair&lt;Integer, String&gt;&gt; zipOneAndTwo = one.zip(two);<br/>ImmutableList&lt;Pair&lt;String, Integer&gt;&gt; zipTwoAndOne = two.zip(one);</span></pre><p id="5257" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们仍然得到相同的输出，因为<code class="du jw jx jy jz b">Pair</code>如何定义<code class="du jw jx jy jz b">toString()</code>。</p><pre class="jf jg jh ji fd lg jz lh li aw lj bi"><span id="601b" class="ka kb hi jz b fi lk ll l lm ln">[1:one, 2:two, 3:three]<br/>[one:1, two:2, three:3]</span></pre><p id="4910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我讨厌将整数装箱。我希望能够使用<code class="du jw jx jy jz b">IntList</code>而不是<code class="du jw jx jy jz b">Integer</code>对象的<code class="du jw jx jy jz b">List</code>。以前在EC里，我们不能把<code class="du jw jx jy jz b">Integer</code>的<code class="du jw jx jy jz b">MutableList</code>改成<code class="du jw jx jy jz b">MutableIntList</code>。现在我们可以了，但是这个新能力凸显了一个小问题。</p><pre class="jf jg jh ji fd lg jz lh li aw lj bi"><span id="1872" class="ka kb hi jz b fi lk ll l lm ln">MutableIntList one = IntLists.<strong class="jz hj"><em class="ju">mutable</em></strong>.with(1, 2, 3);<br/>ImmutableList&lt;String&gt; two = Lists.<strong class="jz hj"><em class="ju">immutable</em></strong>.with(<strong class="jz hj">"one"</strong>, <strong class="jz hj">"two"</strong>, <strong class="jz hj">"three"</strong>);<br/>MutableList&lt;IntObjectPair&lt;String&gt;&gt; zipOneAndTwo = one.zip(two);</span><span id="587a" class="ka kb hi jz b fi lo ll l lm ln">// The following code does not compile<br/><strong class="jz hj"><em class="ju">ImmutableList&lt;ObjectIntPair&lt;String&gt;&gt; zipTwoAndOne = two.zip(one);</em></strong></span></pre><p id="1a78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用下面的签名向原语列表添加了一个方法<code class="du jw jx jy jz b">zip</code>(下面以<code class="du jw jx jy jz b">IntList</code>为例)。</p><pre class="jf jg jh ji fd lg jz lh li aw lj bi"><span id="bd42" class="ka kb hi jz b fi lk ll l lm ln"><em class="ju">/**<br/> * Returns a {</em><strong class="jz hj"><em class="ju">@code </em></strong><em class="ju">MutableList} formed from this {</em><strong class="jz hj"><em class="ju">@code </em></strong><em class="ju">MutableIntList} and a {</em><strong class="jz hj"><em class="ju">@code </em></strong><em class="ju">ListIterable} by<br/> * combining corresponding elements in pairs. If one of the two Lists is longer than the other, its<br/> * remaining elements are ignored.<br/> *<br/> * </em><strong class="jz hj"><em class="ju">@since </em></strong><em class="ju">9.1.<br/> */<br/></em>default &lt;T&gt; MutableList&lt;IntObjectPair&lt;T&gt;&gt; zip(ListIterable&lt;T&gt; list)</span></pre><p id="2913" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jw jx jy jz b">zip</code>我们还不能用一个原语链表来表示一个对象链表。通过在一个方向(图元+对象)上添加一个特征，我发现(或创建)了在另一个方向(对象+图元)上缺乏对称性。</p><h2 id="153b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated">代码生成器的一小步…</h2><p id="024a" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我们可以将两个对象列表压缩在一起，而不考虑对象类型，所以我希望至少能够压缩两个int列表、两个double列表、两个short列表等。除此之外，现在还可以用一个对象列表压缩一个原语列表。因此，下面的签名也包含在内，并且今天生成了代码(下面的例子是<code class="du jw jx jy jz b">IntList</code>上的<code class="du jw jx jy jz b">zipInt</code>)。还为<code class="du jw jx jy jz b">DoubleList</code>生成了一个方法<code class="du jw jx jy jz b">zipDouble</code>，为<code class="du jw jx jy jz b">FloatList</code>生成了<code class="du jw jx jy jz b">zipFloat</code>，以此类推。我使用了一种命名模式，这种模式可以很容易地允许以后添加额外的表单，如果出现了它们的用例的话。</p><pre class="jf jg jh ji fd lg jz lh li aw lj bi"><span id="5f94" class="ka kb hi jz b fi lk ll l lm ln"><em class="ju">/**<br/> * Returns a {</em><strong class="jz hj"><em class="ju">@code </em></strong><em class="ju">MutableList} formed from this {</em><strong class="jz hj"><em class="ju">@code </em></strong><em class="ju">MutableIntList} and another {</em><strong class="jz hj"><em class="ju">@code </em></strong><em class="ju">IntList} by<br/> * combining corresponding elements in pairs. If one of the two {</em><strong class="jz hj"><em class="ju">@code </em></strong><em class="ju">IntList}s is longer than the other, its<br/> * remaining elements are ignored.<br/> *<br/> * </em><strong class="jz hj"><em class="ju">@since </em></strong><em class="ju">9.1.<br/> */<br/></em>default MutableList&lt;IntIntPair&gt; zipInt(IntList list)</span></pre><p id="9463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个使用方法<code class="du jw jx jy jz b">zipInt</code>将两个<code class="du jw jx jy jz b">IntLists</code>压缩在一起的例子。</p><pre class="jf jg jh ji fd lg jz lh li aw lj bi"><span id="20eb" class="ka kb hi jz b fi lk ll l lm ln">MutableIntList one = IntLists.<strong class="jz hj"><em class="ju">mutable</em></strong>.with(1, 2, 3);<br/>ImmutableIntList two = IntLists.<strong class="jz hj"><em class="ju">immutable</em></strong>.with(10, 20, 30);<br/>MutableList&lt;IntIntPair&gt; zipOneAndTwo = one.zipInt(two);<br/>ImmutableList&lt;IntIntPair&gt; zipTwoAndOne = two.zipInt(one);</span></pre><p id="e0ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我输出两个压缩列表，结果如下:</p><pre class="jf jg jh ji fd lg jz lh li aw lj bi"><span id="9228" class="ka kb hi jz b fi lk ll l lm ln">[1:10, 2:20, 3:30]<br/>[10:1, 20:2, 30:3]</span></pre><p id="aa0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以将八种形式的原语列表压缩到对象列表中。我们也可以压缩原语列表的“like”形式(<code class="du jw jx jy jz b">IntList</code>-&gt;-<code class="du jw jx jy jz b">zipInt</code>、<code class="du jw jx jy jz b">DoubleList</code>-&gt;-<code class="du jw jx jy jz b">zipDouble</code>)，等等。).我希望这个功能在可预见的将来能够满足大多数需求。</p><h2 id="62a1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated">北方记得</h2><p id="d398" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">对称不忘，在缺失和需要的时候，开发者总不会轻易原谅。为了对称而达到完美的对称是徒劳的。如果你发现自己在这个领域需要更多的对称性，记住<a class="ae jd" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> Eclipse Collections是开源的</a>。您可以提出请求，也许有人会代表您实现它，但是最快的完成方式可能是积极参与Eclipse集合社区并做出贡献。如果您有兴趣投稿，我们将确保您获得所需的所有帮助。</p><h2 id="442b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated">续集？</h2><p id="e376" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">今天我们在Eclipse集合中有zip，但是我们还没有它的自然对应物:<em class="ju"> unzip </em>。Unzip将接受一个对列表，返回一对列表。Unzip只在对象集合端有意义，因为您只能解压缩一组对。听起来很简单，对吗？现在zip中支持的原语使得Unzip的定义更加复杂。如果你有一个<code class="du jw jx jy jz b">Pair</code>的<code class="du jw jx jy jz b">List</code>，你会得到一个<code class="du jw jx jy jz b">Lists</code>的<code class="du jw jx jy jz b">Pair</code>。如果你有一个<code class="du jw jx jy jz b">ObjectIntPair</code>的<code class="du jw jx jy jz b">List</code>，你会想要得到一个<code class="du jw jx jy jz b">List</code>的<code class="du jw jx jy jz b">Pair</code>和<code class="du jw jx jy jz b">IntList</code> …等等。unzip的返回类型很难定义，至少不会使API变得复杂，因为它不需要任何参数。我认为在试图解决这个对称问题之前，我们应该等待一段时间。然而，有一种模式是非常好的，一旦我们有了它，可能会使使用zip变得不那么有吸引力。这个格局就是<code class="du jw jx jy jz b">collectWithIndex</code>。我们今天有<code class="du jw jx jy jz b">forEachWithIndex</code>和<code class="du jw jx jy jz b">injectIntoWithIndex</code>(仅限原语)。哦，不...敬请关注。</p><p id="9d7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望我的对称同情故事的最新章节是有趣的和有启发性的。</p><p id="ffbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="ju">月食收藏</em> </a> <em class="ju">是开作</em> <a class="ae jd" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="ju">投稿</em> </a> <em class="ju">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p><p id="7231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">你可能喜欢的其他文章:</strong></p><div class="lp lq ez fb lr ls"><a rel="noopener follow" target="_blank" href="/javarevisited/what-next-for-senior-developers-in-tech-project-manager-technical-architect-or-a-devops-engineer-b532a80c9ba1"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">高科技领域的高级开发人员接下来会做什么？项目经理、技术架构师或DevOps工程师</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">是时候考虑职业生涯的下一个层次了。</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">medium.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg jo ls"/></div></div></a></div><div class="lp lq ez fb lr ls"><a rel="noopener follow" target="_blank" href="/javarevisited/what-java-programmers-should-learn-in-2020-648050533c83"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">2020年Java程序员该学什么？</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">2020年Java程序员可以学习的有用工具、技术、框架和库</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">medium.com</p></div></div><div class="mb l"><div class="mh l md me mf mb mg jo ls"/></div></div></a></div><div class="lp lq ez fb lr ls"><a rel="noopener follow" target="_blank" href="/javarevisited/top-5-courses-to-learn-microservices-in-java-and-spring-framework-e9fed1ba804d"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">学习Java和Spring框架中微服务的7大课程</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">微服务是软件开发领域的新术语，尤其是在Java方面，但它已经在实践中…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">medium.com</p></div></div><div class="mb l"><div class="mi l md me mf mb mg jo ls"/></div></div></a></div></div></div>    
</body>
</html>