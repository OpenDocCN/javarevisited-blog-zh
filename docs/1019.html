<html>
<head>
<title>Reactive Programming basics in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的反应式编程基础</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/reactive-programming-basics-in-java-part-1-557989b13c8f?source=collection_archive---------1-----------------------#2021-02-21">https://medium.com/javarevisited/reactive-programming-basics-in-java-part-1-557989b13c8f?source=collection_archive---------1-----------------------#2021-02-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7615" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我开始学习反应式编程时，我发现这里和那里有很多重要的概念，所以想做笔记，后来意识到为什么不把它作为博客发表。所以给你，</p><h2 id="06e1" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">Java中什么是反应式编程？</strong></h2><p id="ff25" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">反应式编程是一种编程范式，它提倡异步、非阻塞、事件驱动的数据处理方法。</p><p id="2ac7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">术语“反应式”指的是围绕对变化做出反应而构建的编程模型——网络组件对I/O事件做出反应，UI控制器对鼠标事件做出反应，等等。</p><p id="163d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这个意义上说，非阻塞是被动的，因为我们现在不是被阻塞，而是在操作完成或数据可用时对通知做出反应。</p><h2 id="ff9b" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">什么是单声道和通量？</strong></h2><p id="4cc2" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Mono和Flux都是出版商。在java中，两者都是从CorePublisher实现的，CorePublisher是从Publisher扩展而来的。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kd"><img src="../Images/bb614c6f04e47255c3b263c55069ab17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*YCuuxQ8Fm0P5jW8IkyAE5A.png"/></div><p class="kl km et er es kn ko bd b be z dx translated">Flux实现CorePublisher</p></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/04/best-reactive-spring-and-webflux-courses-for-java-developers.html"><div class="er es kp"><img src="../Images/bf1c09e0dd7f2c55e5caa193d1a0b3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*39zMWOnk-_ugn27OQVwfJQ.png"/></div></a><p class="kl km et er es kn ko bd b be z dx translated">核心发布者扩展发布者</p></figure><p id="3c6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Flux是发布零个或多个值的发布器，Mono发布零个或一个值。</p><p id="90d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kq">现在让我们看一些例子</em></p><p id="5b95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是通量的例子，</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kr"><img src="../Images/8c0304cec6577dc98ae7fff150897d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxpzylMfPoUOewcLyir1-Q.png"/></div></div></figure><p id="8471" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让数据流动，你必须订阅，没有订阅，数据永远不会流动。默认情况下，流是懒惰的，这意味着没有你消费什么都不会执行。</p><p id="a572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出</strong></p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kw"><img src="../Images/61f784df2feafb5a2e05ce18458187c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyIpE-pAjHgLv3LaLB5chA.png"/></div></div></figure><p id="fbf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而<a class="ae kx" rel="noopener" href="/javarevisited/7-best-webflux-and-reactive-spring-boot-courses-for-java-programmers-33b7c6fa8995">通量</a>可以无限大。我们可以利用像takeUntil或take to stop这样的函数。</p><p id="8c7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">takeUntil的用法</p><pre class="ke kf kg kh fd ky kz la lb aw lc bi"><span id="d6c7" class="jd je hi kz b fi ld le l lf lg">Flux.<em class="kq">fromIterable</em>(lists).takeUntil(s -&gt; s.equalsIgnoreCase("End")).subscribe(System.<em class="kq">out</em>::println);</span></pre><h2 id="aa5f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">什么是发布和订阅？</strong></h2><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lh"><img src="../Images/c703a7a85a90a4d858e4005b73f0deea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*AC66hK3pjR41XD27-XTNUA.png"/></div></figure><p id="85da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">publishOn &amp; subscribeOn是Project Reactor中方便的方法，它接受任何调度程序来更改反应管道中操作的任务执行上下文。subscribeOn强制源排放使用特定的调度程序，publishOn为所有下游操作更改调度程序。</p><p id="17a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">发布</strong>示例:</p><pre class="ke kf kg kh fd ky kz la lb aw lc bi"><span id="28b6" class="jd je hi kz b fi ld le l lf lg">Flux&lt;Integer&gt; flux = Flux.<em class="kq">range</em>(0, 2)<br/>        .publishOn(Schedulers.<em class="kq">parallel</em>())<br/>        .map(i -&gt; {<br/>            System.<em class="kq">out</em>.println("First Block Thread : " + Thread.<em class="kq">currentThread</em>().getName());<br/>            return i;<br/>        }).map(i-&gt; {<br/>            System.<em class="kq">out</em>.println("Second Block Thread : " + Thread.<em class="kq">currentThread</em>().getName());<br/>            return i;<br/>        });<br/><br/>flux.subscribe();<br/>Thread.<em class="kq">sleep</em>(1000);</span></pre><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es li"><img src="../Images/b3090f7375c77cde08ce0a724cb22cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbwIXlWRqxEtCfxnVvmMLA.png"/></div></div></figure><p id="1803" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，上述示例在<strong class="ih hj">发布</strong>之后，所有操作都在同一线程上运行，直到我们看到另一个发布，当我们看到遇到发布方法时，它会更改上下文并在单独的线程中运行(基于提到的调度程序)。</p><p id="15cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">订阅</strong>示例:</p><pre class="ke kf kg kh fd ky kz la lb aw lc bi"><span id="e330" class="jd je hi kz b fi ld le l lf lg">Flux&lt;Integer&gt; flux = Flux.<em class="kq">range</em>(0, 2)<br/>        .subscribeOn(Schedulers.<em class="kq">boundedElastic</em>())<br/>        .map(i -&gt; {<br/>            System.<em class="kq">out</em>.println("First Block Thread : " + Thread.<em class="kq">currentThread</em>().getName());<br/>            return i;<br/>        }).<br/>        subscribeOn(Schedulers.<em class="kq">single</em>())<br/>      .map(i-&gt; {<br/>            System.<em class="kq">out</em>.println("Second Block Thread : " + Thread.<em class="kq">currentThread</em>().getName());<br/>            return i;<br/>        });<br/><br/>flux.subscribe();<br/>Thread.<em class="kq">sleep</em>(1000);</span></pre><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lj"><img src="../Images/d3eea42c78b661f437e8ee1158eb04f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wQxGTQhaAXXEkyoOfK5Pw.png"/></div></div></figure><p id="6c6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，即使我们已经定义了多个subscribe方法(一个是<em class="kq">bounde lastic，另一个是single scheduler) </em>只有靠近源的第一个subscribe方法优先。</p><p id="35fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong> <em class="kq">我们可以有多个发布方法，这些方法会不断切换上下文。然而，subscribeOn方法不能这样做。只有靠近源的第一个subscribeOn方法优先。</em></p><h2 id="78ba" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">什么是调度程序及其类型？</strong></h2><p id="c242" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">一个<code class="du lk ll lm kz b">Scheduler</code>是给用户控制<a class="ae kx" href="https://javarevisited.blogspot.com/2014/07/top-50-java-multithreading-interview-questions-answers.html#axzz6hX6XfwBD" rel="noopener ugc nofollow" target="_blank">线程</a>的抽象。它主要有四种类型，或者你也可以选择编写自己的调度程序。</p><ol class=""><li id="8d93" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated">Schedulers.single() —用于所有调用方的单个可重用线程。</li><li id="3ef0" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">Schedulers.immediate() —保持在当前线程中执行。</li><li id="5f67" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">schedulers . bounde lastic()—与Elastic相同，但它的线程池大小(10 * CPU核心数)，是IO操作/非阻塞调用的好选择。</li><li id="8339" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">Schedulers.parallel() —适用于CPU密集型的短期任务。它可以并行执行<code class="du lk ll lm kz b">N</code>这样的任务(默认情况下N = =数量)</li></ol><h2 id="bf7f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Schedulers.elastic() —这是一个具有无限线程的线程池，不再是首选。</h2><p id="fba5" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">重要参考:</p><ol class=""><li id="681e" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated"><a class="ae kx" href="https://spring.io/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape" rel="noopener ugc nofollow" target="_blank">https://spring . io/blog/2016/06/07/notes-on-reactive-programming-part-I-the-reactive-landscape</a></li><li id="da98" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><a class="ae kx" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-framework/docs/current/reference/html/we B- reactive . html</a></li><li id="1763" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><a class="ae kx" href="https://spring.io/blog/2019/12/13/flight-of-the-flux-3-hopping-threads-and-schedulers" rel="noopener ugc nofollow" target="_blank">https://spring . io/blog/2019/12/13/flight-of-the-flux-3-hopping-threads-and-schedulers</a></li></ol></div></div>    
</body>
</html>