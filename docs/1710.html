<html>
<head>
<title>Distributed Tracing with Spring Boot and Jaeger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot和耶格的分布式追踪</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/distributed-tracing-with-spring-boot-and-jaeger-619bcc13b0c4?source=collection_archive---------0-----------------------#2021-11-08">https://medium.com/javarevisited/distributed-tracing-with-spring-boot-and-jaeger-619bcc13b0c4?source=collection_archive---------0-----------------------#2021-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ad2fe0147bc2269636af538ed0ede3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vp31QYxHKlLLOpy5ZOsAig.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">Spring Boot和耶格的分布式追踪</p></figure><h1 id="0759" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="3561" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">分布式跟踪提供了对请求通过系统时的流程和生命周期的洞察。现代平台可能被分割成许多不同的独立服务，所有这些都可能有助于产生最终结果。在微服务风格的架构中，单个客户端请求可能会产生大量后续请求到各种不同的区域组件中，这些组件又可能会执行额外的下游请求。此外，这可能不是通过相同的协议— <code class="du kq kr ks kt b">HTTP</code>经由<code class="du kq kr ks kt b">RESTful</code>端点，可能是各种类型的队列等。由于每个组件的日志都是独立的，因此当事件流过不同区域时，跟踪一系列事件会非常困难和耗时。</p><p id="fda8" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">我们已经理解了微服务中对分布式跟踪的需求。但是我们需要一些工具来实现它。Jaeger是一个分布式追踪平台——最初由优步开发。它用于对基于微服务的架构进行监控和故障排除。它有一个很好的用户界面，清楚地显示了完整的请求细节&amp;处理时间等。</p><p id="04cf" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated"><strong class="ju hj"> <em class="la">文章中使用的技术:</em> </strong></p><ul class=""><li id="e38a" class="lb lc hi ju b jv ku jz kv kd ld kh le kl lf kp lg lh li lj bi translated">春季开机版本:2.5.6</li><li id="4fc8" class="lb lc hi ju b jv lk jz ll kd lm kh ln kl lo kp lg lh li lj bi translated">贼鸥</li><li id="716b" class="lb lc hi ju b jv lk jz ll kd lm kh ln kl lo kp lg lh li lj bi translated">Java版本1.8</li></ul></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="17ab" class="iu iv hi bd iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr bi translated">创建一个弹簧引导应用程序</h1><p id="d24c" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">使用所需的依赖项创建一个spring boot应用程序。添加spring boot starter web依赖项。此外，将jaeger依赖项包含到spring boot应用程序的pom XML配置文件中。</p><p id="b530" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">下面是pom.xml文件的完整内容。</p><p id="fcbb" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated"><strong class="ju hj"> <em class="la"> pom.xml </em> </strong></p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="e2a0" class="mj iv hi kt b fi mk ml l mm mn">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;project ae kz" href="http://maven.apache.org/POM/4.0.0" rel="noopener ugc nofollow" target="_blank"&gt;http://maven.apache.org/POM/4.0.0"<br/> xmlns:xsi="<a class="ae kz" href="http://www.w3.org/2001/XMLSchema-instance" rel="noopener ugc nofollow" target="_blank">http://www.w3.org/2001/XMLSchema-instance</a>"<br/> xsi:schemaLocation="<a class="ae kz" href="http://maven.apache.org/POM/4.0.0" rel="noopener ugc nofollow" target="_blank">http://maven.apache.org/POM/4.0.0</a> <a class="ae kz" href="https://maven.apache.org/xsd/maven-4.0.0.xsd" rel="noopener ugc nofollow" target="_blank">https://maven.apache.org/xsd/maven-4.0.0.xsd</a>"&gt;<br/> &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/> &lt;parent&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br/>  &lt;version&gt;2.5.6&lt;/version&gt;<br/>  &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;<br/> &lt;/parent&gt;<br/> &lt;groupId&gt;com.example.demo.jaeger&lt;/groupId&gt;<br/> &lt;artifactId&gt;spring-boot-distributed-trace-jaeger&lt;/artifactId&gt;<br/> &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br/> &lt;name&gt;spring-boot-distributed-trace-jaeger&lt;/name&gt;<br/> &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;<br/> &lt;properties&gt;<br/>  &lt;java.version&gt;1.8&lt;/java.version&gt;<br/> &lt;/properties&gt;<br/> &lt;dependencies&gt;<br/>  &lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;<br/>  &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>   &lt;groupId&gt;io.opentracing.contrib&lt;/groupId&gt;<br/>   &lt;artifactId&gt;opentracing-spring-jaeger-cloud-starter&lt;/artifactId&gt;<br/>   &lt;version&gt;3.3.1&lt;/version&gt;<br/>  &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>  &lt;/dependency&gt;<br/>  &lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br/>   &lt;scope&gt;test&lt;/scope&gt;<br/>  &lt;/dependency&gt;<br/> &lt;/dependencies&gt;</span><span id="975a" class="mj iv hi kt b fi mo ml l mm mn">&lt;build&gt;<br/>  &lt;plugins&gt;<br/>   &lt;plugin&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br/>   &lt;/plugin&gt;<br/>  &lt;/plugins&gt;<br/> &lt;/build&gt;</span><span id="e634" class="mj iv hi kt b fi mo ml l mm mn">&lt;/project&gt;</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="0019" class="iu iv hi bd iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr bi translated">添加控制器类</h1><p id="5ded" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">创建一个名为<strong class="ju hj">控制器</strong>的REST API类，并添加以下内容。</p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="c613" class="mj iv hi kt b fi mk ml l mm mn">@RestController<br/>@RequestMapping("/hello")<br/>public class Controller {</span><span id="2f38" class="mj iv hi kt b fi mo ml l mm mn">private static final Logger logger = LoggerFactory.getLogger(Controller.class);<br/>    <br/>private RestTemplate restTemplate;</span><span id="62c5" class="mj iv hi kt b fi mo ml l mm mn">@Value("${spring.application.name}")<br/>    private String applicationName;</span><span id="539d" class="mj iv hi kt b fi mo ml l mm mn">public Controller(RestTemplate restTemplate) {<br/>        this.restTemplate = restTemplate;<br/>    }</span><span id="4266" class="mj iv hi kt b fi mo ml l mm mn">@GetMapping("/path1")<br/>    public ResponseEntity&lt;String&gt;  path1() {</span><span id="5088" class="mj iv hi kt b fi mo ml l mm mn">logger.info("Incoming request at {} for request /path1 ", applicationName);<br/>        String response = restTemplate.getForObject("http://localhost:8090/hello/path2", String.class);<br/>        return ResponseEntity.ok("response from /path1 + " + response);<br/>    }</span><span id="925e" class="mj iv hi kt b fi mo ml l mm mn">@GetMapping("/path2")<br/>    public ResponseEntity&lt;String&gt;  path2() {<br/>        logger.info("Incoming request at {} at /path2", applicationName);<br/>        return ResponseEntity.ok("response from /path2 ");<br/>    }<br/>}</span></pre><p id="3013" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">控制器公开一个带有端点<strong class="ju hj"> /hello/path1 </strong>的GET API，并返回计算出的path1响应。类似地，另一个GET API使用端点<strong class="ju hj"> /hello/path2 </strong>并返回计算出的path2响应。</p><p id="e4fb" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">这里，我们有两个端点<code class="du kq kr ks kt b">/path1</code>和<code class="du kq kr ks kt b">/path2</code>。这里的想法是使用同一个应用程序的两个实例，这样<code class="du kq kr ks kt b">/path1</code>在固定端口8090调用另一个服务的<code class="du kq kr ks kt b">/path2</code>。</p><p id="65f5" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">为了让spans连接到同一个trace id，我们需要创建一个RestTemplate bean来允许Jaeger包含一个拦截器。这有助于向传出请求添加跟踪，这将有助于跟踪整个请求。</p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="6ad5" class="mj iv hi kt b fi mk ml l mm mn">@Bean<br/>   public RestTemplate restTemplate(RestTemplateBuilder builder) {<br/>      return builder.build();<br/>   }</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="7c64" class="iu iv hi bd iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr bi translated">Docker撰写</h1><p id="95d6" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">让我们使用docker在本地启动一个Jaeger服务器。为此，我用端口映射创建了一个docker-compose文件。</p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="3d86" class="mj iv hi kt b fi mk ml l mm mn">version: "3.3"<br/>services:<br/>  jaeger-allinone:<br/>    image: jaegertracing/all-in-one:1.25<br/>    ports:<br/>      - 6831:6831/udp<br/>      - 6832:6832/udp<br/>      - 16686:16686<br/>      - 14268:14268</span></pre><p id="852a" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">我们可以通过UDP或TCP与Jaeger通信。使用<code class="du kq kr ks kt b">docker-compose up</code>启动docker映像后，我们可以使用URL<a class="ae kz" href="http://localhost:16686/" rel="noopener ugc nofollow" target="_blank">http://localhost:16686/</a>访问UI</p><p id="34df" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">现在，让我们添加一些属性，允许应用程序将跟踪发送到Jaeger服务器。我们将通过TCP进行通信，所以请确保我们将跟踪发送到另一个TCP端口。即14268</p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="181c" class="mj iv hi kt b fi mk ml l mm mn">opentracing:<br/>  jaeger:<br/>    http-sender:<br/>      url: http://localhost:14268/api/traces</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="b33d" class="iu iv hi bd iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr bi translated">正在启动服务1</h1><p id="5dbc" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">让我们用下面的命令启动“服务器1”。</p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="46bf" class="mj iv hi kt b fi mk ml l mm mn">java -jar target/spring-boot-distributed-trace-jaeger-0.0.1-SNAPSHOT.jar --spring.application.name=Service-1 --server.port=8080</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="eaee" class="iu iv hi bd iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr bi translated">启动服务2</h1><p id="4480" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在不同的终端上，运行与“服务2”相同的应用程序的新实例，如下所示</p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="d80f" class="mj iv hi kt b fi mk ml l mm mn">java -jar target/spring-boot-distributed-trace-jaeger-0.0.1-SNAPSHOT.jar --spring.application.name=Service-2 --server.port=8090</span></pre><p id="b029" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">一旦应用程序启动，在<code class="du kq kr ks kt b">/path1</code>调用“服务1”，如下所示</p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="e751" class="mj iv hi kt b fi mk ml l mm mn">curl -i <a class="ae kz" href="http://localhost:8080/service/path1" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/hello/path1</a></span></pre><p id="7360" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">我们来看看“服务1”的日志。</p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="7d53" class="mj iv hi kt b fi mk ml l mm mn">INFO 16636 --- [nio-8080-exec-2] i.j.internal.reporters.LoggingReporter   : Span reported: b7c9ce2661df9d7c:c3b96d4fbeb65d4a:b7c9ce2661df9d7c:1 - GET</span></pre><p id="38aa" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">跟踪的格式为[ <strong class="ju hj"> <em class="la">、根跨度Id、当前跨度Id、父跨度Id </em> </strong> ]。在这种情况下，由于“服务1”是源服务，父span Id“b 7 c 9 ce 2661 df 9d 7 c”也是根span Id。</p><p id="aa0c" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">现在，我们来看看“服务2”的日志。</p><pre class="mb mc md me fd mf kt mg mh aw mi bi"><span id="3839" class="mj iv hi kt b fi mk ml l mm mn">INFO 22732 --- [nio-8090-exec-1] i.j.internal.reporters.LoggingReporter   : Span reported: b7c9ce2661df9d7c:bf420c75d1105309:c3b96d4fbeb65d4a:1 - path2</span></pre><p id="d3e6" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">这里我们看到中间值是当前span id和父span id(即第三个值“C3 b 96d 4 FBE 65d 4 a”)是“服务1”的span id。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="e979" class="iu iv hi bd iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr bi translated">Jaeger UI</h1><p id="04af" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">现在，如果您打开UI，您将看到以下内容。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/0c75eb3f5122d672e99fdcc4d71058e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfC4yJfAnADVqegpv32AJw.png"/></div></div></figure><p id="7961" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">当我们深入挖掘时，我们会看到每个跨度的更多细节。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/4ed5b12f428ce48143609c5a0bbee689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MK2zc24VrEdAlSm0_t9Lww.png"/></div></div></figure><p id="b157" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">这里，根跨度id“b 7 c 9 ce 2661 df 9d 7 c”跨越整个请求。另外两个span ids指的是单独的服务。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="b692" class="iu iv hi bd iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr bi translated">结论</h1><p id="51a3" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我们探索了如何将基于OpenTracing的Jaeger与spring boot应用程序集成。</p><p id="00a1" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">这篇文章的代码可以在<a class="ae kz" href="https://github.com/reachansari/spring-boot-distributed-trace-jaeger" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="1cca" class="pw-post-body-paragraph js jt hi ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp hb bi translated">快乐编码..</p></div></div>    
</body>
</html>