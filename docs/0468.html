<html>
<head>
<title>Java Concepts in light of interviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">访谈中的Java概念</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-concepts-in-light-of-interviews-1b3e41c20ac2?source=collection_archive---------1-----------------------#2020-06-01">https://medium.com/javarevisited/java-concepts-in-light-of-interviews-1b3e41c20ac2?source=collection_archive---------1-----------------------#2020-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7179" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文将针对我在采访中问到的那些问题解释Java概念。</p><h2 id="5bde" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Q1。两个相等的对象可以有不同的哈希码吗？</h2><p id="9837" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">答案是否定的。为了解释这一点，我们必须看看Java数据结构的内部工作原理。java中的每个对象都继承了两个方法。</p><ol class=""><li id="48e0" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">哈希码()</li><li id="747c" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">等于()</li></ol><p id="119c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“equals()”方法用于比较两个对象。例如，为了比较两个字符串“str1”和“str2”，可以在Java中使用equals，如str1.equals(str2)。“hashcode()”方法返回的哈希代码只是一个整数。像HashMap和HashSet这样的数据结构使用哈希代码来标识存储桶。例如，默认情况下，最初在一个HashSet中有16个桶。所以一个HashSet将使用哈希码的模数除以桶的总数(哈希码% 16)来标识桶号。如果一个对象的散列码是20，那么HashSet将把这个对象放在第4个桶中(20 % 16 = 4)。如果使用“add”方法将两个具有相同散列码的对象放入HashSet中，那么HashSet会将它们放入同一个桶中，并在它们之间创建一个链表。类似地,“get”方法也将通过上述过程识别桶，但是为了从链表中检索对象，它将遍历链表并对每个对象调用equals。如果equals方法返回true，它将返回该对象。</p><p id="3764" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果两个相等的对象有不同的散列码，那么HashSet可能会将它们放在不同的桶中，这将导致HashSet的错误行为。</p><p id="7464" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题还有其他的变体。</p><p id="bf6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">两个不相等的对象可以有相同的哈希码吗？</em> </strong>答案是肯定的。</p><p id="5353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">两个相等的对象必须有相同的哈希码吗？</em> </strong>答案是肯定的。它是Java中的一个虚拟契约，不应该被破坏，否则插入和检索(get)将不能用于HashSet和HashMap。</p><p id="6c86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，这个问题有各种各样的变体，在回答这个问题之前，你必须考虑HashSet或HashMap的工作原理。当面试官问这个问题的时候，暂停一下，按照上面解释的逻辑，你会得到你的答案。</p><h2 id="ab96" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">ArrayList和LinkedList有什么区别？</h2><p id="0ca3" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">当问及与数据结构相关的问题时，考虑插入、检索(get)和删除操作。</p><p id="73fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数组列表中的插入:</strong>在数组列表中，最坏情况下插入复杂度为O(n)次，一般情况下为O(1)次。默认情况下，Java中ArrayList的大小是10。如果ArrayList达到了它的最大容量，并希望插入一个额外的第11个元素，它将创建一个更大的新ArrayList，并将原始列表中的所有元素复制到新列表中。该操作的时间复杂度为O(n)。但是平均来说，插入需要O(1)时间，因为ArrayList保存了一个大小变量，该变量存储了列表中插入项的数量，当需要向ArrayList中插入额外的项时，它只需要在索引等于数组大小的单元格处插入。</p><p id="d373" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在数组列表中检索:</strong>在数组列表中获取一个带索引的对象需要O(1)时间。</p><p id="0964" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在数组列表中删除:</strong>从数组列表中删除需要O(n)时间，因为需要移动元素。</p><p id="e604" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">linked list中的插入:</strong>linked list中的插入花费O(1)时间，因为只需要更新指向下一个元素的指针。</p><p id="2a2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">LinkedList中的检索:</strong>从LinkedList中获取带有索引的对象需要O(n)时间，因为它必须遍历linked list才能到达某个索引。</p><p id="b91b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">LinkedList中的删除:</strong>linked list中的删除也需要O(n)时间，因为它必须遍历linked list才能到达某个索引。此外，LinkedList具有removeFirst和removeLast方法，这需要O(1)时间，因为只需要调整第一个和最后一个指针，并且不需要像ArrayList那样进行移位操作。</p><h2 id="a289" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Q3)什么时候应该使用ArrayList或LinkedList？</h2><p id="c81b" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">如果插入比读取多，那么我们应该使用LinkedList，否则我们应该使用ArrayList。</p><h2 id="cf54" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Q4)Java中有多少种异常？</h2><p id="f0f9" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">主要有两种例外</p><ol class=""><li id="28bb" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">检查异常</li><li id="26c8" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">未检查的异常</li></ol><p id="7e2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">IOException或ClassNotFound异常是检查异常的示例，因为它们可以在编译时检查。IndexOutOfBoundException或NullpointerException是未检查异常的示例，因为它们只能在运行时检测到。</p><h2 id="86d7" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Q5)如何在Java中对集合进行升序排序？</h2><p id="e0a7" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">假设你有一个收藏</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1a8b" class="jd je hi kx b fi lb lc l ld le">List&lt;Integer&gt; lst=new ArrayList&lt;Integer&gt;();<br/>lst.add(10);<br/>lst.add(4);<br/>lst.add(6);<br/>Collections.sort(lst);</span></pre><p id="f30e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码将对列表进行排序。现在假设您有一个学生列表，您想根据他们的编号对他们进行排序。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2c3a" class="jd je hi kx b fi lb lc l ld le">class Student{<br/> private int rollNumber;</span><span id="32df" class="jd je hi kx b fi lf lc l ld le"> public Student(int rollNumber){<br/>   this.rollNumber=rollNumber;<br/> }</span><span id="8668" class="jd je hi kx b fi lf lc l ld le"> public int getRollNumber(){<br/>  return this.rollNumber;<br/> }</span><span id="6bf4" class="jd je hi kx b fi lf lc l ld le"> public static void main(String[] args){<br/>  List&lt;Student&gt; lstStudent=new ArrayList&lt;Student&gt;();<br/>  lstStudent.add(new Student(10));<br/>  lstStudent.add(new Student(3));<br/>  lstStudent.add(new Student(6));<br/>  //How to sort this list according to Student Rollnumber.<br/> }</span><span id="83b5" class="jd je hi kx b fi lf lc l ld le">}</span></pre><p id="254d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有以下方法可以解决这个问题:</p><p id="afc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">方法一:</em> </strong> Class Student实现comparable接口，然后可以用Collections.sort(lstStudent)对列表进行排序。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7c3a" class="jd je hi kx b fi lb lc l ld le">class Student implements Comparable&lt;Student&gt;{<br/>private int rollNumber;<br/>public Student(int rollNumber){<br/> this.rollNumber=rollNumber;<br/>}</span><span id="1485" class="jd je hi kx b fi lf lc l ld le">public int getRollNumber(){<br/> return rollNumber;<br/>}</span><span id="7f8a" class="jd je hi kx b fi lf lc l ld le">//If smaller then return a negative integer, equal then 0 and if //greater then a positive integer<br/>@Override<br/> public int compareTo(Student arg1) {<br/>  return this.getRollNumber() — arg1.getRollNumber();<br/> }</span><span id="0970" class="jd je hi kx b fi lf lc l ld le">public static void main(String[] args){<br/>  List&lt;Student&gt; lstStudent=new ArrayList&lt;Student&gt;();<br/>  lstStudent.add(new Student(10));<br/>  lstStudent.add(new Student(3));<br/>  lstStudent.add(new Student(6));<br/>  Collections.sort(lstStudent);<br/> }</span><span id="933f" class="jd je hi kx b fi lf lc l ld le">}</span></pre><p id="2754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">方法二:</em> </strong>可以使用匿名类来给出Collections API的sort方法中Comparator接口的实现。通过匿名类，我们可以提供一个接口的实现，抽象类或者在使用时用一个表达式扩展一个类。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9276" class="jd je hi kx b fi lb lc l ld le">public static void main(String[] args){<br/>  List&lt;Student&gt; lstStudent=new ArrayList&lt;Student&gt;();<br/>  lstStudent.add(new Student(10));<br/>  lstStudent.add(new Student(3));<br/>  lstStudent.add(new Student(6));<br/>  Collections.sort(lstStudent, new Comparator(){<br/>    @Override<br/>    public int compare(Student arg0, Student arg1) {<br/>     return arg0.getRollNumber() — arg1.getRollNumber():<br/>    }<br/>  })<br/>}</span></pre><p id="f21e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kr">方法三:</em> </strong>在集合API的sort方法中提供一个lambda表达式。写起来极其简单。我会推荐记住它，因为它在日常编码问题中经常使用。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="56d4" class="jd je hi kx b fi lb lc l ld le">public static void main(String[] args){<br/>  List&lt;Student&gt; lstStudent=new ArrayList&lt;Student&gt;();<br/>  lstStudent.add(new Student(10));<br/>  lstStudent.add(new Student(3));<br/>  lstStudent.add(new Student(6));<br/>  Collections.sort(lstStudent,(x,y)-&gt;x.getRollNumber() -           y.getRollNumber())<br/>}</span></pre><p id="9e09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，该集合仅使用一行代码进行排序。由于比较器接口是一个函数接口，所以lambda表达式可以用来提供它的实现。函数接口就是只有一个抽象方法的接口。</p><p id="846b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Lambda表达式解释:</strong> (x，y)-&gt;x . getrollnumber()—y . getrollnumber()</p><p id="c842" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">x和y是比较函数的两个参数，这个比较函数的实现是x . getrollnumber()-y . getrollnumber()。</p><h2 id="adc0" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Q6)说出这个首要难题的结果:</h2><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3343" class="jd je hi kx b fi lb lc l ld le">class Engine{<br/> public Engine(){<br/>  getCarInitials();<br/> }<br/> public String getCarInitials(){}<br/>}</span><span id="e646" class="jd je hi kx b fi lf lc l ld le">class Car extends Engine{<br/> String carNumber;<br/> public Car(){<br/>   carNumber=”ABC567”;<br/> }</span><span id="bdc2" class="jd je hi kx b fi lf lc l ld le"> @Override<br/> public String getCarInitials(){<br/>  return carNumber.substring(0,3);<br/> }</span><span id="dd92" class="jd je hi kx b fi lf lc l ld le"> public static void main(String[] args){<br/>  Car car=new Car();<br/>  System.out.println(“Car Initials are:”+car.getCarInitials());<br/> }<br/>}</span></pre><p id="ba49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个程序会在第行抛出一个Nullpointer异常(Car car=new Car())。因为我们知道，在设置carNumber之前，首先会在Car()构造函数内部默认调用父构造函数Engine()。调用引擎内部的构造函数“getCarInitials()”，该构造函数实际上在子类中被覆盖。因为它被覆盖了，所以Java将调用被覆盖的方法，并尝试获取空“carNumber”字符串的子字符串。这将导致Nullpointer异常。</p><h2 id="3850" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Q7:这个超载难题的结果会是什么？解释静态绑定和动态绑定的区别。</h2><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="52e2" class="jd je hi kx b fi lb lc l ld le">class Shape{}<br/>class Circle extends Shape{}<br/>class Building{<br/> public void setShape(Shape shape){<br/>  System.out.println(“Parameter is shape”);<br/> }</span><span id="0c56" class="jd je hi kx b fi lf lc l ld le"> public void setShape(Circle circle){<br/>  System.out.println(“Parameter is circle”);<br/> }</span><span id="f412" class="jd je hi kx b fi lf lc l ld le"> public static void main(String[] args){<br/>  Building building=new Building();<br/>  Shape shape=new Circle();<br/>  building.setShape(shape);<br/> }<br/>}</span></pre><p id="5c5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个程序将打印“参数是形状”。Java对重载函数使用静态或编译时绑定。所以这里的参数类型将在编译时检查。另一方面，动态或运行时绑定用于被覆盖的函数。与Java相反，Groovy语言对重载函数使用动态绑定。</p><h2 id="ed9a" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">参考资料:</h2><p id="9587" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated"><a class="ae lg" href="https://manifesto.co.uk/java-lists-arraylist-vs-linkedlist/" rel="noopener ugc nofollow" target="_blank"> Java列表:LinkedList vs ArrayList </a></p><p id="443c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lg" href="https://www.javatpoint.com/load-factor-in-hashmap" rel="noopener ugc nofollow" target="_blank">哈希表中的加载因子</a></p><p id="182d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lg" href="https://beginnersbook.com/2013/04/java-checked-unchecked-exceptions-with-examples/" rel="noopener ugc nofollow" target="_blank">Java中的检查和未检查异常及示例</a></p><p id="3e53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lg" href="https://www.baeldung.com/java-anonymous-classes" rel="noopener ugc nofollow" target="_blank">Java中的匿名类</a></p><p id="9ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lg" href="http://tutorials.jenkov.com/java-functional-programming/functional-interfaces.html#:~:text=A%20functional%20interface%20in%20Java,to%20the%20single%20unimplemented%20method." rel="noopener ugc nofollow" target="_blank"> Java功能接口</a></p></div></div>    
</body>
</html>