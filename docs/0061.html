<html>
<head>
<title>Code Duplication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码复制</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/code-duplication-1e1f759a7fe3?source=collection_archive---------0-----------------------#2019-05-01">https://medium.com/javarevisited/code-duplication-1e1f759a7fe3?source=collection_archive---------0-----------------------#2019-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c79b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重复的代码让我发痒，直到我把它擦掉。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f7e7c993910beb16616f41ea322f60e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLJUnvCEnjFcNLhc5Wbgqg.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">发痒的干草！</p></figure><h1 id="7083" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我讨厌代码复制</h1><p id="1c73" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">没有什么比代码复制更让我烦恼的了。每次我发现代码库中有重复的地方，我都会感到难以忍受的痒。消除瘙痒的唯一方法是找到一种合适的方法来消除重复。</p><p id="5abc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很多年前，当我发现代码重复时，我总是会想起Ryan King 在雅虎论坛上发表的一篇文章中的这段话。</p><blockquote class="kx ky kz"><p id="8d3b" class="if ig la ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">所以，复制很糟糕。一个人越讨厌重复，我就越相信他们在管理信息方面的观点。一个程序员，一旦注意到一些冗余，应该会陷入恐慌，开始喘不过气来，结结巴巴地说“El diablo！！El diablo está en mi软件！”。</p><p id="f12a" class="if ig la ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">—瑞安·金</p></blockquote><p id="b692" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么当我们发现代码重复时，我们能做些什么呢？我们可以学习去除它的方法。Google和StackOverflow是寻找解决许多常见编程问题的答案的绝佳资源。它们可以是您发现和学习新API的第一站，这可能有助于减少您以前编写的一些重复代码。</p><h1 id="9c9b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">简单的复制模式</h1><p id="bc5a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">有时代码重复很容易被发现和删除。我将从描述一些我一直在代码库中发现的非常简单的常见复制模式开始。</p><h2 id="0826" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">布尔测试模式</h2><p id="47fd" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">测试一个<code class="du ls lt lu lv b">boolean</code>值并返回真或假。这些年来，我见过的这种代码模式比你想象的还要多。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="dacf" class="le ju hi lv b fi ma mb l mc md">public boolean isSomething()<br/>{<br/>    if (!this.calculateSomeBooleanValue())<br/>    {<br/>        return true;<br/>    }<br/>    else<br/>    {<br/>        return false;<br/>    }<br/>}</span></pre><p id="d1a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">改为写这个。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="1083" class="le ju hi lv b fi ma mb l mc md">public boolean isSomething()<br/>{<br/>    return !this.calculateSomeBooleanValue();<br/>}</span></pre><h2 id="f0ad" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">集合工厂模式</h2><p id="5613" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">这里有另一个简单的模式，可以很容易地修复。这种代码在测试用例中非常常见。解决包括测试在内的整个代码库的代码重复问题是很重要的。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="8e96" class="le ju hi lv b fi ma mb l mc md">List&lt;String&gt; list = new ArrayList&lt;&gt;();<br/>list.add(<strong class="lv hj">"one"</strong>);<br/>list.add(<strong class="lv hj">"two"</strong>);<br/>list.add(<strong class="lv hj">"three"</strong>);</span></pre><p id="1e21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Eclipse集合<a class="ae kw" rel="noopener" href="/@donraab/as-a-matter-of-factory-part-1-mutable-75cc2c5d72d9">可变工厂模式</a>可以如下替换这段代码。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="252a" class="le ju hi lv b fi ma mb l mc md">List&lt;String&gt; list = Lists.<strong class="lv hj"><em class="la">mutable</em></strong>.with(<strong class="lv hj">"one"</strong>, <strong class="lv hj">"two"</strong>, <strong class="lv hj">"three"</strong>);</span></pre><p id="2782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个StackOverflow上的回答，展示了用Eclipse集合在一行中初始化列表、集合和打包的不同<a class="ae kw" href="https://stackoverflow.com/questions/1005073/initialization-of-an-arraylist-in-one-line/28183168#28183168" rel="noopener ugc nofollow" target="_blank">方法。</a></p><h2 id="9cce" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">不可修改的静态集合初始值设定项模式</h2><p id="a4b2" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">以下代码在Java 9之前的Java版本中很常见，用于创建静态的不可修改的<code class="du ls lt lu lv b">List</code>。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="8434" class="le ju hi lv b fi ma mb l mc md">public static final List&lt;String&gt; <em class="la">LIST</em>;<br/><br/>static<br/>{<br/>    List&lt;String&gt; newList = new ArrayList&lt;&gt;();<br/>    newList.add(<strong class="lv hj">"one"</strong>);<br/>    newList.add(<strong class="lv hj">"two"</strong>);<br/>    newList.add(<strong class="lv hj">"three"</strong>);<br/>    <em class="la">LIST </em>= Collections.<em class="la">unmodifiableList</em>(newList);<br/>}</span></pre><p id="e108" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以用普通的旧Java更简单地写成如下。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="0ac6" class="le ju hi lv b fi ma mb l mc md">public static final List&lt;String&gt; <strong class="lv hj"><em class="la">LIST </em></strong>=<br/>        Collections.<em class="la">unmodifiableList</em>(<br/>                Arrays.<em class="la">asList</em>(<strong class="lv hj">"one"</strong>, <strong class="lv hj">"two"</strong>, <strong class="lv hj">"three"</strong>));</span></pre><p id="9cb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也可以使用Eclipse集合进行替换，如下所示。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="977d" class="le ju hi lv b fi ma mb l mc md">public static final List&lt;String&gt; LIST =<br/>        Lists.<strong class="lv hj"><em class="la">mutable</em></strong>.with(<strong class="lv hj">"one"</strong>, <strong class="lv hj">"two"</strong>, <strong class="lv hj">"three"</strong>).asUnmodifiable();</span></pre><p id="2533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从Java 9开始，您还可以编写以下代码。方法<code class="du ls lt lu lv b">List.of()</code>返回一个不可修改的列表。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="1c2b" class="le ju hi lv b fi ma mb l mc md">public static final List&lt;String&gt; LIST = <br/>        List.<em class="la">of</em>(<strong class="lv hj">"one"</strong>, <strong class="lv hj">"two"</strong>, <strong class="lv hj">"three"</strong>);</span></pre><p id="0d04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想拥有一个像没有可变方法的<code class="du ls lt lu lv b">ImmutableList</code>这样的契约式不可变接口，您也可以使用Eclipse集合中的<code class="du ls lt lu lv b">ImmutableList</code>。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="75b6" class="le ju hi lv b fi ma mb l mc md">public static final ImmutableList&lt;String&gt; LIST = <br/>        Lists.<strong class="lv hj"><em class="la">immutable</em></strong>.with(<strong class="lv hj">"one"</strong>, <strong class="lv hj">"two"</strong>, <strong class="lv hj">"three"</strong>);</span></pre><h2 id="38a5" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">静态映射初始化模式</h2><p id="2903" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">如果在<code class="du ls lt lu lv b">Map</code>中有三个或四个以上的键/值对，初始化一个静态的<code class="du ls lt lu lv b">Map</code>可能会更有挑战性。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="6cd0" class="le ju hi lv b fi ma mb l mc md">public static final Map&lt;Integer, String&gt; <strong class="lv hj"><em class="la">MAP</em></strong>;<br/><br/>static<br/>{<br/>    Map&lt;Integer, String&gt; newMap = new HashMap&lt;&gt;();<br/>    newMap.put(1, <strong class="lv hj">"one"</strong>);<br/>    newMap.put(2, <strong class="lv hj">"two"</strong>);<br/>    newMap.put(3, <strong class="lv hj">"three"</strong>);<br/>    newMap.put(4, <strong class="lv hj">"four"</strong>);<br/>    newMap.put(5, <strong class="lv hj">"five"</strong>);<br/>    <strong class="lv hj"><em class="la">MAP </em></strong>= Collections.<em class="la">unmodifiableMap</em>(newMap);<br/>}</span></pre><p id="fd96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重构以使用Eclipse集合不可修改的映射。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="8326" class="le ju hi lv b fi ma mb l mc md">public static final Map&lt;Integer, String&gt; <strong class="lv hj"><em class="la">MAP </em></strong>=<br/>        Maps.<strong class="lv hj"><em class="la">mutable</em></strong>.&lt;Integer, String&gt;empty()<br/>                .withKeyValue(1, <strong class="lv hj">"one"</strong>)<br/>                .withKeyValue(2, <strong class="lv hj">"two"</strong>)<br/>                .withKeyValue(3, <strong class="lv hj">"three"</strong>)<br/>                .withKeyValue(4, <strong class="lv hj">"four"</strong>)<br/>                .withKeyValue(5, <strong class="lv hj">"five"</strong>)<br/>                .asUnmodifiable();</span></pre><p id="5675" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重构使用一个Eclipse集合<code class="du ls lt lu lv b">ImmutableMap</code>，它的接口中也没有突变方法。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="162c" class="le ju hi lv b fi ma mb l mc md">public static final ImmutableMap&lt;Integer, String&gt; <strong class="lv hj"><em class="la">MAP </em></strong>=<br/>        Maps.<strong class="lv hj"><em class="la">mutable</em></strong>.&lt;Integer, String&gt;empty()<br/>                .withKeyValue(1, <strong class="lv hj">"one"</strong>)<br/>                .withKeyValue(2, <strong class="lv hj">"two"</strong>)<br/>                .withKeyValue(3, <strong class="lv hj">"three"</strong>)<br/>                .withKeyValue(4, <strong class="lv hj">"four"</strong>)<br/>                .withKeyValue(5, <strong class="lv hj">"five"</strong>)<br/>                .toImmutable();</span></pre><p id="34a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是StackOverflow上的一个回答，展示了用Eclipse集合初始化静态地图的各种<a class="ae kw" href="https://stackoverflow.com/questions/507602/how-can-i-initialise-a-static-map/13943037#13943037" rel="noopener ugc nofollow" target="_blank">方法。</a></p><h1 id="af93" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">迭代模式</h1><p id="f36b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我开始构建<a class="ae kw" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>的主要原因之一是，我会看到开发人员一遍又一遍地编写相同的for循环。开发人员不断地在Java中重新实现集合迭代模式。我看到代码复制无处不在！在Java 8之前，开发人员这样做是因为Java开发人员可用的迭代模式仅限于Collections实用程序类。从JDK 1.4开始，Eclipse集合就一直在开发中，并用于生产中。在过去的十五年里，Eclipse Collections 一直是我在Java中删除重复迭代模式代码的首选解决方案。</p><h2 id="2f85" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">过滤模式</h2><p id="44dc" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在Java 8之前，以下是根据某种条件将源集合过滤为目标集合的常用方法。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="c19a" class="le ju hi lv b fi ma mb l mc md">List&lt;Integer&gt; source = Arrays.asList(1, 2, 3, 4, 5);<br/>List&lt;Integer&gt; target = new ArrayList&lt;&gt;();<br/>for (Integer value : source)<br/>{<br/>    if (value % 2 == 0)<br/>    {<br/>        target.add(value);<br/>    }<br/>}</span></pre><p id="2730" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是使用Eclipse Collections <code class="du ls lt lu lv b">select</code>方法重构的相同代码。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="2d45" class="le ju hi lv b fi ma mb l mc md">MutableList&lt;Integer&gt; source = Lists.<strong class="lv hj"><em class="la">mutable</em></strong>.with(1, 2, 3, 4, 5);<br/>MutableList&lt;Integer&gt; target = source.select(each -&gt; each % 2 ==0);</span></pre><p id="7332" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是StackOverflow对“过滤Java集合的最佳方式是什么？”这个问题的<a class="ae kw" href="https://stackoverflow.com/questions/122105/what-is-the-best-way-to-filter-a-java-collection/12573823#12573823" rel="noopener ugc nofollow" target="_blank">回答</a></p><h2 id="0c0c" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">转换模式</h2><p id="2583" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在Java 8之前，以下是将一种集合类型转换成另一种集合类型的典型方式。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="3d9b" class="le ju hi lv b fi ma mb l mc md">List&lt;Integer&gt; source = Arrays.asList(1, 2, 3, 4, 5);<br/>List&lt;String&gt; target = new ArrayList&lt;&gt;();<br/>for (Integer value : source)<br/>{<br/>    target.add(value.toString());<br/>}</span></pre><p id="8341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是使用Eclipse Collections <code class="du ls lt lu lv b">collect</code>方法重构的相同代码。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="2269" class="le ju hi lv b fi ma mb l mc md">MutableList&lt;Integer&gt; source = Lists.<strong class="lv hj"><em class="la">mutable</em></strong>.with(1, 2, 3, 4, 5);<br/>MutableList&lt;String&gt; target = source.collect(Object::toString);</span></pre><h2 id="94cf" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">任何/所有/无模式</h2><p id="750a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在Java 8之前，您要么使用带有<code class="du ls lt lu lv b">boolean</code>变量的<code class="du ls lt lu lv b">break</code>语句，要么从if语句内部直接返回，以查看集合中的元素是否匹配给定条件。</p><h2 id="3668" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">任何模式</h2><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="6247" class="le ju hi lv b fi ma mb l mc md">List&lt;Integer&gt; source = Arrays.asList(1, 2, 3, 4, 5);<br/>boolean <strong class="lv hj">anyEvens </strong>= false;<br/>for (Integer value : source)<br/>{<br/>    if (value % 2 == 0)<br/>    {<br/>        <strong class="lv hj">anyEvens </strong>= true;<br/>        break;<br/>    }<br/>}</span></pre><p id="f04a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用Eclipse Collections <code class="du ls lt lu lv b">anySatisfy</code>方法重构。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="87f7" class="le ju hi lv b fi ma mb l mc md">MutableList&lt;Integer&gt; source = Lists.<strong class="lv hj"><em class="la">mutable</em></strong>.with(1, 2, 3, 4, 5);<br/>boolean anyEvens = source.anySatisfy(each -&gt; each % 2 == 0);</span></pre><h2 id="d08b" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">所有模式</h2><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="cd17" class="le ju hi lv b fi ma mb l mc md">List&lt;Integer&gt; source = Arrays.asList(1, 2, 3, 4, 5);<br/>boolean <strong class="lv hj">allEvens </strong>= true;<br/>for (Integer value : source)<br/>{<br/>    if (value % 2 != 0)<br/>    {<br/>        <strong class="lv hj">allEvens </strong>= false;<br/>        break;<br/>    }<br/>}</span></pre><p id="45dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用Eclipse集合<code class="du ls lt lu lv b">allSatisfy</code>方法重构。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="5767" class="le ju hi lv b fi ma mb l mc md">MutableList&lt;Integer&gt; source = Lists.<strong class="lv hj"><em class="la">mutable</em></strong>.with(1, 2, 3, 4, 5);<br/>boolean allEvens = source.allSatisfy(each -&gt; each % 2 == 0);</span></pre><h2 id="7803" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">无模式</h2><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="992a" class="le ju hi lv b fi ma mb l mc md">List&lt;Integer&gt; source = Arrays.asList(1, 2, 3, 4, 5);<br/>boolean <strong class="lv hj">noneEvens </strong>= true;<br/>for (Integer value : source)<br/>{<br/>    if (value % 2 == 0)<br/>    {<br/>        <strong class="lv hj">noneEvens </strong>= false;<br/>        break;<br/>    }<br/>}</span></pre><p id="d3c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用Eclipse集合<code class="du ls lt lu lv b">noneSatisfy</code>方法重构。</p><pre class="je jf jg jh fd lw lv lx ly aw lz bi"><span id="d8e3" class="le ju hi lv b fi ma mb l mc md">MutableList&lt;Integer&gt; source = Lists.<strong class="lv hj"><em class="la">mutable</em></strong>.with(1, 2, 3, 4, 5);<br/>boolean noneEvens = source.noneSatisfy(each -&gt; each % 2 == 0);</span></pre><h2 id="d309" class="le ju hi bd jv lf lg lh jz li lj lk kd iq ll lm kh iu ln lo kl iy lp lq kp lr bi translated">其他迭代模式</h2><p id="482a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Eclipse集合中还有许多其他迭代模式可以帮助您删除重复的代码。仅在<code class="du ls lt lu lv b"><a class="ae kw" href="https://www.eclipse.org/collections/javadoc/9.2.0/org/eclipse/collections/api/RichIterable.html" rel="noopener ugc nofollow" target="_blank">RichIterable</a></code>父接口上就有超过一百种迭代模式和其他方法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es me"><img src="../Images/4ae694b478545ef7e1734dee1f4b5cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Br4eQEhSsLeRZ1EVZIHhPA.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">丰富的API</p></figure><h1 id="65d3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">有时代码复制是必要的</h1><p id="6ac6" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">有时候，代码复制是解决性能问题的最佳解决方案。Eclipse集合中一个很好的例子是原始集合。Eclipse Collections对所有八种原语组合(<code class="du ls lt lu lv b">boolean</code>、<code class="du ls lt lu lv b">byte</code>、<code class="du ls lt lu lv b">char</code>、<code class="du ls lt lu lv b">double</code>、<code class="du ls lt lu lv b">float</code>、<code class="du ls lt lu lv b">int</code>、<code class="du ls lt lu lv b">long</code>、<code class="du ls lt lu lv b">short</code>)的列表、集合、包、堆栈和地图都有原语集合支持。实现所有这些容器类型的代码几乎是相同的。因此，如果您阅读IntArrayList的代码，它看起来会与<code class="du ls lt lu lv b">ShortArrayList</code>和<code class="du ls lt lu lv b">LongArrayList</code>中的代码非常相似。在您希望为Java中的基本类型提供库支持的情况下，重要的是尽可能利用代码生成策略，并且不要手动复制代码。对于Eclipse集合，我们使用<a class="ae kw" href="https://www.stringtemplate.org/" rel="noopener ugc nofollow" target="_blank"> StringTemplate </a>库，并为每种容器类型编写一次模板，然后使用这些模板生成支持所有原语所需的八种容器类型。</p><p id="66ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在未来，如果Valhalla项目的工作成为JDK发布的一部分，并且我们获得了对基本类型的通用专门化的支持，我们可能会在Java中有新的语言级别策略，以减少我们今天必须生成的支持基本类型的代码量。我非常兴奋地看到这种支持可能会减少我们的代码复制负担。</p><h1 id="a19d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">复制的其他模式</h1><p id="dff7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">那里有更多的复制模式。您的IDE和各种代码分析工具有时可以帮助您找到复制和粘贴导致的明显问题。其他时候，你可能只需要阅读你的代码，看看你是否能识别出一些代码过于详细地描述如何做某事的模式(因为循环有时是一种暗示)。写得好的代码应该清楚地告诉你<strong class="ih hj">它在做什么</strong>，而不是它是如何做的。</p><p id="5c92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除重复代码让我觉得很满足。它有助于降低应用程序或库的总拥有成本。需要阅读、测试、维护和部署的代码越少，意味着需要发现、调试和修复的潜在错误就越少。</p><p id="d693" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kw" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="la">月食收藏</em> </a> <em class="la">为</em> <a class="ae kw" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="la">投稿</em> </a> <em class="la">开放。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div></div>    
</body>
</html>