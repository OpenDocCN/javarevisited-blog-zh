<html>
<head>
<title>Scaling Spring Boot Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展Spring Boot微服务</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/scaling-spring-boot-microservices-81b7e8c61b73?source=collection_archive---------1-----------------------#2021-07-08">https://medium.com/javarevisited/scaling-spring-boot-microservices-81b7e8c61b73?source=collection_archive---------1-----------------------#2021-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ad3731ba9ac8a6eb610305172149595a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gaTgUYlQBkBLsfl0"/></div></div><p class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@carrier_lost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="f803" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们已经编写了Spring Boot应用程序。它已经成功地工作了一段时间。现在，我们知道我们需要启动服务的多个实例来应对增加的负载和可用性。但是在开发过程中，我们没有考虑到这一点。</p><p id="e648" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有什么可以阻止我们只是启动几个实例呢？</p><ol class=""><li id="94c7" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">使用调度程序</li><li id="9b9c" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">使用WebSockets</li><li id="76b9" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">存储在内存中的用户会话</li><li id="8597" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">应用程序缓存——它可以是组件中的简单并发哈希表，也可以是spring缓存。</li></ol><p id="fbdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用正确的工具，所有这些都可以很容易地适应。</p><h1 id="470c" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">调度程序</strong></h1><p id="f4ae" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">使用分布式调度器不是最简单的任务，调整和重写代码需要时间。我们希望快速实现从1到N个同时运行的实例的转换。</p><p id="f3bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">幸运的是，有一个与Spring集成的库，它允许你用几个注释来做这件事。</p><p id="caf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Shedlock在您的数据库中创建一个表(几乎支持任何存储)，并使用它来协调实例，以便一次只有一个实例运行特定的调度程序。</p><p id="5a1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要用默认锁启用Shedlock最多5分钟。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="842b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并添加ShedLock'a注释来指定特定调度程序的名称。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="84bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在调度程序的下一个时钟周期，每个实例将尝试在锁表中写一行关于它自己的内容，第一个成功的实例将继续执行任务。其他人都会跳过滴答。</p><p id="9237" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的案例中，锁定任务将最多持续5分钟。任务完成后，实例将删除表中的锁。如果5分钟过去了，锁还没有被解除，其他实例将认为该实例在任务执行时已经冻结。</p><h1 id="b3ab" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak"> Websockets </strong></h1><p id="ecaa" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">如果在我们的应用程序中，用户可以相互发送消息，为此，我们使用WebSockets，那么当用户Bob连接到实例A，而用户Alice连接到实例b时，可能会出现这种情况。</p><p id="508f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编写这样一个层是一项费力的任务，将大大延迟应用程序的缩放时间。相反，我们可以使用Spring的开箱即用的<code class="du lq lr ls lt b">BrokerRelay </code>实现，它使用外部代理(RabbitMQ、ActiveMQ等)。)来处理WebSockets、管理订阅等等。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="7247" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，<code class="du lq lr ls lt b">/topic</code>和<code class="du lq lr ls lt b">/queue</code>的所有消息都将被转发到外部代理。详细的交互方案可以在<a class="ae iu" href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow" rel="noopener ugc nofollow" target="_blank"> Spring文档</a>中看到。</p><h1 id="2cfc" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">用户会话</strong></h1><p id="b7f4" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">当然，每个应用程序实例的会话不必不同。幸运的是，它们可以存储在任何数据库中。对于冷门存储，需要编写自己的SessionRepository。</p><p id="0f0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于<a class="ae iu" rel="noopener" href="/javarevisited/top-5-courses-to-learn-jdbc-and-database-connectivity-for-java-developers-free-and-best-of-lot-7945156fcc3?source=---------9------------------"> JDBC </a>，加一个依赖就够了。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="9e39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并在<strong class="ix hj"><em class="lu">application . properties:</em></strong>中设置属性</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="0a05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，在这种情况下，值得记住的是，会话数据本身将被存储为blob，有时，当更新<a class="ae iu" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring </a>时，由于反序列化旧对象的问题，您将不得不清除会话。</p><h1 id="7566" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">应用缓存</strong></h1><p id="ad17" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我们不希望每个实例都有自己的缓存。否则，请求结果可能取决于负载平衡器将用户发送到哪里。</p><p id="c721" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于使用共享缓存的所有实例，连接外部存储是值得的，比如Redis、Apache Ignite、Hazelcast等。</p><p id="e67c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于Spring-Cache和Redis，包含一个依赖项就足够了。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="4e33" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，通过<code class="du lq lr ls lt b">@EnableCaching</code>注释，<a class="ae iu" rel="noopener" href="/javarevisited/10-advanced-spring-boot-courses-for-experienced-java-developers-5e57606816bd?source=collection_home---4------0-----------------------"> Spring Boot </a>将自动启用Redis作为默认配置。</p><p id="bfa3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，可以对其进行定制，以便为每个实体设置不同的生存时间。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="4309" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">结论</strong></h1><p id="b304" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">因此，即使您在创建应用程序时没有考虑伸缩性，也有一组工具可以帮助您从1个实例移动到N个同时运行的实例，而无需重写服务本身的业务逻辑。</p></div></div>    
</body>
</html>