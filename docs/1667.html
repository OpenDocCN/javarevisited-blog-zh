<html>
<head>
<title>Solve the Second Shortest Path problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决第二最短路径问题</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/solve-the-second-shortest-path-problem-7c1082e85049?source=collection_archive---------3-----------------------#2021-10-21">https://medium.com/javarevisited/solve-the-second-shortest-path-problem-7c1082e85049?source=collection_archive---------3-----------------------#2021-10-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a204" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过使用BFS或迪杰斯特拉算法</h2></div><p id="27d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们知道，对于单源最短路径(SSSP)问题，我们可以</p><ul class=""><li id="ce26" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">如果在每次探索中没有重量或重量相等或重量相等，则使用BFS求解。</li><li id="6d4d" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">如果图具有正的不相等权重，则使用Dijkstra求解。</li></ul><p id="65ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于本文中的问题，我们可以使用改进的BFS和Dijkstra来解决第二最短路径问题。</p><h2 id="708b" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">2045年。到达目的地的第二最短时间</h2><p id="ed16" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">此题为leetcode 263周赛题第4题。在这篇文章中，我将介绍基于BFS和基于Dijkstra的解决方案。</p><h1 id="6a44" class="li ki hi bd kj lj lk ll kn lm ln lo kr io lp ip ku ir lq is kx iu lr iv la ls bi translated">BFS与最大访问限制</h1><p id="749b" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">既然对于这个问题，权重是相等的，我们可以考虑用BFS来解决这个问题。基本步骤:</p><ol class=""><li id="1a92" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js lt jz ka kb bi translated">使用BFS遍历图形。与标准BFS的不同之处在于，一个节点可以被访问多次。(你可以认为我们应该忽略看到的信息)</li><li id="9829" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js lt jz ka kb bi translated">如果我们首先到达目标节点，我们不应该停止(在标准的SSSP问题中，我们在这里停止)。我们应该做的是继续探索该图，直到为目标节点找到第二条最短路径。</li><li id="08f1" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js lt jz ka kb bi translated">如果我们不对每个节点的访问次数设置限制，我们将得到TLE，因为图的大小可以呈指数增长。我们可以使用一个未经证实的技巧，为每个节点设置一个最大访问时间的上限，这样问题就可以解决了。</li></ol><p id="4786" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参考代码可以在这里找到。</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="1794" class="kh ki hi lz b fi md me l mf mg">using PII = pair&lt;int, int&gt;;<br/>int seen[10010];<br/>class Solution {<br/>    public:<br/>    int secondMinimum(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int time, int change) {<br/>        memset(seen, 0, sizeof seen);<br/>        vector&lt;PII&gt; thisLevel;<br/>        int minCost = INT_MAX;<br/>        thisLevel.emplace_back(1, 0);<br/>        vector&lt;vector&lt;int&gt;&gt; graph(n + 1);<br/>        for (auto e: edges){<br/>            graph[e[0]].push_back(e[1]);<br/>            graph[e[1]].push_back(e[0]);<br/>        }<br/>        seen[1]++;<br/>        int newcost;<br/>        const int MAX_VISIT = 70;<br/>        // BFS with depth constraints for each node.<br/>        while (thisLevel.size()){<br/>            vector&lt;PII&gt; nextLevel;<br/>            for (auto [node, cost]: thisLevel){<br/>                for (auto nei : graph[node]){<br/>                    // comment this line will get TLE.<br/>                    if (seen[nei] &gt; MAX_VISIT)continue;<br/>                    seen[nei]++;<br/>                    newcost = cost + time;<br/>                    // red<br/>                    if ((cost / change) % 2 == 1){<br/>                        newcost += change - (cost % change); <br/>                    } <br/>                    if (nei == n ){<br/>                        if (minCost!= INT_MAX &amp;&amp; newcost &gt; minCost){<br/>                            return newcost;<br/>                        } else {<br/>                            minCost = newcost;<br/>                        }<br/>                    } <br/>                    nextLevel.emplace_back(nei, newcost);   <br/>                }<br/>            }</span><span id="8901" class="kh ki hi lz b fi mh me l mf mg">thisLevel = nextLevel;<br/>        }<br/>        return 0;<br/>    }<br/>};</span></pre><p id="e4d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您对这个BFS解决方案不满意，我们可以转向基于Dijkstra的解决方案。</p><p id="5096" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行时间</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="4d82" class="kh ki hi lz b fi md me l mf mg">Runtime: 1693 ms, faster than 5.50% of C++ online submissions forSecond Minimum Time to Reach Destination.</span><span id="2515" class="kh ki hi lz b fi mh me l mf mg">Memory Usage: 362 MB, less than 5.07% of C++ online submissions forSecond Minimum Time to Reach Destination.</span></pre><h1 id="aa7f" class="li ki hi bd kj lj lk ll kn lm ln lo kr io lp ip ku ir lq is kx iu lr iv la ls bi translated">基于Dijkstra的解决方案</h1><p id="a2f9" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">这个想法很简单:</p><ul class=""><li id="4bb6" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">在标准的Dijkstra算法中，我们为最短路径维护一个优先级队列和一个距离数组。</li><li id="457e" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">对于这个问题，我们维护两个距离数组，一个用于最短路径，一个用于第二短路径。</li></ul><p id="340b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参考代码[1]</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="c683" class="kh ki hi lz b fi md me l mf mg">using PII = pair&lt;int, int&gt;;</span><span id="17ef" class="kh ki hi lz b fi mh me l mf mg">class Solution {<br/>    public:<br/>    int secondMinimum(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int time, int change) {<br/>        vector&lt;int&gt; dis(n+1, INT_MAX), dis2(n+1, INT_MAX);<br/>        vector&lt;vector&lt;int&gt;&gt; graph(n + 1);<br/>        for (auto &amp;e : edges) {<br/>            graph[e[0]].push_back(e[1]);<br/>            graph[e[1]].push_back(e[0]);<br/>        }<br/>        dis[1] = 0;<br/>        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;<br/>        pq.emplace(0, 1);<br/>        while (pq.size()) {<br/>            auto [cost, node] = pq.top();pq.pop();<br/>            if (dis2[node] &lt; cost) continue;<br/>            for (auto nei: graph[node]) {<br/>                int new_cost = cost + time;<br/>                // red<br/>                if ((cost / change) % 2 == 1){<br/>                    new_cost += change - (cost % change);<br/>                }<br/>                if (dis[nei] &gt; new_cost){<br/>                    dis2[nei] = dis[nei];<br/>                    dis[nei] = new_cost;<br/>                    pq.emplace(new_cost, nei);<br/>                } else if (new_cost &gt; dis[nei] &amp;&amp; new_cost &lt; dis2[nei] ) {<br/>                    dis2[nei] = new_cost;<br/>                    pq.emplace(new_cost, nei);<br/>                }<br/>            }<br/>        }<br/>        return dis2[n];<br/>    }<br/>};</span></pre><p id="ec33" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行时间</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="e974" class="kh ki hi lz b fi md me l mf mg">Runtime: 1280 ms, faster than 22.84% of C++ online submissions for Second Minimum Time to Reach Destination.</span><span id="1a69" class="kh ki hi lz b fi mh me l mf mg">Memory Usage: 181.6 MB, less than 74.34% of C++ online submissions for Second Minimum Time to Reach Destination.</span></pre><h1 id="0281" class="li ki hi bd kj lj lk ll kn lm ln lo kr io lp ip ku ir lq is kx iu lr iv la ls bi translated">优化的BFS解决方案</h1><p id="26a7" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">由于每次探索的权重是相等的，所以优先级队列是不必要的(常规队列已经可以使前面的元素具有最小的权重)。只需将priority_queue替换为queue，就可以实现更快的解决方案。</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="62d8" class="kh ki hi lz b fi md me l mf mg">using PII = pair&lt;int, int&gt;;<br/>class Solution {<br/>    public:<br/>    int secondMinimum(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int time, int change) {<br/>        vector&lt;int&gt; dis(n+1, INT_MAX), dis2(n+1, INT_MAX);<br/>        vector&lt;vector&lt;int&gt;&gt; graph(n + 1);<br/>        for (auto &amp;e : edges) {<br/>            graph[e[0]].push_back(e[1]);<br/>            graph[e[1]].push_back(e[0]);<br/>        }<br/>        dis[1] = 0;<br/>        queue&lt;PII&gt; Q;<br/>        Q.emplace(0, 1);<br/>        while (Q.size()) {<br/>            auto [cost, node] = Q.front();Q.pop();<br/>            for (auto nei: graph[node]) {<br/>                int new_cost = cost + time;<br/>                // red<br/>                if ((cost / change) % 2 == 1){<br/>                    new_cost += change - (cost % change);<br/>                }<br/>                if (dis[nei] &gt; new_cost){<br/>                    dis2[nei] = dis[nei];<br/>                    dis[nei] = new_cost;<br/>                    Q.emplace(new_cost, nei);<br/>                } else if (new_cost &gt; dis[nei] &amp;&amp; new_cost &lt; dis2[nei] ) {<br/>                    dis2[nei] = new_cost;<br/>                    Q.emplace(new_cost, nei);<br/>                }<br/>            }<br/>        }<br/>        return dis2[n];<br/>    }<br/>};</span></pre><p id="399f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行时间</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="5269" class="kh ki hi lz b fi md me l mf mg">Runtime: 544 ms, faster than 92.53% of C++ online submissions forSecond Minimum Time to Reach Destination.</span><span id="3f24" class="kh ki hi lz b fi mh me l mf mg">Memory Usage: 182 MB, less than 73.56% of C++ online submissions for Second Minimum Time to Reach Destination.</span></pre><p id="132d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">python版本</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="7515" class="kh ki hi lz b fi md me l mf mg">class Solution:<br/>    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -&gt; int:<br/>        dis, dis2 = [float("inf")]*(n+1), [float("inf")]*(n+1)<br/>        graph = collections.defaultdict(list)<br/>        for u, v in  edges:<br/>            graph[u].append(v)<br/>            graph[v].append(u)<br/>        dis[1] = 0<br/>        Q = deque()<br/>        Q.append((0, 1))<br/>        while Q:<br/>            cost, node = Q.popleft()<br/>            for nei in graph[node]:<br/>                new_cost = cost + time;<br/>                # red signal<br/>                if (cost // change) % 2 == 1:<br/>                    new_cost += change - (cost % change)<br/>                # update two distances.<br/>                if dis[nei] &gt; new_cost:<br/>                    dis2[nei], dis[nei]  = dis[nei], new_cost;<br/>                    Q.append((new_cost, nei))<br/>                elif new_cost &gt; dis[nei] and new_cost &lt; dis2[nei]:<br/>                    dis2[nei] = new_cost<br/>                    Q.append((new_cost, nei))<br/>        return dis2[n]</span></pre><h1 id="30ea" class="li ki hi bd kj lj lk ll kn lm ln lo kr io lp ip ku ir lq is kx iu lr iv la ls bi translated">参考</h1><p id="cd5f" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">[1]提交自<a class="ae lc" href="https://leetcode-cn.com/MaskRay" rel="noopener ugc nofollow" target="_blank">马斯克雷</a></p></div></div>    
</body>
</html>