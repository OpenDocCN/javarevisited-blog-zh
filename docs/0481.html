<html>
<head>
<title>Are you sure to understand Java arrays?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你确定了解Java数组吗？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/are-you-sure-to-understand-java-arrays-99e979905999?source=collection_archive---------2-----------------------#2020-06-07">https://medium.com/javarevisited/are-you-sure-to-understand-java-arrays-99e979905999?source=collection_archive---------2-----------------------#2020-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b1f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java数组是聚集元素的最原始的方式。然而，你真的能理解它们是如何工作和如何使用的吗？你可能会惊讶…</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/48974a455c5016b1b3688c0ce7f273af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c4TWW-DMP6HpGFVq.jpg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">数组代表一行行的东西</p></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="670c" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Java数组:基础知识</h1><p id="3af1" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">Java数组不是这种语言的新特性。回顾一下基础，让我们回忆一下数组类型是用括号<code class="du ld le lf lg b">[ ]</code>表示的，并用花括号<code class="du ld le lf lg b">{ }</code>以一种非常简单的方式创建的:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="2a6a" class="ll kb hi lg b fi lm ln l lo lp">String[] myArrayOfStrings = { "Hello", "World" };</span></pre><p id="4e4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是更详细形式的语法糖(我们将在本文中坚持使用)</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="4c0f" class="ll kb hi lg b fi lm ln l lo lp">String[] myArrayOfStrings = new String[] { "Hello", "World" };</span></pre><p id="0665" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于JVM的优化，访问数组中的元素预计会非常快。与Rust之类的语言相比，数组长度不是数组类型的一部分:我们的数组类型是<code class="du ld le lf lg b">String[]</code>，没有关于其长度的信息。然而，<a class="ae lq" rel="noopener" href="/javarevisited/20-array-coding-problems-and-questions-from-programming-interviews-869b475b9121">数组的长度是不可变的</a>:数组不能改变它的大小。</p><p id="f08d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更改数组的大小，您需要执行两步操作:首先创建一个具有预期新大小的数组，然后在目标中复制源:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="98a1" class="ll kb hi lg b fi lm ln l lo lp">String[] myArrayOfStrings = ...;<br/>String[] withAugmentedSize = new Steing[4];<br/>System.arraycopy(myArrayOfStrings, 0, withAugmentedSize, 0,<br/>                 myArrayOfStrings.length);</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="e0a3" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">数组方差</h1><p id="6fb2" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">在上面的例子中，字符串数组</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="4bf8" class="ll kb hi lg b fi lm ln l lo lp">new String[] { "Hello", "World" }</span></pre><p id="d62b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储在类型为<code class="du ld le lf lg b">String[]</code>的变量中。有人可能想知道我们可以用什么样的变量来存储字符串数组。</p><p id="7c02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好消息是数组类型是<em class="lr">协变的</em>。这意味着如果<code class="du ld le lf lg b">String</code>是<code class="du ld le lf lg b">Object</code>的子类型，那么你可以在<code class="du ld le lf lg b">Object[]</code>类型的变量中存储一些<code class="du ld le lf lg b">String[]</code>:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="0acb" class="ll kb hi lg b fi lm ln l lo lp">Object[] myArrayOfStrings = new String[] { "Hello", "World" };</span></pre><p id="119a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像往常一样，您应该注意两件事:</p><ol class=""><li id="4c12" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">使用变量<code class="du ld le lf lg b">myArrayOfStrings</code>不允许您对条目执行<code class="du ld le lf lg b">String</code>操作，因为它们是<code class="du ld le lf lg b">Object</code>类型，即使它们实际上是<code class="du ld le lf lg b">String</code></li><li id="14d3" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">使用<code class="du ld le lf lg b">new Object[]{ ... }</code>创建数组也会丢失条目实际上是字符串的信息。</li></ol><p id="048b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么数组是协变的？嗯，这个可能看<code class="du ld le lf lg b">arrayCopy</code>方法就明白了。如果数组类型是不变的(如Java中的泛型类型)，这意味着您将需要与数组类型一样多的<code class="du ld le lf lg b">arrayCopy</code>版本。</p><p id="ffaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于在<a class="ae lq" rel="noopener" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"> Java生态系统</a>中每种类型都有一个数组类型，所以不能编写<code class="du ld le lf lg b">arrayCopy</code>方法。你可以用一些泛型来争论，但是不要忘记在那个时候，Java没有泛型！(它们只出现在Java 5中)。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="f4ad" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么会出错？</h1><p id="930c" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">让我们更仔细地检查以下两个代码:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="6009" class="ll kb hi lg b fi lm ln l lo lp">Object[] myArray1OfStrings = new String[] { "Hello", "World" };</span></pre><p id="07d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对抗</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="368f" class="ll kb hi lg b fi lm ln l lo lp">Object[] myArray2OfStrings = new Object[] { "Hello", "World" };</span></pre><p id="eb2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这两种情况下，变量<code class="du ld le lf lg b">myArray_OfStrings</code>都被定义为<code class="du ld le lf lg b">Object[]</code>。这意味着最终用户在访问数组的任何条目时都会收到一些<code class="du ld le lf lg b">Object</code>:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="1504" class="ll kb hi lg b fi lm ln l lo lp">Object x = myArray_OfStrings[0]; // works<br/>String x = myArray_OfStrings[0]; // does not work</span><span id="1912" class="ll kb hi lg b fi mg ln l lo lp">myArray_OfStrings[0] instanceof String; // true<br/>String x = (String) myArray_OfStrings[0]; // works</span></pre><p id="a7d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是还有另一个微妙的区别。如果我们知道试图用另一个对象改变我们的条目会发生什么:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="98f2" class="ll kb hi lg b fi lm ln l lo lp">myArray1OfStrings[0] = new Object(); //java.lang.ArrayStoreException<br/>myArray2OfStrings[0] = new Object(); //works</span></pre><p id="a856" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到底发生了什么？这里有一个窍门:变量<code class="du ld le lf lg b">myArray2OfStrings</code>引用了一个已经被创建为数组<code class="du ld le lf lg b">Object</code>的数组，这个数组包含字符串实例。作为对象的数组仍然知道很多事情:它的长度，以及它的类型。换句话说，<code class="du ld le lf lg b">myArray2OfStrings</code>引用的实例知道它是一个<code class="du ld le lf lg b">Object</code>的数组，因此，如果您在它的一个条目中插入另一个通用对象，它不会崩溃。</p><p id="f402" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，<code class="du ld le lf lg b">myArray1OfStrings</code>引用的实例是一个已经被创建为<code class="du ld le lf lg b">String[]</code>数组的数组。它还知道它的长度和类型，并且知道它应该包含的元素应该是<code class="du ld le lf lg b">String</code>实例。因此，试图在一个条目中插入某个通用对象会导致一个<code class="du ld le lf lg b">ArrayStoreException</code>:你不能在一个<a class="ae lq" rel="noopener" href="/javarevisited/top-21-string-programming-interview-questions-for-beginners-and-experienced-developers-56037048de45">字符串</a>的数组中存储一个对象。</p><h2 id="d8c5" class="ll kb hi bd kc mh mi mj kg mk ml mm kk iq mn mo ko iu mp mq ks iy mr ms kw mt bi translated">但是方差呢？</h2><p id="7445" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">你应该困惑地了解到:我们上面看到的协方差是什么？如果<code class="du ld le lf lg b">String[]</code>是<code class="du ld le lf lg b">Object[]</code>的子类型，我们应该可以在其中存储<code class="du ld le lf lg b">Object[]</code>。</p><p id="5f0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，事实上还有另一件微妙的事情。重点是<code class="du ld le lf lg b">String[]</code>可以赋给<code class="du ld le lf lg b">Object[]</code>，这意味着你可以在<code class="du ld le lf lg b">Object[]</code>类型的变量中引用<code class="du ld le lf lg b">String[]</code>的一个实例。</p><p id="04f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ld le lf lg b">instanceof</code>操作符也表现得很好，因为它主要检查可分配性。</p><p id="3aab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是你要注意<code class="du ld le lf lg b">String[]</code>是<em class="lr">没有<code class="du ld le lf lg b">Object[]</code>的子类</em>。快速测试表明:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="ee50" class="ll kb hi lg b fi lm ln l lo lp">String[].class.getName(); // [Ljava.lang.String<br/>Object[].class.getName(); // [Ljava.lang.Object<br/>String[].class.getSuperclass().getName(); // java.lang.Object</span></pre><p id="63d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，<code class="du ld le lf lg b">String[]</code>不是<code class="du ld le lf lg b">Object[]</code>的子类，尽管它是一个子类型。具体来说，你可以在一个<code class="du ld le lf lg b">Object[]</code>中存储一个<code class="du ld le lf lg b">String[]</code>，但是你不能对它执行任何<code class="du ld le lf lg b">Object[]</code>操作(具体来说，你可以随心所欲地对条目进行变异)。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="e915" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">好吧，但是谁在乎呢？</h1><p id="4c6b" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">你可能觉得上面的例子真的很诡异，没有人绝对不会这么做。嗯，不要那么自信！</p><p id="45c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您有一些接口<code class="du ld le lf lg b">Foo</code>和一个实现<code class="du ld le lf lg b">FooImpl</code>:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="41d4" class="ll kb hi lg b fi lm ln l lo lp">public interface Foo {}</span><span id="4413" class="ll kb hi lg b fi mg ln l lo lp">class FooImpl implements Foo {}</span></pre><p id="2fd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后你暴露一个<code class="du ld le lf lg b">Foo</code>数组(没有<code class="du ld le lf lg b">FooImpl</code>，当然！)但是由于您需要对它执行第一个自定义操作，您可以这样写:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="5b8f" class="ll kb hi lg b fi lm ln l lo lp">Foo[] getAllFoos() {</span><span id="d4d1" class="ll kb hi lg b fi mg ln l lo lp">   FooImpl[] exposedFoos = new FooImpl[] { ... };</span><span id="fa23" class="ll kb hi lg b fi mg ln l lo lp">   performCustomOperationsOnFoos (exposedFoos);<br/>   // this required the array to be FooImpl[]<br/>   // for achieving custom goals</span><span id="953b" class="ll kb hi lg b fi mg ln l lo lp">   return exposedFoos;<br/>}</span></pre><p id="82a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果一个客户也想改变数组来实现他的目标，他会以某种方式结束<code class="du ld le lf lg b">ArrayStoreException</code>！</p><p id="d974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">社区中没有好的实践:您应该首先复制数组以公开一个公平的<code class="du ld le lf lg b">Foo[]</code>还是应该由客户端负责在必要时进行复制？</p><p id="a73f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们至少可以说</strong>(请不要卷入原始数组的争论)<strong class="ih hj">每个人都应该意识到那些管理原始数组世界的微妙规则！</strong></p></div></div>    
</body>
</html>