<html>
<head>
<title>Strategy design pattern — Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">战略设计模式— Java</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/strategy-design-pattern-java-30439e00299e?source=collection_archive---------1-----------------------#2021-07-20">https://medium.com/javarevisited/strategy-design-pattern-java-30439e00299e?source=collection_archive---------1-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7db6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">策略设计模式教程</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/29cf0cde84adf9b12c3bf45189d34c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*3dO6sOPoOPwHUOxA.jpeg"/></div></figure><h1 id="bc1b" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">战略模式的定义</h1><blockquote class="jx jy jz"><p id="e626" class="ka kb kc kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在<a class="ae kx" href="https://en.wikipedia.org/wiki/Computer_programming" rel="noopener ugc nofollow" target="_blank">计算机编程</a>中，<strong class="kd hj">策略模式</strong>(也称为<strong class="kd hj">策略模式</strong>)是一种<a class="ae kx" href="https://en.wikipedia.org/wiki/Behavioral_design_pattern" rel="noopener ugc nofollow" target="_blank">行为</a> <a class="ae kx" href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)" rel="noopener ugc nofollow" target="_blank">软件设计模式</a>，能够在运行时选择<a class="ae kx" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>。代码不是直接实现单个算法，而是接收运行时指令，以决定使用哪一组算法。</p></blockquote><h1 id="53b9" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">在哪里使用工厂模式</h1><p id="66e6" class="pw-post-body-paragraph ka kb hi kd b ke ky ij kg kh kz im kj la lb km kn lc ld kq kr le lf ku kv kw hb bi translated">当您希望算法独立于使用它的客户端而变化时。</p><h1 id="535d" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">UML示例</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/07/strategy-design-pattern-and-open-closed-principle-java-example.html"><div class="er es lg"><img src="../Images/dbea21c8e95f64abc4a8f28a154fa109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tSDptFpU1aazFrlsPHbBeA.png"/></div></a></figure><h1 id="edbb" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">战略模式的实施</h1><p id="e636" class="pw-post-body-paragraph ka kb hi kd b ke ky ij kg kh kz im kj la lb km kn lc ld kq kr le lf ku kv kw hb bi translated">首先，我们需要声明一个接口或者一个抽象类，这里我两个都用了，但是一个抽象类就可以完成这项工作。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="3397" class="pw-post-body-paragraph ka kb hi kd b ke kf ij kg kh ki im kj la kl km kn lc kp kq kr le kt ku kv kw hb bi translated">我想要实现的是，根据上下文，我的代码会有不同的行为，所以让我们实现一些策略。</p><p id="1ee7" class="pw-post-body-paragraph ka kb hi kd b ke kf ij kg kh ki im kj la kl km kn lc kp kq kr le kt ku kv kw hb bi translated">出于本教程的目的，我创建了两个策略:<code class="du lj lk ll lm b">PlusOperationStrategy </code>和<code class="du lj lk ll lm b">MinusOperationStrategy</code>，它们都扩展了我的<a class="ae kx" href="https://javarevisited.blogspot.com/2010/10/abstraction-in-java.html#axzz6oOeSmpNw" rel="noopener ugc nofollow" target="_blank">抽象类</a>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="df6a" class="pw-post-body-paragraph ka kb hi kd b ke kf ij kg kh ki im kj la kl km kn lc kp kq kr le kt ku kv kw hb bi translated">通过<a class="ae kx" href="https://javarevisited.blogspot.com/2012/10/what-is-inheritance-in-java-and-oops-programming.html" rel="noopener ugc nofollow" target="_blank">继承</a>使它们成为相同的超类型，我可以在所需行为的函数中替换它们。</p><p id="3401" class="pw-post-body-paragraph ka kb hi kd b ke kf ij kg kh ki im kj la kl km kn lc kp kq kr le kt ku kv kw hb bi translated">所以现在，如果我想使用我的策略，更准确地说是在其中实现的<strong class="kd hj">计算方法</strong>，我需要一个上下文。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="c1c5" class="pw-post-body-paragraph ka kb hi kd b ke kf ij kg kh ki im kj la kl km kn lc kp kq kr le kt ku kv kw hb bi translated">因此，基于作为参数传递的<a class="ae kx" href="https://www.java67.com/2014/12/strategy-pattern-in-java-with-example.html" rel="noopener ugc nofollow" target="_blank">策略</a>，上下文将使用计算方法it。</p><p id="7f6f" class="pw-post-body-paragraph ka kb hi kd b ke kf ij kg kh ki im kj la kl km kn lc kp kq kr le kt ku kv kw hb bi translated">现在，让我们看看它是如何工作</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="c4dc" class="pw-post-body-paragraph ka kb hi kd b ke kf ij kg kh ki im kj la kl km kn lc kp kq kr le kt ku kv kw hb bi translated">上面的代码片段将返回这个结果</p><pre class="iy iz ja jb fd ln lm lo lp aw lq bi"><span id="58b2" class="lr jg hi lm b fi ls lt l lu lv">5<br/>-1</span></pre></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="9578" class="pw-post-body-paragraph ka kb hi kd b ke kf ij kg kh ki im kj la kl km kn lc kp kq kr le kt ku kv kw hb bi translated">感谢您的阅读，本教程中使用的代码可以在<a class="ae kx" href="https://github.com/ErwanLT/designPattern" rel="noopener ugc nofollow" target="_blank">Github资源库</a>中找到。</p></div></div>    
</body>
</html>