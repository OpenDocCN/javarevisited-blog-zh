<html>
<head>
<title>Maven Plugins for Clean Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于干净代码的Maven插件</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/maven-plugins-for-clean-code-e84f2cb17b00?source=collection_archive---------1-----------------------#2021-09-14">https://medium.com/javarevisited/maven-plugins-for-clean-code-e84f2cb17b00?source=collection_archive---------1-----------------------#2021-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="245f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">代码审查:</h1><p id="e26b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">代码评审是当今几乎每个软件开发公司都在使用的实践。它允许您在CI / CD周期的早期阶段检测到错误，并降低以后发生错误的风险。这也是程序员之间交流知识的一个很好的机会——既有关于好的编码实践的知识，也有给定产品的领域知识。</p><p id="0406" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因为代码审查很重要，但是对于审查者来说，发现格式变化或者发现没有被使用的变量是非常困难的。人眼很难捕捉到这些东西，所以为什么不借助一些工具来实现自动化呢？</p><h1 id="6795" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">有用的Maven插件</strong></h1><h1 id="8f39" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">1.impsort-maven-plugin</h1><p id="b078" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个插件用于自动排序/验证Java源文件中所有导入语句的顺序。除了sort之外，它还提供了许多其他有用的功能，这些功能有助于保持代码库的一致性，比如导入分组和删除不使用的导入。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="9365" class="kp ig hi kl b fi kq kr l ks kt">&lt;plugin&gt;<br/>    &lt;groupId&gt;net.revelc.code&lt;/groupId&gt;<br/>    &lt;artifactId&gt;impsort-maven-plugin&lt;/artifactId&gt;<br/>    &lt;version&gt;1.2.0&lt;/version&gt;<br/>    &lt;configuration&gt;<br/>        &lt;removeUnused&gt;true&lt;/removeUnused&gt;<br/>        &lt;staticGroups&gt;*&lt;/staticGroups&gt;<br/>        &lt;groups&gt;java.,javax.,org.,com.&lt;/groups&gt;<br/>    &lt;/configuration&gt;<br/>    &lt;executions&gt;<br/>        &lt;execution&gt;<br/>            &lt;goals&gt;<br/>                &lt;goal&gt;sort&lt;/goal&gt;<br/>            &lt;/goals&gt;<br/>        &lt;/execution&gt;<br/>    &lt;/executions&gt;<br/>&lt;/plugin&gt;</span></pre><p id="71ed" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在<a class="ae ku" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jenkins-and-ci-cd-for-devops-engineers-and-software-developers-df2de8fe38f3"> CI/CD </a>中集成插件</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="8e45" class="kp ig hi kl b fi kq kr l ks kt">&lt;profile&gt;<br/>  &lt;id&gt;validate-format&lt;/id&gt;<br/>&lt;activation&gt;<br/>    &lt;property&gt;<br/>        &lt;name&gt;{pass property specific to CI/CD}&lt;/name&gt;<br/>    &lt;/property&gt;<br/>&lt;/activation&gt;<br/>  &lt;build&gt;<br/>    &lt;plugins&gt;<br/>      &lt;plugin&gt;<br/>        &lt;groupId&gt;net.revelc.code&lt;/groupId&gt;<br/>        &lt;artifactId&gt;impsort-maven-plugin&lt;/artifactId&gt;<br/>        &lt;executions&gt;<br/>          &lt;execution&gt;<br/>            &lt;goals&gt;<br/>              &lt;goal&gt;check&lt;/goal&gt;<br/>            &lt;/goals&gt;<br/>          &lt;/execution&gt;<br/>        &lt;/executions&gt;<br/>      &lt;/plugin&gt;<br/>      &lt;plugin&gt;<br/>&lt;/profile&gt;</span></pre><p id="b79a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以当这个插件在<a class="ae ku" rel="noopener" href="/javarevisited/7-best-courses-to-learn-intellij-idea-for-beginners-and-experienced-java-programmers-2e9aa9bb0c05?source=---------16------------------"> IDE </a>中使用时，目标是排序，但在CI/CD中使用时，目标是检查，因为我们不想在CI/CD中排序，而是希望验证它，并在验证失败的情况下使构建失败。</p><p id="921c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">更多信息:<a class="ae ku" href="https://code.revelc.net/impsort-maven-plugin/" rel="noopener ugc nofollow" target="_blank">https://code.revelc.net/impsort-maven-plugin/</a></p><h1 id="0abe" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.<strong class="ak">格式化程序-maven-插件</strong></h1><p id="ef12" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个插件用于自动格式化/验证一个maven项目(包括源代码)。遵循某些规范保持编码风格格式的一致性是防止不必要的冲突和代码差异的一个重要要求。</p><p id="65c3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，团队通常保持一种共同的风格，但需要在所有团队成员之间共享。为了避免在IDE中手工共享和导入样式表，推荐使用这个<a class="ae ku" href="https://javarevisited.blogspot.com/2016/08/top-10-maven-plugins-every-java-developer-know.html#axzz5YVjCcR8u" rel="noopener ugc nofollow" target="_blank">插件</a>。</p><p id="125b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们公司定义了java编码标准，这就是为什么把它添加为依赖项的原因，如果你的公司有添加这些标准的话。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5099" class="kp ig hi kl b fi kq kr l ks kt">&lt;plugin&gt;<br/>    &lt;groupId&gt;net.revelc.code.formatter&lt;/groupId&gt;<br/>    &lt;artifactId&gt;formatter-maven-plugin&lt;/artifactId&gt;<br/>    &lt;version&gt;2.0.1&lt;/version&gt;<br/>    &lt;executions&gt;<br/>      &lt;execution&gt;<br/>        &lt;goals&gt;<br/>          &lt;goal&gt;format&lt;/goal&gt;<br/>        &lt;/goals&gt;<br/>      &lt;/execution&gt;<br/>    &lt;/executions&gt;<br/>    &lt;dependencies&gt;<br/>      &lt;dependency&gt;<br/>        &lt;groupId&gt;com.test.standards&lt;/groupId&gt;<br/>        &lt;artifactId&gt;java-coding-standards&lt;/artifactId&gt;<br/>      &lt;/dependency&gt;<br/>    &lt;/dependencies&gt;<br/>    &lt;configuration&gt;<br/>      &lt;configFile&gt;eclipse-neon/eclipse-formatter.xml&lt;/configFile&gt;<br/>      &lt;lineEnding&gt;KEEP&lt;/lineEnding&gt;<br/>      &lt;compilerSource&gt;${java.version}&lt;/compilerSource&gt;<br/>      &lt;compilerCompliance&gt;${java.version}&lt;/compilerCompliance&gt;<br/>      &lt;compilerTargetPlatform&gt;${java.version}&lt;/compilerTargetPlatform&gt;<br/>    &lt;/configuration&gt;<br/>  &lt;/plugin&gt;<br/>&lt;/plugins&gt;</span></pre><p id="6395" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将此与CI/CD集成</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5b82" class="kp ig hi kl b fi kq kr l ks kt">&lt;plugin&gt;<br/>  &lt;groupId&gt;net.revelc.code.formatter&lt;/groupId&gt;<br/>  &lt;artifactId&gt;formatter-maven-plugin&lt;/artifactId&gt;<br/>  &lt;version&gt;2.0.1&lt;/version&gt;<br/>  &lt;executions&gt;<br/>    &lt;execution&gt;<br/>      &lt;goals&gt;<br/>        &lt;goal&gt;validate&lt;/goal&gt;<br/>      &lt;/goals&gt;<br/>    &lt;/execution&gt;<br/>  &lt;/executions&gt;<br/>&lt;/plugin&gt;</span></pre><p id="75c7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以当这个插件将在IDE中使用时，目标是格式，但当在CI/CD中使用时，目标是验证，因为我们不想在CI/CD中排序，而是希望验证它。</p><p id="0e21" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">更多信息:<a class="ae ku" href="https://code.revelc.net/formatter-maven-plugin/" rel="noopener ugc nofollow" target="_blank">https://code.revelc.net/formatter-maven-plugin/</a></p><h1 id="5526" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">3.<strong class="ak"> maven pmd插件</strong></h1><p id="66f0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">PMD是一个源代码分析器，用来发现常见的编程缺陷，比如未使用的变量、<a class="ae ku" href="https://javarevisited.blogspot.com/2013/03/0-exception-handling-best-practices-in-Java-Programming.html" rel="noopener ugc nofollow" target="_blank">空捕捉块</a> s、不必要的对象创建等等。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="b4c8" class="kp ig hi kl b fi kq kr l ks kt">&lt;plugin&gt;<br/>  &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;<br/>  &lt;configuration&gt;<br/>    &lt;excludeRoots&gt;<br/>      &lt;excludeRoot&gt;target/generated-sources&lt;/excludeRoot&gt;<br/>      &lt;excludeRoot&gt;target/generated-test-sources&lt;/excludeRoot&gt;<br/>    &lt;/excludeRoots&gt;<br/>    &lt;linkXRef&gt;true&lt;/linkXRef&gt;<br/>  &lt;/configuration&gt;<br/>&lt;/plugin&gt;</span></pre><p id="98ac" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">更多信息:【https://maven.apache.org/plugins/maven-pmd-plugin/ T4】</p><h1 id="4a76" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">4.<strong class="ak">斑点Bugs Maven插件</strong></h1><p id="4c9b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">SpotBugs在Java程序中寻找bug。它基于bug模式的概念。错误模式是一个经常出错的代码习语。错误模式的出现有多种原因:</p><ul class=""><li id="2c40" class="kv kw hi jf b jg kb jk kc jo kx js ky jw kz ka la lb lc ld bi translated">难懂的语言特征</li><li id="24e5" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated">被误解的API方法</li><li id="20d8" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated">维护期间修改代码时被误解的不变量</li><li id="5a53" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated">花园品种错误:打字错误，使用错误的布尔运算符</li></ul><p id="e918" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">SpotBugs使用<a class="ae ku" href="http://javarevisited.blogspot.sg/2014/02/why-static-code-analysis-is-important.html#axzz4pDTuzL00" rel="noopener ugc nofollow" target="_blank">静态分析</a>来检查Java字节码中bug模式的出现。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c1a4" class="kp ig hi kl b fi kq kr l ks kt">&lt;plugin&gt;<br/>  &lt;groupId&gt;com.github.spotbugs&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spotbugs-maven-plugin&lt;/artifactId&gt;<br/>  &lt;version&gt;4.2.0&lt;/version&gt;<br/>  &lt;executions&gt;<br/>    &lt;execution&gt;<br/>      &lt;id&gt;check&lt;/id&gt;<br/>      &lt;phase&gt;verify&lt;/phase&gt;<br/>      &lt;goals&gt;<br/>        &lt;goal&gt;check&lt;/goal&gt;<br/>      &lt;/goals&gt;<br/>    &lt;/execution&gt;<br/>  &lt;/executions&gt;<br/>&lt;/plugin&gt;<br/>&lt;plugin&gt;</span></pre><p id="b07b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">早期的findBugs是一个插件，但是现在被弃用了。这个插件对于鼓励开发者使用最佳实践非常有用。</p><p id="1c14" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">更多信息:<a class="ae ku" href="https://spotbugs.github.io/spotbugs-maven-plugin/index.html" rel="noopener ugc nofollow" target="_blank">https://spotbugs.github.io/spotbugs-maven-plugin/index.html</a></p><h1 id="f999" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">开发商的行动</strong></h1><p id="4763" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在提交PR之前，请在终端中运行<a class="ae ku" href="https://javarevisited.blogspot.com/2016/10/difference-between-mvn-install-release-and-deploy-in-Maven.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> mvn全新安装</strong> </a>，以便执行所有插件，并且您的CI/CD作业不会因为这些问题而失败。</p><p id="9dd9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">请评论我在这里遗漏的插件/工具。</p></div></div>    
</body>
</html>