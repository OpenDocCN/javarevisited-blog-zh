<html>
<head>
<title>Preventing Flaky Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防止不稳定的测试</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/preventing-flaky-tests-3a084ec5aa6e?source=collection_archive---------1-----------------------#2022-02-11">https://medium.com/javarevisited/preventing-flaky-tests-3a084ec5aa6e?source=collection_archive---------1-----------------------#2022-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/368b1e3160f33f33ca256ca3d4cff14c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G67aJP3FbRvJmine"/></div></div><p class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">国立癌症研究所</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="12b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当一个项目有一些测试成功通过或失败时，许多人都熟悉这种情况。这样的测试被称为易变的，在本文中，我们将讨论如何避免创建这样的测试。</p><p id="f82a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将使用Java <a class="ae iu" href="https://spring.io/?ref=hackernoon.com" rel="noopener ugc nofollow" target="_blank"> Spring框架</a>作为例子，但是这里讨论的原因适用于任何环境。</p><h1 id="5016" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">1.不稳定的环境</h1><p id="a65f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">易变测试的最常见原因是不稳定的环境。<br/>例如，测试使用一些为所有测试部署的公共数据库。当在<a class="ae iu" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jenkins-and-ci-cd-for-devops-engineers-and-software-developers-df2de8fe38f3"> CI/CD管道</a>中并行运行多个构建任务时，测试会修改彼此的数据。</p><p id="ef9f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，最可靠的解决方案是隔离环境。例如，您可以在docker容器中运行数据库(在Java中，有一个流行的库— <a class="ae iu" href="https://www.testcontainers.org/?ref=hackernoon.com" rel="noopener ugc nofollow" target="_blank"> Testcontainers </a>)。因此，一个测试运行将独占使用它的数据库，在测试运行之后，它将终止它。</p><p id="28d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样重要的是，不要忘记在每次测试后清理状态，以免影响测试套件中的后续测试。</p><h1 id="45bc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">2.调度程序和延迟操作</h1><p id="a0c7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">更罕见的原因是使用调度程序或延迟操作。<br/>假设在应用程序的某个部分，我们声明了一个调度程序:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="9aad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，在测试运行期间，它意外地工作了，因为测试正好在那个时间运行。编写测试的开发人员没有想到会有这样的副作用。</p><p id="fb9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了避免这种行为，您可以使时间表可配置。这将使应用程序更容易维护(无需重新构建代码来更改时间表)。它还将允许您在测试中覆盖调度，以便调度器只能手动运行。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="b6a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后在<code class="du lc ld le lf b">application.yml</code>中进行测试:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="f516" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您的应用程序使用延迟操作，您需要更加小心。一个动作可以在一个测试中注册，执行本身可以在另一个测试运行时发生。</p><h1 id="0768" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">3.使用睡眠</h1><p id="7982" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">使用<code class="du lc ld le lf b"><a class="ae iu" href="https://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html" rel="noopener ugc nofollow" target="_blank">Thread.sleep(..)</a></code>来等待某个动作完成，这表明测试有问题。</p><p id="e02f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于某种原因(例如GC暂停)，超时可能不够。如果我们将超时设置为一个较大的裕量，这将显著降低测试运行的速度。</p><p id="0874" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代替<code class="du lc ld le lf b">sleep</code>，我们可以在异步操作中返回<code class="du lc ld le lf b">Future</code>，而<a class="ae iu" href="https://javarevisited.blogspot.com/2015/07/how-to-use-wait-notify-and-notifyall-in.html" rel="noopener ugc nofollow" target="_blank">使用<code class="du lc ld le lf b">Future.get(20, TimeUnit.SECONDS)</code>等待</a>，超时很大。因此，整个测试执行甚至会减少。</p><h1 id="5272" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">4.上下文开关程序</h1><p id="f488" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您使用的是Spring，那么在缓存的上下文之间切换可能会导致不稳定的测试。这种行为很难调试，在添加另一个测试类之后，它可能随时发生。</p><p id="f8e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果套件中的一个测试类使用了<code class="du lc ld le lf b">@MockBean</code>，而另一个没有，那么将会创建两个不同的上下文。而<a class="ae iu" rel="noopener" href="/javarevisited/5-courses-to-learn-junit-and-mockito-in-2019-best-of-lot-f217d8b93688"> JUnit </a>引擎会以某种方式在它们之间切换。</p><p id="9a83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我只知道一种保证避免它的方法——将测试类合并到测试套件中，这样同一套件中的所有测试都使用相同的应用程序上下文。</p><h1 id="3f06" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="cdb2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">古怪的测试会严重破坏开发应用程序时的体验。一些公司建立了特殊的服务来检测不可靠的测试，并且只重新运行它们。</p><p id="a65c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，我的列表是不完整的，所以如果你在评论中写下你不得不处理的原因，我会很高兴。</p></div></div>    
</body>
</html>