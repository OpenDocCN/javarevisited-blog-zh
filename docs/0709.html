<html>
<head>
<title>Spring JPA: when to use “Join Fetch”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring JPA:何时使用“Join Fetch”</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-jpa-when-to-use-join-fetch-a6cec898c4c6?source=collection_archive---------1-----------------------#2020-09-28">https://medium.com/javarevisited/spring-jpa-when-to-use-join-fetch-a6cec898c4c6?source=collection_archive---------1-----------------------#2020-09-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e2b7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">避免N+1次查询并保留检索逻辑</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://medium.com/javarevisited/top-5-books-to-learn-hibernate-for-java-developers-b2cb4b16ccd6?source=---------14------------------"><div class="er es ix"><img src="../Images/009b44a4c7bdfb9d1b227f05241a2401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FxGHmdkX5utqcb1V"/></div></a><p class="jf jg et er es jh ji bd b be z dx translated">照片由<a class="ae jj" href="https://unsplash.com/@melocokr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sam Pak </a>在<a class="ae jj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0d63" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">刚接触<a class="ae jj" rel="noopener" href="/javarevisited/top-5-books-to-learn-hibernate-for-java-developers-b2cb4b16ccd6?source=---------14------------------"> JPA / Hibernate </a>的开发人员遇到的第一个也是最常见的问题之一就是<code class="du kg kh ki kj b">n+1 queries</code>。是因为通常负责<code class="du kg kh ki kj b">n+1 queries</code>的代码看起来并不怪异但是看起来很简单。这使得其他开发人员意识不到性能问题，只有在数据库中有足够的数据/记录时才发现它。</p><p id="c2a7" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">它可能看起来像这样简单:<code class="du kg kh ki kj b">person.getAddresses();</code></p><p id="365f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在本文中，我将讨论一个简单但常见的场景，其中使用“Join Fetch”是有益的。我还将包括两个集成测试来比较性能。但是首先，让我们阅读文档中的定义。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="8e4f" class="kr ks hi bd kt ku kv kw kx ky kz la lb jt lc ld le jx lf lg lh kb li lj lk ll bi translated">Hibernate文档</h2><blockquote class="lm ln lo"><p id="ed38" class="jk jl lp jm b jn jo ij jp jq jr im js lq ju jv jw lr jy jz ka ls kc kd ke kf hb bi translated"><em class="hi">" A</em><strong class="jm hj"><em class="hi">" fetch "</em></strong><em class="hi">join允许使用单次选择来初始化值的关联或集合及其父对象。这在集合的情况下特别有用。</em></p></blockquote><p id="a358" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这里有一个简单的场景来演示上面的定义:</p><h2 id="1ee8" class="kr ks hi bd kt ku kv kw kx ky kz la lb jt lc ld le jx lf lg lh kb li lj lk ll bi translated">领域实体/模型:</h2><blockquote class="lm ln lo"><p id="1b8c" class="jk jl lp jm b jn jo ij jp jq jr im js lq ju jv jw lr jy jz ka ls kc kd ke kf hb bi translated"><em class="hi">有</em> <strong class="jm hj"> <em class="hi">人</em> </strong> <em class="hi">实体有</em> <strong class="jm hj"> <em class="hi">集合</em></strong><em class="hi"/><strong class="jm hj"><em class="hi">地址</em> </strong></p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="2539" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在我们已经准备好了我们的域，创建一个<code class="du kg kh ki kj b">PersonRepository</code>，然后查询来自<code class="du kg kh ki kj b">Person</code>实体和<code class="du kg kh ki kj b">display each address line</code>的所有记录。让我们从导致<code class="du kg kh ki kj b"><a class="ae jj" href="https://www.java67.com/2016/02/top-20-hibernate-interview-questions.html" rel="noopener ugc nofollow" target="_blank">n+1 queries</a></code>的错误方法开始。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="2109" class="lv ks hi bd kt lw lx ly kx lz ma mb lb io mc ip le ir md is lh iu me iv lk mf bi translated">N+1个查询结果</h1><p id="7d30" class="pw-post-body-paragraph jk jl hi jm b jn mg ij jp jq mh im js jt mi jv jw jx mj jz ka kb mk kd ke kf hb bi translated">下面是一个集成测试，演示了导致<code class="du kg kh ki kj b">n+1 queries</code>的代码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><blockquote class="lm ln lo"><p id="c0e9" class="jk jl lp jm b jn jo ij jp jq jr im js lq ju jv jw lr jy jz ka ls kc kd ke kf hb bi translated">根据集成测试的要点，我有意删除了导入和其他注释——这样我们就可以专注于重要的部分。</p></blockquote><h2 id="212f" class="kr ks hi bd kt ku kv kw kx ky kz la lb jt lc ld le jx lf lg lh kb li lj lk ll bi translated">运行上述集成测试的结果:</h2><p id="abb5" class="pw-post-body-paragraph jk jl hi jm b jn mg ij jp jq mh im js jt mi jv jw jx mj jz ka kb mk kd ke kf hb bi translated"><code class="du kg kh ki kj b">121515718 nanoseconds spent executing <strong class="jm hj">51 JDBC statements</strong>;</code></p><p id="fff6" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">检索了<code class="du kg kh ki kj b">50</code>条记录，执行了<code class="du kg kh ki kj b">51</code>个查询，花费了大约<code class="du kg kh ki kj b">121 ms</code></p><p id="c620" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这可能看起来微不足道，因为我们只有50条记录，但这清楚地展示了<code class="du kg kh ki kj b">n+1 queries</code>场景。现在让我们尝试使用“Join Fetch ”,同时保留这种显示所有地址行的方式，并使用相同的记录比较结果。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="a6ba" class="lv ks hi bd kt lw lx ly kx lz ma mb lb io mc ip le ir md is lh iu me iv lk mf bi translated">连接提取结果</h1><p id="543e" class="pw-post-body-paragraph jk jl hi jm b jn mg ij jp jq mh im js jt mi jv jw jx mj jz ka kb mk kd ke kf hb bi translated">下面是<code class="du kg kh ki kj b">PersonRepository</code>的代码，它有一个利用JPQL来使用“连接提取”的<code class="du kg kh ki kj b">retrieveAll</code>方法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="e88b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">集成测试与上一个几乎相似，唯一的不同是我们现在使用我们刚刚创建的<code class="du kg kh ki kj b">retrieveAll</code>方法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lt lu l"/></div></figure><blockquote class="lm ln lo"><p id="4d60" class="jk jl lp jm b jn jo ij jp jq jr im js lq ju jv jw lr jy jz ka ls kc kd ke kf hb bi translated">根据集成测试的要点，我有意删除了导入和其他注释——这样我们就可以专注于重要的部分。</p></blockquote><h2 id="67b7" class="kr ks hi bd kt ku kv kw kx ky kz la lb jt lc ld le jx lf lg lh kb li lj lk ll bi translated">运行上述集成测试的结果:</h2><p id="cb45" class="pw-post-body-paragraph jk jl hi jm b jn mg ij jp jq mh im js jt mi jv jw jx mj jz ka kb mk kd ke kf hb bi translated"><code class="du kg kh ki kj b">15411157 nanoseconds spent executing 1 JDBC statements</code></p><p id="1c9b" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">检索了<code class="du kg kh ki kj b">50</code>条记录，执行了<code class="du kg kh ki kj b">1</code>个查询，花费了大约<code class="du kg kh ki kj b">15 ms</code></p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="82ad" class="lv ks hi bd kt lw lx ly kx lz ma mb lb io mc ip le ir md is lh iu me iv lk mf bi translated">结论</h1><p id="a19d" class="pw-post-body-paragraph jk jl hi jm b jn mg ij jp jq mh im js jt mi jv jw jx mj jz ka kb mk kd ke kf hb bi translated"><code class="du kg kh ki kj b">N+1 Queries</code>:执行<code class="du kg kh ki kj b">51</code>查询，取约<code class="du kg kh ki kj b">121 ms</code> <br/> <code class="du kg kh ki kj b">JOIN FETCH</code>:执行<code class="du kg kh ki kj b">1</code>查询，取约<code class="du kg kh ki kj b">15 ms</code></p><p id="0c73" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">上述比较虽然可能会有所不同，并且仅限于<code class="du kg kh ki kj b">50</code>条记录，但在性能上存在巨大差距，并且可能会有与记录数量成正比的指数差异。</p><p id="ecbb" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">使用Join Fetch是解决n+1查询的一种方法，同时保留了检索逻辑。有鉴于此，还有其他方法，如预测等。</p><p id="caf2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">本文的完整源代码可以在<a class="ae jj" href="https://github.com/emyasa/medium-articles/tree/master/java-persistence-api" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><p id="03a3" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我希望你喜欢读这篇文章。</p><p id="160a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">编码快乐！</p></div></div>    
</body>
</html>