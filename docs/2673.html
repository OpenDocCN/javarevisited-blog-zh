<html>
<head>
<title>Do You Know Immutable Class in Java? Why String is Immutable?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你知道Java中的不可变类吗？为什么字符串是不可变的？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/do-you-know-immutable-class-in-java-why-string-is-immutable-dc18b0cec4b9?source=collection_archive---------2-----------------------#2022-12-31">https://medium.com/javarevisited/do-you-know-immutable-class-in-java-why-string-is-immutable-dc18b0cec4b9?source=collection_archive---------2-----------------------#2022-12-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="dced" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">字符串-面试-问题</h2><div class=""/><div class=""><h2 id="ee4d" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">关于不变性的一切——什么、如何以及何时。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/98380dc8446743830e275125967da6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0hBA8NnTD6l7L8Z2j-eiQ.jpeg"/></div></div><p class="js jt et er es ju jv bd b be z dx translated">阿玛多·洛雷罗在<a class="ae jw" href="https://unsplash.com/s/photos/alphabet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="ae7b" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">嘿，这篇文章是关于Java中的可变性和不变性的。我将解释不可变类，它们的优点，如何创建它们，最后解释为什么string类是不可变的。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="ded2" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated">什么是Java中的不可变类？</h1><p id="2691" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">不可变类意味着一旦类的对象被创建，它的字段<em class="lx">就不能被修改或改变。</em> <strong class="kg hs"> </strong>在Java中，所有的包装类像<em class="lx"> Boolean、Short、Integer、Long、Float、Double、Byte、Char和</em> <strong class="kg hs"> <em class="lx"> String </em> </strong>类都是不可变类。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="2aa8" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated">不可变类的优点是什么？</h1><p id="6eb5" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">以下是不可变类或对象的优点:</p><ol class=""><li id="04de" class="ly lz hi kg b kh ki kk kl kn ma kr mb kv mc kz md me mf mg bi translated">无法更改或修改对象<strong class="kg hs">字段(状态)。</strong></li><li id="f7ed" class="ly lz hi kg b kh mh kk mi kn mj kr mk kv ml kz md me mf mg bi translated">它可以传递给任何方法，而不用担心该方法是否更改或修改了任何对象字段。</li><li id="c37a" class="ly lz hi kg b kh mh kk mi kn mj kr mk kv ml kz md me mf mg bi translated">对象的<strong class="kg hs">散列码</strong>很容易被<strong class="kg hs">缓存</strong>。</li><li id="b517" class="ly lz hi kg b kh mh kk mi kn mj kr mk kv ml kz md me mf mg bi translated">这些物体是地图的<strong class="kg hs">键</strong>的好选择。</li><li id="3f48" class="ly lz hi kg b kh mh kk mi kn mj kr mk kv ml kz md me mf mg bi translated">这些对象有利于多线程环境，因为对象的状态不会改变。</li><li id="28d9" class="ly lz hi kg b kh mh kk mi kn mj kr mk kv ml kz md me mf mg bi translated">不可变对象的状态不会改变，所以同一个对象可以在多个地方使用，从而节省内存。</li></ol></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="03e7" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated">如何在Java中创建不可变类？</h1><p id="029f" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">按照下面的步骤，一个简单的java <strong class="kg hs"> POJO </strong>类可以很容易地转换成一个不可变的类:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mm"><img src="../Images/33006edb9acfea3597c0ad69481dada8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*JoUCnY4L_Bs8FNYcQJ0dSQ.png"/></div><p class="js jt et er es ju jv bd b be z dx translated"><strong class="bd lc">不可变类的创建步骤</strong></p></figure><p id="0baf" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">我写过两个POJO类<strong class="kg hs">员工</strong>和<strong class="kg hs">公司</strong>。公司<strong class="kg hs"> </strong>是员工<strong class="kg hs"> </strong>类的一个属性。通过使用上面提到的5个步骤，我们将使Employee <strong class="kg hs"> </strong>成为一个不可变的类。Company <strong class="kg hs"> </strong>类在本文各处都保持不变。</p><h2 id="7330" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">公司类别:</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="na nb l"/></div><p class="js jt et er es ju jv bd b be z dx translated"><strong class="ak">公司类将在下面分</strong>使用</p></figure><h2 id="e0d2" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">1.不要为类编写Setters:</h2><p id="d5d7" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">通过删除或不写对象字段的设置器，程序员别无选择，只能使用<strong class="kg hs">设置器</strong>方法改变对象字段值。</p><h2 id="b02b" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">员工类别:</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="na nb l"/></div><p class="js jt et er es ju jv bd b be z dx translated"><strong class="ak">没有设置器的雇员类</strong></p></figure><p id="2685" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">您可能已经注意到，我已经跳过了<strong class="kg hs"> Employee </strong>类的对象字段的setter方法。这样就没有人能使用<strong class="kg hs"> setter </strong>方法改变对象字段值。</p><h2 id="ec93" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">2.包括所有参数构造函数:</h2><p id="32e4" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">通过在类中包含一个all参数构造函数，我们只允许在对象创建时初始化对象字段。</p><h2 id="c2ee" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">员工类别:</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="na nb l"/></div><p class="js jt et er es ju jv bd b be z dx translated"><strong class="ak">带所有参数的雇员类构造函数</strong></p></figure><h2 id="00ec" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">3.将课程设为最终课程:</h2><p id="aeb0" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">通过使我们的<strong class="kg hs"> Employee </strong>类成为final，这个类不能被任何其他类扩展，因此我们的final类的对象不能被任何其他类修改，因为没有其他类能够扩展它。</p><h2 id="23f1" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">员工类别:</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="na nb l"/></div><p class="js jt et er es ju jv bd b be z dx translated"><strong class="ak">作为最终类别的员工</strong></p></figure><h2 id="c197" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">4.对构造函数中的可变字段使用深度克隆:</h2><p id="b094" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">通过对在创建对象时传递给all参数构造函数的可变字段使用深度克隆，我们可以确保没有对对象克隆字段的任何引用，这样就没有人可以修改这个对象。</p><h2 id="8cc7" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">员工类别:</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="na nb l"/></div><p class="js jt et er es ju jv bd b be z dx translated"><strong class="ak">构造函数中可变字段的深度克隆</strong></p></figure><p id="6606" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">如果我们直接使用传递给构造函数的<code class="du nc nd ne nf b"><strong class="kg hs">company</strong></code>引用来给<code class="du nc nd ne nf b"><strong class="kg hs">Employee</strong></code>类的<code class="du nc nd ne nf b"><strong class="kg hs">company</strong></code>字段赋值，那么使用这个引用，我们可以改变传递给构造函数的引用的<code class="du nc nd ne nf b"><strong class="kg hs">companyName</strong></code>或<code class="du nc nd ne nf b"><strong class="kg hs">companySize</strong></code>字段，因为<code class="du nc nd ne nf b"><strong class="kg hs">Company</strong></code>类是一个可变类。</p><p id="b133" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">因此，使用<code class="du nc nd ne nf b"><strong class="kg hs">new</strong></code> <strong class="kg hs"> </strong>操作符创建<code class="du nc nd ne nf b"><strong class="kg hs">company</strong></code>引用的深度克隆，然后将其分配给<code class="du nc nd ne nf b"><strong class="kg hs">Employee</strong></code>类的<code class="du nc nd ne nf b"><strong class="kg hs">company</strong></code> <strong class="kg hs"> </strong>字段。</p><h2 id="2f60" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">5.从Getter方法返回类的可变字段的深层克隆对象:</h2><p id="49c6" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">通过从getter方法返回Employee类的可变字段的深度克隆对象，将没有对该类的实际可变字段的引用，因此没有人可以更改或修改Employee类的对象的可变字段。</p><h2 id="fe7f" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">员工类别:</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="na nb l"/></div><p class="js jt et er es ju jv bd b be z dx translated"><strong class="ak">getter方法中类的可变字段的深度克隆对象</strong></p></figure><h2 id="ea3d" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">最后，我们将Employee作为一个不可变的类，它的对象状态不会改变。</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="na nb l"/></div><p class="js jt et er es ju jv bd b be z dx translated">Employee作为一个不可变的类。</p></figure><p id="c5a5" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">输出:</p><pre class="jh ji jj jk fd ng nf nh bn ni nj bi"><span id="e573" class="nk lb hi nf b be nl nm l nn no">Employee Object is : Employee{name=’Ram’, empId=1000, company=Company{companyName=’Medium’, companySize=50}}</span></pre><blockquote class="np nq nr"><p id="5e23" class="ke kf lx kg b kh ki is kj kk kl iv km ns ko kp kq nt ks kt ku nu kw kx ky kz hb bi translated">注意:可以选择将Employee类的所有字段声明为final，这样就不能在其他地方修改它。</p></blockquote></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="6fda" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated">为什么字符串是不可变的？</h1><p id="0016" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">以下是字符串不变性的主要原因:</p><h2 id="b38f" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">1.字符串常量池的使用:</h2><p id="1237" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">字符串池是指存储在堆内存区域中的字符串的集合。当多个字符串变量包含相同的字符串文字时，它们可以引用字符串池中的相同字符串对象。这个概念允许Java虚拟机有效地节省内存。下图说明了字符串池的概念。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><a href="https://www.java67.com/2018/06/top-35-java-string-interview-questions.html"><div class="er es nv"><img src="../Images/a8f01655e307588817fa58e0077252bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*4Mc0ByeWsjXudY5_nPvgDw.png"/></div></a><p class="js jt et er es ju jv bd b be z dx translated">Java中的字符串池</p></figure><h2 id="5af3" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">2.安全性:</h2><p id="8bb0" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">在Java中，字符串通常用于存储敏感信息，如用户名和密码。如果字符串是可变的，那么这些字符串就有被恶意的个人修改的风险。因此，将敏感信息存储为可变字符串是不安全的。</p><h2 id="6267" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">3.线程安全:</h2><p id="159d" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">因为字符串对象是不可变的，所以从多个线程访问它们不会导致更改，这使得它们在多线程环境中使用更安全。此外，同一个字符串对象可以在多个线程之间共享。</p><h2 id="bab9" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">4.可缓存HashCode:</h2><p id="b946" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">字符串是任何java应用程序中使用最广泛的对象。分别用于<code class="du nc nd ne nf b"><strong class="kg hs">HashMap</strong></code> <strong class="kg hs">、</strong>、<code class="du nc nd ne nf b"><strong class="kg hs">HashTable</strong></code>、<strong class="kg hs">、</strong>、<code class="du nc nd ne nf b"><strong class="kg hs">HashSet</strong></code>等。。还要注意，String类的被覆盖的<strong class="kg hs"> </strong> <code class="du nc nd ne nf b"><strong class="kg hs">hashCode()</strong></code>方法被频繁地调用以进行分桶。</p><p id="d3ab" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">由于字符串是不可变的，因此它们不会改变，因此当第一次调用被缓存的字符串对象的hashcode时，随后，对于频繁的<code class="du nc nd ne nf b">hashCode()</code>方法调用，返回相同的值。</p><p id="6ea9" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">如果我们将可变对象与类似于<code class="du nc nd ne nf b"><strong class="kg hs">HashMap</strong></code>、<code class="du nc nd ne nf b"><strong class="kg hs">HashSet</strong></code>或<code class="du nc nd ne nf b"><strong class="kg hs">HashTable</strong></code>的集合一起使用，可能会有不同的hashcodesss，一个是对象内容未被修改时的hashcode，另一个是对象内容被修改时的hashcode。因此，在<code class="du nc nd ne nf b"><strong class="kg hs">Map</strong></code> <strong class="kg hs"> </strong>数据结构的情况下，不应该使用可变对象作为键，如果在Map中使用它们，那么我们可能会丢失与Map中的键相关联的值。</p><h2 id="e2fd" class="mn lb hi bd lc mo mp mq lg mr ms mt lk kn mu mv lm kr mw mx lo kv my mz lq ho bi translated">5.改进的性能:</h2><p id="53c4" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated">通常，性能和内存使用密切相关。通过使用字符串池，具有相同内容的多个字符串变量只占用池中的一个实例，如前一点所述。JVM堆中内存使用的减少导致了应用程序性能的提高。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="2cb5" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated"><strong class="kg hs"> <em class="lx">感谢您阅读本文。我希望我已经涵盖了不可变类和字符串的所有方面。</em>T3】</strong></p><h1 id="e4a2" class="la lb hi bd lc ld nw lf lg lh nx lj lk ix ny iy lm ja nz jb lo jd oa je lq lr bi translated">您可以关注<a class="ob oc ge" href="https://medium.com/u/2c3b611409dc?source=post_page-----dc18b0cec4b9--------------------------------" rel="noopener" target="_blank">维克拉姆·古普塔</a>了解类似内容。</h1><p id="4623" class="pw-post-body-paragraph ke kf hi kg b kh ls is kj kk lt iv km kn lu kp kq kr lv kt ku kv lw kx ky kz hb bi translated"><strong class="kg hs"> <em class="lx">你可能喜欢看下面的面试问题:</em> </strong></p><div class="od oe ez fb of og"><a rel="noopener follow" target="_blank" href="/@basecs101/what-does-string-pool-mean-in-java-996f0554e1dc"><div class="oh ab dw"><div class="oi ab oj cl cj ok"><h2 class="bd hs fi z dy ol ea eb om ed ef hr bi translated">字符串池在Java中是什么意思？</h2><div class="on l"><h3 class="bd b fi z dy ol ea eb om ed ef dx translated">了解Java中的字符串池，以及如何在字符串池中存储和检索对象。</h3></div><div class="oo l"><p class="bd b fp z dy ol ea eb om ed ef dx translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou jq og"/></div></div></a></div><div class="od oe ez fb of og"><a href="https://levelup.gitconnected.com/string-stringbuilder-and-stringbuffer-a-complete-guide-5ddd083a2ad5" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab dw"><div class="oi ab oj cl cj ok"><h2 class="bd hs fi z dy ol ea eb om ed ef hr bi translated">String、StringBuilder和StringBuffer:完整指南</h2><div class="on l"><h3 class="bd b fi z dy ol ea eb om ed ef dx translated">了解java中的文本/字符串操作类，如何以及何时使用它们。</h3></div><div class="oo l"><p class="bd b fp z dy ol ea eb om ed ef dx translated">levelup.gitconnected.com</p></div></div><div class="op l"><div class="ov l or os ot op ou jq og"/></div></div></a></div><div class="od oe ez fb of og"><a href="https://levelup.gitconnected.com/working-of-tostring-and-comparing-concat-and-append-f688a5f8433c" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab dw"><div class="oi ab oj cl cj ok"><h2 class="bd hs fi z dy ol ea eb om ed ef hr bi translated">处理toString并比较Concat、“+”和append</h2><div class="on l"><h3 class="bd b fi z dy ol ea eb om ed ef dx translated">如何以及何时在java应用程序中使用toString方法。</h3></div><div class="oo l"><p class="bd b fp z dy ol ea eb om ed ef dx translated">levelup.gitconnected.com</p></div></div><div class="op l"><div class="ow l or os ot op ou jq og"/></div></div></a></div></div></div>    
</body>
</html>