<html>
<head>
<title>Java GC, the basic I think we should already know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java GC，基本的我想大家应该已经知道了</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-gc-the-basic-i-think-we-should-already-know-98f20a98eb5c?source=collection_archive---------1-----------------------#2020-02-21">https://medium.com/javarevisited/java-gc-the-basic-i-think-we-should-already-know-98f20a98eb5c?source=collection_archive---------1-----------------------#2020-02-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/312a45ca7bc2791506e125b1dbe36bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N7KFWP2xLFWUoOk0"/></div></div><p class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@gary_at_unsplash?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陈嘉里</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b335" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近，当我被问及Java垃圾收集器时，我认为我应该知道的一切都从我的脑海中消失了。我是说，这很不幸，但没关系；现在，我有机会在练习英语的同时打磨和重塑我的知识(如果你正在用葡萄牙语阅读这篇文章，请忽略)，现在，有一个地方可以让这个主题在我的脑海中保持新鲜，希望在其他人的脑海中也是如此。因此，让我们来看看这个伟大的内存管理工具的一些基本情况，以及它如何改变您作为Java开发人员的日常编码。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="fc8c" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">垃圾收集器是什么？</h1><p id="eb78" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我亲切地称它为JGC(在你的脑海中读出“Jay Gee See”)，或者简称为GC，正如它的名字所说:“听起来像是某种收集垃圾的东西”。太好了！GC在Java中找到不用的对象并删除它们来释放一些内存，这样你就不用担心内存不够用了。这是一个执行堆内存管理的自动过程，堆是JVM (Java虚拟机)用来创建对象的专用内存部分。而这种“管理”是如何做到的？通过清理不用的物品。</p><div class="ld le ez fb lf lg"><a href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hj fi z dy ll ea eb lm ed ef hh bi translated">学习JVM内部结构、内存管理和Java性能调优的前5门课程</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">对于一个高级Java开发人员来说，了解JVM的工作原理以及如何解决与…相关的问题是非常重要的</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu io lg"/></div></div></a></div><h1 id="7a78" class="ka kb hi bd kc kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx bi translated">JGC是如何工作的？</h1><p id="9f25" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们的朋友GC真的很聪明:正如我所说的，它是一个自动的过程，不像其他编程语言，比如C，你不必担心标记要删除的对象:GC实现知道如何找到未使用的对象，我指的是现在被另一个活动对象引用的对象。</p><h2 id="65eb" class="ma kb hi bd kc mb mc md kg me mf mg kk jg mh mi ko jk mj mk ks jo ml mm kw mn bi translated">但是怎么做呢？</h2><p id="9f13" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">当我们说要“斩草除根”时，GC却反其道而行之:它不再寻找无用的东西，而是开始逐根寻找好的东西——在这种情况下，我们称之为<em class="mo">活着的对象</em>。</p><p id="c403" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和我一起走向绿色，想象一棵树:b̶e̶ ̶a̶ ̶y̶o̶u̶永远是主要的方法，就像这样:</p><pre class="mp mq mr ms fd mt mu mv mw aw mx bi"><span id="7e32" class="ma kb hi mu b fi my mz l na nb">public static void main(String[] args){<br/>// oh, how I love this method &lt;3<br/>Cat myBWCat = new Cat("Gerald");<br/>Cat myShyCat = new Cat("Gray");<br/>Cat myGirlCat = new Cat("Yennefer");<br/>doingSomeStuff();<br/>}</span></pre><p id="a8bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们最早的树根之一！当您第一次启动您的应用程序时，必须有一些东西让您的对象保留下来，并且不会被GC删除，为什么不保留您面前的第一个东西呢？</p><p id="8a99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，从这个根开始，GC开始标记<em class="mo">实际上正在使用的对象</em>，使我们的树变得更强壮，充满分枝、树枝、树叶和果实。并且像这样，引用的对象被标记为<em class="mo">活的</em>。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html"><div class="er es nc"><img src="../Images/462b482417084dd4c3ac9a12effd09d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*m5EXM3I72zAZIvMuFuTmRQ.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">这棵小小的猫树上的三个果实，根在main()上。请注意，我们仍然有对它们的引用。</p></figure><p id="56e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而地上的枯叶烂果呢？有时(我们会看到这也是可配置的，但不是确定性的)，GC会检查堆中的所有对象，看看什么是杂乱的，并为我们清理它。假设我创建了一个对象，但之后我丢失了对它的引用，比如:</p><pre class="mp mq mr ms fd mt mu mv mw aw mx bi"><span id="abd0" class="ma kb hi mu b fi my mz l na nb">public static void main(String[] args){<br/>// Now, other objects here<br/>Pet cat = new Cat("Garfield");<br/>Pet dog = new Dog("Odie");<br/>cat = null;<br/>}</span></pre><p id="8126" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">加菲猫去哪了？在这个例子中，Cat类的对象“Garfield”将从内存中清除，因为在我们的应用程序中没有对它的引用。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><a href="https://www.java67.com/2020/02/50-garbage-collection-interview-questions-answers-java.html"><div class="er es nc"><img src="../Images/27b1a938ae3d6d9bda95dafbc7290bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*falNKPc_PZqRUtNEFZV_VQ.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">加菲猫会被收集起来，因为它到处漂浮。</p></figure><p id="fa48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时，我们会发生一些有趣的事情:假设一个对象A引用一个对象B，而B引用A，这听起来像是GC会忽略的事情，因为这里没有松散引用。但是我没有告诉你的是<em class="mo">只有一些东西可以是根</em>，因此，A→B→A对象关系不会被认为是GC的活对象树，除非A或B是一个<em class="mo">有效的</em>根。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/ee20dc5e49ccfc28abc54ce594b37bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*LmAiS07wk12qSOyE6f-U4w.png"/></div><p class="iq ir et er es is it bd b be z dx translated">将收集a和B。这也被称为“孤岛”。你也可以把一个单独的物体看作一个岛。</p></figure><h2 id="c738" class="ma kb hi bd kc mb mc md kg me mf mg kk jg mh mi ko jk mj mk ks jo ml mm kw mn bi translated">一切善的根源是什么？</h2><p id="6145" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">GC根有很多种，我可以花一整天的时间来提及和解释每一种。它们也是垃圾收集器实现的一个特殊细节。因此，从理论上讲，我可以实现一个垃圾收集，它总是将任何猫对象标记为活动的，并有一个装满猫的堆，这将是非常棒的。</p><p id="af86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来谈谈最广为人知的JVM实现，由Oracle公司维护和发布的Java虚拟机<em class="mo"> HotSpot </em>。我提到过垃圾收集属于JVM吗？没有吗？嗯，现在我做到了:)</p><p id="85d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记下这一点，“通常被算作GC算法的根的例子”:</p><ul class=""><li id="b628" class="ne nf hi ix b iy iz jc jd jg ng jk nh jo ni js nj nk nl nm bi translated">main方法中的局部变量；</li><li id="12df" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">主线程；</li><li id="c19e" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">主类的静态变量；</li><li id="ed7b" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">用于同步的监视器；</li><li id="c7c3" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">由Java系统类加载器加载的类</li></ul><p id="b498" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任何与它们相关的(或被它们引用的)东西都不会受到GC的攻击并被标记。</p><div class="ld le ez fb lf lg"><a href="https://www.java67.com/2019/08/best-books-to-learn-java-virtual-machine-in-depth.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hj fi z dy ll ea eb lm ed ef hh bi translated">深入学习Java虚拟机、垃圾收集和性能的前5本书</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">在过去的几年里，我看到了一种趋势，许多Java开发人员想要学习更多关于JVM的知识…</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">www.java67.com</p></div></div><div class="lp l"><div class="ns l lr ls lt lp lu io lg"/></div></div></a></div><h2 id="b469" class="ma kb hi bd kc mb mc md kg me mf mg kk jg mh mi ko jk mj mk ks jo ml mm kw mn bi translated">好了，现在怎么办？</h2><p id="7bec" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">好了，现在我们有了自己的根，我们必须做一些清洁工作。其实不是现在，我们要把之前的一切都整理好！你知道什么时候你需要整理你的盘子、杯子和餐具，这样你就有空间去清理它们了？这就是GC正在做的事情。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/10/133-java-interview-questions-answers-from-last-5-years.html#axzz5ntvpdIs3"><div class="er es nt"><img src="../Images/ea1415c8ae18d83722047e3ea227c803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4E7YUW5BWIWw3V7M"/></div></a><p class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·拉克</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ca3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GC标记所有对象，从根开始遍历相互引用的对象树。在HotSpot实现中，实际上还有其他实现，使用了一个很好的对象管理策略:按年龄对对象进行分类，称为分代垃圾收集策略。</p><p id="f81d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很巧妙:大多数应用程序会创建很多很多小而短暂的对象，但是它们也会有一些对象在应用程序的整个生命周期中一直存在。没有什么比更频繁地检查自服务器启动以来就存在的bean更好的了。</p><p id="5059" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，GC将内存中的一些部分分开:</p><ul class=""><li id="c6e5" class="ne nf hi ix b iy iz jc jd jg ng jk nh jo ni js nj nk nl nm bi translated">最新的对象从年轻一代开始。这一部分被细分为伊甸园空间和两个幸存者空间，伊甸园空间是他们开始生活的地方，幸存者空间是在一次收集活动中幸存下来的新物品举行聚会庆祝他们的第一个“生日”的地方</li><li id="e781" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">幸存者在庆祝了一些生日后，会搬到老一代区(也叫终身职位，我觉得这个名字更可爱、更甜蜜)</li><li id="8bed" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">在Java 8之前，有永久生成部分，保存来自类和内部化字符串的数据。在Java 8中，这被换成了元空间，元空间现在保存类定义，而其他东西回到了传统的内存堆。</li></ul><div class="ld le ez fb lf lg"><a href="https://javarevisited.blogspot.com/2018/07/top-5-java-performance-tuning-books-for.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hj fi z dy ll ea eb lm ed ef hh bi translated">面向有经验程序员的5大Java性能调优书籍——最好的，必读</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">您可能会想，为什么Java开发人员要读一本关于性能调优的书呢？当我第一次面对这个问题的时候…</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="lp l"><div class="nu l lr ls lt lp lu io lg"/></div></div></a></div><h2 id="b0e4" class="ma kb hi bd kc mb mc md kg me mf mg kk jg mh mi ko jk mj mk ks jo ml mm kw mn bi translated">现在，我们打扫？</h2><p id="debd" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">是的，现在我们打扫！有3种垃圾收集事件:次要、主要和完整事件:</p><ul class=""><li id="0ef5" class="ne nf hi ix b iy iz jc jd jg ng jk nh jo ni js nj nk nl nm bi translated">在未成年人，对象是从年轻一代部分收集；</li><li id="8674" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">在major中，较旧的对象是从Tenured Generation部分收集的；</li><li id="7f14" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">在完整事件中，所有部分都收集了它们未使用的对象。</li></ul><p id="dd60" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">友情提醒:收集的对象是从有效根开始<em class="mo">不是</em>标记为活的，好吗？</p><h1 id="5452" class="ka kb hi bd kc kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx bi translated">后续步骤</h1><p id="ba6c" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">哦，我的天，有这么多我没有提到的！我们可以在这里写下一大堆稀奇古怪的东西，但是文字太长了。我将在这里列出一些我发现的关于GC的非常特别的主题，稍后我会写出来，但是如果你太好奇而等不及的话，你可以自己搜索一下。</p><p id="0844" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">—性能</p><ul class=""><li id="a410" class="ne nf hi ix b iy iz jc jd jg ng jk nh jo ni js nj nk nl nm bi translated">实际上，世代假设可能不适用于您的应用程序；</li><li id="f8a4" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">从HotSpot中选择4个GC实现之一；</li><li id="234e" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">当GC被触发时(停止世界事件)</li></ul><p id="2136" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">—内存使用</p><ul class=""><li id="8c0e" class="ne nf hi ix b iy iz jc jd jg ng jk nh jo ni js nj nk nl nm bi translated">巨大的物体(我喜欢这个词)；</li><li id="b547" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">当GC被触发时(某些区域已满)；</li><li id="842d" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">记忆是如何细分的；</li><li id="d3be" class="ne nf hi ix b iy nn jc no jg np jk nq jo nr js nj nk nl nm bi translated">这些细分是如何工作的</li></ul><p id="b066" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">—其他东西</p><ul class=""><li id="27fe" class="ne nf hi ix b iy iz jc jd jg ng jk nh jo ni js nj nk nl nm bi translated">finalize()方法！我的天啊。</li></ul><p id="7374" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再次感谢你的耐心，希望你喜欢它，并期待下一个！</p><div class="ld le ez fb lf lg"><a href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hj fi z dy ll ea eb lm ed ef hh bi translated">学习JVM内部结构、内存管理和Java性能调优的前5门课程</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">对于一个高级Java开发人员来说，了解JVM的工作原理以及如何解决与…相关的问题是非常重要的</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu io lg"/></div></div></a></div><h1 id="bec3" class="ka kb hi bd kc kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx bi translated">参考</h1><p id="1334" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated"><a class="ae iu" href="https://stackify.com/what-is-java-garbage-collection/" rel="noopener ugc nofollow" target="_blank">https://stackify.com/what-is-java-garbage-collection/</a><br/><a class="ae iu" href="https://www.java67.com/2019/08/best-books-to-learn-java-virtual-machine-in-depth.html" rel="noopener ugc nofollow" target="_blank">https://www . Java 67 . com/2019/08/best-books-to-learn-Java-virtual-machine-in-depth . html</a><br/><a class="ae iu" href="https://www.javaworld.com/article/2078645/jvm-performance-optimization-part-3-garbage-collection.html" rel="noopener ugc nofollow" target="_blank">https://www . javaworld . com/article/2078645/JVM-performance-optimization-part-3-garbage-collection . html</a><br/><a class="ae iu" href="https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html#axzz4zt6jlTWS" rel="noopener ugc nofollow" target="_blank">https://Java reviewed . blogspot . com/2011/2011</a></p><div class="ld le ez fb lf lg"><a href="https://javarevisited.blogspot.com/2019/10/the-java-developer-roadmap.html#123" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hj fi z dy ll ea eb lm ed ef hh bi translated">2020年Java开发者路线图</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">大家好，首先祝大家2020新年快乐。我已经分享了很多成为网络的路线图…</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="lp l"><div class="nv l lr ls lt lp lu io lg"/></div></div></a></div></div></div>    
</body>
</html>