<html>
<head>
<title>Hexagonal Architecture in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的六边形架构</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/hexagonal-architecture-in-java-9031d3570d15?source=collection_archive---------2-----------------------#2020-05-23">https://medium.com/javarevisited/hexagonal-architecture-in-java-9031d3570d15?source=collection_archive---------2-----------------------#2020-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8952" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Java中六边形架构的一个实例</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ebc74c3d70de4686b40a17a33aae4c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fMloZow6VoHAh4KL"/></div></div></figure><h1 id="a8b4" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">1.概观</h1><p id="4ff1" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在本教程中，我们将看看Java 中的<strong class="kd hj">六边形架构。为了进一步说明这一点，我们将创建一个Spring Boot应用程序。</strong></p><h1 id="fbf2" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">2.六角形建筑</h1><p id="92ab" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">六边形体系结构描述了围绕领域逻辑设计软件应用程序的模式。<strong class="kd hj">六边形描述了应用程序的</strong> <strong class="kd hj">核心，由领域对象和应用程序的用例</strong>组成。</p><p id="00d2" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">六边形的边缘为六边形的外部提供了<strong class="kd hj">入站和出站端口</strong>，如web界面、数据库等。所以，在这种<a class="ae lc" rel="noopener" href="/javarevisited/top-5-courses-to-learn-software-architecture-in-2020-best-of-lot-5d34ebc52e9">软件架构</a>、<strong class="kd hj">中，组件之间的所有</strong>、<strong class="kd hj">依赖都指向域</strong>对象。</p><p id="d6bf" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">因此，只有使用<strong class="kd hj">端口和适配器</strong>才能实现核心应用程序和外部部分之间的通信。</p><p id="73e9" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在下面的章节中，我们可以深入探讨六边形架构的不同层次。</p><h1 id="0f15" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">3.域对象</h1><p id="45a6" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">域对象是应用程序的核心部分。</strong>它既可以有状态，也可以有行为。然而，它没有任何外部依赖性。因此其他层中的任何变化都不会影响域对象。</p><p id="ea5f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">只有当业务需求发生变化时，域对象才会发生变化。因此，这是<a class="ae lc" rel="noopener" href="/javarevisited/25-software-design-interview-questions-to-crack-any-programming-and-technical-interviews-4b8237942db0">软件设计</a>的<a class="ae lc" rel="noopener" href="/javarevisited/10-oop-design-principles-you-can-learn-in-2020-f7370cccdd31">实体原则</a>中单一责任原则的一个例子。</p><p id="8497" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">首先，让我们创建一个域对象<code class="du ld le lf lg b"><em class="lh">Product</em></code>，它构成了应用程序的核心。它包含产品相关信息和业务验证:</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="019c" class="lm jk hi lg b fi ln lo l lp lq">public class Product {<br/><br/>    private Integer productId;<br/>    private String type;<br/>    private String description;<br/><br/><br/>    public Product() {<br/>        super();<br/>    }<br/><br/>    public Product(Integer productId, String type, String description) {<br/>        this.productId = productId;<br/>        this.type = type;<br/>        this.description = description;<br/>    }<br/>    //getters and setters<br/>}</span></pre><h1 id="705f" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">4.港口</h1><p id="0f21" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">端口是允许入站和出站流量的接口。因此，应用程序的核心部分使用专用端口与外部部分通信。</p><h1 id="9a2c" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">4.1.入境港口</h1><p id="1f30" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">入站端口将核心应用程序暴露给外部</strong>。它是一个可以被外部组件调用的接口。这些调用入站端口的外部组件被称为<strong class="kd hj">主适配器或输入适配器。</strong></p><p id="3f83" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">让我们定义一个接口<code class="du ld le lf lg b"><em class="lh">ProductService</em></code>，它是入站端口:</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="a0d5" class="lm jk hi lg b fi ln lo l lp lq">public interface ProductService {<br/><br/>    List&lt;Product&gt; getProducts();<br/><br/>    Product getProductById(Integer productId);<br/><br/>    Product addProduct(Product product);<br/><br/>    Product removeProduct(Integer productId);<br/>}</span></pre><h1 id="94b9" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">4.2.出站端口</h1><p id="4261" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">出站端口允许核心应用</strong>的外部功能。它是一个接口，使核心应用的用例能够与外部通信，如<a class="ae lc" rel="noopener" href="/javarevisited/7-free-courses-to-learn-database-and-sql-for-programmers-and-data-scientist-e7ae19514ed2">数据库</a>访问。因此，出站端口由称为<strong class="kd hj">次级或输出适配器</strong>的外部组件实现。</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="95e7" class="lm jk hi lg b fi ln lo l lp lq">public interface ProductRepository {<br/><br/>    List&lt;Product&gt; getProducts();<br/><br/>    Product getProductById(Integer productId);<br/><br/>    Product addProduct(Product product);<br/><br/>    Product removeProduct(Integer productId);<br/>}</span></pre><h1 id="8611" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">5.适配器</h1><p id="061e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">适配器是六角形结构的外部部分。因此，它们只通过使用入站和出站端口与核心应用程序进行交互。</p><h1 id="f69f" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">5.1.主要适配器</h1><p id="f00e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">主适配器也称为输入或驱动适配器。因此，<strong class="kd hj">它们通过使用入站端口</strong>调用核心应用的相应用例来驱动应用。例如，主适配器是REST APIs或web接口。</p><p id="c6ad" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">让我们定义一个<code class="du ld le lf lg b"><em class="lh">ProductController</em></code>类作为我们的主适配器。特别是，它是一个<a class="ae lc" rel="noopener" href="/javarevisited/top-5-books-and-courses-to-learn-restful-web-services-in-java-using-spring-mvc-and-spring-boot-79ec4b351d12"> REST控制器</a>，为创建和访问产品提供端点。随后，它使用入站端口服务与核心应用程序进行交互:</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="58cd" class="lm jk hi lg b fi ln lo l lp lq">@RestController<br/>@RequestMapping("/api/v1/product")<br/>public class ProductController {<br/><br/>    private ProductService productService;<br/><br/>    @Autowired<br/>    public ProductController(ProductService productService) {<br/>        this.productService = productService;<br/>    }<br/><br/>    @GetMapping<br/>    public ResponseEntity&lt;List&lt;Product&gt;&gt; getProducts() {<br/>        return new ResponseEntity&lt;&gt;(productService.getProducts(), HttpStatus.<em class="lh">OK</em>);<br/>    }<br/><br/>    @GetMapping("/{productId}")<br/>    public ResponseEntity&lt;Product&gt; getProductById(@PathVariable Integer productId) {<br/>        return new ResponseEntity&lt;&gt;(productService.getProductById(productId), HttpStatus.<em class="lh">OK</em>);<br/>    }<br/><br/>    @PostMapping<br/>    public ResponseEntity&lt;Product&gt; addProduct(@RequestBody Product product) {<br/>        return new ResponseEntity&lt;&gt;(productService.addProduct(product), HttpStatus.<em class="lh">CREATED</em>);<br/>    }<br/><br/>    @DeleteMapping("/{productId}")<br/>    public ResponseEntity&lt;Product&gt; removeProduct(@PathVariable Integer productId) {<br/>        return new ResponseEntity&lt;&gt;(productService.removeProduct(productId), HttpStatus.<em class="lh">OK</em>);<br/>    }<br/>}</span></pre><h1 id="c231" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">5.2.辅助适配器</h1><p id="cddf" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">次级适配器也称为输出或驱动适配器。<strong class="kd hj">这些是出站端口接口</strong>的实现。核心应用程序的用例使用输出端口调用辅助适配器。例如，辅助适配器是到数据库和外部API调用的连接。</p><p id="0b3d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">让我们定义一个类<code class="du ld le lf lg b"><em class="lh">ProductRepositoryImplementation</em></code>作为我们的辅助适配器。特别是，这个类实现了出站端口接口<code class="du ld le lf lg b"><em class="lh">ProductRepository</em></code>，并允许核心应用程序访问数据库:</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="6fa6" class="lm jk hi lg b fi ln lo l lp lq">@Repository<br/>public class ProductRepositoryImplementation implements ProductRepository {<br/><br/>    private static final Map&lt;Integer, Product&gt; <em class="lh">productMap </em>= new HashMap&lt;Integer, Product&gt;(0);<br/><br/>    @Override<br/>    public List&lt;Product&gt; getProducts() {<br/>        return new ArrayList&lt;Product&gt;(<em class="lh">productMap</em>.values());<br/>    }<br/><br/>    @Override<br/>    public Product getProductById(Integer productId) {<br/>        return <em class="lh">productMap</em>.get(productId);<br/>    }<br/><br/>    @Override<br/>    public Product addProduct(Product product) {<br/>        <em class="lh">productMap</em>.put(product.getProductId(), product);<br/>        return product;<br/>    }<br/><br/>    @Override<br/>    public Product removeProduct(Integer productId) {<br/>        if(<em class="lh">productMap</em>.get(productId)!= null){<br/>            Product product = <em class="lh">productMap</em>.get(productId);<br/>            <em class="lh">productMap</em>.remove(productId);<br/>            return product;<br/>        } else<br/>            return null;<br/><br/>    }<br/>}</span></pre><p id="3233" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kd hj">适配器为应用提供了灵活性，而不会影响核心应用逻辑</strong>。如果除了现有客户端之外，新的客户端也可以使用该应用程序，那么我们可以将新的客户端添加到入站端口。此外，如果应用程序需要不同的<a class="ae lc" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-microsoft-sql-server-and-oracle-database-in-2020-6708afcf4ad7">数据库</a>，我们可以添加一个新的辅助适配器来实现相同的出站端口。</p><h1 id="6a8f" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">6.核心应用程序的使用案例</h1><p id="d424" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">核心应用的用例是六角形架构</strong>的内部部分。它们是入站端口的特定用例实现。因此，<strong class="kd hj">它包含了所有用例特定的业务规则验证和逻辑</strong>。用例没有类似于域对象的外部依赖。</p><p id="31fa" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">让我们定义一个提供特定用例实现的类<code class="du ld le lf lg b"><em class="lh">ProductServiceImplementation</em></code>:</p><pre class="iy iz ja jb fd li lg lj lk aw ll bi"><span id="16d2" class="lm jk hi lg b fi ln lo l lp lq">@Service<br/>public class ProductServiceImplementation implements ProductService {<br/>    @Autowired<br/>    private ProductRepository productRepository;<br/><br/>    @Override<br/>    public List&lt;Product&gt; getProducts() {<br/>        return productRepository.getProducts();<br/>    }<br/><br/>    @Override<br/>    public Product getProductById(Integer productId) {<br/>        return productRepository.getProductById(productId);<br/>    }<br/><br/>    @Override<br/>    public Product addProduct(Product product) {<br/>        return productRepository.addProduct(product);<br/>    }<br/><br/>    @Override<br/>    public Product removeProduct(Integer productId) {<br/>        return productRepository.removeProduct(productId);<br/>    }<br/>}</span></pre><h1 id="7d5f" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">7.结论</h1><p id="ec50" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">与分层架构相比，六边形架构有几个优点:</p><ul class=""><li id="7750" class="lr ls hi kd b ke kx kh ky kk lt ko lu ks lv kw lw lx ly lz bi translated">它<strong class="kd hj">通过分离应用的内部和外部部分来简化架构</strong> <strong class="kd hj">设计</strong></li><li id="576f" class="lr ls hi kd b ke ma kh mb kk mc ko md ks me kw lw lx ly lz bi translated">核心业务逻辑与任何外部依赖相隔离，这有助于<strong class="kd hj">实现高度的解耦</strong></li><li id="4f58" class="lr ls hi kd b ke ma kh mb kk mc ko md ks me kw lw lx ly lz bi translated"><strong class="kd hj">端口允许</strong> <strong class="kd hj">灵活地连接到新网络客户端或数据库形式的新适配器</strong></li></ul><p id="1d99" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">六边形架构可能是设计简单CRUD应用程序的开销。然而，当我们设计一个领域驱动的应用程序时，这个架构是很有用的。</p><p id="f873" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这些例子的代码可以在Github 的<a class="ae lc" href="https://github.com/anirban99/hexagonal-architecture" rel="noopener ugc nofollow" target="_blank">中找到。</a></p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="ae15" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><em class="lh">原载于</em> <a class="ae lc" href="https://theanirban.dev/" rel="noopener ugc nofollow" target="_blank"> <em class="lh">阿尼尔班的科技博客</em> </a></p></div></div>    
</body>
</html>