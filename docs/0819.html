<html>
<head>
<title>Contract, Assertions, Phantom Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">契约、断言、幻影类型</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/contract-assertions-phantom-types-76d80f8a884e?source=collection_archive---------1-----------------------#2020-12-01">https://medium.com/javarevisited/contract-assertions-phantom-types-76d80f8a884e?source=collection_archive---------1-----------------------#2020-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0a7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将研究一个简单的契约式设计案例，使用幻影类型设计模式进行编译时交叉检查。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/753b7523decf20a0f994a698e1c268bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*hpfkhun9M3ZVssxyqYKIGg.png"/></div><p class="jl jm et er es jn jo bd b be z dx translated">如何使用虚拟类型来证明合同。</p></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="9a33" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">用例:单值还是多值</h1><p id="0bf3" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们将要处理的用例是数据类型的表示</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="2470" class="le jx hi la b fi lf lg l lh li">MonoOrMulti&lt;T&gt; =:= T | List&lt;T&gt;</span></pre><p id="740f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你进入Java的世界时，你很快就会面临联合类型的问题。在<a class="ae lj" rel="noopener" href="/javarevisited/10-free-courses-to-learn-java-in-2019-22d1f33a3915"> Java </a>中，类型的联合确实是不可能实现的。未来的语言升级将引入密封类的概念，然而这个概念更像是一个通过限制来联合的概念。在本文中，我们将研究一种更加灵活的方法。</p><h1 id="0023" class="jw jx hi bd jy jz lk kb kc kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt bi translated">问题解决</h1><h2 id="7373" class="le jx hi bd jy lp lq lr kc ls lt lu kg iq lv lw kk iu lx ly ko iy lz ma ks mb bi translated">在Java类型系统中表示联合</h2><p id="6d29" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们首先创建一个类型来处理我们的联合。我们首先将这个类设计得非常弱，因为我们希望它尽可能通用。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/e3e0156a12139d54adcf4f0ae276d6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*H2GLwp5n6QHfXKcSEwZaKg.png"/></div></figure><p id="1a22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有意义的话，我们希望下面的合同成立:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="4a5f" class="le jx hi la b fi lf lg l lh li">assert (!isMonoValued &amp;&amp; value instance List&lt;@NonNull T&gt; &amp;&amp;<br/>          value.stream.noneMatch(Objects::isNull))<br/>    || (isMonoValued &amp;&amp; value instanceof T)</span></pre><p id="07b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，要么该值是非空的<code class="du md me mf la b">T</code>类型的对象(单值情况)，要么该值是<code class="du md me mf la b">T</code>的非空的<code class="du md me mf la b">List</code>，我们要求它也是非空的，具有非空元素。</p><p id="d61b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们需要明确一点:我们并不期望IO操作直接创造<code class="du md me mf la b">MonoOrMulti</code>价值:开发者将承担这个责任。换句话说，开发人员应该保证构造函数在其契约范围内被调用。</p><h2 id="7fe6" class="le jx hi bd jy lp lq lr kc ls lt lu kg iq lv lw kk iu lx ly ko iy lz ma ks mb bi translated">通过构建器绑定创建</h2><p id="fd56" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">为了强制正确创建我们的<code class="du md me mf la b">MonoOrMulti</code>值，我们可以做的第一件事是，在不改变其构造函数的情况下，强制该类的用户使用间接方式创建它，作为<a class="ae lj" href="http://javarevisited.blogspot.sg/2011/12/factory-design-pattern-java-example.html#axzz51cvxH5kW" rel="noopener ugc nofollow" target="_blank">工厂</a>或<a class="ae lj" href="http://javarevisited.blogspot.sg/2012/06/builder-design-pattern-in-java-example.html" rel="noopener ugc nofollow" target="_blank">构建器</a>。</p><p id="d7f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在工厂和建筑商之间，我们选择了建筑商，因为它允许灵活性；我们确实可以从顶级构建者开始</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mg"><img src="../Images/6c3b74692f6bbef86dfd9d6bfacdce27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*pRsiP2jKbaolFqMDSzJMyw.png"/></div></figure><p id="c75a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它为单个值提供对特定构建器的访问:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mh"><img src="../Images/bb79091e7b846a3d53c286d87935cb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*Kh4qGNGnQSfX-HoGyZrQhQ.png"/></div></figure><p id="cfd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个用于特定多值:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mi"><img src="../Images/b2027c35e1e3f16a694aa533e2fe896a.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*JSFxPpEotir_ppeTnAjt3Q.png"/></div></figure><p id="401a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管我们在类型层次上划分构建器，但是我们可以提供一个独特的实现来集中关注点，对于第一个草图:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mj"><img src="../Images/93ee2da0d4564d99e1f9d1dd3cec8d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*-VNgKumgdR2Mh3Gpub4g4A.png"/></div></figure><p id="1022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个多态构建器强制执行下面的两个路径，这里写在<a class="ae lj" href="https://www.java67.com/2018/06/top-35-java-string-interview-questions.html" rel="noopener ugc nofollow" target="_blank">字符串</a>类型类上:</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="4ad6" class="le jx hi la b fi lf lg l lh li">newBuilder(String.class)<br/>   .monoValued()<br/>   .buildFromValue("Hello world");</span><span id="06a5" class="le jx hi la b fi mk lg l lh li">newBuilder(String.class)<br/>   .multiValued()<br/>   .addAll(List.of("Hello", "world"))<br/>   .build();</span></pre><p id="ebae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法使得各种创造性的可能性结合起来成为可能。构建器代码中的asserts语句清楚地表明，我们的union类型契约已经完成:我们有一个类型为<code class="du md me mf la b">T</code>的单值元素，或者这样的有序集合。</p><h2 id="aaf6" class="le jx hi bd jy lp lq lr kc ls lt lu kg iq lv lw kk iu lx ly ko iy lz ma ks mb bi translated">坚持强制执行</h2><p id="7bb1" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">到目前为止，我们的建造者不是空敌对的，这是我们想要的。在Java中，<code class="du md me mf la b"><a class="ae lj" href="https://javarevisited.blogspot.com/2014/12/9-things-about-null-in-java.html#axzz6fLto55st" rel="noopener ugc nofollow" target="_blank">null</a></code>是类型系统的一部分，我们不能避免使用类型，也不能像以前那样调整构造路径。</p><p id="22fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，有一种惯用的Java方式可以表明我们是空敌对的。<code class="du md me mf la b">assert</code>关键字可用于在合同级别上实施这种行为。修改很简单:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ml"><img src="../Images/9b36b7ed3ae2841ccd76c89113b61180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*8erJI5a8uwgZWd-J33pj3A.png"/></div></figure><p id="e9cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lj" href="https://javarevisited.blogspot.com/2012/01/what-is-assertion-in-java-java.html" rel="noopener ugc nofollow" target="_blank"> Java断言</a>是契约声明的完美用例:如果违反了契约，就会抛出<code class="du md me mf la b">AssertionError</code>(Java故障系统中的一个严重错误)。由于按合同设计是开发人员的业务，出于IO考虑，开发人员应该注意避免它们。</p><p id="77ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也清楚地表明，我们是在契约级编码:抛出(未检查的)异常将会以某种方式隐藏这种非常特殊和准确的语义。</p><p id="ea74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">assert的问题是一个严重的问题，它在生产中是关闭的。这意味着我们不应该依赖他们。嗯，这不会是一个非常严重的业务实际上，因为我们(应该)相信我们的开发人员的团队！</p><p id="c0b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一个最大的问题<code class="du md me mf la b">assert</code>没有处理:他们带来了完全不属于类型系统的合同信息。在我们的例子中，这一点非常清楚:一旦创建，用户就有了一个<code class="du md me mf la b">MonoOrMulti&lt;T&gt;</code>实例，而没有任何关于它是表示单值还是多值的进一步信息。这正是我们要用幻影类型解决的问题。</p><h2 id="906f" class="le jx hi bd jy lp lq lr kc ls lt lu kg iq lv lw kk iu lx ly ko iy lz ma ks mb bi translated">作为编译时断言的幻象类型</h2><p id="eb9c" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们不会删除任何资产。相反，我们将把它们添加到类型系统中。怎么会？</p><p id="9747" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将介绍一种幻影类型。作为一个比文字更好解释的例子，让我们直接用代码:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es mm"><img src="../Images/ec2f423433668a0614b9d3c9d8aaab96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*6sIrLKpNMqV56pTvHec4dg.png"/></div></div></figure><p id="5aae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且对于or <code class="du md me mf la b">MonoOrMulti</code>结构类:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mr"><img src="../Images/0e39a1935a049f71ba9d596464f1743e.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*uy7s3nHryAlC8C_PoDSNRw.png"/></div></figure><p id="d067" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们引入了一个绑定到<code class="du md me mf la b">ValueKind</code>的虚拟类型参数；我们感兴趣的类型是<code class="du md me mf la b">NullHostileMono</code>和<code class="du md me mf la b">NullHostileOrderedMulti</code>，因为它们是我们所关心的问题。</p><p id="093b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了强调我们的模式实际上非常灵活和高效，我们特意在<code class="du md me mf la b">ValueKind</code>层次上描绘了一个非常复杂的类型系统。这是由于Java中接口和类继承的不同。如果我们想在<em class="ms">类层次</em>上编码二分法，我们需要子类<code class="du md me mf la b">MonoOrMulti&lt;T&gt;</code>，这在契约方面是昂贵的:我们需要在每个开发步骤中保持子类和父类之间的契约一致。</p><p id="a8ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二，<a class="ae lj" rel="noopener" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"> Java </a>中的类继承层次受到单亲原则的约束:一个类不能有两个父类。</p><p id="2130" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这对于保持内部状态一致是非常有用的，但是在我们所关心的问题中，这是一个很大的问题，因为我们想从一个菱形图类型的系统中获益。</p><p id="6f1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的构建器也需要重构，以考虑新的约束。这里我们只重复接口:实现更新是微不足道的。对于单声道生成器，我们将<code class="du md me mf la b">buildFromValue</code>方法更新为</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="f94b" class="le jx hi la b fi lf lg l lh li">MonoOrMulti&lt;T, ValueKind.NullHostileMono&gt; buildFromValue(T value);</span></pre><p id="8df4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于multi builder，我们只需要将<code class="du md me mf la b">build</code>方法重新定义为</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="1053" class="le jx hi la b fi lf lg l lh li">MonoOrMulti&lt;T, ValueKind.NullHostileOrderedMulti&gt; build();</span></pre><p id="8500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当用户现在沿着道路行驶时</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="624a" class="le jx hi la b fi lf lg l lh li">newBuilder(String.class)<br/>   .monoValued()<br/>   .buildFromValue("Hello world");</span></pre><p id="6349" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">他将获得一个编译时级别的信息，表明所获得的实例属于类型<code class="du md me mf la b">NullHostileMono</code>。同样，沿着这条路</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="f479" class="le jx hi la b fi lf lg l lh li">newBuilder(String.class)<br/>   .multiValued()<br/>   .addAll(List.of("Hello", "world"))<br/>   .build();</span></pre><p id="d17f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">产生一个<code class="du md me mf la b">NullHostileOrderedMulti</code>元素，同样:这个信息以一种非常灵活的方式属于类型系统。</p><p id="5512" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ms">幻影类型信息在这里不是取代断言保证的契约，而是在编译时反映出来</em>，这是断言在Java中做不到的。</p><h2 id="4448" class="le jx hi bd jy lp lq lr kc ls lt lu kg iq lv lw kk iu lx ly ko iy lz ma ks mb bi translated">绑定契约和虚拟类型</h2><p id="457a" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">不知何故，我们目前的设置有点缺陷。事实上，我们在<code class="du md me mf la b">ValueKind</code>标记和合约之间没有如此强的耦合。构建器中的断言要求我们保持最新，它们没有形成可重用的特性集。</p><p id="19ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以更进一步，通过绑定契约和虚拟类型。我们首先开始在<code class="du md me mf la b">ValueKind</code>型磁体上定义一个默认方法，其目的是断言默认契约是否有效。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es mt"><img src="../Images/e5ed115254536ac54ff9b1b4e70c2681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qnVgBO4pVonMJng-5otug.png"/></div></div></figure><p id="61e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，<code class="du md me mf la b">ValueKind</code>的每个子元素都将覆盖这个默认实现，并重用它来定义自己的契约:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mu"><img src="../Images/58b5cc520f6161659450d42102918701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*An7Bc3Si1Odz0Qf0nu6v3A.png"/></div></figure><p id="a58b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那些合同现在可能被用于<a class="ae lj" href="https://www.java67.com/2014/05/difference-between-stringbuilder-and-StringBuffer-java.html" rel="noopener ugc nofollow" target="_blank">建造商</a>本身。我们重用幻影类型本身提供的共享契约，而不是在每个方法中重新发明全部。我们只举一个例子来说明这个想法:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mu"><img src="../Images/e636d73f30867292bd3eed537497fa31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*DLNKcnrUxEVU_1mfnQb_Bw.png"/></div></figure><h1 id="77e2" class="jw jx hi bd jy jz lk kb kc kd ll kf kg kh lm kj kk kl ln kn ko kp lo kr ks kt bi translated">联合评估法</h1><p id="b3d3" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">作为最后一部分，我们提供了一个可能实现的具体示例。假设我们想要提供该方法的一个实现</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="8d8e" class="le jx hi la b fi lf lg l lh li">message -&gt; message if message does not contain " ",<br/>           [word for words in message] otherwise</span></pre><p id="9eef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对代数数据类型的了解告诉我们，这是一个指数映射<code class="du md me mf la b">String -&gt; String | List&lt;String&gt;</code>，因此可以通过两个映射<code class="du md me mf la b">String -&gt; String</code>和<code class="du md me mf la b">String -&gt; List&lt;String&gt;</code>来表示，以及区分情况的方法。</p><p id="30a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用我们的设置，它可以实现为</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mv"><img src="../Images/2710fa0ed606d6dc1022a4e0802c094b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*5X8KlWcPaEbMJSTh1-2X-A.png"/></div></figure><p id="e39c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，<code class="du md me mf la b">MonoOrMulti</code>实例是有序的并且不能包含空值，这些信息仍然存在于类型系统中，即使我们已经丢失了它的一部分(单值或多值)。</p><p id="be66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们仍然可以恢复全部信息，因为我们还有合同。然而，这需要人工干预:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mw"><img src="../Images/2d6c1408c5f63cb15693e4413bf305a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*I6YJ5hppuGPCMYQhrei_PA.png"/></div></figure><p id="6f36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这个断言中，我们知道结果的值是一个<code class="du md me mf la b">List&lt;String&gt;</code>，因此我们可以继续一个强制转换操作，计算管道继续运行！</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="0e6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇课文就到这里，已经够长了。我希望你喜欢它，最重要的是，我希望它能给你灵感，或者相反，让你现在的习惯更经得起批评！</p></div></div>    
</body>
</html>