<html>
<head>
<title>How to Do Device Monitoring with JavaFX, FXGL and Mosquitto | foojay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JavaFX、FXGL和Mosquitto | foojay进行设备监控</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/how-to-do-device-monitoring-with-javafx-fxgl-and-mosquitto-foojay-548ed96948e7?source=collection_archive---------2-----------------------#2021-01-11">https://medium.com/javarevisited/how-to-do-device-monitoring-with-javafx-fxgl-and-mosquitto-foojay-548ed96948e7?source=collection_archive---------2-----------------------#2021-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a1fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在之前的帖子<a class="ae jd" href="https://foojay.io/today/category/java/javafx/" rel="noopener ugc nofollow" target="_blank">“FXGL游戏开发入门”</a>中，我们已经了解了由<a class="ae jd" href="https://twitter.com/AlmasBaim" rel="noopener ugc nofollow" target="_blank"> Almas Baimagambetov </a>开发的<a class="ae jd" href="https://github.com/AlmasB/FXGL" rel="noopener ugc nofollow" target="_blank"> FXGL游戏开发框架</a>。</p><p id="f303" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，这个游戏引擎也可以用于其他用例。在本帖中，我们将构建一个可以在Raspberry Pi上运行的系统监控仪表板。仪表板可以用来监视任何可以向队列报告其状态的设备。而且，对我个人来说，当我的路由器决定洗牌时，它终于解决了找到我所有树莓派的IP地址的问题…😉</p><h1 id="4a3f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">应用程序描述</h1><p id="e828" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">已经建立了一个概念验证，使用一个Raspberry Pi作为“中央系统”来托管队列(Mosquitto)。在这个Raspberry Pi和其他平台上，运行一个Python脚本来每秒向队列发送设备状态。<br/>对于列表中出现的每个新设备(由IP地址决定),都会创建一个新的仪表板“标题”来显示一些数据。通过单击此区块，我们可以放大区块视图，以包含所有正在接收的数据。</p><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/06/top-5-courses-to-learn-java-fx-in-2020.html"><div class="er es kh"><img src="../Images/846f097efeeb2d040ec98c2ea45f1326.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/0*zjT627MUU7NTCYFQ.png"/></div></a></figure><p id="c40c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当应用程序启动时，您可以在“模拟数据”或带有队列的板的IP地址之间进行选择。这个视频展示了被嘲笑的结果:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="d890" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个项目的源代码可以在FXGLSystemMonitoring库的<a class="ae jd" href="https://github.com/FDelporte/FXGLSystemMonitoring" rel="noopener ugc nofollow" target="_blank"> GitHub上找到。</a></p><h1 id="9526" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">莫斯基托</h1><p id="33a7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Eclipse Mosquitto 是一个实现MQTT协议的开源消息代理，它是轻量级的，适用于从低功耗单板计算机到完整服务器的所有设备。因此，用在树莓派上是一个完美的搭配。</p><h1 id="feb2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">在树莓墩上安装Mosquitto</h1><p id="761c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">安装Mosquitto可以用下面的命令来完成，这也将把它配置成一个服务，只要你的Raspberry Pi(重新)通电就启动。</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="02b5" class="kw jf hi ks b fi kx ky l kz la">$ sudo apt update <br/>$ sudo apt install -y mosquitto mosquitto-clients <br/>$ sudo systemctl enable mosquitto.service</span></pre><p id="60f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过请求版本来检查它是否正确安装并运行:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="9060" class="kw jf hi ks b fi kx ky l kz la">$ mosquitto -v <br/>1569780732: mosquitto version 1.5.7 starting <br/>1569780732: Using default config. <br/>1569780732: Opening ipv4 listen socket on port 1883. <br/>1569780732: Error: Address already in use</span></pre><p id="0f9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">错误信息的最后一行可以忽略。</p><h1 id="72e4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">在码头上测试蚊子</h1><p id="d882" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">通过打开两个终端窗口，可以使用已安装的mosquito客户端轻松测试mosquito在Pi上是否运行正常。在第一个示例中，我们启动了一个主题为“测试/测试主题”的监听器:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="74f3" class="kw jf hi ks b fi kx ky l kz la">$ mosquitto_sub -v -t 'testing/TestTopic'</span></pre><p id="63c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第二个终端中，我们为这个特定主题发送多个命令和一条消息，如下所示:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="45f6" class="kw jf hi ks b fi kx ky l kz la">$ mosquitto_pub -t 'testing/TestTopic' -m 'hello world' <br/>$ mosquitto_pub -t 'testing/TestTopic' -m 'hello world' <br/>$ mosquitto_pub -t 'testing/TestTopic' -m 'jieha it works'</span></pre><p id="0a7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个终端窗口中的每个“发布”都会出现在第一个窗口中，正如您在这些屏幕截图中看到的:</p><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://www.java67.com/2020/07/top-5-courses-to-learn-linux-in-depth.html"><div class="er es lb"><img src="../Images/1ae68ad058bec320b9fdcc75ea24e262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*zXqrcIqBcmeaGh-o.png"/></div></a></figure><h1 id="049c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">从Raspberry Pi发送状态</h1><p id="0ede" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了将状态从我们所有的Raspberry Pi-boards发送到Mosquitto，GitHub项目中提供了一个<a class="ae jd" href="https://github.com/FDelporte/FXGLSystemMonitoring/blob/main/python/statsSender.py" rel="noopener ugc nofollow" target="_blank">脚本。对于这个脚本，我们使用Python，因为我们只需要一些最小的示例数据，这些数据很容易从“psutil”库中获得。当然，Java也可以做到这一点，但是让我们拥抱Python一次吧😉</a></p><h1 id="4456" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">额外的依赖性</h1><p id="81f9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果你从默认的Raspberry Pi操作系统开始，那么<a class="ae jd" rel="noopener" href="/javarevisited/my-favorite-books-to-learn-python-in-depth-77465633b46e"> Python </a>已经安装好了。所以我们只需要用pip-命令添加两个额外的库来发送数据到队列(用paho)和获取设备状态信息(用psutil)。</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="7065" class="kw jf hi ks b fi kx ky l kz la">pip install paho-mqtt <br/>pip install psutil</span></pre><p id="ee1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本例中，我们仅使用psutil提供的所有数据的子集作为概念验证。在<a class="ae jd" href="https://pypi.org/project/psutil/" rel="noopener ugc nofollow" target="_blank">pypi.org/project/psutil</a>上可以看到完整的概述。</p><p id="b35a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一小部分<a class="ae jd" href="https://javarevisited.blogspot.com/2019/09/5-websites-to-learn-python-for-free.html" rel="noopener ugc nofollow" target="_blank"> Python代码</a>展示了如何使用虚拟内存信息来构建json-message:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="8ae0" class="kw jf hi ks b fi kx ky l kz la">virtual = psutil.virtual_memory() </span><span id="0732" class="kw jf hi ks b fi lc ky l kz la">jsonString = "{" <br/>... <br/>jsonString += " 'virtual_memory': {" <br/>jsonString += " 'total':'" + str(virtual.total) + "'," <br/>jsonString += " 'available':'" + str(virtual.available) + "'," <br/>jsonString += " 'used':'" + str(virtual.used) + "'," <br/>jsonString += " 'free':'" + str(virtual.free) + "'," <br/>jsonString += " 'percent':'" + str(virtual.percent) + "'" <br/>jsonString += " }," <br/>... <br/>jsonString = "}"</span></pre><p id="f2de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用paho-library，我们可以向队列发送这样的消息:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="1f29" class="kw jf hi ks b fi kx ky l kz la">client = paho.Client(hostname + ":" + str(address)) <br/>client.connect(mosquitto) <br/>client.publish(topicName, jsonString)</span></pre><h1 id="5e3d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">在监控应用程序内部</h1><p id="a507" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">该应用程序在MonitorApp中启动，它扩展了一个FXGL游戏应用程序。</p><p id="0e61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/FDelporte/FXGLSystemMonitoring" rel="noopener ugc nofollow" target="_blank"> Java/JavaFX/FXGL Maven项目</a>被组织成数据包、队列包和视图包，以使代码易于理解。除了预期的特定于FXGL的覆盖(initSettings，initGame)，我们可以找到一些FXGL提供的额外特性的好例子。</p><p id="56ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，启动时的对话框要求用户选择模拟或真实模式:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="8501" class="kw jf hi ks b fi kx ky l kz la">runOnce(() -&gt; {</span><span id="fcc4" class="kw jf hi ks b fi lc ky l kz la">   var choiceBox = getUIFactoryService().newChoiceBox(</span><span id="25a1" class="kw jf hi ks b fi lc ky l kz la">      FXCollections.observableArrayList("192.168.0.223", "Mock Data")</span><span id="7169" class="kw jf hi ks b fi lc ky l kz la">   );</span><span id="c890" class="kw jf hi ks b fi lc ky l kz la">   choiceBox.getSelectionModel().selectFirst();<br/></span><span id="11c9" class="kw jf hi ks b fi lc ky l kz la">   var btnOK = getUIFactoryService().newButton("OK");</span><span id="3407" class="kw jf hi ks b fi lc ky l kz la">   btnOK.setOnAction(e -&gt; {</span><span id="d43f" class="kw jf hi ks b fi lc ky l kz la">      var result = choiceBox.getSelectionModel().getSelectedItem();</span><span id="d5a2" class="kw jf hi ks b fi lc ky l kz la">         if ("Mock Data".equals(result)) {</span><span id="54e6" class="kw jf hi ks b fi lc ky l kz la">            startWithMockData();</span><span id="e784" class="kw jf hi ks b fi lc ky l kz la">         } else {</span><span id="9d97" class="kw jf hi ks b fi lc ky l kz la">            getExecutor().startAsync(() -&gt; startWithClient(result));</span><span id="8846" class="kw jf hi ks b fi lc ky l kz la">         }</span><span id="b11b" class="kw jf hi ks b fi lc ky l kz la">   });</span><span id="470b" class="kw jf hi ks b fi lc ky l kz la">   getDialogService().showBox("Select mode", choiceBox, btnOK);</span><span id="d770" class="kw jf hi ks b fi lc ky l kz la">}, Duration.seconds(0.01));</span></pre><p id="4278" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个是<code class="du ld le lf ks b">run()</code>方法，它每秒运行一次提供的代码。在这种情况下，代码使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Perlin_noise" rel="noopener ugc nofollow" target="_blank">柏林噪声</a>为“模拟”模式生成随机数据:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="7f55" class="kw jf hi ks b fi kx ky l kz la">run(() -&gt; monitors.forEach(m -&gt; { <br/>   var t = random(0.5, 150000.0); </span><span id="e22f" class="kw jf hi ks b fi lc ky l kz la">   var reading = new Reading( <br/>      noise1D(t * 7) * 100, <br/>      (long) (noise1D((t + 1000) * 2) * 40), <br/>      (long) (noise1D((t + 3000) * 3) * 75) <br/>   ); <br/>   m.onReading(reading); <br/>}), DATA_UPDATE_FREQUENCY);</span></pre><h1 id="7c89" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">输入数据</h1><p id="c886" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">通过使用JSONB，传入的数据被转换成Java对象。例如，让我们看看将Python数据映射到Java对象的<code class="du ld le lf ks b">VirtualMemory</code>类。每个JsonbProperty都有一个name-value，如果变量具有相同的名称，这不是必需的，但是为了清楚起见，我还是喜欢定义它，以避免以后在重命名Java变量时出现错误。</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="8f74" class="kw jf hi ks b fi kx ky l kz la">public class VirtualMemory {</span><span id="41f9" class="kw jf hi ks b fi lc ky l kz la">   @JsonbProperty("total")</span><span id="6488" class="kw jf hi ks b fi lc ky l kz la">   private long total;</span><span id="3ba3" class="kw jf hi ks b fi lc ky l kz la">   @JsonbProperty("available")</span><span id="a302" class="kw jf hi ks b fi lc ky l kz la">   private long available; </span><span id="fa18" class="kw jf hi ks b fi lc ky l kz la">   @JsonbProperty("used")</span><span id="0b66" class="kw jf hi ks b fi lc ky l kz la">   private long used;</span><span id="7bc7" class="kw jf hi ks b fi lc ky l kz la">   @JsonbProperty("free")</span><span id="7e70" class="kw jf hi ks b fi lc ky l kz la">   private long free;</span><span id="ca43" class="kw jf hi ks b fi lc ky l kz la">   @JsonbProperty("percent")</span><span id="7b8b" class="kw jf hi ks b fi lc ky l kz la">   private double percent;</span><span id="cf9f" class="kw jf hi ks b fi lc ky l kz la">   public VirtualMemory() {</span><span id="55ac" class="kw jf hi ks b fi lc ky l kz la">      // NOP needed for JSON mapping</span><span id="61f2" class="kw jf hi ks b fi lc ky l kz la">   }</span><span id="da85" class="kw jf hi ks b fi lc ky l kz la">  // Getters - Setters</span><span id="5e70" class="kw jf hi ks b fi lc ky l kz la">}</span></pre><h1 id="6677" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">长队</h1><p id="c8a7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">通过使用<a class="ae jd" href="https://www.eclipse.org/paho/" rel="noopener ugc nofollow" target="_blank">" org . eclipse . PAHO . client . mqttv 3 "依赖关系</a>，我们可以很容易地连接到队列:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="ba49" class="kw jf hi ks b fi kx ky l kz la">MqttClient client = new MqttClient(<br/>   "tcp://" + ipAddress + ":1883", <br/>   MqttClient.generateClientId()); <br/>client.setCallback(new ClientCallback(readings)); <br/>client.subscribe(topicName);</span></pre><p id="29be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当我们前面提到的主题有可用的消息时，就会调用<code class="du ld le lf ks b">ClientCallBack </code>。</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="cadc" class="kw jf hi ks b fi kx ky l kz la">@Override public void messageArrived(String s, MqttMessage mqttMessage) { <br/>   String data = new String(mqttMessage.getPayload()); <br/>   System.out.println("Message received: " + data); <br/>}</span></pre><h1 id="7b27" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">视图组件</h1><p id="f9c2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">所有视图都被分割到单独的JavaFX节点中。总<code class="du ld le lf ks b">MonitorView</code>负责处理<code class="du ld le lf ks b">CollapsedView</code>和<code class="du ld le lf ks b">ExpandedView</code>两者，这两者又分别将其职责委托给<code class="du ld le lf ks b">LoadView</code> <br/>和<code class="du ld le lf ks b">CanvasLineChart</code>。这些关系的示例如下:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="b2aa" class="kw jf hi ks b fi kx ky l kz la">App uses MonitorView </span><span id="9169" class="kw jf hi ks b fi lc ky l kz la">MonitorView uses CollapsedView and ExpandedView </span><span id="1e3a" class="kw jf hi ks b fi lc ky l kz la">CollapsedView uses LoadView </span><span id="ad18" class="kw jf hi ks b fi lc ky l kz la">ExpandedView uses CanvasLineChart</span></pre><p id="7206" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些视图都实现了<code class="du ld le lf ks b">ReadingHandler</code>回调，当队列中有新的读数可用时，回调会通知每个视图。因此，所有视图都可以在收到通知后轻松更新。</p><h1 id="91c8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">动画片</h1><p id="3084" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">单击时，每个控制面板平铺会展开以填充整个窗口。这种扩展以动画的形式出现，无缝地将<code class="du ld le lf ks b">CollapsedView</code>转换为<code class="du ld le lf ks b">ExpandedView</code>。动画本身使用FXGL动画系统，该系统使用“fluent”API，我们可以在其中配置各种属性，如持续时间和插值。我们还提供了我们正在制作动画的<a class="ae jd" rel="noopener" href="/javarevisited/6-free-courses-to-learn-servlet-jsp-and-java-fx-in-2020-best-of-lot-720201c84f63"> JavaFX </a> observable属性(<code class="du ld le lf ks b">bg.widthProperty()</code>)以及动画开始和结束时的值:</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="9243" class="kw jf hi ks b fi kx ky l kz la">animationBuilder() <br/>   .duration(ANIMATION_DURATION) <br/>   .interpolator(Interpolators.EXPONENTIAL.EASE_OUT()) <br/>   .animate(bg.widthProperty()) <br/>   .from(MONITOR_WIDTH) <br/>   .to(APP_WIDTH) <br/>   .buildAndPlay();</span></pre><h1 id="0704" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用模拟数据运行应用程序</h1><p id="e27f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">当应用程序启动时，您可以选择带有Mosquitto队列的Raspberry Pi的IP地址和“模拟数据”。选择第二个选项后，将在应用程序中创建16个设备，每个设备由随机生成的数据驱动。这是测试所有应用程序功能的理想选择。</p><div class="ki kj kk kl fd ab cb"><figure class="lg km lh li lj lk ll paragraph-image"><a href="https://medium.com/javarevisited/6-free-courses-to-learn-servlet-jsp-and-java-fx-in-2020-best-of-lot-720201c84f63"><img src="../Images/ce6c9200c82dab8e285f03b37bb388d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*zXZUYIZWmL-t9EFCAoRbyg.png"/></a></figure><figure class="lg km lm li lj lk ll paragraph-image"><a href="https://javarevisited.blogspot.com/2020/06/top-5-courses-to-learn-kubernetes-for-devops-and-certification.html"><img src="../Images/ff8eb85ee82ad4a12ad7b72e40f3e15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*JTTwOBXqGCJ_7mQp6WcIKQ.png"/></a></figure><figure class="lg km ln li lj lk ll paragraph-image"><a href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html"><img src="../Images/bab5ce0e3425f5be2fe7aba2b25c814c.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*tlUcVggEeVQeSIcWcl-Y5g.png"/></a></figure></div><h1 id="4702" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用真实数据运行应用程序</h1><p id="50cc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">重启应用程序并选择IP地址。一旦从具有新IP地址的设备接收到数据，就会创建一个新的切片来可视化数据。在几个设备上启动<a class="ae jd" rel="noopener" href="/javarevisited/10-free-python-tutorials-and-courses-from-google-microsoft-and-coursera-for-beginners-96b9ad20b4e6"> Python脚本</a>，查看结果，如下面的视频所示。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="e954" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在视频中看到的，我的Pi不是很忙。通过使用压力工具，我们可以在设备上触发额外的负载，以测试仪表板中的可视化效果。</p><p id="1582" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的Raspberry Pi (B4 8Gb内存)上，cpu命令只影响CPU值，而vm命令会导致更高的CPU和内存使用率。</p><pre class="ki kj kk kl fd kr ks kt ku aw kv bi"><span id="41d7" class="kw jf hi ks b fi kx ky l kz la">$ sudo apt install stress <br/>$ stress --cpu 2 <br/>$ stress --vm 4 --vm-bytes 1024M</span></pre><h1 id="7620" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="cf4e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">应该注意的是，Gerrit格伦瓦德的华丽的<a class="ae jd" href="https://github.com/HanSolo/tilesfx" rel="noopener ugc nofollow" target="_blank"> TilesFX库也可以做类似的事情，但是我们特意采用了另一种方法来向您展示如何使用JavaFX和FXGL自己创建可视化组件。</a></p><p id="d29c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结合正确的JsonB和Paho库，Java再次证明了可以用最少的易于阅读和扩展的代码创建非常强大的应用程序。</p><p id="bf4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这只是一个概念验证，仍有很大的改进空间…只是一些想法:</p><ul class=""><li id="1d9b" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">指示在过去X秒内未发送数据的设备，并将视图背景变为红色</li><li id="2324" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">组合图表上的多个值</li><li id="359f" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">在扩展视图中提供附加信息</li><li id="7a18" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">添加一个对话框，询问用户队列IP地址</li></ul><p id="62b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">非常感谢Almas对范例项目和这篇文章的贡献！</strong></p><p id="721a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随意使用这个项目作为一个起点或作为一个灵感，但请分享你创造了什么！</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="d60f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mj">原载于2021年1月11日</em><a class="ae jd" href="https://foojay.io/today/device-monitoring-with-javafx-and-fxgl/" rel="noopener ugc nofollow" target="_blank"><em class="mj">https://foojay . io</em></a><em class="mj">。</em></p></div></div>    
</body>
</html>