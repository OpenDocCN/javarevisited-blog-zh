# 60 倍的性能提升和全面升级—构建 DDTJ 第 7 天

> 原文：<https://medium.com/javarevisited/60x-performance-improvement-moving-on-fullstack-building-ddtj-day-7-1deec0dc932a?source=collection_archive---------3----------------------->

![](img/0d5812a8312ff4e73195512c4456060b.png)

昨天[事情开始好转](https://dev.to/codenameone/good-news-and-bad-news-pivot-and-turn-building-ddtj-day-6-1pl4)，今天我完全康复了…

自周四以来，我一直有点情绪低落。这是每个重要项目中的一个自然阶段。它仍然很难，这是大多数人在开源项目中崩溃的地方。它不再“有趣”。但是坚持是很重要的。一旦我们有了一个你好的世界，能量就回来了，这是新的一天！

与此同时，我合并了两个公关。这个[怪物 PR](https://github.com/ddtj/ddtj/pull/4) 最终实现了所有的调试逻辑，所以我们可以收集我们需要的所有数据。然后[我合并了一个小的补丁](https://github.com/ddtj/ddtj/pull/5)，它提升了性能，稍后我会讨论。

直到昨天，我仍然怀疑自己是否有能力交付我选择的架构。性能是否足够合理？

# 60 倍的改进

昨天我想分享我对性能的怀疑，但我选择不这样做。我遇到过很多这样的情况，人们不停地谈论…他们肯定性能问题是由 x 引起的。然后他们以丢脸告终。

我的“猜测”实际上是正确的。我在没有任何状态保存代码的情况下测量了应用程序运行时。也就是说我们只是和 JDI 一起发布，没有其他的。性能几乎一样差，这意味着我的大部分代码运行良好。

那么是什么原因导致了性能缓慢呢？

在开发过程中，我必须删除对以下内容的调用:

```
methodEntryRequest.addClassFilter(filter);
```

实际上，有很多电话。我尝试了很多东西，如排除过滤器等。

我不得不删除它们的原因是它们不起作用！

# 如果方法不“添加”,就不要将其命名为“添加”

[addClassFilter](https://docs.oracle.com/en/java/javase/11/docs/api/jdk.jdi/com/sun/jdi/request/MethodEntryRequest.html#addClassFilter(java.lang.String)) API 其实应该命名为`setClassFilter`。添加额外的过滤器会禁用该功能。不幸的是，JavaDoc 中没有提到这一点。我选择的解决方法实际上非常简单，我创建了多个`MethodEntryRequest`实例，并将每个实例绑定到不同的过滤器类型。

现在它仅限于用户类过滤器和`javax`包。为了证明概念，我可能会添加更多。为此，我们自然需要更多的配置选项。

添加一个简单的过滤器就完全不同了。它减少了虚拟机的网络开销，并实现了快速性能。也许如果我采用了代理方法(也就是“过程中”)，我会有更好的表现。可能需要重新评估未来。

有了这个小小的调整，现在项目生命的这个阶段的性能是可以接受的，所以我们可以继续了。

# 您在 PR 变更日志中看不到的内容

我进行了压缩和合并，所以在这个过程中我的很多修改都消失在日志中了。除非你去明确的公关和审查提交，你不会看到这一点。当我决定转而使用方法入口/出口时，我写了很多代码，结果都在剪辑室的地板上。

对于这种类型的项目，这是开发人员需要处理的最困难的事情之一:沉没成本的谬误。我已经写了代码，我不能旋转。

自然，这是有价值的。我不是在提倡一种 yoyo 发展战略。但是我们需要准备放弃工作，保持客观。

# 我没怎么评论

一些人私下向我指出，我写代码时没有注释。

我曾经注释了很多…事实上，我的代码比源代码有更多的注释行。正如你从我的博客中看到的，我喜欢写作，并且可以用键盘创作很多作品。阻碍因素不是时间，甚至不是努力。

问题是，评论变得陈旧，如果你写得太多，大多数人都不会看。我尽量让代码简单。如果需要评论，我会尽量简化。通过尽可能避免评论，我确保人们阅读真正重要的评论。

在构建公共 API 时有一个主要的例外，那就是 JavaDoc。这一点很重要，应该一直完整地写下来。但是源代码中的注释经常被忽略。

# 我需要清理测试

一段时间以来，我一直在追逐我的覆盖率故事，试图让每次公关的覆盖率达到 80%。这很痛苦。不幸的是，这些测试有很多重复的代码和简单的黑客行为。

我需要对这个东西做一次彻底的检查，但我想先把产品拿出来。我可能别无选择，因为我昨晚花了几个小时试图让覆盖率超过 80%。

# 在本地工作时，CI 在服务器上失败

前几天这让我抓狂。单元测试在本地完全通过，但在 github 操作中运行时无法工作。错误消息表明 spring framework 打包有些奇怪。一些完全没有意义的事情。

我试图隔离环境差异等等。原来这一条[小线](https://github.com/ddtj/ddtj/blob/3af940425721155557d0b9253fb5a0fded970f3a/.github/workflows/build.yml#L43)，确保 java bin 目录在路径中。这个小小的改变让测试通过了。我不知道我是怎么猜到的。我什么都试过了，直到成功。

# 转到 CLI 和测试生成

我可以选择两个方向:

*   试着让 Spring Boot 运行代码
*   完成 CLI 并为 hello world 测试用例生成一个测试

我倾向于后者，无论何时你在新项目中遇到这样的问题，你也应该这样做。

当创建项目时，我们需要先建立它的广度，而不是深度。我们至少需要一个所有东西协同工作的基本实现，这样我们才能理解移动的部分。所以我们可以接受第三方在项目中的帮助。广度有助于透视，它“证明”项目。深度在后面。

考虑到这一点，我将注意力转向了 CLI，并实现了所有当前仍未实现的功能。至此，我还有最后一项任务来完成概念验证…

# 生成测试

第一次测试我想把目标定得很低。但是它必须模拟一个要求这是一个“好的”有效测试的呼吁。这将是我今天的重点。

如果我能让这个工作，我的下一个优先事项将是让这个运行在 Spring Boot 宠物诊所演示。我认为过滤 spring 代理会有一些挑战。可能还有其他问题。但如果我能在本周完成这两项任务，我会认为这是一个巨大的成功。

现在我正在设置第一个 Freemarker 生成的测试模板，一旦成功，我计划用 Spring MVC 来创建一个简单的代码生成器。那么它应该绑定到 CLI。应该是比较简单的，著名的遗言…

# 明天

我希望明天我们将有适当的源代码生成与 Freemarker 一起工作。我正在整合它，然后我会检查代码来生成测试。那么它应该绑定到 CLI。越来越近了！

如果你想了解这个系列和我从事的许多其他事情的最新进展，那么[在 twitter 上关注我](https://twitter.com/debugagent)。