<html>
<head>
<title>ReST API Design: A Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReST API设计:初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/rest-api-design-things-to-consider-96ac8a549aff?source=collection_archive---------0-----------------------#2020-11-22">https://medium.com/javarevisited/rest-api-design-things-to-consider-96ac8a549aff?source=collection_archive---------0-----------------------#2020-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a8a6eb4a6b6dcbc03d85fedf916173eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUGaRCsqwcE9gi7jhq9m6w.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@kaleidico?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">万花筒</a>在<a class="ae iu" href="https://unsplash.com/s/photos/white-boarding-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="be27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一名开发人员，您可能在职业生涯的某个阶段创建、使用(或两者都使用)过API。如果你是一名移动/web/UI开发人员，你肯定会与API交互，因为要显示的数据需要来自某个地方；如果你是一名<a class="ae iu" href="https://javarevisited.blogspot.com/2019/02/the-2019-web-developer-roadmap.html" rel="noopener ugc nofollow" target="_blank">后端开发人员</a>，你肯定会创建API来与其他服务交互(UI和其他类似的后端服务)。</p><p id="8a39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于软件工程师，尤其是那些必须构建API的工程师来说，最好的事情之一就是提供一个<a class="ae iu" href="https://tools.ietf.org/html/rfc2616" rel="noopener ugc nofollow" target="_blank"> RFC </a>来处理所有与API相关的事情:状态代码、标题、cookies、请求/响应体等等。也就是说，不太好的一点是，RFC只是一个规范，也就是说，团队可以选择是否遵循它们。</p><p id="1b3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果后端服务对应用程序崩溃发送回一个成功的响应，没有什么会阻止它运行。当被遵循时，规范是伟大的，但是没有什么强迫团队或框架去遵循它们。</p><p id="e240" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是值得注意的是，像<a class="ae iu" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring </a>这样的流行框架确实迫使使用它们的团队遵循其中的一些标准(例如:不能为GET请求指定请求体)。</p><p id="2390" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到RFC，这些规范的存在是有原因的，并且为所有后端服务创建了一个标准。如果我致力于创建一个遵循RFC的后端服务“A ”,然后转而创建另一个服务“B”或者调用第三方API，那么让所有这些服务都遵循一个预定义的规范将会非常有帮助。它确保了一致性，因为所有服务都使用相同的语言。</p><p id="1eff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我想谈谈我是如何开始设计API的。无论如何，我都不会声称自己是专家，这篇文章的目的只是提供一个起点，而不是深入探讨。因此，抛开这些免责声明，下面是我开始设计API的方法:</p><h1 id="00ef" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">API命名</h1><p id="1a2b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">API路由是任何后端服务的入口点。下面是一些关于命名的注意事项:</p><h2 id="1c74" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">识别资源</h2><p id="a7c3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您的应用程序有用户帐户的概念，并且您正在创建捕获用户登录历史的API(让我们假设应用程序需要这一点，并且用户喜欢这一特性)，建模登录历史API的一种方法是将登录历史嵌套在用户下，即/ <code class="du lk ll lm ln b">users/{userId}/loginHistory.</code>这是一个定义明确的API，它定义了登录历史的层次结构。这很重要，因为现在您知道登录历史不是它自己的独立资源，而是用户资源的一部分，并且总是属于一个用户(由一个userId标识)。</p><h2 id="cabb" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">提出一致的API命名策略</h2><p id="5807" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">命名API有几种流行的方法。您可以使用连字符或骆驼大小写(在其他选项中，我敢肯定)。<br/>如果我们使用连字符登录，历史将是这样的:</p><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="1717" class="kw ju hi ln b fi lw lx l ly lz">/users/{userId}/login-history</span></pre><p id="391c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们使用camel case log in，History将是这样的:</p><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="75cf" class="kw ju hi ln b fi lw lx l ly lz">/users/{userId}/loginHistory</span></pre><p id="3de1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不确定这里是否有一个硬性规定，除了选择一个并坚持下去。胜利的一致性！</p><h2 id="fb2d" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">识别操作</h2><p id="602e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在我们确定了需要管理的资源之后，下一步是确定可以在这些资源上执行什么操作。通常这是CRUD的一个子集(创建、读取、更新、删除)。</p><p id="c9bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时，您只希望允许用户创建某些内容，而不希望更新它(可能您希望强制用户删除资源并重新创建它，而不允许他们更新它)。</p><p id="ef06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在操作被识别之后，我们选择HTTP动词。因此，在我们想要管理用户登录历史的示例中，我们可以决定只允许创建和获取用户登录历史，而不允许更新和删除。</p><h1 id="f348" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">HTTP动词</h1><p id="3721" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">HTTP动词告诉API的消费者该API提供什么操作。最受欢迎的有:</p><ul class=""><li id="2ddb" class="ma mb hi ix b iy iz jc jd jg mc jk md jo me js mf mg mh mi bi translated">获取:读取或获取资源</li><li id="97c0" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">上传:更新或修改资源</li><li id="df3b" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">删除:删除资源</li><li id="727a" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">发布:创建新资源</li></ul><p id="57e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用正确的动词很重要，因为这就像对API的响应中所期望的不言而喻的语言(例如:post通常会在响应体中返回新创建的资源，带有201响应状态代码，其中201代表created)。</p><p id="b7ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">动词还告诉用户他们可能需要在请求中提供什么，包括是否允许请求体(如果遵循RFC)。例如，get请求通常没有请求体(因为唯一标识和获取资源所需的任何标识符都应该是GET请求的请求体中URI/API路由vs的一部分)。</p><p id="e568" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">说到HTTP动词，我想快速地谈谈另外两个不常用的HTTP动词:HEAD和PATCH</p><h2 id="75b7" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">头</h2><p id="bf99" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">HEAD动词与GET动词非常相似，只是HEAD请求不能包含响应体。HEAD请求用于测试给定的URI是否可用。例如，如果我们想检查userId为“123”的用户是否包含loginHistory，我们可以向/users/123/loginHistory发出HEAD请求，如果返回成功，我们可以向同一个URI发出GET请求。这在向某个URI发出请求时节省了带宽，尤其是在响应很大的情况下。</p><h2 id="e3ae" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">修补</h2><p id="aae5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">修补动词非常类似于PUT请求，也用于更新资源。主要区别在于，PUT请求替换了整个资源，这意味着在使用PUT动词时，资源的所有字段(无论是否正在更新)都需要传递给API。但是当我们使用补丁请求时，我们只需要传递将用于更新资源的指令，包括需要做什么以及应该应用哪个字段更新。</p><p id="e743" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，假设我们已经决定只允许用户创建和获取他们的登录历史，我们的API可能如下所示:</p><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="cd6b" class="kw ju hi ln b fi lw lx l ly lz">POST  /users/{userId}/loginHistory<br/>GET /users/{userId}/loginHistory</span></pre><h1 id="482b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">请求正文</h1><p id="a96a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">下一步是确定是否会有请求体，如果有，那么就想出一个应该是什么样子的模式。根据RFC，GET请求不包含请求体，所以我们将遵循它，只为post请求创建一个请求体。因此，<a class="ae iu" href="https://javarevisited.blogspot.com/2017/02/how-to-consume-json-from-restful-web-services-Spring-RESTTemplate-Example.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>中的登录历史POST请求体示例可能是:</p><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="8e14" class="kw ju hi ln b fi lw lx l ly lz">{<br/> “time”: “1605202745”,<br/> “appVersion”: “5.2.0”<br/>}</span></pre><p id="a524" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">userId被排除在请求主体之外，因为它应该从API路由中获取。此外，捕获所有登录历史相关信息所需的其他附加字段可以添加到上面的正文中。</p><h1 id="11d1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">响应状态</h1><p id="3761" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">响应的响应状态应传达两件事:</p><ul class=""><li id="3656" class="ma mb hi ix b iy iz jc jd jg mc jk md jo me js mf mg mh mi bi translated">手术成功了吗？</li><li id="b349" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">后续步骤(如果有)？</li></ul><p id="ea90" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有许多状态代码可用(包括何时使用和使用什么的RFC)。因为响应状态传达的第一件事是操作是成功还是失败，我认为不言而喻，当错误发生时使用2xx(指示成功的200系列状态代码)是一个大的否定</p><p id="bd63" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当涉及到状态代码时，在响应中传递正确的子状态代码非常重要。例如，200表示OK，表示一切顺利，而201用于表示资源创建成功。所以200更适合GET/PUT请求，而201更适合POST请求(假设POST请求创建了一个对象)。POST请求使用200不会有问题，主要是因为它也传达了成功。但是，201将更适合，因为除了指示请求被成功接收和处理之外，它还指示新资源被创建。对于成功的删除，最好使用204(无内容)状态代码向调用客户端表明，虽然请求成功，但没有预期的响应正文(即，如果没有响应正文)。</p><p id="384e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成功代码互换使用比失败代码互换使用影响更小。例如，使用401(未授权)代替403(禁止)是不好的，因为它向用户(或可能是UI组件的调用客户端)给出了错误的指示。401表示提供的身份验证凭据与后端比较的记录不匹配。403表示用户试图访问他们无权访问的资源。修复401的解决方案是更改提交给应用程序的身份验证凭证，而修复403的解决方案可能简单到“对不起，这里没有要修复的内容”。通常情况下，正确的错误状态代码将指示后续步骤。因此，使用正确的状态代码变得更加重要，尤其是在出现错误时。</p><p id="0007" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一般来说，在选择状态代码时，严格遵循RFC是非常重要的，因为它们意味着一些东西(使用你的API的应用/服务希望它们与RFC一致，因为这是每个人的共同参考！)有时很容易把它们弄混。</p><h1 id="a204" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">响应正文</h1><p id="a309" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">API设计中下一个最重要的步骤是确定响应体。确保响应体包含调用客户端需要的所有内容是非常常见的做法(例如:如果一个web应用程序请求API获取用户的登录历史，我们确保从后端向它们提供web显示所需的所有信息)。在极少数情况下，我们可能需要比调用客户端所需的信息更多的信息，特别是如果后端没有利用任何缓存，额外的信息不是来自后端，后端将需要这些信息来处理传入的请求。举个例子会有帮助，对吗？绝对的。让我们考虑一个场景，其中后端调用服务提供者X获取一些信息，并将其作为响应的一部分传递回UI，尽管(让我们假设)UI根本不使用这些信息，但因为后端不缓存，并且服务X花费大量时间来响应请求(让我们继续假设)，那么将这些信息传递到UI并传递回UI将会很有帮助，以便后端可以使用这些信息来做它需要做的任何事情。</p><p id="8522" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在最终确定API时，我喜欢考虑的另一个重要因素是确保响应不会比需要的大。如果你有非常大的响应体，一个很好的问题是询问是否有可能将单个API分解成多个API。例如，如果您有一个消息应用程序，而不是有一个单一的API来提供与页面上显示的消息相关的所有信息(假设我们实现了分页，每页显示20条消息)。因此，一种选择是让20条消息包含所有消息信息，或者让20条消息只包含需要在消息列表页面上显示的信息，并使用另一个API在用户单击消息时在页面上显示更多信息。在两者之间做出决定可能需要考虑其他因素，如带宽考虑、处理时间、响应时间等。但是如果可以控制这些考虑因素，那么考虑后者可能是个好主意:为消息列表创建两个API，其中一个API包含关于消息的最少信息(/messages？page=2)和另一个更具体的API来获取单个消息的附加信息(/messages/{messageId})。</p><p id="d7cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当涉及到错误场景时，响应体必须以这样一种方式构造，即关于发生了什么的信息和关于如何修复错误的指示将是有帮助的。</p><h1 id="819f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">查询参数与路径变量</h1><p id="73be" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">API开发人员可以自由决定某个字段是否需要出现在查询参数或路径变量中。根据实现的不同，我们可以让这两种变化都很好地工作。帮助我决定某个领域走向的两条经验法则是:</p><ul class=""><li id="422f" class="ma mb hi ix b iy iz jc jd jg mc jk md jo me js mf mg mh mi bi translated">考虑请求变量是用于唯一标识资源，还是请求变量更像一个搜索标准。</li><li id="5889" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">如果所使用的变量可用于所有资源(如果我们考虑登录历史，并且说只有某些登录历史资源具有某个字段，那么使用该字段作为路径变量是不可取的，因为具有该变量的URI不能唯一地标识登录历史资源)。例如，我们需要一个userId来唯一地标识一个用户，但是像isAccountActive这样的搜索参数是一个搜索标准，没有办法只使用这个字段来获取特定的用户。但重要的是，我在此基础上添加了一条额外的规则。如果有多个字段可以用来标识一个资源，我更喜欢使用系统的最终用户无法控制的字段。例如，如果可以使用userId和用户名唯一地标识用户，我会选择userId，因为用户名可以由用户更改，但userId不能更改(这是需要的方式，用户不应该有更改userId的选项)。</li></ul><h1 id="cf3d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="b055" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">API设计充满了乐趣，因为围绕着普遍理解和期望的东西有规范和规则，同时也为创造性留有余地。我认为这条线很细，但是遵循规范或者至少诚实地尝试，对于确保一致性大有帮助，不仅对于包含API的应用程序，而且对于使用它的应用程序。</p></div></div>    
</body>
</html>