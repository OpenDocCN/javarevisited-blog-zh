<html>
<head>
<title>Preposition Preference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介词偏好</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/preposition-preference-1f1c709b098b?source=collection_archive---------3-----------------------#2017-11-15">https://medium.com/javarevisited/preposition-preference-1f1c709b098b?source=collection_archive---------3-----------------------#2017-11-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="56ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">怎么了？一个介词。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4155d3b58c25437a3e8fa088c50d4859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TuvUzb7iICZLWUWbi1-xkQ.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">照片摄于新泽西州汉密尔顿的雕塑场地</p></figure><p id="f5e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在罗格斯大学的一个朋友总是会回答这样一个问题:“你好吗？”一致的回答是:“一个介词。”我陷入这个陷阱太多次了。</p><h1 id="196b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">你有没有想过我们在Java APIs中使用了多少介词？</h1><p id="3433" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们在<a class="ae kw" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>的方法中使用了几个不同的介词。每一个都表达了不同的意思。在Eclipse集合中多次出现的介词有<code class="du kx ky kz la b">with</code>、<code class="du kx ky kz la b">of</code>、<code class="du kx ky kz la b">by</code>、<code class="du kx ky kz la b">as</code>、<code class="du kx ky kz la b">to</code>、<code class="du kx ky kz la b">from</code>、<code class="du kx ky kz la b">into</code>。当我们在方法名中使用介词时，它应该有助于清楚地表达意思。如果没有，那么没有它我们会过得更好。</p><h2 id="3cdc" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">两个介词进入。一个介词离开。</h2><p id="3f5d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在今年的JavaOne大会上，我描述了我们曾经在两个介词之间为命名Eclipse Collections API中的集合工厂方法而发生的一场战斗。这场战斗发生在<code class="du kx ky kz la b">of</code>和<code class="du kx ky kz la b">with</code>之间。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="0a0e" class="lb ju hi la b fi lt lu l lv lw">MutableList&lt;String&gt; list = Lists.mutable.<strong class="la hj">of</strong>("1", "2", "3");</span><span id="0951" class="lb ju hi la b fi lx lu l lv lw"><strong class="la hj"><em class="ly">                           vs.</em></strong></span><span id="4fd0" class="lb ju hi la b fi lx lu l lv lw">MutableList&lt;String&gt; list = Lists.mutable.<strong class="la hj">with</strong>("1", "2", "3");</span></pre><p id="1d37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过激烈的辩论，我们最终为我们的集合工厂类提供了两种选择。我们认为这是一个我们可以提供多种选择的地方，允许开发者使用他们自己的偏好。然而，这并不是故事的结尾。有时候，我们要赢得的不仅仅是一场战斗。</p><p id="00fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">介词<code class="du kx ky kz la b">of</code>和<code class="du kx ky kz la b">with</code>都可以很好地命名创建集合的工厂方法。我个人更喜欢<code class="du kx ky kz la b">with</code>，主要是因为这是Smalltalk使用的。在Smalltalk中，我会定期写下以下内容:</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="1641" class="lb ju hi la b fi lt lu l lv lw">|set|<br/>set := Set <strong class="la hj">with</strong>: ‘1’ <strong class="la hj">with</strong>: ‘2’ <strong class="la hj">with</strong>: ‘3’.</span></pre><p id="db33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是对Eclipse集合使用Java的等效例子。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="e3d3" class="lb ju hi la b fi lt lu l lv lw">MutableSet&lt;String&gt; set = Sets.mutable.<strong class="la hj">with</strong>("1", "2", "3");</span></pre><p id="861d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您愿意，也可以使用 工厂方法的<strong class="ih hj"> <em class="ly">创建一个集合。</em></strong></p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="f8ab" class="lb ju hi la b fi lt lu l lv lw">MutableSet&lt;String&gt; set = Sets.mutable.<strong class="la hj">of</strong>("1", "2", "3");</span></pre><p id="ffa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有一些表单将一个<code class="du kx ky kz la b">Iterable</code>作为参数。这些被称为<code class="du kx ky kz la b">ofAll</code>和<code class="du kx ky kz la b">withAll</code>。</p><p id="cdd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du kx ky kz la b">java.util.Collection</code>中，有在集合中添加和删除元素的方法。它们被命名为<code class="du kx ky kz la b">add</code>、<code class="du kx ky kz la b">addAll</code>、<code class="du kx ky kz la b">remove</code>和<code class="du kx ky kz la b">removeAll</code>。这四个方法返回<code class="du kx ky kz la b">boolean</code>。这使得他们不适合流畅地编写代码。</p><p id="f52a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在Eclipse集合中有自己的可变接口，所以我们知道可以通过使用两个介词中的一个来解决流畅性问题。我们决定用<code class="du kx ky kz la b">with</code>，因为<code class="du kx ky kz la b">with</code>有一个名为<code class="du kx ky kz la b">without</code>的自然反义词。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="9b30" class="lb ju hi la b fi lt lu l lv lw">Set&lt;String&gt; set = <br/>    Sets.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>)<br/>        .with(<strong class="la hj">"4"</strong>)<br/>        .without(<strong class="la hj">"2"</strong>);</span><span id="1d65" class="lb ju hi la b fi lx lu l lv lw">Assert.<em class="ly">assertEquals</em>(Sets.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"3"</strong>, <strong class="la hj">"4"</strong>), set);</span></pre><p id="4b21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当通过<code class="du kx ky kz la b">Iterable</code>添加元素时，这种命名模式也工作得很好。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="e802" class="lb ju hi la b fi lt lu l lv lw">Set&lt;String&gt; set =<br/>        Sets.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>)<br/>                .withAll(Lists.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"4"</strong>))<br/>                .withoutAll(Lists.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"3"</strong>));</span><span id="e4d2" class="lb ju hi la b fi lx lu l lv lw">Assert.<em class="ly">assertEquals</em>(Sets.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"2"</strong>, <strong class="la hj">"4"</strong>), set);</span></pre><p id="59b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我们有<code class="du kx ky kz la b">with</code>、<code class="du kx ky kz la b">withAll</code>、<code class="du kx ky kz la b">without</code>和<code class="du kx ky kz la b">withoutAll</code>作为直接在我们的可变集合上的实例方法。这些方法不是返回像add或remove这样的布尔值，而是返回<code class="du kx ky kz la b">this</code>，这是该方法正在操作的集合。这些方法与返回<code class="du kx ky kz la b">boolean</code>的集合上的现有方法具有良好的<a class="ae kw" rel="noopener" href="/@donraab/symmetric-sympathy-2c59d4541d60">对称性</a>，彼此之间也是如此。</p><p id="1735" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也将这种模式扩展到了不可变集合中。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="3850" class="lb ju hi la b fi lt lu l lv lw">ImmutableSet&lt;String&gt; set =<br/>        Sets.<strong class="la hj"><em class="ly">immutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>)<br/>                .newWithAll(Lists.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"4"</strong>))<br/>                .newWithoutAll(Lists.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"3"</strong>));</span><span id="1629" class="lb ju hi la b fi lx lu l lv lw">Assert.<em class="ly">assertEquals</em>(Sets.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"2"</strong>, <strong class="la hj">"4"</strong>), set);</span></pre><p id="f3e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在可变的情况下，<code class="du kx ky kz la b">withAll</code>和<code class="du kx ky kz la b">withoutAll</code>方法改变了现有的集合。在<code class="du kx ky kz la b">newWithAll</code>和<code class="du kx ky kz la b">newWithoutAll</code>的情况下，每次都返回一个新的集合，从而保持了原始集合的不变性。</p><h2 id="3046" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">克隆人的进攻</h2><p id="7989" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">介词<code class="du kx ky kz la b">of</code>在Eclipse集合中输掉了基于实例的集合工厂方法之战，因为<code class="du kx ky kz la b">of</code>没有像<code class="du kx ky kz la b">with</code>那样的好的自然反义词。也就是说，<code class="du kx ky kz la b">of</code>有时是Eclipse集合API中其他方法名的重要部分。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="a6e2" class="lb ju hi la b fi lt lu l lv lw"><strong class="la hj">// Bag API - occurrencesOf<br/></strong>MutableBag&lt;String&gt; bag = Bags.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>);<br/>Assert.<em class="ly">assertEquals</em>(1, bag.occurrences<strong class="la hj">Of</strong>(<strong class="la hj">"2"</strong>));</span><span id="b4ad" class="lb ju hi la b fi lx lu l lv lw"><strong class="la hj">// List API - indexOf<br/></strong>MutableList&lt;String&gt; list = Lists.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>);<br/>Assert.<em class="ly">assertEquals</em>(1, list.index<strong class="la hj">Of</strong>(<strong class="la hj">"2"</strong>));</span><span id="ef81" class="lb ju hi la b fi lx lu l lv lw"><strong class="la hj">// RichIterable API - sumOfInt, sumOfLong, sumOfFloat, sumOfDouble <br/></strong>MutableList&lt;String&gt; list = Lists.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>);<br/>long sum = list.sum<strong class="la hj">Of</strong>Int(Integer::<em class="ly">parseInt</em>);<br/>Assert.<em class="ly">assertEquals</em>(6L, sum);</span><span id="c738" class="lb ju hi la b fi lx lu l lv lw"><strong class="la hj">// RichIterable API - selectInstancesOf<br/></strong>MutableList&lt;String&gt; list = Lists.<strong class="la hj"><em class="ly">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>);<br/>MutableList&lt;String&gt; filtered = list.selectInstances<strong class="la hj">Of</strong>(String.class);<br/>Assert.<em class="ly">assertEquals</em>(list, filtered);</span></pre><h2 id="5fb9" class="lb ju hi bd jv lc ld le jz lf lg lh kd iq li lj kh iu lk ll kl iy lm ln kp lo bi translated">与...的复仇</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/41eae2ad92430ed5a0c7ea20ff04a589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g20ZGu9E3HnUP8NVvznoXA.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">RichIterable接口中的“With”方法</p></figure><p id="f388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">With</code>在Eclipse Collections API中变得更加流行，因为它被用来扩充现有的方法，如<code class="du kx ky kz la b">select</code>、<code class="du kx ky kz la b">reject</code>、<code class="du kx ky kz la b">collect</code>等。<code class="du kx ky kz la b">RichIterable</code>接口中的<code class="du kx ky kz la b">With</code>方法最初是作为优化添加的。通过提供更多的机会使匿名内部类完全无状态，它们允许我们使匿名内部类成为静态的。作为一个完全独立和意外的好处，<code class="du kx ky kz la b">With</code>方法为我们提供了更多的机会来使用Eclipse集合API的方法引用。这是一件好事，因为我有一个<strong class="ih hj">方法引用偏好</strong>。下面是一些使用这些方法的例子，方法引用使用来自<a class="ae kw" href="https://github.com/eclipse/eclipse-collections-kata" rel="noopener ugc nofollow" target="_blank"> Eclipse集合Pet Kata </a>的域。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="9993" class="lb ju hi la b fi lt lu l lv lw">boolean any =<br/>        this.people.anySatisfy<strong class="la hj">With</strong>(Person::hasPet, PetType.<strong class="la hj"><em class="ly">CAT</em></strong>);<br/>Assert.<em class="ly">assertTrue</em>(any);<br/><br/>boolean all =<br/>        this.people.allSatisfy<strong class="la hj">With</strong>(Person::hasPet, PetType.<strong class="la hj"><em class="ly">CAT</em></strong>);<br/>Assert.<em class="ly">assertFalse</em>(all);<br/><br/>boolean none =<br/>        this.people.noneSatisfy<strong class="la hj">With</strong>(Person::hasPet, PetType.<strong class="la hj"><em class="ly">CAT</em></strong>);<br/>Assert.<em class="ly">assertFalse</em>(none);<br/><br/>Person found =<br/>        this.people.detect<strong class="la hj">With</strong>(Person::hasPet, PetType.<strong class="la hj"><em class="ly">CAT</em></strong>);<br/>Assert.<em class="ly">assertNotNull</em>(found);<br/><br/>int count =<br/>        this.people.count<strong class="la hj">With</strong>(Person::hasPet, PetType.<strong class="la hj"><em class="ly">CAT</em></strong>);<br/>Assert.<em class="ly">assertEquals</em>(2, count);<br/><br/>MutableList&lt;Person&gt; selected =<br/>        this.people.select<strong class="la hj">With</strong>(Person::hasPet, PetType.<strong class="la hj"><em class="ly">CAT</em></strong>);<br/>MutableList&lt;Person&gt; rejected =<br/>        this.people.reject<strong class="la hj">With</strong>(Person::hasPet, PetType.<strong class="la hj"><em class="ly">CAT</em></strong>);<br/>PartitionMutableList&lt;Person&gt; partition =<br/>        this.people.partition<strong class="la hj">With</strong>(Person::hasPet, PetType.<strong class="la hj"><em class="ly">CAT</em></strong>);<br/>Assert.<em class="ly">assertEquals</em>(selected, partition.getSelected());<br/>Assert.<em class="ly">assertEquals</em>(rejected, partition.getRejected());</span></pre><p id="452a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">更新(2022年2月):</strong>在我最初写这篇文章的几年后，一个名为<code class="du kx ky kz la b"><a class="ae kw" href="https://www.eclipse.org/collections/javadoc/11.0.0/org/eclipse/collections/api/RichIterable.html#containsBy(org.eclipse.collections.api.block.function.Function,V)" rel="noopener ugc nofollow" target="_blank">containsBy</a></code>的新API被添加到Eclipse集合中。我觉得有趣的是，我们重构了Pet Kata中的<code class="du kx ky kz la b">Person</code>类上的<code class="du kx ky kz la b">hasPet</code>方法，以使用containsBy，当然是使用方法引用。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="85ec" class="lb ju hi la b fi lt lu l lv lw">public boolean hasPet(PetType petType)<br/>{<br/>    return this.pets.containsBy(Pet::getType, petType);<br/>}</span></pre><p id="fbce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的API设计很难，因为命名很难。当你发现并使用一个能向其他开发者清楚传达意图的名字时，这种感觉很棒。最好的办法是，在确定名字之前，让和你一起工作的其他开发人员使用你的名字，以取得一致意见。在极少数不可能达成共识的情况下(例如，两个同样好的选择)，要么只选择一个赢家，要么承担提供两者的成本。我的偏好几乎总是选择一个赢家，然后继续前进。希望同时提供<code class="du kx ky kz la b">of</code>和<code class="du kx ky kz la b">with</code>工厂方法是一个罕见的例外。</p><p id="857d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ly">我是</em><a class="ae kw" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="ly">Eclipse Collections</em></a><em class="ly">OSS项目在</em><a class="ae kw" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="ly">Eclipse Foundation</em></a><em class="ly">的项目负责人。</em> <a class="ae kw" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="ly">月食收藏</em> </a> <em class="ly">是开投</em> <a class="ae kw" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="ly">投稿</em> </a> <em class="ly">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p><div class="ma mb ez fb mc md"><a rel="noopener follow" target="_blank" href="/javarevisited/what-next-for-senior-developers-in-tech-project-manager-technical-architect-or-a-devops-engineer-b532a80c9ba1"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">高科技领域的高级开发人员下一步会做什么？项目经理、技术架构师或DevOps工程师</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">是时候考虑职业生涯的下一个层次了。</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">medium.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr jn md"/></div></div></a></div><div class="ma mb ez fb mc md"><a rel="noopener follow" target="_blank" href="/javarevisited/what-java-programmers-should-learn-in-2020-648050533c83"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">2020年Java程序员该学什么？</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">2020年Java程序员可以学习的有用工具、技术、框架和库</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">medium.com</p></div></div><div class="mm l"><div class="ms l mo mp mq mm mr jn md"/></div></div></a></div></div></div>    
</body>
</html>