<html>
<head>
<title>Debugging the Java Message Service (JMS) API using Lightrun</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Lightrun调试Java消息服务(JMS) API</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/debugging-the-java-message-service-jms-api-using-lightrun-3e2ad5765a8e?source=collection_archive---------4-----------------------#2022-05-03">https://medium.com/javarevisited/debugging-the-java-message-service-jms-api-using-lightrun-3e2ad5765a8e?source=collection_archive---------4-----------------------#2022-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a3f27a7362f78f9a30fc5ba81f40920b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R51TYYeSR2zDS3RVdA-nZg.jpeg"/></div></div></figure><p id="3d39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java消息服务API (JMS)是在Java EE(T1)时代由Sun Microsystems开发的。JMS API为我们提供了简单的消息传递抽象，包括消息生产者、消息消费者等。消息传递API允许我们将消息放在一个“队列”中，并使用放入该队列中的消息。这对高吞吐量系统非常有用——企业应用程序可以发送消息，而不是通过实时执行缓慢的操作来浪费用户时间。这种非阻塞方法支持极高的吞吐量，同时保持大规模可靠性。</p><p id="bf4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该消息携带一个事务上下文，该上下文提供了对可传递性和可靠性的一些保证。因此，我们可以在一个方法中发布一条消息，然后返回，这提供了与我们在写入一个<a class="ae jo" href="https://javarevisited.blogspot.com/2011/11/database-transaction-tutorial-example.html#axzz5WDqhDqX3" rel="noopener ugc nofollow" target="_blank"> ACID数据库</a>时类似的保证。</p><p id="a03f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以认为消息传递有点像社区邮件列表。您向代表特定列表的电子邮件地址发送邮件。订阅该列表的每个人都会收到该消息。在这种情况下，消息主题表示社区邮件列表地址。您可以向它发送消息，Java消息服务处理程序可以使用消息侦听器来接收所述事件。</p><p id="78f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值得注意的是，在<a class="ae jo" href="https://javarevisited.blogspot.com/2020/05/top-16-jms-java-messaging-service-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank"> JMS </a>中有两种消息传递模型:发布-订阅模型(我们在这里讨论过)和点对点消息传递，点对点消息传递允许您将消息发送到特定的目的地。</p><p id="9c81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们快速演示一下。</p><h1 id="1bc1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">简单的演示</h1><p id="3903" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了调试Java消息服务调用，我创建了一个简单的演示应用程序，其源代码可以在这里找到<a class="ae jo" href="https://github.com/lightrun-platform/lightrun/tree/main/examples" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="566f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个JMS演示是一个简单的数据库日志API——它是一个微服务，您可以用它来发布一个日志条目，然后该日志条目被异步写入到数据库<a class="ae jo" rel="noopener" href="/javarevisited/7-free-courses-to-learn-database-and-sql-for-programmers-and-data-scientist-e7ae19514ed2">中。然后，RESTful应用程序可以使用这个数据库日志API来添加数据库日志条目，而不会有数据库访问的开销。</a></p><p id="48db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码实现了主要的web服务:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7faa" class="lb jq hi kx b fi lc ld l le lf">@RestController<br/>@RequiredArgsConstructor<br/>public class EventRequest {<br/>   private final JmsTemplate jmsTemplate;<br/>   private final EventService eventService;<br/>   private final Moshi moshi = new Moshi.Builder().build();</span><span id="c76f" class="lb jq hi kx b fi lg ld l le lf">   @PostMapping("/add")<br/>   public void event(@RequestBody EventDTO event) {<br/>       String json = moshi.adapter(EventDTO.class).toJson(event);<br/>       jmsTemplate.send("event", session -&gt;<br/>               session.createTextMessage(json));<br/>   }</span><span id="a06f" class="lb jq hi kx b fi lg ld l le lf">   @GetMapping("/list")<br/>   public List&lt;EventDTO&gt; listEvents() {<br/>       return eventService.listEvents();<br/>   }<br/>}</span></pre><p id="0c01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意向事件主题发布消息的<code class="du lh li lj kx b">event()</code>方法。为了简单起见，我之前没有讨论消息体，但是请注意，在这种情况下，我只是传递了一个<a class="ae jo" href="https://javarevisited.blogspot.com/2015/05/how-to-print-json-string-in-java-jackson-example.html" rel="noopener ugc nofollow" target="_blank"> JSON字符串</a>作为消息体。虽然JMS支持对象序列化，但是使用该功能有其自身的复杂性，我希望保持代码简单。</p><p id="8445" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了补充主web服务，我们需要构建一个侦听器来处理传入的消息:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4742" class="lb jq hi kx b fi lc ld l le lf">@Component<br/>@RequiredArgsConstructor<br/>public class EventListener {<br/>   private final EventService eventService;</span><span id="3f38" class="lb jq hi kx b fi lg ld l le lf">   private final Moshi moshi = new Moshi.Builder().build();</span><span id="27f0" class="lb jq hi kx b fi lg ld l le lf">   @JmsListener(destination = "event")<br/>   public void handleMessage(String eventDTOJSON) throws IOException {<br/>       eventService.storeEvent(moshi.adapter(EventDTO.class).fromJson(eventDTOJSON));<br/>   }<br/>}</span></pre><p id="9b9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">侦听器由发送给侦听器的<a class="ae jo" href="https://javarevisited.blogspot.com/2014/12/how-to-read-write-json-string-to-file.html" rel="noopener ugc nofollow" target="_blank"> JSON字符串</a>调用，我们解析该字符串并将其发送给服务。</p><h1 id="3363" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">调试隐藏代码</h1><p id="d031" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">像<a class="ae jo" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring </a>和<a class="ae jo" href="https://www.java67.com/2020/04/top-jms-java-messaging-service-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank"> JMS </a>这样的抽象的伟大之处在于你不需要写很多样板代码。不幸的是，这种类型的面向消息的中间件隐藏了许多脆弱的实现细节，这些细节可能会在实现过程中失败。</p><p id="a783" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在生产场景中尤其痛苦，因为很难知道问题是否是因为消息没有正确发送而发生的。这就是Lightrun的用武之地。</p><p id="741f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以放置Lightrun操作(快照、日志等。)直接集成到平台API和消息服务的实现中。这让我们可以确定消息选择器是否按预期工作，以及消息监听器是否确实被触发。</p><p id="a3e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上图所示，通过JMS支持的<a class="ae jo" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25"> Spring </a>,我们可以打开<code class="du lh li lj kx b">JmsTemplate</code>并向执行方法添加一个快照:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><a href="https://www.java67.com/2021/04/5-free-microservice-courses-for-java.html"><div class="er es lk"><img src="../Images/1685f8ac595b1fadec0c5363ed5df4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e-1kyaptDyxpxlTC"/></div></a></figure><p id="5c71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您所看到的，当发送到一个主题时，这个动作被调用。我们可以检查堆栈框架，查看接收消息的主题，并使用条件来缩小正确的消息处理程序。</p><p id="daf4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以在消息源中放置一个匹配的快照，这样我们就可以跟踪消息流。在<code class="du lh li lj kx b">EventRequest</code>的一个快照可以给我们一些启示。我们也可以从另一个方向挖。</p><p id="353b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的堆栈中，您可以看到第584行的方法send调用了execute方法。execute方法包装调用方，因此操作将是异步的。我们可以进一步深入堆栈，转到闭包并在那里放置一个快照:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><a href="http://www.java67.com/2017/11/top-5-free-core-spring-mvc-courses-learn-online.html"><div class="er es ll"><img src="../Images/ae5541a0131fad5bd85454bfac648a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5082jC1qSgbMO7aJ"/></div></a></figure><p id="3aef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，这里我们可以对特定主题设置一个条件，并缩小范围。</p><h1 id="0ea5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="6334" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们选择消息传递系统是为了让我们的应用程序可靠。然而，企业消息传递系统在生产中很难调试，这不利于可靠性。我们可以在消息的目标中看到日志，但是如果我们没有到达它会发生什么呢？</p><p id="9b00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了Lightrun，我们可以在基于消息传递的应用程序的所有不同层中放置动作。这有助于我们缩小问题范围，而不管消息标准或平台如何。您可以使用<a class="ae jo" href="https://lightrun.com/free" rel="noopener ugc nofollow" target="_blank">空闲层</a>来完成所有这一切。</p></div></div>    
</body>
</html>