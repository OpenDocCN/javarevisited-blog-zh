<html>
<head>
<title>Spring RestTemplate Request &amp; Response Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring RestTemplate请求和响应日志记录</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-resttemplate-request-response-logging-f021be66c2c0?source=collection_archive---------1-----------------------#2021-09-02">https://medium.com/javarevisited/spring-resttemplate-request-response-logging-f021be66c2c0?source=collection_archive---------1-----------------------#2021-09-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b4ff8c4d315b607e52c7ca9572114b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZmoXnMB80VqQy76oehqUw.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">记录请求和响应的拦截器</p></figure><p id="c30c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用Spring RestTemplate时，记录HTTP请求和响应有时很有用。如果需要精确控制记录的内容，可以使用定制的拦截器在远程调用之前和之后添加日志记录。</p><h1 id="165c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建拦截器</h1><p id="03eb" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">您需要创建一个扩展<strong class="iw hj"><em class="kv">clienthttp request interceptor</em></strong>的类，并实现<strong class="iw hj"> <em class="kv"> intercept </em> </strong>方法，如下所示。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a922" class="lf jt hi lb b fi lg lh l li lj"><a class="ae lk" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a><br/>public class LoggingInterceptor implements ClientHttpRequestInterceptor {<br/> <br/>    <a class="ae lk" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {<br/>        <br/>  logRequest(request, body);<br/>        ClientHttpResponse response = execution.execute(request, body);<br/>        logResponse(response);<br/>        <br/>        return response;<br/>    } <br/>    <br/>    private void logRequest(HttpRequest request, byte[] body) throws IOException {<br/>        <br/>      if (log.isDebugEnabled()) {<br/>            log.debug("===log request start===");<br/>            log.debug("URI: {}", request.getURI());<br/>            log.debug("Method: {}", request.getMethod());<br/>            log.debug("Headers: {}", request.getHeaders());<br/>            log.debug("Request body: {}", new String(body, "UTF-8"));<br/>            log.debug("===log request end===");<br/>        }<br/>    }<br/> <br/>    private void logResponse(ClientHttpResponse response) throws IOException {<br/>        <br/>      if (log.isDebugEnabled()) {<br/>            log.debug("===log response start===");<br/>            log.debug("Status code: {}", response.getStatusCode());<br/>            log.debug("Status text: {}", response.getStatusText());<br/>            log.debug("Headers: {}", response.getHeaders());<br/>            log.debug("Response body: {}", StreamUtils.copyToString(response.getBody(), Charset.defaultCharset()));<br/>           log.debug("===log response end===");<br/>        }<br/>    }<br/>}</span></pre><p id="dfb2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当这个类用<a class="ae lk" href="https://javarevisited.blogspot.com/2017/02/how-to-consume-json-from-restful-web-services-Spring-RESTTemplate-Example.html" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj"><em class="kv">rest template</em></strong></a>注册时，Spring将在请求被分派之前调用<strong class="iw hj"> <em class="kv"> intercept </em> </strong>方法，这允许您记录请求。在<strong class="iw hj"> <em class="kv"> logRequest </em> </strong>方法中，我从请求中获取了我想要记录的信息。显然，您可以在这里随意记录。</p><p id="42a1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">记录请求后，我调用<strong class="iw hj"><em class="kv">client http request execution</em></strong>对象上的<strong class="iw hj"> <em class="kv"> execute </em> </strong>方法来分派请求。当收到响应时，我记录状态、标题和正文。</p><h1 id="1570" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">配置RestTemplate</h1><p id="fa48" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">为了确保拦截器被调用，你需要用<strong class="iw hj"> <em class="kv"> RestTemplate </em> </strong>注册它。在下面的例子中，我只添加了<strong class="iw hj"><em class="kv">logging interceptor</em></strong>，但是你可以自由添加多个拦截器，Spring会在运行时将它们链接在一起。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0d2d" class="lf jt hi lb b fi lg lh l li lj"><br/><a class="ae lk" href="http://twitter.com/Bean" rel="noopener ugc nofollow" target="_blank">@Bean</a><br/>public RestTemplate createRestTemplate(LoggingInterceptor loggingInterceptor, RestErrorHandler restErrorHandler) {<br/>    <br/>  RestTemplate restTemplate = new RestTemplate();<br/>  restTemplate.setInterceptors(Collections.singletonList(loggingInterceptor));<br/>    <br/>  return restTemplate;<br/>}</span></pre><p id="8a33" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你当然可以在<strong class="iw hj"> <em class="kv"> RestTemplate </em> </strong>包中启用调试日志记录，但是我喜欢使用一个拦截器，就好像给你一个细粒度的控制来记录你想要的东西。</p><p id="3a21" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">快乐编码..</p></div></div>    
</body>
</html>