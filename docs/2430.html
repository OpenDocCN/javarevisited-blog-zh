<html>
<head>
<title>Chain of Responsibility Pattern in Spring Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring应用中的责任链模式</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/chain-of-responsibility-pattern-in-spring-application-f79b35f341e5?source=collection_archive---------0-----------------------#2022-10-02">https://medium.com/javarevisited/chain-of-responsibility-pattern-in-spring-application-f79b35f341e5?source=collection_archive---------0-----------------------#2022-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="18e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将向您展示如何在Spring应用程序中顺利地应用责任链模式。你可以在GitHub库中找到源代码。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/d3fa7a0e1887242a565bad3e8c37bc63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*QHT7XJjjrIq77ZBb.png"/></div><p class="jm jn et er es jo jp bd b be z dx translated">文章模因封面</p></figure><h1 id="accb" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">领域</h1><p id="89e9" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">让我们明确一下CoR模式的目的。你可以通过<a class="ae jd" href="https://sourcemaking.com/design_patterns/chain_of_responsibility" rel="noopener ugc nofollow" target="_blank">这个链接</a>阅读它的完整解释。尽管现在我和你们分享一个特别的例子。</p><p id="564d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，我们正在创建一个实时的丰富服务。它消费一条消息，用附加数据完成它，并产生最终的丰富消息作为输出。假设我们有三种类型的浓缩:</p><ol class=""><li id="0a2b" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">通过<code class="du lc ld le lf b"><a class="ae jd" href="https://javarevisited.blogspot.com/2012/08/what-is-jsessionid-in-j2ee-web.html" rel="noopener ugc nofollow" target="_blank">SESSIONID</a></code> cookie确定电话号码。</li><li id="d2da" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">通过<code class="du lc ld le lf b">userId</code>字段检索人的年龄。</li><li id="a5d4" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">通过他们的IP地址获得的人的地理位置。</li></ol><h1 id="0738" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">发展</h1><p id="1f33" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">首先，我们需要<code class="du lc ld le lf b">EnrichmentStep</code>界面。</p><pre class="jf jg jh ji fd ll lf lm ln aw lo bi"><span id="ca24" class="lp jr hi lf b fi lq lr l ls lt">public interface EnrichmentStep {<br/>    Message enrich(Message msg);<br/>}</span></pre><p id="2e97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接口接受当前的<code class="du lc ld le lf b">Message</code>并返回一个丰富的。</p><blockquote class="lu lv lw"><p id="2766" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><em class="hi">在本例中，</em> <code class="du lc ld le lf b"><em class="hi">Message</em></code> <em class="hi">类是</em><a class="ae jd" href="https://www.geeksforgeeks.org/create-immutable-class-java/" rel="noopener ugc nofollow" target="_blank"><em class="hi"/></a><em class="hi">不可变的。这意味着</em> <code class="du lc ld le lf b"><em class="hi">EnrichmentStep</em></code> <em class="hi">返回新的对象，而不是被修改的同一对象。不可变类的使用是很好的实践，因为它消除了许多可能的</em> <a class="ae jd" href="https://enlear.academy/how-to-avoid-a-deadlock-while-writing-concurrent-programs-java-example-988bb07db25f" rel="noopener ugc nofollow" target="_blank"> <em class="hi">并发问题。</em> </a></p></blockquote><p id="6ab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有3种类型的浓缩。因此，我们需要3个<code class="du lc ld le lf b">EnrichmentStep</code>实现。我在给你看电话号码的例子。不过如果你好奇的话，你可以在仓库里看到其他的。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">电话号码丰富步骤</p></figure><blockquote class="lu lv lw"><p id="b7b9" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><em class="hi">在这种情况下，我们不关心</em> <code class="du lc ld le lf b"><em class="hi">PhoneNumberRepository</em></code> <em class="hi">的实现。</em></p></blockquote><p id="05a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那好吧。每个<code class="du lc ld le lf b">EnrichmentStep</code>可能会用额外的数据增强输入消息。但是我们需要继续所有的浓缩步骤来获得完整的信息。责任链模式就派上了用场。让我们稍微重写一下<code class="du lc ld le lf b">EnrichmentStep</code>界面。</p><pre class="jf jg jh ji fd ll lf lm ln aw lo bi"><span id="26c5" class="lp jr hi lf b fi lq lr l ls lt">public interface EnrichmentStep {<br/>  Message enrich(Message message);<br/><br/>  void setNext(EnrichmentStep step);<br/>}</span></pre><p id="5dab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个<code class="du lc ld le lf b">EnrichmentStep</code>实现可能引用下一个链元素。看一看修改后的<code class="du lc ld le lf b">PhoneNumberEnrichmentStep</code>实现。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">使用下一个元素的电话号码丰富步骤</p></figure><p id="84e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在<code class="du lc ld le lf b">PhoneNumberEnrichmentStep</code>的工作方式有点不同:</p><ol class=""><li id="b849" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">如果成功地丰富了消息，则满足的结果进行到下一个丰富步骤。</li><li id="a0ba" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">否则，没有修改的消息会更进一步。</li></ol><p id="510f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候将<code class="du lc ld le lf b">EnrichmentStep</code>的实现连接成一个链表了，也就是建立责任链。</p><p id="31e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们来指出另一个必不可少的细节。你看，<code class="du lc ld le lf b">EnrichmentStep</code>定义了总有下一步。但是链条不可能是无限的。因此，下一个链元素有可能不存在。在这种情况下，我们必须在每个<code class="du lc ld le lf b">EnrichmentStep</code>中重复<em class="lx">非空</em>检查。因为任何实现都可能是最后一步。谢天谢地，有更好的选择。<code class="du lc ld le lf b">NoOpEnrichmentStep</code>是只返回相同消息而不做任何动作的类。看看下面的代码块。</p><pre class="jf jg jh ji fd ll lf lm ln aw lo bi"><span id="e486" class="lp jr hi lf b fi lq lr l ls lt">public class NoOpEnrichmentStep implements EnrichmentStep {<br/><br/>  @Override<br/>  public Message enrich(Message message) {<br/>    return message;<br/>  }<br/><br/>  @Override<br/>  public void setNext(EnrichmentStep step) {<br/>    // no op<br/>  }<br/>}</span></pre><p id="8446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它允许我们将这个对象设置为最后一个链元素。因此，它保证了<code class="du lc ld le lf b">setNext</code>方法总是以某个值被调用，我们不必重复<em class="lx">非空</em>检查。</p><blockquote class="lu lv lw"><p id="d8b9" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><em class="hi"/><code class="du lc ld le lf b"><em class="hi">NoOpEnrichmentStep</em></code><em class="hi">实际上是</em> <a class="ae jd" href="https://sourcemaking.com/design_patterns/null_object" rel="noopener ugc nofollow" target="_blank"> <em class="hi">空对象设计模式</em> </a> <em class="hi">的一个例子。</em></p></blockquote><p id="1455" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们正在创建<code class="du lc ld le lf b">EnrichmentStepFacade</code>。看看下面的代码片段。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">浓缩步骤外观</p></figure><p id="eeee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构造函数接受所有在当前<a class="ae jd" href="https://www.baeldung.com/spring-application-context" rel="noopener ugc nofollow" target="_blank">应用程序上下文</a>中注册为Spring beans的<code class="du lc ld le lf b">EnrichmentStep</code>实现的列表(框架会自动完成这项工作)。如果列表为空，那么<code class="du lc ld le lf b">chainHead</code>就是<code class="du lc ld le lf b">NoOpEnrichmentStep</code>实例。</p><p id="4334" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">否则，当前元素将链接到下一个元素。但是最后一个链元素总是引用<code class="du lc ld le lf b">NoOpEnrichmentStep</code>。这意味着调用所提供列表的第一个元素将执行整个链！更令人兴奋的是，您可以通过添加Spring <code class="du lc ld le lf b"><a class="ae jd" href="https://www.baeldung.com/spring-order" rel="noopener ugc nofollow" target="_blank">@Order</a></code>注释来定义元素在链中的顺序。注入的<code class="du lc ld le lf b">List&lt;EnrichmentStep&gt;</code>集合将被相应地排序。</p><h1 id="c06d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">重构</h1><h2 id="fd75" class="lp jr hi bd js md me mf jw mg mh mi ka iq mj mk ke iu ml mm ki iy mn mo km mp bi translated">通用链元素</h2><p id="79ef" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">虽然解决方案正在运行，但还不完整。有几个细节需要改进。首先，再看一下<code class="du lc ld le lf b">EnrichmentStep</code>的定义。</p><pre class="jf jg jh ji fd ll lf lm ln aw lo bi"><span id="4935" class="lp jr hi lf b fi lq lr l ls lt">public interface EnrichmentStep {<br/>  Message enrich(Message message);<br/><br/>  void setNext(EnrichmentStep step);<br/>}</span></pre><p id="8793" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">责任链是通用模式。也许我们可以把它应用到另一个场景中。所以，让我们将<code class="du lc ld le lf b">setNext</code>方法提取到单独的接口。看看下面的定义。</p><pre class="jf jg jh ji fd ll lf lm ln aw lo bi"><span id="5bee" class="lp jr hi lf b fi lq lr l ls lt">public interface ChainElement&lt;T&gt; {<br/>  void setNext(T step);<br/>}</span></pre><p id="7b18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在<code class="du lc ld le lf b">EnrichmentStep</code>应该用适当的通用值扩展它。</p><pre class="jf jg jh ji fd ll lf lm ln aw lo bi"><span id="7ad3" class="lp jr hi lf b fi lq lr l ls lt">public interface EnrichmentStep extends ChainElement&lt;EnrichmentStep&gt; {<br/>  Message enrich(Message message);<br/>}</span></pre><h2 id="8d28" class="lp jr hi bd js md me mf jw mg mh mi ka iq mj mk ke iu ml mm ki iy mn mo km mp bi translated">链构建封装</h2><p id="71a7" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这是一个微小的进步。我们还能做什么？再看看下面的<code class="du lc ld le lf b">EnrichmentStepFacade</code>定义。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">浓缩步骤外观</p></figure><p id="91df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，<code class="du lc ld le lf b">EnrichmentStep</code>接口代表了一个通用的链元素。所以，我们可以直接将代码封装在<code class="du lc ld le lf b">ChainElement</code>接口中。查看下面的代码片段。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">链构建封装</p></figure><p id="52a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lc ld le lf b">buildChain</code>方法接受一个业务实现列表，该列表以实际用例以及作为最后一个元素的存根为基础(即<code class="du lc ld le lf b">NoOpEnrichmentStep</code>)。</p><p id="a730" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们也可以重构<code class="du lc ld le lf b">EnrichmentStepFacade</code>。看看下面的代码示例。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">委派给ChainElement.buildChain的专有步骤外观</p></figure><p id="491c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更加清晰易懂。</p><h2 id="7213" class="lp jr hi bd js md me mf jw mg mh mi ka iq mj mk ke iu ml mm ki iy mn mo km mp bi translated">AbstractEnrichmentStep</h2><p id="51b8" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">无论如何，关于<code class="du lc ld le lf b">EnrichmentStep</code>的实现还是有一些需要注意的地方。看看下面的<code class="du lc ld le lf b">PhoneNumberEnrichmentStep</code>定义。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">使用下一个元素的电话号码丰富步骤</p></figure><p id="7d2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想指出两个细节:</p><ol class=""><li id="4d3f" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated"><code class="du lc ld le lf b">setNext</code>方法覆盖。每个实现都必须存储对下一个链元素的引用。</li><li id="183d" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">调用了2次<code class="du lc ld le lf b">next.enrich(...)</code>方法。因此，实现必须一遍又一遍地重复合同要求。</li></ol><p id="e9c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了消除这些代码气味，我们声明了<code class="du lc ld le lf b">AbstractEnrichmentStep</code>类。看看下面的代码片段。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">抽象浓缩步骤</p></figure><p id="be0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，下一个<code class="du lc ld le lf b">EnrichmentStep</code>被封装在<code class="du lc ld le lf b">AbstractEnrichmentStep</code>中，而<code class="du lc ld le lf b">setNext</code>方法是最终的。因此，实现不需要存储更多的链元素。</p><p id="6c26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，还有新方法<code class="du lc ld le lf b">enrichAndApplyNext</code>。事实上，一个实现根本不用担心链接的细微差别。如果富集成功，则该方法返回新消息。否则，检索<code class="du lc ld le lf b">Optional.empty</code>。</p><p id="fba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，<code class="du lc ld le lf b">enrich</code>方法也是最终方法。因此，它的实现是固定的。如您所见，我们浓缩算法不是跨多个类复制的，而是放在一个方法中。很简单:</p><ol class=""><li id="9891" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">如果<code class="du lc ld le lf b">enrichAndApplyNext</code>返回值，则进入下一个加浓步骤。</li><li id="b6a4" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">如果没有值，用原始消息调用下一步。</li><li id="0bed" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">如果出现任何错误，请将其记录下来，并继续正常的富集链。</li></ol><p id="cdc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一点至关重要。我们不知道会有多少实现，以及它们可能抛出什么异常。然而，我们不想完全停止浓缩过程，而只是跳过失败的链块执行。看看下面的<code class="du lc ld le lf b">PhoneNumberEnrichmentRepository</code>实现，它扩展了已定义的<code class="du lc ld le lf b">AbstractEnrichmentStep</code>。</p><pre class="jf jg jh ji fd ll lf lm ln aw lo bi"><span id="f07a" class="lp jr hi lf b fi lq lr l ls lt">@Service<br/>class PhoneNumberEnrichmentStep extends AbstractEnrichmentStep {<br/>  private final PhoneNumberRepository phoneNumberRepository;</span><span id="0290" class="lp jr hi lf b fi mq lr l ls lt">  @Override<br/>  protected Optional&lt;Message&gt; enrichAndApplyNext(Message message) {<br/>    return message.getValue("SESSIONID")<br/>        .flatMap(phoneNumberRepository::findPhoneNumber)<br/>        .map(phoneNumber -&gt;<br/>            message.with("phoneNumber", phoneNumber)<br/>        );<br/>  }<br/>}</span></pre><p id="3b2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，不再有基础设施代码了。纯粹的商业逻辑。</p><h1 id="928b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">改进点</h1><p id="7d39" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">如果你有许多浓缩步骤，那么你当然要监控它们的活动。</p><ol class=""><li id="2793" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">在特定的步骤中，需要多少时间来充实信息？</li><li id="b6cf" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">什么是浓缩统计？哪一个强化步骤最常失败？</li><li id="974c" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">哪些步骤失败了，为什么？</li></ol><p id="a560" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">度量是所有这些问题的答案。此外，<code class="du lc ld le lf b">AbstractEnrichmentStep</code>声明还可以帮助我们更清晰地记录监控值。查看下面的代码片段。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">用度量标准抽象浓缩步骤</p></figure><p id="fac5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先有一个新的抽象方法<code class="du lc ld le lf b">getEnrichmentType()</code>。每个实现都应该返回其类型，以正确区分结果指标。</p><p id="01ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">规则是这样的:</p><ol class=""><li id="726b" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">如果成功地丰富了消息，就调用<code class="du lc ld le lf b">recordHit</code>方法。</li><li id="bc57" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">如果跳过消息丰富，则<code class="du lc ld le lf b">recordMiss</code>开始。</li><li id="583a" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">如果出现任何错误，那么<code class="du lc ld le lf b">recordError</code>就会发挥作用。</li><li id="f332" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">最后，通过调用<code class="du lc ld le lf b">recordDuration</code>存储整个浓缩步骤的持续时间。</li></ol><p id="c325" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以按照自己的方式调整指标。这个想法是实现不关心这些细节。<a class="ae jd" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开合原理</a>在行动！</p><h1 id="db9c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="6c21" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这就是我想告诉你的关于Spring生态系统中的责任实现链的全部内容。如果您有任何问题或建议，请在下面留下您的评论。感谢阅读！</p><h1 id="1bfd" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">资源</h1><ol class=""><li id="3d8b" class="kt ku hi ih b ii ko im kp iq mr iu ms iy mt jc ky kz la lb bi translated"><a class="ae jd" href="https://github.com/SimonHarmonicMinor/spring-chain-of-responsibility-example" rel="noopener ugc nofollow" target="_blank">带有源代码的存储库</a></li><li id="caac" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated"><a class="ae jd" href="https://sourcemaking.com/design_patterns/null_object" rel="noopener ugc nofollow" target="_blank">空对象设计模式</a></li><li id="40be" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated"><a class="ae jd" href="https://sourcemaking.com/design_patterns/chain_of_responsibility" rel="noopener ugc nofollow" target="_blank">责任链模式解释</a></li><li id="2c57" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated"><a class="ae jd" href="https://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">Java中的不变性</a></li><li id="97d8" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated"><a class="ae jd" href="https://www.baeldung.com/spring-application-context" rel="noopener ugc nofollow" target="_blank"> Spring应用上下文</a></li><li id="2198" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated"><a class="ae jd" href="https://javarevisited.blogspot.com/2015/07/strategy-design-pattern-and-open-closed-principle-java-example.html#axzz5CqPlkiLV" rel="noopener ugc nofollow" target="_blank">开闭原理</a></li></ol></div></div>    
</body>
</html>