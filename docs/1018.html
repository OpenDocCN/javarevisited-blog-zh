<html>
<head>
<title>Let’s Learn Together Sessions: Spring Batch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们一起学习会话:春季批次</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/lets-learn-together-sessions-spring-batch-e690fd5428ec?source=collection_archive---------0-----------------------#2021-02-21">https://medium.com/javarevisited/lets-learn-together-sessions-spring-batch-e690fd5428ec?source=collection_archive---------0-----------------------#2021-02-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a0ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，您将了解如何借助Spring Batch框架，在基于Spring的应用程序中使用批处理。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6a9ddefe8c1ca9d9f11e261784488d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ku9J9z_AX3a_hFbv"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">杰拉尔丁·莱瓦在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="c8dc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">批处理的历史:</h1><p id="6cd9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">批处理是一个已经存在多年的术语。<br/>批处理可以被认为是一组过程，包括在每一步处理大量输入数据的某一部分。</p><p id="f8b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种类型的批处理过程通常包括日常或预定时间的操作。多年来，批处理的方式发生了变化，但即使在今天，这个术语仍然是一种常见的做法。</p><p id="5291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最早的批处理是基于第一个计算系统的开发。第一批计算机一次只能做一项工作。也就是说，控制机器的一个人可以在单位时间内运行一个作业，这个人必须等到当前作业完成后才能开始另一个作业。当正在运行的作业完成时，控制机器的人必须触发机器开始下一个作业。</p><p id="bf3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个新作业或批处理作业，都要重复这一过程。时间复杂度是指一个人完成一项工作所需的时间。另一方面，每一项工作都是在人工干预下完成的，因此显然需要人工来保证流程的连续性。</p><p id="2c3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在那个时代，使用计算机系统的人们使用穿孔卡(下图)或磁带来运行批处理。穿孔卡片的发明可以追溯到18世纪。1890年，美国统计学家赫尔曼·何乐礼发明了一种处理穿孔卡片的机器。赫尔曼最初在美国1890年人口普查中使用这台机器。这台机器将全美人口普查时间从8年缩短到6年。这是用真实机器进行批处理的最早例子之一。<strong class="ih hj">【1】</strong></p><p id="51a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管这个系统部分地消除了批量操作的时间复杂性，但是系统中人的需求仍然是清楚的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/2ff2d4814c3284ee7584ac34c693d3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DtdrlYDTMrtOh-kkIrVmg.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">图片来源:<a class="ae jt" href="https://www.computerhope.com/jargon/p/punccard.htm" rel="noopener ugc nofollow" target="_blank">https://www.computerhope.com/jargon/p/punccard.htm</a>:::打卡</p></figure><p id="6aab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，下一个目标是消除批处理中的人工需求。批处理在接下来的几十年里继续发展。随着批处理过程中新技术和软件系统的出现，人工干预日益减少。</p><p id="28b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着诸如大型机系统之类的高可用性和高性能计算系统的发展，批处理已经变得可以以更高的性能和更少的内存消耗进行处理。</p><p id="9c8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了<a class="ae jt" rel="noopener" href="/javarevisited/top-10-programming-languages-you-can-learn-for-jobs-and-career-in-technology-491e611c22bc?source=extreme_sidebar---------0-2----------------------">软件语言</a>，如<strong class="ih hj"> COBOL </strong>和<strong class="ih hj"> REEX </strong>，它们提供了容易的开发和高可读性，批量处理的转换在大型机系统中使用变得更加容易。</p><p id="e959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，现代的<a class="ae jt" rel="noopener" href="/javarevisited/7-free-scala-and-functional-programming-courses-for-beginners-370f3cd41a4e">函数式</a>和<a class="ae jt" rel="noopener" href="/swlh/5-free-object-oriented-programming-online-courses-for-programmers-156afd0a3a73">面向对象语言</a>已经取代了Cobol等老式的方法语言。因此，业务需求所需的批处理操作已经开始用这些现代的、高度可伸缩的、有特色的语言来开发。</p><p id="f7c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，虽然开源的<a class="ae jt" rel="noopener" href="/javarevisited/top-10-courses-to-learn-big-data-and-hadoop-best-of-lot-23ef8691633f"> <strong class="ih hj"> Hadoop </strong> </a>框架如<a class="ae jt" rel="noopener" href="/javarevisited/5-free-courses-to-learn-apache-spark-in-2020-bdff2d60c800"> Spark </a>被用于大数据处理，但人们更喜欢批量的<strong class="ih hj"> ETL </strong>工具如Informatica用于较小的数据集。</p><p id="806b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，像<strong class="ih hj">亚马逊红移</strong>和<strong class="ih hj">谷歌大查询</strong>这样的关系数据库是在你的日常业务操作中使批处理成为可能的其他流行选项。<strong class="ih hj">【2】</strong></p><p id="e14b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Java EE中，还可以借助规范<a class="ae jt" href="https://jcp.org/en/jsr/detail?id=352" rel="noopener ugc nofollow" target="_blank"> JSR352 </a>使用批处理。应用程序开发人员可以使用这个规范模型来开发健壮的批处理系统。</p><p id="d997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像Spring这样的现代Java Web框架也在这个规范上开发了批处理框架。开发人员现在能够使用批处理框架提供的特定配置和预实现的接口和监听器，以最少的工作量进行批处理。Spring在它的文档网站上解释了它开发的流行的批处理框架如下:</p><blockquote class="ky"><p id="90a1" class="kz la hi bd lb lc ld le lf lg lh jc dx translated">一个轻量级、全面的批处理框架，旨在支持对企业系统的日常操作至关重要的健壮批处理应用程序的开发。</p></blockquote><p id="0d94" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Spring Batch framework不仅提供有用的功能，还支持日志/跟踪、事务管理、作业进程统计、作业跳过、重启和资源管理功能。我们可以列出spring批处理提供的主要功能如下:</p><ul class=""><li id="26c1" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated">事务管理</li><li id="18bf" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">基于组块的处理</li><li id="badd" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">说明性输入输出</li><li id="ac02" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">启动/停止/重启</li><li id="959c" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">重试/跳过</li><li id="469d" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">基于Web的管理界面</li></ul><p id="3c02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，尽管批处理可以追溯到18世纪，但是在今天的计算世界中，批处理的数量和用途已经发生了变化。在文章的下一部分，让我们看看现在在哪里使用批处理。</p><h1 id="59a7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">在哪里使用批处理？</h1><p id="4a3f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">批处理已经在不同的领域和部门使用了多年。如今，批处理仍然是公司甚至政府机关使用的主要操作之一。</p><p id="6425" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">批处理技术主要用于ETL事务，目的是从多个系统中提取数据，然后将数据存储在数据仓库系统中，再将数据从数据仓库转换到分析平台。例如，一个成本会计系统可以结合来自工资，销售和采购的数据。</p><p id="26f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，<a class="ae jt" rel="noopener" href="/javarevisited/8-best-data-visualization-tools-and-libraries-data-analysts-and-scientists-can-learn-d2734371df16">数据可视化工具</a>从几个系统收集数据，如数据库、社交媒体条目、数据收集工具和其他服务，然后将其存储在数据仓库中，并可以通过对数据进行转换为客户提供定制的数据可视化。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/d2a8547449caa04acb52eabdbfc6b0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xh1YfHygqmHSpWj3QAsyXg.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">图片来源:【https://www.spec-india.com/tech-in-200-words/what-is-etl T2】::ETL流程</p></figure><p id="4eb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，遗留系统中的数据迁移是一个通过批处理广泛执行的过程。报告生成过程、计费分析系统和日志分析系统使用批处理在可管理和可监控的结构中实现高效和可扩展的解决方案。</p><p id="0adb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">批处理是处理大量数据时生成的日常操作和业务报告的首选技术之一。</p><p id="fb6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着批处理的转变，许多数据输入专业人员的工作被计算机取代，另一方面，公司避免了一笔巨大的开支。</p><p id="894a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了这些使用领域，未来需要人工干预的过程向无人化过程的转化将会增加。虽然这种转变将导致许多人失业，但它也将为计算系统管理人员创造新的工作机会。</p><h1 id="d44d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">它是如何工作的？</h1><p id="35d8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">要理解Spring Batch框架中的批处理，您必须了解批处理系统的术语和主要组件。</p><p id="a763" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据的批量处理是先采集大量数据，然后以特定方式处理，再产生批量结果的过程。批处理通常由称为作业的任务组成。每个<strong class="ih hj"> <em class="mc">工作</em> </strong>描述一个加工流程或步骤。每个<strong class="ih hj"> <em class="mc">步骤</em> </strong>由一个阅读器、一个处理器和一个写入器组成。在Spring Batch中，主任务称为作业。作业可以按时间安排，也可以由事件触发。</p><p id="c805" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，步骤，即作业的处理单元，是Spring Batch基础设施的关键点之一。根据我们定义的逻辑，一个作业可以包含一个或多个步骤。我们可以通过使用<strong class="ih hj"> chunk </strong>或<strong class="ih hj"> tasklet </strong>模型来定义Spring批处理中的一个步骤。</p><p id="9589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在分块方法中，一个步骤的初始化有3个组成部分，其顺序如下:</p><ul class=""><li id="d52d" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated"><strong class="ih hj">项目阅读器:</strong>从数据库、消息队列或其他地方读取。</li><li id="91b4" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><strong class="ih hj">商品处理器:</strong>对来自商品阅读器的数据应用业务逻辑，并对数据进行处理。</li><li id="3b45" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><strong class="ih hj">条目编写器:</strong>获取数据并写入数据库或消息队列。</li></ul><p id="c9ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据存储在定义的块中，并在这些块上进行处理。<br/>一个<strong class="ih hj"> chunk </strong>是某一部分数据的组合。您可以使用<strong class="ih hj">块大小</strong>参数指定块中数据的大小。“区块提供了一种简单的解决方案来处理分页读取或我们不想在内存中保留大量数据的情况”。<strong class="ih hj">【3】</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es md"><img src="../Images/638113938db7021d23f1f8b50c710959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/0*x981OyAMMhSfgEZI.jpg"/></div><p class="jp jq et er es jr js bd b be z dx translated">图片鸣谢:<a class="ae jt" href="https://livebook.manning.com/concept/spring/filter-item-processor" rel="noopener ugc nofollow" target="_blank">https://live book . manning . com/concept/spring/filter-item-processor</a>:::面向组块的步骤</p></figure><p id="e83c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，在小任务模型<strong class="ih hj">中，小任务</strong>作为一个步骤中的单个任务来执行。小任务模型中的作业包括读取、处理和写入步骤，并且一个接一个地执行每个步骤。与块模型不同，它在一个步骤中处理所有数据。作为一种风险，如果您的数据非常大，资源可能会耗尽。因此，如果您的数据量很大，那么选择块方法会更好。小任务模型步骤创建，通常用于删除资源或执行查询等操作。</p><p id="1a9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Spring Batch框架中，另一个重要组件是<strong class="ih hj"> JobRepository </strong>。它将作业和步骤细节存储在由框架处理的内存数据库中。另一方面，这个存储库在项目处理期间定期存储作业和步骤执行，并计算执行度量以提供统计数据。因此，作业和步骤执行的管理和流程由Spring Batch框架提供。</p><p id="b32c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Spring Batch基础设施中定义了一个作业和相关步骤之后，您需要一个<strong class="ih hj"> JobLauncher </strong>来运行一个特定的作业。Spring Batch为JobLauncher的作业运行和所有可能的特别执行提供了一个简单的接口。根据实施情况，用户可以手动同步或异步运行作业。要使用JobLauncher运行作业，您需要创建一个<strong class="ih hj"> JobInstance </strong>，并使用<strong class="ih hj"> JobParameters </strong>为JobInstance提供作业参数，如果可用的话。</p><p id="d3cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在下图中看到Spring Batch框架的主要基础设施:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es me"><img src="../Images/8fd751c6798235aaac1f20613baefdad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDLh5VxrlYquwYevJDNPWQ.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">图片来源:<a class="ae jt" href="https://www.toptal.com/spring/spring-batch-tutorial" rel="noopener ugc nofollow" target="_blank">https://www.toptal.com/spring/spring-batch-tutorial</a>::春批框架</p></figure><p id="ee24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们设计一个应用程序，从提供冠状病毒数据的免费API中读取数据。这个演示应用程序通过在处理器步骤中使用映射器将数据转换成实体对象。然后它将所有的Covid数据保存到一个<a class="ae jt" href="https://javarevisited.blogspot.com/2015/06/2-ways-to-parse-csv-files-in-java-example.html" rel="noopener ugc nofollow" target="_blank"> CSV文件</a>。</p><p id="9d11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在一个<a class="ae jt" href="https://javarevisited.blogspot.com/2020/12/top-5-project-based-courses-to-learn-java-python-javascript.html" rel="noopener ugc nofollow" target="_blank"> Java项目</a>中使用Spring Batch框架，您需要向您的应用程序添加以下依赖项。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="a2e1" class="mk jv hi mg b fi ml mm l mn mo">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="8944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要启用批处理，您需要向主类添加<strong class="ih hj"> @EnableBatchProcessing </strong>注释。使用enable annotation，您可以使用Spring批处理功能，并为在配置类中设置批处理作业提供基本配置。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="8954" class="mk jv hi mg b fi ml mm l mn mo">@SpringBootApplication<br/>@EnableBatchProcessing<br/>public class CovidBatchServiceApplication {<br/>}</span></pre><p id="b49b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加完依赖项和注释后，您可以通过定义批处理过程中的步骤来开始应用程序的设计。在Spring Batch框架中，您可以使用<strong class="ih hj"> StepBuilderFactory </strong>来定义一个步骤。它使用<a class="ae jt" href="http://javarevisited.blogspot.sg/2012/06/builder-design-pattern-in-java-example.html" rel="noopener ugc nofollow" target="_blank">构建器模式</a>创建一个新对象，并将读取器、处理器和写入器对象作为如下参数:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="cf26" class="mk jv hi mg b fi ml mm l mn mo">@Autowired<br/>private StepBuilderFactory stepBuilderFactory;</span><span id="3910" class="mk jv hi mg b fi mp mm l mn mo">@Bean<br/>Step saveDataFromApiToCsvFileStep(){<br/>    return stepBuilderFactory.get("saveDataFromApiToCsvFileStep")<br/>            .&lt;CovidCountryDataDTO,CovidCountryData&gt;chunk(5)<br/>            .reader(reader())<br/>            .processor(processor())<br/>            .writer(fileItemWriter())<br/>            .build();<br/>}</span></pre><p id="1a1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，块大小设置为5，默认的批处理块大小为1。因此，它每次读取、处理和写入5个数据集。阅读器可以通过使用来自Spring Batch框架的<strong class="ih hj"> ItemReader </strong>接口来定义。</p><p id="1866" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ItemReader接口包含一个<strong class="ih hj"> read() </strong>方法，所以这个方法可以在实现的Reader类中被覆盖。在类的初始化时间，reader类使用一个服务读取数据，该服务使用<a class="ae jt" href="https://javarevisited.blogspot.com/2017/02/how-to-consume-json-from-restful-web-services-Spring-RESTTemplate-Example.html" rel="noopener ugc nofollow" target="_blank"> RestTemplate </a>从API获取数据。</p><p id="8e3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后在read方法中，通常对每个批处理调用多次，每次调用<code class="du mq mr ms mg b">read()</code>都返回下一个值，最后当所有输入数据都用尽时返回<code class="du mq mr ms mg b">null</code>，如下所示<strong class="ih hj">【4】</strong>:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="9ef1" class="mk jv hi mg b fi ml mm l mn mo">public class CovidDataItemReader implements ItemReader&lt;CovidCountryDataDTO&gt; , InitializingBean {<br/><br/>    @Autowired<br/>    CovidApiBatchService covidApiBatchService;<br/><br/>    private List&lt;CovidCountryDataDTO&gt; covidCountryDataList;<br/>    private Integer index = 0;<br/>    private boolean initialized;<br/><br/>    private void init() {<br/><br/>        covidCountryDataList = covidApiBatchService.getCovidSummaryData().getCountries();<br/>        initialized = true;<br/>    }<br/><br/>    @Override<br/>    public void afterPropertiesSet() throws Exception {<br/>        init();<br/>    }<br/><br/><br/>    @Override<br/>    public CovidCountryDataDTO read(){<br/><br/>        if(!initialized)<br/>            init();<br/><br/>        if(index == covidCountryDataList.size()){<br/>            index = 0;<br/>            initialized = false;<br/>            return null;<br/>        }<br/><br/>        CovidCountryDataDTO countryDTO = covidCountryDataList.get(index);<br/>        index++;<br/>        return countryDTO;<br/>    }<br/>}</span></pre><p id="8321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在自定义Reader类实现之后，需要开发一个处理器，将来自Reader的数据映射到实体对象列表。在<strong class="ih hj"> ItemProcessor </strong>的帮助下，可以轻松实现一个定制的ItemProcessor类。ItemProcessor包含<strong class="ih hj"> process() </strong>方法，该方法允许我们将业务逻辑应用于读取器进程中读取的数据。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="0d26" class="mk jv hi mg b fi ml mm l mn mo">@Slf4j<br/>public class CovidDataItemProcessor implements ItemProcessor&lt;CovidCountryDataDTO, CovidCountryData&gt; {<br/><br/>    @Autowired<br/>    private CovidCountryDataMapper covidCountryDataMapper;<br/><br/>    @Override<br/>    public CovidCountryData process(CovidCountryDataDTO covidCountryDataDTO){<br/><br/>        return covidCountryDataMapper.map(covidCountryDataDTO);<br/>    }<br/>}</span></pre><p id="b526" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现自定义处理器类后，最后一步是设计编写类。与读取器和处理器步骤一样，另一个Spring批处理接口<strong class="ih hj"> ItemWriter </strong>可用于实现编写器功能。如果您想将数据写入文件，<a class="ae jt" rel="noopener" href="/javarevisited/10-best-spring-framework-books-for-java-developers-360284c37036"> Spring </a>为此功能提供了另一个定制接口，称为<strong class="ih hj"> FlatFileItemWriter。</strong></p><p id="7a61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，您需要定义一个实现这个接口的类。在实现的writer类的构造函数中，首先设置文件的标题字段。然后为<a class="ae jt" href="https://www.java67.com/2019/05/how-to-read-csv-file-in-java-using-jackson-library.html" rel="noopener ugc nofollow" target="_blank"> CSV文件</a>定义分隔符，并将数据列交给bean包装器字段提取器，以便只从数据中提取某些字段。方法将数据写入属性文件中定义的资源。此功能的示例实现如下:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="8a74" class="mk jv hi mg b fi ml mm l mn mo">public class CovidDataFileItemWriter extends FlatFileItemWriter&lt;CovidCountryData&gt; {<br/><br/>    private static final String[] <em class="mc">dataColumns </em>= new String[]{"country", "countryCode", "newConfirmed", "totalConfirmed", "newDeaths", "totalDeaths", "newRecovered", "totalRecovered"};<br/><br/><br/>    public CovidDataFileItemWriter(ApplicationProperties applicationProperties){<br/><br/>        super();<br/><br/>        this.setHeaderCallback(writer -&gt; writer.write("Country;CountryCode;New Confirmed;Total Confirmed;New Deaths;Total Deaths;New Recovered;Total Recovered"));<br/><br/>        this.setAppendAllowed(true);<br/><br/>        DelimitedLineAggregator&lt;CovidCountryData&gt; delimitedLineAggregator = new DelimitedLineAggregator&lt;&gt;();<br/><br/>        delimitedLineAggregator.setDelimiter(";");<br/><br/>        BeanWrapperFieldExtractor&lt;CovidCountryData&gt; fieldExtractor = new BeanWrapperFieldExtractor&lt;&gt;();<br/><br/>        fieldExtractor.setNames(<em class="mc">dataColumns</em>);<br/><br/>        delimitedLineAggregator.setFieldExtractor(fieldExtractor);<br/><br/><br/>        this.setResource(new PathResource(applicationProperties.getCsvFilePath()));<br/>        this.setLineAggregator(delimitedLineAggregator);<br/><br/>   }<br/>}</span></pre><p id="4625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，第一步完成了读取器、处理器和写入器方法的实现。我们再定义一个步骤，从上一步写的<a class="ae jt" href="http://www.java67.com/2015/08/how-to-load-data-from-csv-file-in-java.html" rel="noopener ugc nofollow" target="_blank"> CSV文件</a>中读取数据，然后用上一步设计的处理器处理数据，最后将处理后的数据写入一个数据库。为此，我们将定义另一个步骤bean，如下所示:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="0031" class="mk jv hi mg b fi ml mm l mn mo">@Bean<br/>Step  (){<br/>    return stepBuilderFactory.get("saveDataFromCsvFileToDbStep")<br/>            .&lt;CovidCountryDataDTO,CovidCountryData&gt;chunk(5)<br/>            .reader(fileItemReader())<br/>            .processor(processor())<br/>            .writer(writer())<br/>            .build();<br/>}</span></pre><p id="6c28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">reader类可以通过使用来自Spring Batch框架的<strong class="ih hj"> FlatFileItemReader </strong>接口来定义。所以你必须定义一个实现这个接口的类。</p><p id="67fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实现的reader类的<a class="ae jt" href="https://javarevisited.blogspot.com/2012/12/what-is-constructor-in-java-example-chainning-overloading.html" rel="noopener ugc nofollow" target="_blank">构造函数</a>中，首先指定从文件中读取数据的分隔符，然后给出要解析的数据列。您还需要指定目标对象类型，并设置读取器将读取的资源。此外，假设文件的第一行是标题行，您必须将<strong class="ih hj"> linesToSkip </strong>参数作为1传递，以便在读取类的过程中跳过文件的第一行。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="f11c" class="mk jv hi mg b fi ml mm l mn mo">public class CovidDataFileItemReader extends FlatFileItemReader&lt;CovidCountryDataDTO&gt; {<br/><br/><br/>    private static final String[] <em class="mc">dataColumns </em>= new String[]{"country", "countryCode", "newConfirmed", "totalConfirmed", "newDeaths", "totalDeaths", "newRecovered", "totalRecovered"};<br/><br/>    private static final int <em class="mc">LINES_TO_SKIP </em>= 1;<br/><br/><br/>    public CovidDataFileItemReader(ApplicationProperties applicationProperties){<br/><br/>        super();<br/><br/>        DefaultLineMapper&lt;CovidCountryDataDTO&gt; lineMapper = new DefaultLineMapper&lt;&gt;();<br/><br/>        DelimitedLineTokenizer delimitedLineTokenizer = new DelimitedLineTokenizer();<br/>        delimitedLineTokenizer.setDelimiter(";");<br/><br/>        delimitedLineTokenizer.setNames(<em class="mc">dataColumns</em>);<br/><br/>        BeanWrapperFieldSetMapper&lt;CovidCountryDataDTO&gt; fieldSetMapper = new BeanWrapperFieldSetMapper&lt;&gt;();<br/>        fieldSetMapper.setTargetType(CovidCountryDataDTO.class);<br/><br/>        lineMapper.setLineTokenizer(delimitedLineTokenizer);<br/><br/>        lineMapper.setFieldSetMapper(fieldSetMapper);<br/><br/>        this.setResource(new PathResource(applicationProperties.getCsvFilePath()));<br/>        this.setLineMapper(lineMapper);<br/>        this.setLinesToSkip(<em class="mc">LINES_TO_SKIP</em>);<br/>    }<br/>}</span></pre><p id="896f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在处理器步骤中，我们将使用在上一步中已经定义的处理器类。</p><p id="8145" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们希望将数据存储在数据库中，而不是写在CSV文件中，我们需要开发一个实现<strong class="ih hj"> ItemWriter </strong>接口的类。ItemWriter接口提供了一个<strong class="ih hj"> write() </strong>方法，使得写操作在批处理中成为可能。在下面的代码中，数据存储的<strong class="ih hj"> saveAll </strong>方法被调用并保存到<a class="ae jt" rel="noopener" href="/javarevisited/8-free-oracle-database-and-sql-courses-for-beginners-f4e9b25b33c4">数据库</a>。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="7a2a" class="mk jv hi mg b fi ml mm l mn mo">public class CovidDataItemWriter implements ItemWriter&lt;CovidCountryData&gt; {</span><span id="e15a" class="mk jv hi mg b fi mp mm l mn mo">    @Autowired<br/>    private CovidDataRepository covidDataRepository;</span><span id="13a3" class="mk jv hi mg b fi mp mm l mn mo">    @Override<br/>    public void write(List&lt;? extends CovidCountryData&gt; countryDataList){<br/>        if(countryDataList != null) {<br/>            covidDataRepository.saveAll(countryDataList);<br/>        }<br/>    }<br/>}</span></pre><p id="5aed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们就完成了这两个步骤的实现，分别是<strong class="ih hj">saveDataFromApiToCsvFileStep</strong>和<strong class="ih hj">saveDataFromCsvFileToDbStep</strong>。<strong class="ih hj"> </strong>我们需要将这两个步骤连接到一个作业来运行它们。要在Spring Batch中定义一个作业，可以使用<strong class="ih hj"> JobBuilderFactory </strong>。与StepBuilderFactory一样，它也是用构建器模式设计的，并使用给定的参数创建一个作业实例。</p><p id="3459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要运行的步骤在作业中定义。此外，如果您想要多次运行作业，您必须定义一个<strong class="ih hj"> incrementer </strong>，它一次递增一个作业实例ID。否则，它返回错误<strong class="ih hj">“作业实例已经存在，并且对于parameters={}”是完整的。</strong>使用<strong class="ih hj">下一步</strong>和<strong class="ih hj">流程</strong>步骤字段，您可以指定哪些步骤将首先开始，哪些步骤将在每个步骤之后开始:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="6ccb" class="mk jv hi mg b fi ml mm l mn mo">@Autowired<br/>private JobBuilderFactory jobBuilderFactory;</span><span id="34fc" class="mk jv hi mg b fi mp mm l mn mo">@Bean<br/>Job batchJob(){<br/>    return jobBuilderFactory.get("job1")<br/>            .incrementer(new RunIdIncrementer())<br/>            .flow(saveDataFromApiToCsvFileStep())<br/>            .next(saveDataFromCsvFileToDbStep())<br/>            .end()<br/>            .build();<br/>}</span></pre><p id="a225" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您定义了作业bean，当应用程序启动时，它会尝试运行作业。您可以在属性文件中禁用它，这样就可以手动或通过计划的操作调用作业。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="8d2d" class="mk jv hi mg b fi ml mm l mn mo">spring.batch.job.enabled=false</span></pre><p id="559e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在运行应用程序之前，我们可以在application.yml中启用H2(内存中)控制台，如下所示:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="50eb" class="mk jv hi mg b fi ml mm l mn mo">spring:<br/>  h2:<br/>    console:<br/>      enabled: true<br/>  jpa:<br/>    database-platform: org.hibernate.dialect.H2Dialect<br/>    show-sql: false<br/>  datasource:<br/>    url: jdbc:h2:mem:testdb<br/>    driverClassName: org.h2.Driver<br/>    username: admin<br/>    password: admin</span></pre><p id="3a84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用Spring批处理框架中的JobLauncher接口来运行作业。JobLauncher包括<strong class="ih hj"> run() </strong>方法，该方法创建一个<strong class="ih hj"> JobInstance </strong>来运行作业及其步骤。使用Spring Batch框架中的<strong class="ih hj"> JobParameters </strong>类，我们可以将任何参数(如用户、开始时间和运行参数)传递给作业实例，如下所示:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="f4eb" class="mk jv hi mg b fi ml mm l mn mo">JobParameters jobParameters = new JobParametersBuilder()<br/>        .addString("user", user)<br/>        .addDate("startDate",new Date())<br/>        .toJobParameters();<br/><br/>jobLauncher.run(batchJob, jobParameters);</span></pre><p id="62b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring Batch提供了一个内存中的H2数据库，名为<a class="ae jt" href="https://www.java67.com/2021/01/spring-data-jpa-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">job repository</strong></a><strong class="ih hj">。</strong>这些存储库的模式如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mt"><img src="../Images/cc2caf0e55b485571699404ca25d068c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HkGzBeM0FSC4Exa2.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">图片鸣谢:<a class="ae jt" href="https://docs.spring.io/spring-batch/docs/current/reference/html/schema-appendix.html" rel="noopener ugc nofollow" target="_blank">https://docs . Spring . io/Spring-Batch/docs/current/reference/html/schema-appendix . html</a>:Spring批处理表</p></figure><p id="18a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行作业后，我们可以使用<strong class="ih hj"> batch_step_execution </strong>和<strong class="ih hj"> batch_job_execution </strong>表来查看已执行作业和步骤的状态，以及计算读、写、事务数量以及开始和结束时间的指标值。</p><p id="2872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring Batch框架支持使用监听器接口进行流程干预。Spring Batch框架中实现的接口有:<strong class="ih hj">【5】</strong></p><ul class=""><li id="54d6" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated">JobExecutionListener</li><li id="4655" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">StepExecutionListener</li><li id="4a69" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">ItemReadListener</li><li id="0330" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">ItemProcessListener</li><li id="a175" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">ItemWriteListener</li><li id="bdf7" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">SkipListener</li></ul><p id="fe70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在作业或步骤的执行过程中进行干预，以进行记录、检验等。它们用于处理一些操作。<strong class="ih hj"> JobExecutionListener </strong>接口为Spring批处理作业提供了拦截，因此您可以借助<strong class="ih hj"> beforeJob </strong>和<strong class="ih hj"> afterJob </strong>被覆盖的方法来应用作业前后的任何逻辑。在下面的例子中，我们在作业执行前后创建了一个<strong class="ih hj">信息</strong>级别的日志。</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="c52d" class="mk jv hi mg b fi ml mm l mn mo">@Log4j2<br/>public class CovidDataJobItemListener implements JobExecutionListener {<br/><br/>    @Override<br/>    public void beforeJob(JobExecution jobExecution) {<br/>        <em class="mc">log</em>.info("Job started for user: {}.",jobExecution.getJobParameters().getString("user"));<br/>    }<br/><br/>    @Override<br/>    public void afterJob(JobExecution jobExecution) {<br/>        <em class="mc">log</em>.info("Job ended for user: {}.",jobExecution.getJobParameters().getString("user"));<br/>    }<br/>}</span></pre><p id="a1be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与JobExecutionListener一样，StepExecutionListener为Spring批处理步骤提供了拦截，因此您可以借助于步骤前的<strong class="ih hj">步骤后的</strong>和步骤后的<strong class="ih hj">覆盖方法来应用步骤前后的任何逻辑。您不仅可以截取一个步骤，还可以截取读取器、处理器、编写器步骤中任何单个步骤的前后。</strong></p><p id="33d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> ItemReaderListener </strong>、<strong class="ih hj"> ItemProcessorListener、</strong>和<strong class="ih hj">itemrewriterlistener</strong>接口可以实现操作前后功能的定制。同样，通过在这些接口中使用<strong class="ih hj"> on…Error </strong>方法，您可以捕捉和管理错误。<strong class="ih hj">【6】</strong>下面的例子展示了这些接口实现的一般结构:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="ad30" class="mk jv hi mg b fi ml mm l mn mo">@Log4j2<br/>public class CovidDataItemReaderListener implements ItemReadListener&lt;CovidCountryDataDTO&gt; {<br/><br/><br/>    @Override<br/>    public void beforeRead() {<br/>    }<br/><br/>    @Override<br/>    public void afterRead(CovidCountryDataDTO covidCountryDataDTO) {<br/>    }<br/><br/>    @Override<br/>    public void onReadError(Exception e) {<br/>    }<br/>}</span></pre><p id="8915" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实现这样的自定义侦听器类之后，您需要将它们作为参数传递给bean定义中的作业或步骤对象，如下所示:</p><pre class="je jf jg jh fd mf mg mh mi aw mj bi"><span id="0179" class="mk jv hi mg b fi ml mm l mn mo">@Bean<br/>Step saveDataFromApiToCsvFileStep(){<br/>    return stepBuilderFactory.get("saveDataFromApiToCsvFileStep")<br/>            .&lt;CovidCountryDataDTO,CovidCountryData&gt;chunk(5)<br/>            .reader(reader())<br/>            .processor(processor())<br/>            .writer(fileItemWriter())<br/>            .listener(processListener())<br/>            .listener(readerListener())<br/>            .listener(writerListener())<br/>            .build();<br/>}</span></pre><h1 id="70d4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论:</h1><p id="05db" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">多年来，批处理一直是处理大量数据的公认标准技术。虽然这些年来技术和工具发生了变化，但是流程背后的思想仍然是标准。批处理不仅为数据处理提供了更快的解决方案，还减少了人工干预，降低了公司管理批处理的成本。</p><p id="0930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring Batch framework在Java EE JSR352标准上提供了高度可用和可配置的批处理功能。该框架不仅提供了构建器类来简化作业和步骤的创建，还提供了接口来为作业和步骤的执行和侦听器开发定制的解决方案。</p><p id="86c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您使用Spring Batch框架时，您不必处理批处理的事务和上下文管理。Spring Batch框架支持事务机制、数据库和上下文执行管理，还支持本文中没有讨论的分区。如果您想定制框架中的任何实现，您可以使用给定的接口轻松地覆盖任何功能。</p><p id="8ae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">批处理已经被许多公司使用多年。公司寻求将ETL和其他批处理过程转换成现代的高性能框架和批处理工具。如果您在项目中有类似的需求，Spring Batch框架将是您的完美解决方案。</p></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><p id="011e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码在<a class="ae jt" href="https://github.com/justayar/SpringBootTemplates/tree/master/springbatch" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Github </strong> </a>上有。</p><h2 id="b96c" class="mk jv hi bd jw nb nc nd ka ne nf ng ke iq nh ni ki iu nj nk km iy nl nm kq nn bi translated"><strong class="ak">参考文献:</strong></h2><p id="0e51" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">[1]<a class="ae jt" href="https://www.bmc.com/blogs/what-is-batch-processing-batch-processing-explained/" rel="noopener ugc nofollow" target="_blank">https://www . BMC . com/blogs/what-is-batch-processing-batch-processing-explained/</a></p><p id="0d91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://www.upsolver.com/blog/batch-stream-a-cheat-sheet" rel="noopener ugc nofollow" target="_blank">https://www.upsolver.com/blog/batch-stream-a-cheat-sheet</a></p><p id="fa83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://www.baeldung.com/spring-batch-tasklet-chunk" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/spring-batch-tasklet-chunk</a></p><p id="6178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://www.toptal.com/spring/spring-batch-tutorial" rel="noopener ugc nofollow" target="_blank">https://www.toptal.com/spring/spring-batch-tutorial</a></p><p id="9865" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[5]<a class="ae jt" href="https://howtodoinjava.com/spring-batch/spring-batch-event-listeners/" rel="noopener ugc nofollow" target="_blank">https://howtodoinjava . com/spring-batch/spring-batch-event-listeners/</a></p><p id="144a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[6]<a class="ae jt" href="https://www.javadevjournal.com/spring-batch/spring-batch-listeners/" rel="noopener ugc nofollow" target="_blank">https://www . javadevjournal . com/spring-batch/spring-batch-listeners/</a></p></div></div>    
</body>
</html>