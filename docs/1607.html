<html>
<head>
<title>Spring Core: Using REST and Spring MVC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring核心:使用REST和Spring MVC</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-core-using-rest-and-spring-mvc-cef35acbec8e?source=collection_archive---------1-----------------------#2021-09-30">https://medium.com/javarevisited/spring-core-using-rest-and-spring-mvc-cef35acbec8e?source=collection_archive---------1-----------------------#2021-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b0e6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">理解Spring如何在幕后工作——第五章</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/83b07e7c6508d717185ad0b48ae1dfd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggMFatSwN_ZjjjutaN4iFA.png"/></div></div></figure><p id="e3d1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">大多数面试过程要求你能够从头开始创建一个应用程序。如果您已经阅读了之前的文章，那么您将非常熟悉所有的Spring核心基础知识，例如<a class="ae kf" rel="noopener" href="/javarevisited/spring-core-ioc-and-container-c01608b527a1">容器</a>、<a class="ae kf" rel="noopener" href="/javarevisited/spring-core-all-you-need-to-know-about-dependency-injection-2048d80340af">依赖注入</a>、<a class="ae kf" rel="noopener" href="/javarevisited/spring-core-including-aspect-oriented-programming-in-your-skills-2c37eaa75c2a"> AOP </a>和<a class="ae kf" rel="noopener" href="/javarevisited/spring-core-managing-transactions-effectively-781bba6c47e8">事务管理</a>，所以现在，我们将把所有这些放在一起，创建一个非常简单但可扩展的API，并通过REST公开我们的web服务。</p><h1 id="3c7b" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">探索MVC</h1><p id="7616" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">模型视图控制器是web应用程序的架构设计。不仅与Java生态系统相关，而且几乎可以应用于任何编程语言。可以想象，Spring有自己的模块，以非常简单的方式在应用程序中实现MVC。</p><ul class=""><li id="cf65" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">模型:数据层，在这里您可以配置和执行您的业务逻辑。</li><li id="4048" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">视图:最终用户的响应。您通过web模板、<a class="ae kf" href="https://javarevisited.blogspot.com/2017/02/how-to-consume-json-from-restful-web-services-Spring-RESTTemplate-Example.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>对象、XML……</li><li id="21fd" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">控制器:负责处理和创建对浏览器的响应。</li></ul><p id="3fc9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，让我们开始定义我们的应用程序架构:</p><ul class=""><li id="9094" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">存储库层，用于数据访问管理</li><li id="61f3" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">服务层，用于业务逻辑</li><li id="7f90" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">控制器层，用于公开我们的API方法并返回输出。</li></ul><p id="8098" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您熟悉Spring原型，也许您已经注意到层名与那些原型注释相同。那是因为<a class="ae kf" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring </a>帮助你明确地组织你的应用层，同时，将它们标记为Spring组件。所以，翻译成普通语言，<code class="du lr ls lt lu b">@Repository</code>、<code class="du lr ls lt lu b">@Service</code>、<code class="du lr ls lt lu b">@Controller</code>不过是<code class="du lr ls lt lu b">@Component</code>的名义上的延伸。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html"><div class="er es lv"><img src="../Images/788cb0aba64fda388f675cd156501b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jbc3SlGV0m1Jr6YqC1P-w.png"/></div></a></figure><blockquote class="lw lx ly"><p id="1f85" class="jj jk lz jl b jm jn ij jo jp jq im jr ma jt ju jv mb jx jy jz mc kb kc kd ke hb bi translated">记住，在Spring上下文中，所有标记的类都被认为是组件，所以为了组织代码，原型明确地划分了每个应用层。如果您用<code class="du lr ls lt lu b">@Component</code>替换任何原型，行为不会改变，但是不容易识别它属于哪个应用层。</p></blockquote><p id="c90c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，记住你在前面章节中学到的，我们将开始组织我们的项目结构并注入依赖关系。<code class="du lr ls lt lu b">@Repository</code>类应该注入到<code class="du lr ls lt lu b">@Services</code>中，<code class="du lr ls lt lu b">@Services</code>应该由<code class="du lr ls lt lu b">@Controller</code>类使用。</p><pre class="iy iz ja jb fd md lu me mf aw mg bi"><span id="b98a" class="mh kh hi lu b fi mi mj l mk ml">@Repository<br/>public class ArticleRepository {</span><span id="b75c" class="mh kh hi lu b fi mm mj l mk ml">  // Repository methods<br/></span></pre><p id="42c7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，一旦这个类准备好被Spring扫描，我们就可以把它注入服务类。</p><pre class="iy iz ja jb fd md lu me mf aw mg bi"><span id="fd0e" class="mh kh hi lu b fi mi mj l mk ml">@Service<br/>public class ArticleService {     <br/>   private ArticleRepository articleRepository;     </span><span id="57ab" class="mh kh hi lu b fi mm mj l mk ml">   public ArticleService(ArticleRepository articleRepository) {          <br/>      this.articleRepository = articleRepository;    <br/>   }</span><span id="050b" class="mh kh hi lu b fi mm mj l mk ml">   // Service methods<br/>}</span></pre><blockquote class="lw lx ly"><p id="6a63" class="jj jk lz jl b jm jn ij jo jp jq im jr ma jt ju jv mb jx jy jz mc kb kc kd ke hb bi translated">从<a class="ae kf" href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.spring-beans-and-dependency-injection" rel="noopener ugc nofollow" target="_blank"> Spring Boot 1.4 </a>开始，构造函数注入是自动连接的，不需要显式使用@Autowired注释。</p></blockquote><p id="6982" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，一旦我们有了我们的项目结构，让我们探索更多关于控制器本身。</p><h1 id="0c99" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">控制器操作</h1><p id="a1d0" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">Spring控制器负责接收处理后的数据，并以预定的格式将输出返回给最终用户。所以，和另一层一样，我们可以用<code class="du lr ls lt lu b">@Controller,</code>来标记我们的控制器类，但是控制器里面到底应该有什么呢？带有已定义端点的公开方法。</p><p id="887b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，我们需要在我们的API中为Articles模型提供CRUD操作，并公开这些操作供我们的客户使用。因此，遵循RESTful最佳实践，我们必须提供:</p><p id="339a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">具有以下HTTP方法的端点:</p><ul class=""><li id="32e0" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><strong class="jl hj">发布</strong> <code class="du lr ls lt lu b">/articles</code>用于创建新文章</li><li id="2d79" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><strong class="jl hj">获取</strong> <code class="du lr ls lt lu b">/articles</code>用于检索所有文章</li><li id="1998" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><strong class="jl hj">获取</strong> <code class="du lr ls lt lu b">/articles/{id}</code>用于检索特定的文章</li><li id="5ae2" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><strong class="jl hj">放</strong>和<code class="du lr ls lt lu b">/articles/{id}</code>用于更新现有文章</li><li id="fe66" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><strong class="jl hj">删除</strong> <code class="du lr ls lt lu b">/articles/{id}</code></li></ul><p id="4856" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">还有其他的HTTP方法，但是不会在这个例子中使用。好的一面是你现在将学到的东西对其他方法也是有用的，所以让我们继续吧！</p><p id="b9a5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么，我们如何通知控制器类我们想要公开那些REST操作呢？Spring用<code class="du lr ls lt lu b">@RequestMapping</code>解决。这个注释将把<code class="du lr ls lt lu b">/articles</code>路径解析成控制器中的目标方法。例如，对于GET操作，我们可以提供以下方法:</p><pre class="iy iz ja jb fd md lu me mf aw mg bi"><span id="8e88" class="mh kh hi lu b fi mi mj l mk ml">@RequestMapping(value = "/articles", method = RequestMethod.GET)    <br/>public ResponseEntity&lt;Article&gt; findArticles() {        <br/>   return ResponseEntity.ok(service.getAllArticles());    <br/>}</span></pre><p id="60aa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">解释代码:</p><ul class=""><li id="ad89" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">当使用<code class="du lr ls lt lu b">GET</code>方法时，<code class="du lr ls lt lu b">@RequestMapping </code>将在<code class="du lr ls lt lu b"> /articles</code>路径中公开findArticles方法。</li><li id="5d8a" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><code class="du lr ls lt lu b">ResponseEntity&lt;&gt;</code>包装器用于将我们的输出格式定义为正确的JSON响应(状态代码、主体、标题)。您可以直接返回对象，Spring会为您包装它，但是使用包装器是一个很好的实践，因为您可以完全控制响应。</li></ul><p id="013e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">同样，我们可以实现其他方法:</p><pre class="iy iz ja jb fd md lu me mf aw mg bi"><span id="cc7d" class="mh kh hi lu b fi mi mj l mk ml">@RequestMapping(value = "/articles/{id}", method = RequestMethod.GET)    <br/>public ResponseEntity&lt;Article&gt; findArticlesByID(@PathVariable Long id) {        <br/>   return ResponseEntity.ok(service.getById(id));    <br/>}</span></pre><p id="ebfb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">解释代码:</p><ul class=""><li id="df6a" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><code class="du lr ls lt lu b">/articles/{id}</code>资源现在有一个显式的路径参数来检索特定的文章。</li><li id="a645" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><code class="du lr ls lt lu b">@PathVariable</code>将把<code class="du lr ls lt lu b">{id}</code>参数映射到我们的方法变量<code class="du lr ls lt lu b">Long id</code>。</li></ul><p id="9afd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果变量名与路径不同，我们必须在<code class="du lr ls lt lu b"><a class="ae kf" href="https://javarevisited.blogspot.com/2017/10/differences-between-requestparam-and-pathvariable-annotations-spring-mvc.html#axzz5jtleVQXB" rel="noopener ugc nofollow" target="_blank">@PathVariable</a></code>注释中指定路径名。</p><pre class="iy iz ja jb fd md lu me mf aw mg bi"><span id="d42b" class="mh kh hi lu b fi mi mj l mk ml">@RequestMapping(value = "/articles/{id}", method = RequestMethod.GET)    <br/>public ResponseEntity&lt;Article&gt; findArticlesByID(@PathVariable("id") Long articleID) {        <br/>   return ResponseEntity.ok(service.getById(id));    <br/>}</span></pre><p id="4e00" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kf" href="https://www.java67.com/2016/09/when-to-use-put-or-post-in-restful-web-services.html" rel="noopener ugc nofollow" target="_blank"> POST和PUT操作</a>的情况下，方法是相同的，唯一的区别是我们在请求中接收一个主体，它将被映射到某个Java对象并持久存储到我们的数据库中。为此，我们将使用<code class="du lr ls lt lu b">@RequestBody</code>注释。</p><pre class="iy iz ja jb fd md lu me mf aw mg bi"><span id="26ae" class="mh kh hi lu b fi mi mj l mk ml">@RequestMapping(value = "/articles", method = RequestMethod.POST)    <br/>public ResponseEntity&lt;Article&gt; save(@RequestBody Article article) {<br/>   Article saved = service.save(article);        <br/>   return new ResponseEntity&lt;&gt;(saved, prepareHeader(saved.getId()), CREATED);    <br/>}</span></pre><p id="e577" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">解释代码:</p><ul class=""><li id="2e7c" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">现在使用的请求方法是POST，所以我们期望请求中有一个主体。</li><li id="cc45" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">Spring提取主体并将其映射到Java对象的方式是通过<code class="du lr ls lt lu b">@RequestBody</code>注释。</li><li id="a781" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">我们正在利用来自<code class="du lr ls lt lu b">ResponseEntity</code>包装器的好处来创建一个带有标题和状态码<code class="du lr ls lt lu b">CREATED</code>的适当的Restful响应。</li></ul><p id="fe2d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如您可能注意到的，所有端点的<code class="du lr ls lt lu b">@RequestMapping</code>代码几乎相同:</p><ul class=""><li id="8c2a" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated">根资源<code class="du lr ls lt lu b">/articles</code>对所有人都一样</li><li id="d0c8" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">唯一改变的是方法和请求参数。</li></ul><p id="a2c0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，通过改进我们的代码，我们可以将<code class="du lr ls lt lu b">/articles </code>资源移动到类级别的注释中。这样，我们将控制器定义为负责整个资源。然后，我们可以从控制器方法中移除<code class="du lr ls lt lu b">/articles</code>路径，如果需要，只使用参数路径<code class="du lr ls lt lu b">/{id}</code>。现在，当请求到来时，类映射将被用作根，并用方法映射来完成。</p><p id="b767" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，为了避免在控制器上重复相同的注释，Spring创建了更多有用的注释，以使我们的代码更容易阅读:<code class="du lr ls lt lu b">@PostMapping</code>、<code class="du lr ls lt lu b">@GetMapping</code>、<code class="du lr ls lt lu b">@PutMapping</code>和<code class="du lr ls lt lu b">@DeleteMapping</code>，这取决于您需要使用的HTTP方法。</p><p id="078b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们运行应用程序并调用<code class="du lr ls lt lu b">/articles</code>端点。也许响应不是您所期望的，这是因为我们使用了<code class="du lr ls lt lu b">@Controller</code>注释，而没有通知Spring我们想要返回JSON对象而不是web模板(默认配置)。怎么解决？<code class="du lr ls lt lu b">@ResponseBody</code>注释为您处理这项工作，并且可以在类级或方法级使用，这取决于您的需要。在大多数情况下，当您创建API方法时，您不需要返回web模板，因此您必须在所有控制器类中使用带有<code class="du lr ls lt lu b">@ResponseBody</code>的<code class="du lr ls lt lu b">@Controller</code>注释。再一次，Spring通过合并<code class="du lr ls lt lu b">@RestController</code>中的这两个注释使这项工作变得更加容易。</p><p id="2a07" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对我们的代码进行一些更改，控制器将如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="cf14" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们的应用程序已经准备好处理请求，并将处理后的数据以JSON格式返回给客户机。当然，我们可以将输出格式修改为XML、文本或任何我们需要的格式。</p><p id="80af" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这只是Spring MVC模块的第一步。我们有更多有趣的话题，如:</p><ul class=""><li id="b113" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><a class="ae kf" href="https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc" rel="noopener ugc nofollow" target="_blank">异常处理程序</a></li><li id="7b50" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><a class="ae kf" href="https://www.baeldung.com/spring-mvc-model-model-map-model-view" rel="noopener ugc nofollow" target="_blank">返回模型、模型图和模型视图</a></li></ul><p id="bd45" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个例子基于我几年前为一次面试创建的现有应用程序。如果你想看看它在现实生活中是如何工作的，<a class="ae kf" href="https://github.com/Darguelles/upd-articles-api" rel="noopener ugc nofollow" target="_blank">这里是GitHub库</a>。此外，我强烈建议您阅读更多关于MVC的内容，以了解所有组件如何协同工作。</p><div class="mp mq ez fb mr ms"><a href="https://github.com/Darguelles/upd-articles-api" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">GitHub-Darguelles/upd-articles-API:使用Spring的Restful API示例，集成测试与…</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">使用Spring的Restful API示例、与RestAssured的集成测试、Docker容器内的部署和文档…</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jh ms"/></div></div></a></div></div><div class="ab cl nh ni gp nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hb hc hd he hf"><p id="5283" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们已经完成了我将于本月发布的Spring Core系列的第五章，也是最后一章。如果您觉得它有用，请关注我并与您的同事分享，同时也请继续关注新内容:</p><ul class=""><li id="fe01" class="ld le hi jl b jm jn jp jq js lf jw lg ka lh ke li lj lk ll bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/javarevisited/spring-core-ioc-and-container-c01608b527a1">弹簧芯:IoC和容器</a></li><li id="12ce" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/javarevisited/spring-core-all-you-need-to-know-about-dependency-injection-2048d80340af"> Spring Core:关于依赖注入你需要知道的一切</a></li><li id="f4d5" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/javarevisited/spring-core-including-aspect-oriented-programming-in-your-skills-2c37eaa75c2a"> Spring Core:在你的技能中包含面向方面编程</a></li><li id="f440" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated"><a class="ae kf" rel="noopener" href="/javarevisited/spring-core-managing-transactions-effectively-781bba6c47e8"> Spring Core:有效管理交易</a></li><li id="5831" class="ld le hi jl b jm lm jp ln js lo jw lp ka lq ke li lj lk ll bi translated">Spring核心:使用REST和Spring MVC</li></ul><p id="125c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">还有，不要犹豫，把你的疑惑贴出来。我非常乐意在这个奇妙的旅程中帮助你。</p><p id="3ca9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可能喜欢的其他<strong class="jl hj"> Spring和REST文章和资源</strong></p><div class="mp mq ez fb mr ms"><a rel="noopener follow" target="_blank" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">2021年学习Spring框架的10个最佳在线课程</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">学习Spring框架、Spring Boot、Spring安全和RESTful Web服务的最佳在线课程</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">medium.com</p></div></div><div class="nb l"><div class="no l nd ne nf nb ng jh ms"/></div></div></a></div><div class="mp mq ez fb mr ms"><a rel="noopener follow" target="_blank" href="/javarevisited/why-spring-is-the-best-framework-for-developing-rest-apis-in-java-784590e484a4"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">为什么Spring是用Java开发REST APIs的最佳框架？</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">REST现在已经成为开发web服务的标准方法，而说到Java，有许多框架和…</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">medium.com</p></div></div><div class="nb l"><div class="np l nd ne nf nb ng jh ms"/></div></div></a></div><div class="mp mq ez fb mr ms"><a rel="noopener follow" target="_blank" href="/javarevisited/top-5-books-and-courses-to-learn-restful-web-services-in-java-using-spring-mvc-and-spring-boot-79ec4b351d12"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">使用Spring MVC和Spring Boot学习Java中RESTful Web服务的前5本书和课程</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">大家好，如果你对web开发感兴趣，那么你应该知道架构正在向微服务和…</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">medium.com</p></div></div><div class="nb l"><div class="np l nd ne nf nb ng jh ms"/></div></div></a></div></div></div>    
</body>
</html>