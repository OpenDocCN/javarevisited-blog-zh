<html>
<head>
<title>Concurrency Model And Distributed Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并发模型和分布式系统</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/concurrency-model-and-distributed-systems-a4c03d7e2c93?source=collection_archive---------2-----------------------#2021-02-07">https://medium.com/javarevisited/concurrency-model-and-distributed-systems-a4c03d7e2c93?source=collection_archive---------2-----------------------#2021-02-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2513bda695bf946809d5d3a34b3884e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVvqGVA7MtCiQRPeFpctSA.jpeg"/></div></div></figure><p id="608b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">并发模型:</strong>Java中的并发模型被定义为负责执行系统中线程之间的通信的模型，该系统负责执行系统中运行的大型或执行大型进程以及适当的同步，以防止部分读取或写入系统中运行的程序中的最终值。</p><p id="0e70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">分布式系统:</strong>分布式计算系统(Distributed system in computing)是指为了提高系统的效率，在不同的分布式计算机之间连接或共享软件组件的系统。</p><p id="0efd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Java中不同的并发模型:</strong></p><figure class="jp jq jr js fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2014/07/top-50-java-multithreading-interview-questions-answers.html"><div class="er es jo"><img src="../Images/5ef2d87fb14175ce61ce32cc56b98815.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/0*mE8Ds0Q3c6mENbOp"/></div></a><p class="jt ju et er es jv jw bd b be z dx translated">图1.1:并行工人模型</p></figure><p id="3eed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">并行工作者模型:</strong>并行工作者并发模型在java中被定义为这样一种模型，其中工作被分配给不同的工作者，同时彼此并行地工作，每个线程并行地执行不同的任务，这些任务可以是单个大任务的所有不同任务或子任务。这里，每个线程完成全部任务，它们可能运行在不同的CPU中。上面给出了描述并行工作者模型的图表，该模型的最大优点之一是，在该过程中，没有单个线程或工作者处于空闲状态，这很容易理解和实现，并且增加了系统的计算能力。系统中添加了更多的线程或工作者，图表如上所示。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/9f36d5057b3809a6ef769f23bf187135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gykr9w12UfXc8Ra2"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">图2.2:装配线模型</p></figure><p id="ac56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">装配线模型:</strong>这种模型之所以这样叫，是因为工作是在一条线上或一个接一个地执行的，每个工人都要完成一定量的工作，这种模型也被称为工人模型、并行工人模型、反应式系统，甚至是事件驱动系统。在这种方法中，工人的安排方式类似于工人在工厂中的安排方式。不是所有的工作都由一个工人完成，而是将工作分成小部分，由队列中的每个工人在一个方向上一行一行地执行。<strong class="is hj">装配线模型的工作被解释为当工作被指定完成时，而不是在I/O阶段期间，工人不等待C.P.U .完成其任务，而是一完成任务就将下一个任务分配给队列中的下一个工人，并且该过程继续进行，直到工作完成。</strong>在这里，每个工人都是独立的，与相邻的工人没有任何共享，因此流程是并发进行的，如上图所示。</p><p id="85e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">功能并行:</strong>并行定义为在系统中并行执行多个任务，功能并行定义为在系统中使用多个CPU并行运行或执行的多个功能，这是Java 8编程语言中的新概念。传递到函数中的值被复制，以防止程序共享数据上的竞争条件，因此所有进程在系统内相互依赖地进行。并行运行的每个不同进程在计算机内的不同处理器中执行，功能并行仅在有多个处理器或CPU的系统中可用</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="727f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">平行工人模型的优势:</strong>平行工人模型的优势描述如下:-</p><ul class=""><li id="8ab5" class="kf kg hi is b it iu ix iy jb kh jf ki jj kj jn kk kl km kn bi translated">很容易实现，也很容易理解。</li><li id="e2f9" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">如果工作量很大或更多，那么为了降低时间复杂度或减少执行时间，可以添加更多的工人来并行增加工作量。</li></ul></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="ae79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">平行工人模式的缺点:</strong>平行工人模式的缺点是:-</p><ul class=""><li id="a734" class="kf kg hi is b it iu ix iy jb kh jf ki jj kj jn kk kl km kn bi translated">由于<a class="ae kt" href="https://javarevisited.blogspot.com/2013/02/how-to-join-multiple-threads-in-java-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">多个线程</a>可以访问相同的存储数据，该机制应该以这样的顺序工作，以便多个字符串可以正确地读写存储空间中的数据，并且一个线程上所做的更改对其他线程是可见的，从而避免死锁、竞争条件和其他共享并发问题。</li><li id="861e" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">由于等待不同线程执行以完成进程的时间，等待执行的线程数量增加，并且可能发生只有有限数量的线程有机会被执行，由于这种情况，队列中即将被并行执行的线程的串行化增加，可以使用非阻塞并发算法来减少争用，但是它们难以实现。</li><li id="6b5f" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">在持久列表的情况下，原始内容的副本被保留，并且当线程试图修改列表中的数据时，修改成功发生，但是已经创建的数据副本保持不变，并且正在运行的所有其他线程可以从那里访问数据， 但是这种方法虽然看起来很完美，但是它也有一些缺点，即当在数据中有任何修改时，所有的改变都是在头节点中进行的，并且函数简单地返回对新创建的列表的引用，但是列表中的先前线程仍然保持对列表的先前第一个节点的引用，因此数据保持不变，并且不能看到新添加的元素。</li><li id="a2aa" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">这种方法的一个主要缺点是这种方法是不确定的，即不能保证系统中的进程会按顺序执行或者不会执行，假设如果进程1必须在进程2之后执行，那么进程2可能会在进程1之后执行，因此我们不能从系统中获得正确的输出。</li><li id="3f67" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">因为该过程是并发执行的，所以从存储器中读取数据应该并行进行，但是每次重新读取数据会花费大量时间，效率很低。</li></ul></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="4fb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">装配线模型的类型:</strong>主要有两种装配模型</p><figure class="jp jq jr js fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/06/top-5-java-multithreading-and-concurrency-courses-experienced-programmers.html"><div class="er es ku"><img src="../Images/159b7ee102cda37cdebe5e320dccb970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bLwJ2j47c6hbs-it"/></div></a><p class="jt ju et er es jv jw bd b be z dx translated">图3.3:多重装配模型</p></figure><p id="a61d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">多装配模型:</strong>这种模型属于并行工人模型，在这种模型中，要执行的任务被分成各种子任务，并分配给不同的工人，有时要执行的任务太大，以至于工作必须以并行的顺序在不同线程的许多工人中执行，如上图所示。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/2e45710ae988dd44db7d013a228d1174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*omgMAvyu1CGx_him"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">图4.4:中间装配线</p></figure><p id="3bff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">中间装配线:</strong>这种类型的模型主要描述不同线程的工人的工作交给同一个普通工人执行的装配线，如上图所示。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="eb44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">装配线模式的优势:</strong>装配线模式的优势如下:-</p><ul class=""><li id="0f0c" class="kf kg hi is b it iu ix iy jb kh jf ki jj kj jn kk kl km kn bi translated">这些工人彼此完全独立，他们完全不关心工人之间共享数据可能引起的不同并发问题。</li><li id="ee6f" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">由于装配线模型，系统有可能成功地调度作业，使得当作业被写入日志时，作业被顺利且完美地执行，然后在系统故障期间，存储在日志中的作业从工作已经停止的地方被执行，并从相同的地方恢复。</li><li id="2abb" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">因为线程不能修改工作者的工作，所以工作者可以是有状态的，并且可以使用存储器中的数据来进行计算和处理。</li></ul></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="899c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">与装配线模型相关的一些术语:</strong></p><p id="3e3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有各种与装配线模型相关的术语，下面将对其中一些进行描述</p><figure class="jp jq jr js fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/01/what-is-happens-before-in-java-concurrency.html"><div class="er es kv"><img src="../Images/22e9f154e1c05e094785c811a329ac41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/0*Hp1tG8XwpNEu_Lme"/></div></a><p class="jt ju et er es jv jw bd b be z dx translated">图5.5:装配线模型中的参与者</p></figure><ul class=""><li id="14a8" class="kf kg hi is b it iu ix iy jb kh jf ki jj kj jn kk kl km kn bi translated"><strong class="is hj">参与者:</strong>参与者负责与不同的组件或不同的其他参与者进行通信，以便处理一个或多个作业，如装配线并发模型的情况所示，该模型如上图所示。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/d120acbc622834d9cedf222a0eef8a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dJcmngMDClv2qd8o"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">图6.6装配线模型中的通道</p></figure><ul class=""><li id="aae7" class="kf kg hi is b it iu ix iy jb kh jf ki jj kj jn kk kl km kn bi translated"><strong class="is hj">通道:</strong>当不同的参与者与其他不同的参与者通信时，他们不能直接相互通信，有一种特殊的通信模式用于发布他们的消息，即通过通道，发送者通过通道发布他们的消息以与其他参与者通信，发送者不知道消息是通过这些通道发送的，他们只是知道他们必须通过哪个通道发送或发布他们的消息，通道如上图所示。</li></ul><p id="9d67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">不断学习，不断成长，不断探索！</strong></p><p id="5dad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">万事如意！</strong></p><p id="8210" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多有趣和信息丰富的文章和提示请关注我的<a class="ae kt" href="https://swapnilkant11.medium.com/" rel="noopener"> <strong class="is hj"> Medium </strong> </a> <strong class="is hj">和</strong><a class="ae kt" href="https://www.linkedin.com/in/swapnil-kant-279a3b148/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Linkedin</strong></a></p></div></div>    
</body>
</html>