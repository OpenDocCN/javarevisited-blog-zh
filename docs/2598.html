<html>
<head>
<title>String Class in Java : The Begining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的字符串类:开始</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/string-class-in-java-the-begining-c0bc35e42798?source=collection_archive---------4-----------------------#2022-12-14">https://medium.com/javarevisited/string-class-in-java-the-begining-c0bc35e42798?source=collection_archive---------4-----------------------#2022-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div></figure><p id="a8ab" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">今天我们要看一下<a class="ae jj" href="https://javarevisited.blogspot.com/2022/03/3-examples-to-parse-json-in-java-using.html" rel="noopener ugc nofollow" target="_blank"> String类</a>，它是java.lang包中的入门类之一。正是这个内置的类帮助程序员解决了许多与数据及其操作相关的问题。</p><p id="2e65" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">让我们从字符串类的签名开始。</p><pre class="jk jl jm jn fd jo jp jq bn jr js bi"><span id="afe9" class="jt ju hi jp b be jv jw l jx jy">public final class String<br/>extends Object<br/>implements Serializable, Comparable&lt;String&gt;, CharSequence</span></pre><p id="2355" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">有了上面的声明，我们可以说<a class="ae jj" href="https://javarevisited.blogspot.com/2010/10/why-string-is-immutable-or-final-in-java.html" rel="noopener ugc nofollow" target="_blank">字符串是最终的类</a>，它继承了一个对象类的属性并实现了<a class="ae jj" href="https://javarevisited.blogspot.com/2014/05/why-use-serialversionuid-inside-serializable-class-in-java.html" rel="noopener ugc nofollow" target="_blank"> <em class="jz">可序列化</em> </a>、<a class="ae jj" href="https://www.java67.com/2019/06/top-5-sorting-examples-of-comparator-and-comparable-in-java.html" rel="noopener ugc nofollow" target="_blank"> <em class="jz">可比</em> </a>和CharSequence接口。因为它是一个带有final关键字的类，所以我们不能为它定义子类。</p><p id="03b8" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><a class="ae jj" href="https://www.java67.com/2014/01/why-string-class-has-made-immutable-or-final-java.html" rel="noopener ugc nofollow" target="_blank">字符串对象本质上是不可变的</a>，这意味着一旦对象被创建，那么对象的内容或数据就不能被修改。如果我们试图修改一个对象的内容或数据，那么就会创建一个新的对象。我们可以用两种方法创建String类的对象:</p><h1 id="5450" class="ka ju hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">没有新操作员</h1><ol class=""><li id="e625" class="kx ky hi in b io kz is la iw lb ja lc je ld ji le lf lg lh bi translated"><a class="ae jj" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686"> JVM </a>为字符串引用变量分配内存，并验证字符串常量池中的字符串文字。<a class="ae jj" href="http://javarevisited.blogspot.sg/2016/07/difference-in-string-pool-between-java6-java7.html" rel="noopener ugc nofollow" target="_blank">字符串常量池</a>放在<a class="ae jj" href="https://javarevisited.blogspot.com/2011/05/java-heap-space-memory-size-jvm.html" rel="noopener ugc nofollow" target="_blank"> <em class="jz">堆内存</em> </a>中，在这里定义字符串的值。字符串的内部状态在整个程序中保持不变，字符串常量池有助于通过对象的不变性来实现这一点。</li><li id="880a" class="kx ky hi in b io li is lj iw lk ja ll je lm ji le lf lg lh bi translated">如果<a class="ae jj" href="https://www.java67.com/2014/08/difference-between-string-literal-and-new-String-object-Java.html" rel="noopener ugc nofollow" target="_blank">字符串文字</a>不在字符串常量池中，那么它在字符串常量池中创建一个新的字符串对象，新创建的字符串对象将被赋给<a class="ae jj" href="https://javarevisited.blogspot.com/2015/12/when-to-use-intern-method-of-string-in-java.html" rel="noopener ugc nofollow" target="_blank"> <em class="jz">字符串引用变量</em> </a>。</li><li id="a06a" class="kx ky hi in b io li is lj iw lk ja ll je lm ji le lf lg lh bi translated">如果JVM发现字符串文字可用，那么现有的字符串对象地址将被分配给字符串引用变量。</li></ol><figure class="jk jl jm jn fd ii er es paragraph-image"><a href="https://www.java67.com/2018/06/top-35-java-string-interview-questions.html"><div class="er es ln"><img src="../Images/3607107273c76c2931648408d451cd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpRVgpwfyaK1OyY1gvPeUg.png"/></div></a><p class="lq lr et er es ls lt bd b be z dx translated">创建不带新运算符的字符串</p></figure><figure class="jk jl jm jn fd ii er es paragraph-image"><a href="https://javarevisited.blogspot.com/2012/10/10-java-string-interview-question-answers-top.html"><div class="er es lu"><img src="../Images/411ef4c1875f142a9e8d331a63d1bc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aL_RezL6GdjTLY8FFhnkuw.png"/></div></a><p class="lq lr et er es ls lt bd b be z dx translated">幕后的字符串操作</p></figure><h1 id="854f" class="ka ju hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用新运算符</h1><ol class=""><li id="8095" class="kx ky hi in b io kz is la iw lb ja lc je ld ji le lf lg lh bi translated">这里，JVM也为字符串引用变量分配内存，并验证字符串常量池中的字符串文字。</li><li id="3af2" class="kx ky hi in b io li is lj iw lk ja ll je lm ji le lf lg lh bi translated">如果字符串常量池中不存在字符串文字，那么在这种情况下，它会在字符串常量池中创建新的字符串对象。</li><li id="038a" class="kx ky hi in b io li is lj iw lk ja ll je lm ji le lf lg lh bi translated">如果字符串常量池中存在字符串文字，则忽略它，在常量池外创建一个新的字符串对象，并将字符串常量池外新创建的字符串对象的地址分配给字符串引用变量。</li></ol><figure class="jk jl jm jn fd ii er es paragraph-image"><a href="https://javarevisited.blogspot.com/2013/02/how-to-convert-json-string-to-java-object-jackson-example-tutorial.html"><div class="er es ln"><img src="../Images/eca3fe89c6e9d49da21717d2df424fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUCKyFoylWRDcaufugJXBQ.png"/></div></a><p class="lq lr et er es ls lt bd b be z dx translated">带有新运算符的字符串对象</p></figure><figure class="jk jl jm jn fd ii er es paragraph-image"><a href="https://www.java67.com/2019/04/how-to-check-if-two-string-are-anagram.html"><div class="er es lv"><img src="../Images/6a00dca58af733c3606d2aed0daf7b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msyp_nnRqk3Fy0eSP6wYUQ.png"/></div></a></figure><h1 id="8976" class="ka ju hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">String类的intern()方法</h1><p id="5aaf" class="pw-post-body-paragraph il im hi in b io kz iq ir is la iu iv iw lw iy iz ja lx jc jd je ly jg jh ji hb bi translated"><a class="ae jj" href="https://javarevisited.blogspot.com/2015/12/when-to-use-intern-method-of-string-in-java.html" rel="noopener ugc nofollow" target="_blank"> intern()方法</a>的签名为“public native String intern()”，它从字符串常量池中返回字符串对象的引用。</p><p id="ced5" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">当调用intern()方法时，JVM使用string类的equals(object)方法检查池中是否已经包含一个等于string对象的字符串，然后返回string pool对象。否则，将这个字符串对象添加到池中，并返回对这个字符串对象的引用。</p><h1 id="57c3" class="ka ju hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">症结</strong></h1><ol class=""><li id="e699" class="kx ky hi in b io kz is la iw lb ja lc je ld ji le lf lg lh bi translated">当我们创建两个字符串对象而没有使用新的操作符并且具有相同的内容时，两个引用变量指向同一个对象。</li><li id="20c9" class="kx ky hi in b io li is lj iw lk ja ll je lm ji le lf lg lh bi translated">当您使用new运算符创建一个字符串对象时，每次都会在字符串常量池之外创建一个新对象，并将该地址赋给引用变量。</li></ol><p id="84f4" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">我希望你明白这个主题，如果你有任何困惑，请告诉我，以便我可以用一些更具互动性的例子来更深入地解释它。更多类似的话题，请关注，如果你喜欢这些内容，请鼓掌。敬请期待！</p><figure class="jk jl jm jn fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/4004c2a6b1551a66f1abd676901da384.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*9jCsG81nxrMTn9cx_cCngw.gif"/></div></figure></div></div>    
</body>
</html>