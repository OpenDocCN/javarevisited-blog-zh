<html>
<head>
<title>[Java] Concurrent Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Java]并发编程</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-concurrent-programming-9c7661466fdf?source=collection_archive---------4-----------------------#2021-07-11">https://medium.com/javarevisited/java-concurrent-programming-9c7661466fdf?source=collection_archive---------4-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/23a34dba21c94a03886a8626548aec1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hc4eN0lzm738gTl2"/></div></div></figure><blockquote class="iq ir is"><p id="1088" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用户理所当然地认为他们的系统可以同时做多件事情。他们认为自己可以继续在文字处理器中工作，而其他应用程序可以下载文件、管理打印队列和传输音频。…能做这些事情的软件被称为<em class="hi">并发软件</em></p><p id="6b3b" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">—<a class="ae js" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/" rel="noopener ugc nofollow" target="_blank">Java教程</a></p></blockquote><h1 id="e6bb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是并发软件？</h1><p id="53ab" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je kt ku jh ji kv kw jl jm kx ky jp jq jr hb bi translated">关于并发编程，我找不到比Java教程中写的更好的定义了。它被称为“<a class="ae js" href="https://www.toptal.com/software/introduction-to-concurrent-programming" rel="noopener ugc nofollow" target="_blank">多个操作序列在重叠的时间段内运行</a>”。Java用<code class="du kz la lb lc b">Thread</code>类支持并发。</p><h1 id="09d0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是线程？</h1><p id="e223" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je kt ku jh ji kv kw jl jm kx ky jp jq jr hb bi translated"><strong class="iw hj">线程是程序中执行的线程。</strong>JVM允许应用程序同时运行多个执行线程。为了深入理解Java提供的多线程环境，您需要知道线程之间是如何交互的。</p><p id="22b4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kt jg jh ji kv jk jl jm kx jo jp jq jr hb bi translated">每个线程都有一个优先级。优先级较高的线程优先于优先级较低的线程执行。每个线程可能会也可能不会被标记为<strong class="iw hj">守护进程。</strong></p><p id="33b7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kt jg jh ji kv jk jl jm kx jo jp jq jr hb bi translated"><a class="ae js" href="http://www.java67.com/2016/06/difference-between-daemon-vs-user-thread-in-java.html" rel="noopener ugc nofollow" target="_blank">守护线程</a>是一个低优先级线程，在后台运行，执行垃圾收集等任务。当在某个线程中运行的代码创建一个新的<a class="ae js" href="https://javarevisited.blogspot.com/2020/04/how-to-use-exchanger-in-java-with-example.html#axzz6dqIph09n" rel="noopener ugc nofollow" target="_blank">线程对象</a>时，该新线程的优先级最初被设置为等于创建线程的优先级，并且当且仅当创建线程是守护线程时，该新线程才是<a class="ae js" href="https://javarevisited.blogspot.com/2012/03/what-is-daemon-thread-in-java-and.html" rel="noopener ugc nofollow" target="_blank">守护线程。</a></p><h1 id="91e6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">线程是如何创建的？</h1><p id="78ce" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je kt ku jh ji kv kw jl jm kx ky jp jq jr hb bi translated">创建Thread实例的应用程序必须提供将在该线程中运行的代码。有两种方法可以做到这一点:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="c884" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kt jg jh ji kv jk jl jm kx jo jp jq jr hb bi translated">一种方法是创建一个扩展<code class="du kz la lb lc b">Thread</code>的子类，并覆盖它的<code class="du kz la lb lc b">run</code>方法。或者，你可以直接提供一个<a class="ae js" href="https://javarevisited.blogspot.com/2016/08/useful-difference-between-callable-and-Runnable-in-Java.html#axzz6e8hmwujv" rel="noopener ugc nofollow" target="_blank">可运行的</a>对象作为参数。<code class="du kz la lb lc b">Runnable</code>接口定义了一个方法<code class="du kz la lb lc b"><a class="ae js" href="https://javarevisited.blogspot.com/2012/03/difference-between-start-and-run-method.html#axzz6vPUwyVzv" rel="noopener ugc nofollow" target="_blank">run</a></code> <a class="ae js" href="https://javarevisited.blogspot.com/2012/03/difference-between-start-and-run-method.html#axzz6vPUwyVzv" rel="noopener ugc nofollow" target="_blank"> </a>，其中包含了执行代码。</p><p id="36b0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kt jg jh ji kv jk jl jm kx jo jp jq jr hb bi translated"><code class="du kz la lb lc b">Runnable</code>对象被传递给<code class="du kz la lb lc b">Thread</code>构造函数，如示例所示。哪个更好看？根据<a class="ae js" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html" rel="noopener ugc nofollow" target="_blank"> ORACLE </a>文档，使用Runnable对象更加通用，因为您可以扩展除Thread之外的类。</p><h1 id="ed25" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">线程的操作</h1><h2 id="6536" class="lj ju hi bd jv lk ll lm jz ln lo lp kd kt lq lr kh kv ls lt kl kx lu lv kp lw bi translated">休眠时暂停执行</h2><p id="4e17" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je kt ku jh ji kv kw jl jm kx ky jp jq jr hb bi translated"><code class="du kz la lb lc b">Thread.sleep()</code>使当前线程暂停执行一段时间。当正在运行的方法被中断请求终止时，线程抛出<code class="du kz la lb lc b">InterruptedException</code>，这通常发生在一个线程中断另一个活动线程时。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><h2 id="6f95" class="lj ju hi bd jv lk ll lm jz ln lo lp kd kt lq lr kh kv ls lt kl kx lu lv kp lw bi translated">用中断中断执行</h2><p id="a33b" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je kt ku jh ji kv kw jl jm kx ky jp jq jr hb bi translated"><code class="du kz la lb lc b">Thread.interrupt()</code>与<code class="du kz la lb lc b">Thread.sleep</code>不同，导致当前线程<a class="ae js" href="https://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html" rel="noopener ugc nofollow" target="_blank">停止执行</a>并做其他事情。线程通过调用线程对象上的中断来发送中断，以使线程被中断。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><h2 id="305d" class="lj ju hi bd jv lk ll lm jz ln lo lp kd kt lq lr kh kv ls lt kl kx lu lv kp lw bi translated">等待另一个线程加入</h2><p id="59e1" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je kt ku jh ji kv kw jl jm kx ky jp jq jr hb bi translated"><code class="du kz la lb lc b"><a class="ae js" href="https://javarevisited.blogspot.com/2013/02/how-to-join-multiple-threads-in-java-example-tutorial.html#axzz6pTHjcWBu" rel="noopener ugc nofollow" target="_blank">join</a></code>方法允许一个线程等待另一个线程完成它的操作。如果newThread是当前正在工作的线程，<code class="du kz la lb lc b">newThread.join</code>使执行加入主线程。然后，主线程暂停其操作，直到新线程终止。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="2bce" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结果</h1><p id="9ab5" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je kt ku jh ji kv kw jl jm kx ky jp jq jr hb bi translated">这个<code class="du kz la lb lc b">Thread</code>对象是用<a class="ae js" href="https://javarevisited.blogspot.com/2016/06/5-books-to-learn-concurrent-programming-multithreading-java.html" rel="noopener ugc nofollow" target="_blank"> Java </a>设计的，目的是让开发人员根据需要处理任意多的操作。因此，由它们来决定创建多少线程，响应中断，并在指定的时间内交互工作。</p><p id="a891" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kt jg jh ji kv jk jl jm kx jo jp jq jr hb bi translated">然而，随着线程数量的增加，相应地管理它们变得棘手，这需要另一个对象将它们集成在一起。在<a class="ae js" rel="noopener" href="/ryanjang-devnotes/java-managing-concurrency-467993a01e6f">的下一篇文章</a>中，我们将讨论对象。</p><p id="5a12" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je kt jg jh ji kv jk jl jm kx jo jp jq jr hb bi translated">感谢你阅读这篇文章。</p><h1 id="8dbb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考</h1><div class="lx ly ez fb lz ma"><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">定义和启动线程</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">创建Thread实例的应用程序必须提供将在该线程中运行的代码。有两个…</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">docs.oracle.com</p></div></div></div></a></div><div class="lx ly ez fb lz ma"><a href="https://javarevisited.blogspot.com/2012/03/what-is-daemon-thread-in-java-and.html" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">什么是Java中的守护线程以及与非守护线程的区别——教程示例</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">Java中的守护线程是那些在后台运行的线程，主要由JVM创建，用于执行…</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">javarevisited.blogspot.com</p></div></div></div></a></div><div class="lx ly ez fb lz ma"><a href="https://www.toptal.com/software/introduction-to-concurrent-programming" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">并发编程介绍:初学者指南</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">并发性允许程序同时处理大量的任务。但是编写并发程序并不是一件特别…</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">www.toptal.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo io ma"/></div></div></a></div></div></div>    
</body>
</html>