<html>
<head>
<title>What is Recursion and How does it Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是递归，它是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/what-is-recursion-and-how-does-it-work-ea20f1b4e697?source=collection_archive---------2-----------------------#2022-02-16">https://medium.com/javarevisited/what-is-recursion-and-how-does-it-work-ea20f1b4e697?source=collection_archive---------2-----------------------#2022-02-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9635" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你们在看任何一种编程语言的代码时，有没有注意到一个被定义的函数在它自己的定义中被应用？也许你只是忽略了这一点，啊！只是函数调用，那是什么我必须做的？</p><p id="c863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，这是编程中最重要的概念之一，基本上当你谈到<a class="ae jd" rel="noopener" href="/javarevisited/5-best-mathematics-and-statistics-courses-for-data-science-and-machine-learning-programmers-bf4c4f34e288">数学</a>和<a class="ae jd" rel="noopener" href="/javarevisited/8-best-computer-science-courses-for-beginners-to-learn-online-696379aa4e96">计算机科学</a>的时候，其中一个函数直接或间接调用它自己，或者一个被定义的函数在它自己的定义内被应用。</p><p id="1971" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们中的大多数人已经编写了涉及编写<strong class="ih hj">递归</strong> <strong class="ih hj">函数</strong>的代码，但是在编写定义良好的<strong class="ih hj">递归函数</strong>之前，我们需要记住以下两个非常重要的<strong class="ih hj">条件，它们是:</strong></p><ol class=""><li id="f89e" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">对于我们的函数，<strong class="ih hj">递归函数</strong>的<strong class="ih hj">基础用例</strong>显然定义了无限数量的函数调用，因此为了在某个步骤结束函数调用，您将需要一个<strong class="ih hj">基础用例</strong>来完成同样的任务！</li><li id="acce" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">递归步骤</strong>现在，要到达基本情况，您需要一个<strong class="ih hj">递归步骤</strong>，它将最终导致<strong class="ih hj">基本情况</strong>并终止流程。</li></ol><figure class="jt ju jv jw fd jx er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/11/top-5-courses-to-learn-recursion-for.html"><div class="er es js"><img src="../Images/85770bb235c1c66ab7cf3f4fe328324d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*VhKFV2tae8DYilKU8kMzFA.gif"/></div></a></figure><p id="ff28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能听说过<strong class="ih hj">斐波那契数列，</strong>这是<strong class="ih hj">递归</strong>的最好例子之一</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="ff66" class="kf kg hi kb b fi kh ki l kj kk">Fib(0) = 0 as base case 1<br/>Fib(1) = 1 as base case 2<br/>For all integers <em class="kl">n</em> &gt; 1, Fib(<em class="kl">n</em>) = Fib(<em class="kl">n</em> − 1) + Fib(<em class="kl">n</em> − 2)</span></pre><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es km"><img src="../Images/d564e64dcc41292aa571780e5f845950.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*WlaNpRuLDddq6dy_CHUq3g.gif"/></div></figure><p id="cdd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们来看看并了解一下<a class="ae jd" href="https://javarevisited.blogspot.com/2012/12/recursion-in-java-with-example-programming.html" rel="noopener ugc nofollow" target="_blank">递归如何工作</a>，尽管研究<strong class="ih hj">递归函数</strong>并写下解决各种算法问题的代码<a class="ae jd" rel="noopener" href="/javarevisited/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0"><strong class="ih hj"/></a><strong class="ih hj"/>很容易，但你有没有尝试去理解它，看看它在屏幕后面实际上是如何工作的，以及你如何做出必要的改变来操纵你的函数来执行一些不仅仅是刚刚提到的事情？好吧，如果不是，那么不要担心！我将通过一个二叉树的<strong class="ih hj">前序遍历的例子使你的工作变得容易，并帮助你理解它实际上是如何工作的！</strong></p><p id="7dad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在跳转到我们的代码和理解更多关于<strong class="ih hj">递归之前，</strong>让我们来看看一个新术语，即<strong class="ih hj">递归堆栈或调用堆栈</strong></p><h2 id="eb04" class="kf kg hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">定义:</h2><p id="4374" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated"><strong class="ih hj">调用栈</strong>与我们在解决各种<strong class="ih hj">算法问题时可能用到的东西非常相似，</strong>即<a class="ae jd" href="https://javarevisited.blogspot.com/2022/02/-stack-and-queue-data-structure-interview-questions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">栈</strong> </a> <strong class="ih hj">，</strong>我们都知道，它使用<strong class="ih hj"> LIFO规则</strong>来执行函数，这代表<strong class="ih hj">后进先出，</strong>你可以一个接一个地添加东西，并从中取出最近添加的项目！在移动到<a class="ae jd" href="https://javarevisited.blogspot.com/2016/07/binary-tree-preorder-traversal-in-java-using-recursion-iteration-example.html#axzz6dXsEfLvJ" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">前先序遍历</strong></a><strong class="ih hj"/>让我们知道，什么是前序遍历？</p><h2 id="434a" class="kf kg hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated"><strong class="ak">定义:</strong></h2><p id="01a2" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated"><strong class="ih hj">前序</strong> <strong class="ih hj">遍历</strong>是一种在<strong class="ih hj">二叉树</strong>中遍历的方式，我们从<strong class="ih hj">根节点</strong>开始，遍历每个<strong class="ih hj">级</strong>的<strong class="ih hj">父节点</strong>的<strong class="ih hj">左子节点</strong>，然后到达其<strong class="ih hj">右子节点。</strong></p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="0ace" class="kf kg hi kb b fi kh ki l kj kk">Algorithm:<br/>1. Visit the root.<br/>   2. Traverse the left subtree, i.e., call Preorder(left-subtree)<br/>   3. Traverse the right subtree, i.e., call Preorder(right-subtree)</span></pre><h2 id="325b" class="kf kg hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">前序遍历代码</h2><p id="5af1" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">现在，让我们看一下代码:</p><pre class="jt ju jv jw fd ka kb kc kd aw ke bi"><span id="c1c4" class="kf kg hi kb b fi kh ki l kj kk"><strong class="kb hj">void</strong> <!-- -->preorderTraversal(<strong class="kb hj">struct</strong> n<!-- -->ode* node){</span><span id="6be2" class="kf kg hi kb b fi ll ki l kj kk"><strong class="kb hj">if</strong> <!-- -->(node == NULL)<br/>   <strong class="kb hj">return</strong>;</span><span id="7fb2" class="kf kg hi kb b fi ll ki l kj kk">/* first print data of node */<br/>cout &lt;&lt; node-&gt;val &lt;&lt; " ";</span><span id="2bfe" class="kf kg hi kb b fi ll ki l kj kk">/* recursion performed on left subtree */<br/>preorderTraversal(node-&gt;left);</span><span id="24ea" class="kf kg hi kb b fi ll ki l kj kk">/* now perform recursion on right subtree */<br/>preorderTraversal(node-&gt;right);</span><span id="6853" class="kf kg hi kb b fi ll ki l kj kk">}</span></pre><p id="1cf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看二叉树的<strong class="ih hj">前序遍历</strong>并理解<strong class="ih hj">递归</strong>是如何工作的！</p><figure class="jt ju jv jw fd jx er es paragraph-image"><a href="https://www.java67.com/2022/01/how-to-find-maximum-sum-level-in-given-binary-tree-java.html"><div class="er es lm"><img src="../Images/ed5488c0e622d7aa616168ddfde8fc0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CC2epfGPVnDHtKiaOr53GQ.jpeg"/></div></a><p class="ln lo et er es lp lq bd b be z dx translated">图0.0:一棵二叉树</p></figure><p id="0f4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经给出了如上图所示的<a class="ae jd" href="https://javarevisited.blogspot.com/2015/10/how-to-implement-binary-search-tree-in-java-example.html#axzz7DyRjLUX9" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">二叉树</strong> </a> <strong class="ih hj"> </strong>！</p><figure class="jt ju jv jw fd jx er es paragraph-image"><a href="https://javarevisited.blogspot.com/2016/12/how-to-count-number-of-leaf-nodes-in-java-recursive-iterative-algorithm.html"><div class="er es lm"><img src="../Images/34aeeec1d17ae9e85ae6a438d7cb00ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*865_FXy0BHNYicvxmWSZBA.jpeg"/></div></a><p class="ln lo et er es lp lq bd b be z dx translated">图1.1</p></figure><p id="bdfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在<strong class="ih hj">的第一步中，</strong>我们在左侧有一个<strong class="ih hj">二叉树</strong>，在右侧有一个<strong class="ih hj">调用栈</strong>，现在指针指向<strong class="ih hj">根节点</strong>，如图所示，我们移动到<strong class="ih hj">根节点的</strong>左子节点，并将<strong class="ih hj">根节点</strong>推送到我们的<strong class="ih hj">调用栈</strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lm"><img src="../Images/405358c8b825287eb9a73840126d9d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6nVgU40rBOGrr4aloA-KQ.jpeg"/></div></div><p class="ln lo et er es lp lq bd b be z dx translated">图2.2</p></figure><p id="18d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">第二步中，</strong>我们将<strong class="ih hj">当前节点</strong>推入<strong class="ih hj">调用栈</strong>并移动到其<strong class="ih hj">左侧子节点</strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><a href="https://dev.to/javinpaul/21-binary-tree-interview-questions-for-programmers-42bh"><div class="er es lm"><img src="../Images/ca3306a5133c646b2a5efb5c38075cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lwid_Eti0uVvpjgbzgcIw.jpeg"/></div></a><p class="ln lo et er es lp lq bd b be z dx translated">图3.3</p></figure><p id="2b00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">第三步中，</strong>我们将<strong class="ih hj">当前</strong>最后<strong class="ih hj">左节点</strong>推到堆栈中，并移动到其<strong class="ih hj">左子节点</strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><a href="https://www.java67.com/2016/07/binary-tree-preorder-traversal-in-java-without-recursion.html"><div class="er es lm"><img src="../Images/18064415b47c499dd4db2ca31981bf54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*af4Jd7VjfcyNMO3bKQMw9A.jpeg"/></div></a><p class="ln lo et er es lp lq bd b be z dx translated">图4.4</p></figure><p id="6d07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">的第四步中，</strong>我们可以观察到既没有20的<strong class="ih hj">左孩子</strong>也没有<strong class="ih hj">右孩子</strong>，所以我们将弹出当前节点并且<strong class="ih hj">递归地</strong>移动到代码行<strong class="ih hj">preorder traversal(node-&gt;right)</strong>，其中节点10的<strong class="ih hj">右孩子</strong>被推送到我们的<strong class="ih hj">调用堆栈，</strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><a href="https://www.java67.com/2016/07/how-to-implement-preorder-traversal-of-binary-tree-in-java.html"><div class="er es lm"><img src="../Images/87dd50c39e41c3f0b3efb0d07f278bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHV_NVC4SYCE22U1bv1asw.jpeg"/></div></a><p class="ln lo et er es lp lq bd b be z dx translated">图5.5</p></figure><p id="9162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一个<strong class="ih hj"> pre final步骤中，</strong>由于我们没有25的<strong class="ih hj">左</strong>或<strong class="ih hj">右<strong class="ih hj">子节点</strong>，我们将弹出当前节点，并将<strong class="ih hj">递归地</strong>移回<strong class="ih hj">根节点的右子节点</strong> 15，并将其推入<strong class="ih hj">调用栈，</strong>和<strong class="ih hj">弹出</strong>根节点<strong class="ih hj">5】</strong></strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><a href="https://www.java67.com/2021/07/recursion-programming-exercises-in-java.html"><div class="er es lm"><img src="../Images/67166a1a7e98a78637bfce45373a0fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9UB3TspTY6w5sdt2OhPWA.jpeg"/></div></a><p class="ln lo et er es lp lq bd b be z dx translated">图6.6</p></figure><p id="724c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">最后一步</strong>中，我们再次看到，没有节点15的<strong class="ih hj">左</strong>和<strong class="ih hj">右</strong>子节点，所以我们<strong class="ih hj">弹出当前节点</strong>并得到如上图所示的输出，这是我们的最终输出。</p><p id="e057" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，你可以很容易地理解<strong class="ih hj">递归</strong>是如何工作的，还有更多<strong class="ih hj">递归的例子，</strong>我试图用一种简单的方式来解释它，通过一个许多学生在编写<a class="ae jd" href="https://www.java67.com/2020/02/top-40-binary-tree-interview-questions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">二叉树</strong> </a> <strong class="ih hj">代码时面临的复杂问题。</strong></p><p id="d560" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续学习，继续成长，继续探索！</p><p id="b9af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">祝一切顺利！</p><p id="1f2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更多有趣和信息丰富的文章和提示请关注我的<a class="ae jd" href="https://swapnilkant11.medium.com/" rel="noopener"> <strong class="ih hj"> Medium </strong> </a> <strong class="ih hj">和</strong><a class="ae jd" href="https://www.linkedin.com/in/swapnil-kant-279a3b148/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">Linkedin</strong></a></p><div class="lv lw ez fb lx ly"><a href="https://javarevisited.blogspot.com/2021/09/top-10-recursion-interview-questions.html?m=0" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">编码面试的前25个递归面试问题</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">程序员经常害怕递归，因为许多程序员很难想象和理解它，但是…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm jy ly"/></div></div></a></div></div></div>    
</body>
</html>