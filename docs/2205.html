<html>
<head>
<title>E2E-Testing in CI Environment With Testcontainers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">e2e-在CI环境中使用Testcontainers进行测试</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/e2e-testing-in-ci-environment-with-testcontainers-ea7537697bd9?source=collection_archive---------2-----------------------#2022-06-23">https://medium.com/javarevisited/e2e-testing-in-ci-environment-with-testcontainers-ea7537697bd9?source=collection_archive---------2-----------------------#2022-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8668" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我写过很多关于<a class="ae jd" href="https://dev.to/kirekov/apache-spark-hive-and-spring-boot-testing-guide-mdp" rel="noopener ugc nofollow" target="_blank">单元</a> <a class="ae jd" href="https://dev.to/kirekov/spring-boot-testing-testcontainers-and-flyway-2jpd" rel="noopener ugc nofollow" target="_blank">和</a> <a class="ae jd" href="https://dev.to/kirekov/spring-boot-testing-data-and-services-288f" rel="noopener ugc nofollow" target="_blank">集成</a> <a class="ae jd" href="https://dev.to/kirekov/spring-boot-jpa-clear-tests-45he" rel="noopener ugc nofollow" target="_blank">测试</a>的博文。但是今天我想告诉你一些超越它的事情。这是E2E测试。尽管清楚地测试每个服务的行为很重要。但是在整个运行的系统上验证业务场景的有效性也是至关重要的。在这篇文章中，我将告诉你什么是E2E测试，为什么它如此重要，以及你如何在你的发布管道中实现它。您将学习如何在将变更合并到<code class="du je jf jg jh b">master</code>分支之前，对每个新的拉请求运行E2E测试。</p><p id="afde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码示例是用Java编写的，但是所提出的解决方案适用于任何编程语言。你可以在<a class="ae jd" href="https://github.com/SimonHarmonicMinor/e2e-tests-example" rel="noopener ugc nofollow" target="_blank">这个链接</a>找到整个项目的源代码。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/11/why-devops-engineer-learn-docker-kubernetes.html#axzz6dXsEfLvJ"><div class="er es ji"><img src="../Images/c417f058c8d89e085fb406f66b19ac3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*wRfwnl3901h0PurW.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">文章模因封面</p></figure><h1 id="ea5c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">领域</h1><p id="b2e2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们将开发一个系统来获取即将到来的信息和额外的数据。看看下面的模式。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/03/5-courses-programmers-can-join-to-learn.html#axzz6U9Y03ecl"><div class="er es kx"><img src="../Images/86224e486004153462e13d57eeb2665d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cyrtwCzkTJuJOBcF.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">领域设计</p></figure><p id="9e21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">消息处理算法很简单:</p><ol class=""><li id="6cde" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">用户通过<a class="ae jd" rel="noopener" href="/javarevisited/10-best-java-web-services-rest-soap-and-api-courses-for-beginners-724a8f51298d"> REST API </a>发送消息。</li><li id="2459" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du je jf jg jh b">API-Service</code>转移到RabbitMQ。</li><li id="3732" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du je jf jg jh b">Gain-Service</code>在<a class="ae jd" href="https://javarevisited.blogspot.com/2022/02/top-5-courses-to-learn-redis.html" rel="noopener ugc nofollow" target="_blank"> Redis </a>中更新数据，如果消息包含有价值的东西。然后将附加数据添加到消息本身中，然后再次将其传输到RabbitMQ。</li></ol><h1 id="f995" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">测试</h1><h1 id="e913" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">单元测试</h1><p id="c5d1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们如何验证系统的行为？有几种选择。最简单的是单元测试。看看下面的图表。我用淡绿色和蓝色的椭圆形指出了测试区域。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/03/how-to-prepare-for-system-design.html"><div class="er es kx"><img src="../Images/7dc603c81fdc6bbbe6a42fa0a77dd8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2PdftVZHfhyt9vNJ.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">单元测试区域</p></figure><p id="baa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单元测试有几个优点:</p><ol class=""><li id="fec2" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">他们跑得很快。</li><li id="020b" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">轻松集成到<a class="ae jd" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jenkins-and-ci-cd-for-devops-engineers-and-software-developers-df2de8fe38f3"> CI/CD管道</a>。</li><li id="458b" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">可以并行运行(如果写的合适的话)。</li></ol><p id="e24b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管他们也有一个问题。单元测试不检查与真实外部服务的交互(例如Redis、RabbitMQ)。它是关于验证业务逻辑，而不是实际的生产场景。</p><blockquote class="lm ln lo"><p id="941d" class="if ig lp ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated"><em class="hi">我写了一篇关于单元测试模式和最佳实践的</em><a class="ae jd" href="https://semaphoreci.com/blog/unit-testing" rel="noopener ugc nofollow" target="_blank"><em class="hi">longread</em></a><em class="hi">。去看看吧，真的很牛逼。</em></p></blockquote><h1 id="5031" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">集成测试</h1><p id="ab87" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们需要扩展视角。因此，集成测试可以派上用场，对不对？请看下图。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/04/top-5-tools-to-test-rest-apis-in-java.html#axzz7CGBoUS1n"><div class="er es kx"><img src="../Images/23c7447ddda79cd474bb7b6eb688307b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FNjRH2VvPbeuuO2q.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">集成测试区域</p></figure><p id="7043" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们检查与外部服务的交互。尽管还有一个问题。商业运作涉及几个沟通的组成部分。即使每个模块都经过了适当的测试，我们如何验证多服务请求(即业务场景)的正确性呢？例如，如果<code class="du je jf jg jh b">API-service</code>对输出消息的格式进行了重大更改，那么<code class="du je jf jg jh b">gain-service</code>将不能成功地继续进行浓缩。尽管<code class="du je jf jg jh b">API-service</code>集成和<a class="ae jd" href="https://javarevisited.blogspot.com/2018/01/10-unit-testing-and-integration-tools-for-java-programmers.html#axzz6j8KhisSX" rel="noopener ugc nofollow" target="_blank">单元测试</a>会通过。</p><p id="dda6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了克服这个问题，我们需要集成测试之外的东西。</p><blockquote class="lm ln lo"><p id="652c" class="if ig lp ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated"><em class="hi">我写了一篇</em> <a class="ae jd" href="https://semaphoreci.com/blog/integration-tests" rel="noopener ugc nofollow" target="_blank"> <em class="hi">的文章</em> </a> <em class="hi">深入讲解了集成测试。你应该去看看。</em></p></blockquote><h1 id="dc5d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">E2E测试</h1><p id="b395" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">E2E测试的想法很简单。我们将整个系统视为一个黑盒，它接受一些数据并返回计算结果(同步或异步)。看看下面的模式。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/02/-spring-boot-testing-interview-questions-answers-java.html"><div class="er es kx"><img src="../Images/839b1fc3f69f552ad60d215bdda7e077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*inj8PQVP6cJEX_GE.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">E2E测试区</p></figure><p id="4e85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，听起来合理可信。但是怎么才能实现呢？我们从哪里开始？让我们开始一步步解构这个问题。</p><h1 id="7fe0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">发布策略</h1><p id="f6e0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">首先，让我们弄清楚单个服务的发布管道。这将有助于我们理解整个E2E测试方法。看看下面的模式。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://www.java67.com/2012/08/10-java-coding-interview-questions-and.html"><div class="er es kx"><img src="../Images/2c98be219e9e016f10f7238281cbed36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5Qv519tsrVsJgqCa.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">通用发布策略</p></figure><p id="6210" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一步一步的流程:</p><ol class=""><li id="b011" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">开发人员将变更推送到<code class="du je jf jg jh b">feature/task</code>分支。</li><li id="393e" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">然后从<code class="du je jf jg jh b">feature/task</code>向<code class="du je jf jg jh b">master</code>分支发出拉取请求。</li><li id="8b64" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">在CI管道中，构建拉请求(即单元测试和集成测试的执行)。</li><li id="94cc" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">如果管道是绿色的，变更将被合并到<code class="du je jf jg jh b">master</code>分支。</li><li id="e691" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">当拉请求被合并时，产生的工件被发布到Docker Hub。</li><li id="0054" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">当发布被触发时(例如在预定的基础上)，<code class="du je jf jg jh b">deploy</code>阶段提取所需的Docker映像(默认为最新的)并在指定的环境中运行它。</li></ol><p id="93f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，我们如何将E2E测试放在规定的过程中呢？其实有几种方法。</p><h1 id="3b0a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">同步发布策略</h1><p id="2f51" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是最容易理解的方法。无论我们有多少个服务，发布管道都将它们部署在一个单独的作业中。在这种情况下，我们只需要在将工件部署到生产之前运行E2E测试。看看下面描述这个过程的模式。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://www.java67.com/2021/04/top-5-courses-to-learn-docker-for-java.html"><div class="er es kx"><img src="../Images/043ac050093fc1dd6008fa4aad300aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P9sRz1jQYD8ZTeiR.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">同步发布策略</p></figure><p id="ef53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">算法是:</p><ol class=""><li id="b4de" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">触发释放</li><li id="fc21" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">从Docker Hub中提取所有服务的图像(默认为最新)。</li><li id="cef2" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">用提取的图像运行E2E测试(我将在本文后面向您解释这种方法)。</li><li id="169d" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">如果测试成功，部署提取的映像。</li></ol><p id="b149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管这种方法很简单，但它有一个很大的障碍。不能更新单个<a class="ae jd" rel="noopener" href="/javarevisited/10-best-java-microservices-courses-with-spring-boot-and-spring-cloud-6d04556bdfed">微服务</a> <br/>隔离。这意味着不同的模块必须同时发布。尽管在现实中，一些<a class="ae jd" rel="noopener" href="/javarevisited/7-free-microservices-courses-for-java-programmers-c9b2f3a2ea7d">微服务</a>必须比其他的更频繁地更新。但是这里您必须选择一个满足(至少部分满足)每个服务需求的发布触发器。</p><h1 id="807c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">异步释放策略</h1><p id="19e3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这意味着像更新独立的功能一样更新每个服务。每个模块都可以根据自己的规则进行部署。</p><p id="ae54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个异步发布策略的例子。看看下面的模式。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://www.java67.com/2021/02/microservices-interview-questions-answers-java-spring.html"><div class="er es kx"><img src="../Images/9b825553c8971ed52569515f923c11f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WG6Flx4Cuf9YuPJq.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">异步释放策略</p></figure><p id="7ba5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，该图类似于我们之前看到的单一模块发布管道。虽然有细微的差别。现在有了<code class="du je jf jg jh b">E2E-tests</code>阶段，它既在拉式请求构建期间运行，也在部署到生产之前运行。<br/>如果它们已经在拉请求管道上完成，为什么我们还需要再次运行<code class="du je jf jg jh b">E2E-tests</code>？看看下图就明白问题了。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://www.java67.com/2018/02/5-free-docker-courses-for-java-and-DevOps-engineers.html"><div class="er es kx"><img src="../Images/4b6d8a54b4170d9f4530a8dd7175c593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pnAx9m6lV8MpRRaK.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">同时释放问题</p></figure><p id="63a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在PR合并后立即部署了<code class="du je jf jg jh b">API-Service</code>。但是我们将<code class="du je jf jg jh b">Gain-Service</code>的发布推迟了一天。因此，如果E2E测试只在拉请求构建期间运行，那么其他一些服务可能已经被更新了。但是我们只验证了以前版本的正确性，因为在拉式请求构建期间，最新的版本还没有被提升。</p><p id="d2da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您坚持异步发布策略，您必须在部署到生产之前以及在拉请求构建期间运行E2E测试。</p><blockquote class="lm ln lo"><p id="723c" class="if ig lp ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated"><em class="hi">在本文中，我们将异步发布策略视为</em> <a class="ae jd" rel="noopener" href="/javarevisited/top-5-frameworks-java-developers-can-learn-for-microservices-development-in-2022-848da66d6651"> <em class="hi">微服务</em> </a> <em class="hi">的首选。</em></p></blockquote><h1 id="fcc7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">建立流程</h1><p id="d20e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">嗯，这听起来很有希望。但是我们如何建立这个场景呢？我可以说这并没有看起来那么复杂。看看下面为<code class="du je jf jg jh b">API-Service</code>运行E2E测试的例子。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-spring-microservices-courses-with-spring-boot-and-spring-cloud.html"><div class="er es kx"><img src="../Images/10fa117c1eb0f79df6c469d35e4cfed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uy2ktqV6J3qJV6y8.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">建立流程</p></figure><p id="8806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两部分。在拉式请求构建期间以及将产品部署到生产之前运行E2E测试。让我们一步一步地浏览每个场景。</p><h1 id="bd45" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">拉式请求构建</h1><ol class=""><li id="9de9" class="ky kz hi ih b ii ks im kt iq lt iu lu iy lv jc ld le lf lg bi translated">首先，运行单元测试和集成测试。这两个步骤通常与建筑制品本身相结合。</li><li id="7802" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">那么当前版本的<code class="du je jf jg jh b">API-Service</code>将被构建并作为Docker映像保存在本地。我们没有把它推到中心，因为提议的更改可能不正确(我们还没有运行E2E测试来检查它)。尽管有些CI提供者不允许在本地构建Docker映像以便以后重用。在这种情况下，您可以指定一个不会在生产中使用的标签。例如，<code class="du je jf jg jh b">dev-CI_BUILD_ID</code>。</li><li id="6abc" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">然后我们拉一个包含E2E测试本身的Docker图像。正如我们稍后看到的，这是一个简单的应用程序。所以，在Docker Hub中保存也很方便。</li><li id="5e48" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">最后，是时候进行E2E测试了。包含测试的应用程序应该是可配置的，可以运行不同的Docker服务映像(在本例中，<code class="du je jf jg jh b">API-Service</code>和<code class="du je jf jg jh b">Gain-Service</code>)。这里我们将<code class="du je jf jg jh b">API_SERVICE_IMAGE</code>变量值作为我们在步骤2中本地构建的值。</li></ol><blockquote class="lm ln lo"><p id="90cf" class="if ig lp ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated">所有其他服务应该将默认的Docker图像作为最新的标签。这将使我们有机会通过覆盖当前的服务映像版本，在任何存储库中运行E2E测试。</p></blockquote><p id="bce3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果所有验证都通过，请购单将被合并。合并后，新版本的<code class="du je jf jg jh b">API-Service</code>被推送到带有<code class="du je jf jg jh b">latest</code>标签的<a class="ae jd" href="https://javarevisited.blogspot.com/2022/05/docker-interview-questions-answers-for.html" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>。</p><h1 id="54e1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">e2e-在部署阶段之前运行的测试</h1><ol class=""><li id="528c" class="ky kz hi ih b ii ks im kt iq lt iu lu iy lv jc ld le lf lg bi translated">单元测试和集成测试以同样的方式运行。</li><li id="ada5" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">最新版本的<code class="du je jf jg jh b">E2E-tests</code>图片来自Docker Hub。</li><li id="5c89" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">e2e——所有服务都使用标签<code class="du je jf jg jh b">latest</code>进行测试。</li></ol><p id="4140" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">API-Service</code>已经被推送到Docker Hub，pull请求merge上的标签为<code class="du je jf jg jh b">latest</code>。因此，不需要在E2E测试运行时指定特定的映像版本。</p><h1 id="f2f6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">代码实现</h1><p id="2e82" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">让我们开始实施E2E测试。你可以通过<a class="ae jd" href="https://github.com/SimonHarmonicMinor/e2e-tests-example" rel="noopener ugc nofollow" target="_blank">这个链接</a>查看源代码。<br/>我使用<a class="ae jd" href="https://javarevisited.blogspot.com/2021/02/-spring-boot-testing-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"> Spring Boot测试</a>作为E2E测试的框架。但是你可以应用任何你喜欢的技术。</p><blockquote class="lm ln lo"><p id="81d1" class="if ig lp ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated">为了简单起见，我将所有模块(包括 <code class="du je jf jg jh b"><em class="hi">e2e-tests</em></code> <em class="hi">)放在一个单一的仓库中。无论如何，我向你描述的方法是全面的。因此，您也可以将它应用到多存储库微服务中。</em></p></blockquote><p id="03f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先从<code class="du je jf jg jh b">E2ESuite</code>说起吧。这个将包含所有的配置，并作为所有测试用例的超类。看看下面的代码示例。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">E2ESuite基本配置</p></figure><p id="de97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们必须声明<a class="ae jd" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-jenkins-docker-and-kubernetes-for-devops-in-2020-best-of-lot-62a0541ffeb3"> Docker </a>容器在Testcontainers环境中运行。这里我们有Redis和RabbitMQ，它们是基础架构的一部分。而<code class="du je jf jg jh b">API_SERVICE</code>和<code class="du je jf jg jh b">GAIN_SERVICE</code>是实现业务逻辑的定制服务。</p><blockquote class="lm ln lo"><p id="f76d" class="if ig lp ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated"><em class="hi"/><code class="du je jf jg jh b"><em class="hi">@Import</em></code><em class="hi">注释用于将自定义类添加到Spring上下文中，用于测试目的。它们的实现很简单。因此，您可以通过上面的存储库链接找到它。虽然</em> <code class="du je jf jg jh b"><a class="ae jd" href="https://javarevisited.blogspot.com/2019/02/difference-between-contextconfiguration-and-springapplicationConfiguration-annotations-in-spring-boot-testing.html#axzz7BnOZ1wuB" rel="noopener ugc nofollow" target="_blank"><em class="hi">@ContextConfiguration</em></a></code> <em class="hi">很重要。我们很快就会谈到这一点。</em></p></blockquote><p id="819d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有，<code class="du je jf jg jh b">SHARED_NETWORK</code>至关重要。你看，容器应该相互通信，因为这是E2E场景的目的。但是我们还必须能够向<code class="du je jf jg jh b">API-Service</code>发送HTTP请求来调用业务逻辑。为了实现这两个目标，我们将所有的容器绑定在一个网络上，并将<code class="du je jf jg jh b">API-Service</code> HTTP端口转发给客户端。看看下面描述这个过程的模式。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><a href="https://www.java67.com/2018/05/top-20-system-design-interview-questions-answers-programming.html"><div class="er es kx"><img src="../Images/321eb8118fb63c8782f255cbd8994b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bO0CrRkIH372sOe2.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">Docker网络通信</p></figure><p id="07c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要以某种方式初始化和启动容器。此外，我们还必须指定正确的属性来将我们的<code class="du je jf jg jh b">E2E-tests</code>应用程序连接到最近启动的<a class="ae jd" rel="noopener" href="/javarevisited/top-5-free-courses-to-learn-docker-for-beginners-best-of-lot-b2b1ad2b98ad"> Docker容器</a>。在这种情况下，<code class="du je jf jg jh b">@ContextConfiguration</code>注解就可以派上用场了。它提供了代表在Spring上下文初始化阶段调用的回调的参数<code class="du je jf jg jh b">initializers</code>。这里我们放了内部类<code class="du je jf jg jh b">Initializer</code>。看看下面的代码示例。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">E2ESuite初始值设定项</p></figure><p id="a8fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一步一步地解构这个功能。首先创建Redis容器。看看下面的代码片段。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">Redis容器配置</p></figure><p id="d784" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在撰写本文时，Testcontainers库中没有Redis的明确容器。所以，我用的是一般的。最重要的属性是<code class="du je jf jg jh b">network</code>和<code class="du je jf jg jh b">network aliases</code>。它们的存在使得一个容器对于同一网络中的其他容器是可到达的。我们还公开了<code class="du je jf jg jh b">6379</code>端口(默认的Redis端口),因为E2E测试用例将在执行过程中连接到Redis。</p><p id="dda1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有，我想请你注意一下<code class="du je jf jg jh b">log consumer</code>。你看，当E2E方案失败时，原因并不总是显而易见的。有时，为了理解问题的根源，您必须深入研究容器的日志。幸运的是，<code class="du je jf jg jh b">log consumer</code>允许我们将容器的日志转发给任何<a class="ae jd" href="https://www.slf4j.org/" rel="noopener ugc nofollow" target="_blank"> SLF4J </a>日志记录器实例。在这个项目中，容器的日志被转发到常规的文本文件中(你可以在<a class="ae jd" href="https://github.com/SimonHarmonicMinor/e2e-tests-example/blob/master/e2e-tests/src/test/resources/logback.xml" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到<a class="ae jd" href="https://logback.qos.ch/" rel="noopener ugc nofollow" target="_blank"> Logback </a>配置)。尽管将日志转移到外部测井设施(例如<a class="ae jd" href="https://www.elastic.co/kibana/" rel="noopener ugc nofollow" target="_blank"> Kibana </a>)要好得多。</p><p id="2bae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来是RabbitMQ。看看下面的容器初始化。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">RabbitMQ容器初始化</p></figure><p id="1977" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个想法类似于Redis容器实例化。但是这里我们也调用了<code class="du je jf jg jh b">withQueue</code>方法(它是<code class="du je jf jg jh b">RabbitMQContainer</code>类的一部分)来指定RabbitMQ start上的默认主题。<code class="du je jf jg jh b">API-Service</code>向<code class="du je jf jg jh b">queue.api</code>主题发送消息，<code class="du je jf jg jh b">Gain-Service</code>向<code class="du je jf jg jh b">queue.gain</code>主题发送消息(这些属性是可配置的)。因此，在应用程序启动时创建所需的主题很方便。</p><p id="a2a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后是一行有趣的代码。</p><pre class="jj jk jl jm fd ly jh lz ma aw mb bi"><span id="6d59" class="mc jv hi jh b fi md me l mf mg">Startables.deepStart(REDIS, RABBIT).join();</span></pre><p id="716c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">deepStart</code>方法接受容器的<em class="lp">变量</em>开始并返回<code class="du je jf jg jh b">CompletableFuture</code>。我们需要那些容器在<code class="du je jf jg jh b">API-Service</code>和<code class="du je jf jg jh b">Gain-Service</code>之前开始。因此，我们调用<code class="du je jf jg jh b">join</code>方法等待，直到容器准备好接受请求。</p><blockquote class="lm ln lo"><p id="fbed" class="if ig lp ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated"><em class="hi">您也可以使用单个</em> <code class="du je jf jg jh b"><em class="hi">deepStart</em></code> <em class="hi">方法调用来启动所有容器，并通过调用容器本身的</em> <code class="du je jf jg jh b"><em class="hi">dependsOn</em></code> <em class="hi">方法来指定顺序。它更有表现力，但更难通读。所以，我留下一个更简单的例子。</em></p></blockquote><p id="4991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以开始定制容器了。</p><pre class="jj jk jl jm fd ly jh lz ma aw mb bi"><span id="d9db" class="mc jv hi jh b fi md me l mf mg">var apiExposedPort = environment.getProperty("api.exposed-port", Integer.class);<br/>API_SERVICE = createApiServiceContainer(environment, apiExposedPort);</span></pre><p id="cd3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们深入探讨一下<code class="du je jf jg jh b">createApiServiceContainer</code>方法。看看下面截取的代码。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">API-服务容器初始化</p></figure><p id="ccf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有些事情我想指出来。</p><p id="d090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">withEnv</code>方法只是设置了一个常规的环境变量。那些是用来配置<code class="du je jf jg jh b">API-Service</code>的。你可能已经注意到<code class="du je jf jg jh b">RabbitMQ</code>的网址是<code class="du je jf jg jh b">amqp://rabbit:5672</code>。因为<code class="du je jf jg jh b">rabbit</code>是内部网络中相应容器的名称(我们在容器的实例化上将它指定为网络别名)。这就是为什么<code class="du je jf jg jh b">RabbitMQ</code>可以被<code class="du je jf jg jh b">API-Service</code>到达。</p><p id="8101" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">waitingFor</code>条款更有意思。Testcontainers必须知道容器已经准备好接受连接。<code class="du je jf jg jh b">API-Service</code>公开了返回<code class="du je jf jg jh b">200</code>代码的<code class="du je jf jg jh b">/actuator/health</code> HTTP路径，如果准备好了实例的话。</p><p id="34ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结合了<code class="du je jf jg jh b">withCreateContainerCmdModifier</code>和<code class="du je jf jg jh b">withExposedPorts</code>方法的<code class="du je jf jg jh b">withCreateContainerCmdModifier</code>将内部容器的端口<code class="du je jf jg jh b">8080</code>绑定到<code class="du je jf jg jh b">apiExposedPort</code>(在E2E测试开始之前由环境变量指定)。</p><p id="a033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">withImagePullPolicy</code>定义了直接从Docker Hub检索图像的规则。默认情况下，Testcontainers在本地检查图像是否存在。如果它找到一个，它不会从远程服务器获取任何东西。该行为适合于测试特定的图像。但是如果你指定了一个带有<code class="du je jf jg jh b">latest</code>标签的版本，那么这个库就有可能不会拉出最相关的版本。在这种情况下，Testcontainers总是从远程Docker Hub获取图像。</p><p id="55f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看下面的<code class="du je jf jg jh b">Gain-Service</code>容器声明。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">增益-服务容器初始化</p></figure><p id="15a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，初始化类似于<code class="du je jf jg jh b">API-Service</code>。所以，让我们更进一步。</p><p id="a047" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<code class="du je jf jg jh b">API-Service</code>和<code class="du je jf jg jh b">Gain-Service</code>集装箱准备好时，我们可以启动它们。看看下面的代码片段。</p><pre class="jj jk jl jm fd ly jh lz ma aw mb bi"><span id="681c" class="mc jv hi jh b fi md me l mf mg">Startables.deepStart(API_SERVICE, GAIN_SERVICE).join();<br/>setPropertiesForConnections(environment);</span></pre><p id="a1f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经讨论过<code class="du je jf jg jh b">Startables.deepStart</code>的想法。尽管<code class="du je jf jg jh b">setPropertiesForConnections</code>需要一些解释。该方法将启动容器的URL设置为E2E测试用例的属性。因此，测试套件可以验证结果。看看下面的过程实现。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="f8f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们为RabbitMQ和Redis指定了连接。此外，我们存储了用于发送HTTP请求的<code class="du je jf jg jh b">API-Service</code>主机。</p><p id="5c7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好，让我们做测试用例。我们正在写一个单一的E2E场景。看看下面的列表。</p><ol class=""><li id="80e7" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">客户端向<code class="du je jf jg jh b">API-Service</code>发送包含<code class="du je jf jg jh b">msisdn</code>和<code class="du je jf jg jh b">cookie</code>值的消息</li><li id="1329" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">没有修改的消息最终应该被传输到RabbitMQ。</li><li id="47fb" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">客户端向<code class="du je jf jg jh b">API-Service</code>发送仅包含<code class="du je jf jg jh b">cookie</code>值的消息。</li><li id="f2a0" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">具有确定的<code class="du je jf jg jh b">msisdn</code>值的丰富消息应该最终被传输到RabbitMQ。</li></ol><p id="c733" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看下面的测试套件。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">增益测试套件</p></figure><p id="7ce8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们用<code class="du je jf jg jh b">cookie</code>和<code class="du je jf jg jh b">msisdn</code>发送一条消息。然后，我们检查消息是否按原样进一步传输。下一步是发送另一条省略了<code class="du je jf jg jh b">msisdn</code>但显示了<code class="du je jf jg jh b">cookie</code>值的消息。最后，具有丰富的<code class="du je jf jg jh b">msisdn</code>值的消息最终应该由<code class="du je jf jg jh b">Gain-Service</code>推送到RabbitMQ。</p><p id="c92b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在本地运行测试，可能需要一段时间。反正下载需要的图片和启动相应的容器都是需要时间的。但是测试应该会成功通过。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mh"><img src="../Images/f0614eb11a39685be6c3dc7a220d9fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lotNRWmF5zV8txH-.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">增益测试结果</p></figure><h1 id="323c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">在CI环境中运行</h1><p id="b54b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">嗯，听起来不错。但是我们如何在CI流程中运行E2E测试呢？</p><p id="326c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们应该把E2E试卷包装成码头工人的形象。看看下面的docker文件。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="3cbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，测试是在容器的起点编译和运行的。</p><blockquote class="lm ln lo"><p id="a9a0" class="if ig lp ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated"><em class="hi">测试不是编译后的工件的一部分(在本例中，</em> <code class="du je jf jg jh b"><em class="hi">.jar</em></code> <em class="hi">文件)。这就是为什么我们复制整个目录和代码本身。</em></p></blockquote><p id="0650" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来是GitHub动作管道的YAML配置。结果剧本<a class="ae jd" href="https://github.com/SimonHarmonicMinor/e2e-tests-example/blob/master/.github/workflows/build.yml" rel="noopener ugc nofollow" target="_blank">很长</a>。所以，我把它分成小部分展示给你们。</p><p id="29a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将对每个拉请求和每个到<code class="du je jf jg jh b">master</code>分支的合并运行测试用例。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">GitHub Actions build.yml</p></figure><p id="7882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个流水线由3项工作组成:</p><ol class=""><li id="31c8" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated"><code class="du je jf jg jh b">build</code>编译所有服务(<code class="du je jf jg jh b">API-Service</code>和<code class="du je jf jg jh b">Gain-Service</code>)，并运行单元和集成测试。</li><li id="a9e7" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du je jf jg jh b">build-dev-images</code>将所有组件(包括<code class="du je jf jg jh b">E2E-tests</code>在内)打包成Docker镜像，并将其推送到带有<code class="du je jf jg jh b">dev-$CI_BUILD_NUM</code>标签的Docker Hub。</li><li id="4a03" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du je jf jg jh b">e2e-tests</code>对推送到<code class="du je jf jg jh b">build-dev-images</code>任务的图像运行E2E测试。</li><li id="d9da" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du je jf jg jh b">build-prod-images</code>将所有组件打包成Docker映像，并将其推送到带有<code class="du je jf jg jh b">latest</code>标签的Docker Hub。成功通过<code class="du je jf jg jh b">e2e-tests</code>作业后，仅在<code class="du je jf jg jh b">master</code>分部运行。</li></ol><p id="fae2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们清楚地看看每项工作。</p><h2 id="6ec1" class="mc jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">建设</h2><p id="71a3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">那是最琐碎的一个。而且，GitHub可以为你生成这个。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">GitHub Actions build.yml</p></figure><h2 id="daae" class="mc jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">构建-开发-映像</h2><p id="1399" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这个比较棘手。首先，我们必须将<code class="du je jf jg jh b">DOCKERHUB_USERNAME</code>和<code class="du je jf jg jh b">DOCKERHUB_TOKEN</code>存储为存储库机密，以推送Docker构建的图像。那我们应该推动人工制品。最后，我们必须将计算出的<code class="du je jf jg jh b">dev</code>标签转发给下一个作业。看看下面的实现。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">GitHub Actions build.yml</p></figure><p id="35ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你们注意这几行代码。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">GitHub Actions build.yml</p></figure><p id="ef4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">export IMAGE_TAG_ENV=dev-${{ github.run_number }}</code>行将带有生成的编译号的<code class="du je jf jg jh b">dev</code>标记设置为<code class="du je jf jg jh b">IMAGE_TAG_ENV</code>环境变量。</p><p id="8318" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">echo "IMAGE_TAG=$IMAGE_TAG_ENV" &gt;&gt; "$GITHUB_ENV"</code>线使<code class="du je jf jg jh b">${{ env.IMAGE_TAG }}</code>变量可用。它用于在后续步骤中指定图像发布的Docker标签。</p><p id="2857" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">echo "::set-output name=image_tag::$IMAGE_TAG_ENV"</code>保存<code class="du je jf jg jh b">image_tag</code>变量作为输出。因此，下一个作业可以引用它来运行指定版本的E2E测试。</p><p id="e222" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">推送到Docker Hub本身是通过<code class="du je jf jg jh b">docker/build-push-action</code>实现的。看看下面的代码片段。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">GitHub Actions build.yml</p></figure><p id="a76d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">建推<code class="du je jf jg jh b">API-Service</code>与<code class="du je jf jg jh b">Gain-Service</code>相似。</p><h2 id="c904" class="mc jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">e2e测试</h2><p id="15e2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在是时候进行E2E测试了。看看下面的配置。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="lw lx l"/></div><p class="jq jr et er es js jt bd b be z dx translated">GitHub Actions build.yml</p></figure><p id="0cf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">container.image</code>指定要运行的E2E测试的版本。<code class="du je jf jg jh b">${{needs.build-dev-images.outputs.image_tag}}</code>变量引用了上一步中由<code class="du je jf jg jh b">build-dev-images</code>作业公开的变量。</p><p id="8365" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">volumes: /var/run/docker.sock:/var/run/docker.sock</code>至关重要。因为<code class="du je jf jg jh b">e2e-tests</code> images使用Testcontainers库来运行另一个Docker容器。安装<code class="du je jf jg jh b">docker.sock</code>作为卷实现Docker虫洞模式。你可以通过<a class="ae jd" href="https://www.testcontainers.org/supported_docker_environment/continuous_integration/dind_patterns/" rel="noopener ugc nofollow" target="_blank">这个链接</a>了解更多。</p><h2 id="59fa" class="mc jv hi bd jw mm mn mo ka mp mq mr ke iq ms mt ki iu mu mv km iy mw mx kq my bi translated">构建-产品-图像</h2><p id="d15c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这个步骤和<code class="du je jf jg jh b">build-dev-images</code>差不多。你可以在<a class="ae jd" href="https://github.com/SimonHarmonicMinor/e2e-tests-example/blob/master/.github/workflows/build.yml" rel="noopener ugc nofollow" target="_blank">库</a>里找到。</p><h1 id="9e94" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="c88b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">因此，我们配置了CI环境来运行多个业务组件(即<code class="du je jf jg jh b">Gain-Service</code>和<code class="du je jf jg jh b">API-Service</code>)和外部服务(即RabbitMQ、Redis)的单元测试、集成测试和E2E测试。Testcontainers允许我们构建全面和可靠的管道。更令人兴奋的是，您不必拥有专用的服务器来进行E2E测试。纯CI管道就够了！</p><p id="cde5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你喜欢我提出的E2E测试方法。如果您有任何问题或建议，请在下面留下您的评论。另外，你可以直接给我发短信。我很乐意讨论这个话题。感谢阅读！</p><h1 id="259a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">资源</h1><ol class=""><li id="9053" class="ky kz hi ih b ii ks im kt iq lt iu lu iy lv jc ld le lf lg bi translated"><a class="ae jd" href="https://github.com/SimonHarmonicMinor/e2e-tests-example" rel="noopener ugc nofollow" target="_blank">储存库与源代码</a></li><li id="6ed3" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://dev.to/kirekov/apache-spark-hive-and-spring-boot-testing-guide-mdp" rel="noopener ugc nofollow" target="_blank">阿帕奇Spark、Hive和Spring Boot测试指南</a></li><li id="c8bd" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://dev.to/kirekov/spring-boot-testing-testcontainers-and-flyway-2jpd" rel="noopener ugc nofollow" target="_blank"> Spring Boot测试—测试容器和飞行路线</a></li><li id="1393" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://dev.to/kirekov/spring-boot-testing-data-and-services-288f" rel="noopener ugc nofollow" target="_blank"> Spring Boot测试—数据和服务</a></li><li id="a2f2" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://dev.to/kirekov/spring-boot-jpa-clear-tests-45he" rel="noopener ugc nofollow" target="_blank">春季数据JPA —清除测试</a></li><li id="c3e7" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://semaphoreci.com/blog/unit-testing" rel="noopener ugc nofollow" target="_blank">深入单元测试</a></li><li id="42b2" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://semaphoreci.com/blog/integration-tests" rel="noopener ugc nofollow" target="_blank">正确进行集成测试</a></li><li id="b41b" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://www.slf4j.org/" rel="noopener ugc nofollow" target="_blank"> SLF4J </a></li><li id="fd41" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://logback.qos.ch/" rel="noopener ugc nofollow" target="_blank">回退</a></li><li id="7722" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">基巴纳</li><li id="ec7f" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><a class="ae jd" href="https://www.testcontainers.org/supported_docker_environment/continuous_integration/dind_patterns/" rel="noopener ugc nofollow" target="_blank">在Docker容器中运行测试的模式</a></li></ol></div></div>    
</body>
</html>