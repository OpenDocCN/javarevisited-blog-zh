<html>
<head>
<title>Spark 3.0 — New Functions in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark 3.0 —简而言之的新功能</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spark-3-0-new-functions-in-a-nutshell-a929fca93413?source=collection_archive---------0-----------------------#2020-06-14">https://medium.com/javarevisited/spark-3-0-new-functions-in-a-nutshell-a929fca93413?source=collection_archive---------0-----------------------#2020-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://medium.com/javarevisited/5-free-courses-to-learn-apache-spark-in-2020-bdff2d60c800"><div class="er es if"><img src="../Images/0f5b847cfe4512e0c4c686eeaff73b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/0*YF5cfiJ99-eIvjDf.png"/></div></a></figure><p id="1bcb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最近，Apache Spark社区发布了Spark 3.0的预览版，其中包含许多重要的新功能，将有助于Spark在这个<a class="ae jk" rel="noopener" href="/dataseries/top-6-courses-to-learn-big-data-and-hadoop-in-2020-2e20593347fe">大数据</a>和<a class="ae jk" href="https://becominghuman.ai/9-data-science-and-machine-learning-courses-by-harvard-ibm-udemy-and-others-12a0c7c23ec1" rel="noopener ugc nofollow" target="_blank">数据科学</a>时代拥有广泛的企业用户和开发人员。</p><p id="1bc0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在新版本中，spark community已经将一些函数从Spark <a class="ae jk" rel="noopener" href="/javarevisited/7-free-courses-to-learn-database-and-sql-for-programmers-and-data-scientist-e7ae19514ed2"> SQL </a>移植到编程Scala API( <code class="du jl jm jn jo b">org.apache.spark.sql.functions</code>)中，这鼓励开发人员将这些函数直接用作其数据帧转换的一部分，而不是进入SQL模式或创建视图，并将这些函数与SQL表达式或<strong class="io hj"> callUDF </strong>函数一起使用。</p><p id="e1a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">社区也努力引入了一些新的数据转换函数和partition_transforms函数，这些函数在使用Spark的新<code class="du jl jm jn jo b">DataFrameWriterv2 </code>将数据写到外部存储器时非常有用。</p><blockquote class="jp jq jr"><p id="33e0" class="im in js io b ip iq ir is it iu iv iw jt iy iz ja ju jc jd je jv jg jh ji jj hb bi translated">Spark 3中的一些新功能已经是Databricks Spark以前版本的一部分。因此，如果您曾在Databricks cloud中工作过，您可能会发现其中一些函数很熟悉。</p></blockquote><p id="41b5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在整篇文章中，我们将介绍Spark在Spark SQL和Scala API中的新函数，用于访问<code class="du jl jm jn jo b">DataFrame </code>操作，以及从Spark SQL移植到Scala API的函数，用于编程访问。</p><h1 id="aea7" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">Spark 3.0在Spark SQL中引入的函数，用于数据帧转换</strong></h1><h2 id="851f" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak"> from_csv </strong></h2><p id="3af9" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">像from_json一样，这个函数解析包含CSV字符串的列，并将其转换为Struct类型。如果CSV字符串不可解析，它将返回null。</p><p id="9e2a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">例题</em> </strong>:</p><p id="1a4a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个函数需要一个结构模式和选项来指示如何解析CSV字符串。选项与CSV数据源相同。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="fc25" class="ku jx hi jo b fi lv lw l lx ly">val studentInfo = "1,Jerin,CSE"::"2,Jerlin,ECE"::"3,Arun,CSE"::<em class="js">Nil</em></span><span id="6abc" class="ku jx hi jo b fi lz lw l lx ly">val <em class="js">schema </em>= new StructType() <br/>            .add("Id",IntegerType)<br/>            .add("Name",StringType)<br/>            .add("Dept",StringType)</span><span id="792a" class="ku jx hi jo b fi lz lw l lx ly">val <em class="js">options </em>= <em class="js">Map</em>("delimiter" -&gt;",")</span><span id="607e" class="ku jx hi jo b fi lz lw l lx ly">val studentDF = studentInfo.toDF("Student_Info")<br/>.withColumn("csv_struct",<em class="js">from_csv</em>('Student_Info, <em class="js">schema</em>,<em class="js">options</em>))<br/>studentDF.show()</span></pre><h2 id="a31a" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">至_csv </strong></h2><p id="8071" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">将结构类型列转换为CSV字符串。</p><p id="dde0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">例题</em> </strong> <em class="js"> : </em></p><p id="1aeb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了Struct type列，该函数还接受一个可选的options参数，该参数指示如何将Struct列转换为CSV字符串。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="99c0" class="ku jx hi jo b fi lv lw l lx ly">studentDF<br/>.withColumn("csv_string",<em class="js">to_csv</em>($"csv_struct",<em class="js">Map</em>.<em class="js">empty</em>[String, String].asJava))<br/>.show</span></pre><h2 id="5998" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">模式_of_csv </strong></h2><p id="a114" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">推断CSV字符串的架构，并以DDL格式返回架构。</p><p id="1931" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="3a40" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个函数需要一个CSV字符串列和一个可选参数，该参数包含如何解析CSV字符串的选项。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="7d6d" class="ku jx hi jo b fi lv lw l lx ly">studentDF<br/>.withColumn("schema",<em class="js">schema_of_csv</em>("csv_string"))<br/>.show</span></pre><h2 id="bf79" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak"> for_all </strong></h2><p id="6530" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">将给定的谓词应用于数组中的所有元素，并且仅当数组中的所有元素评估为true时返回true，否则产生false。</p><p id="bcef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="6b96" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">检查给定数组列中的所有元素是否都是偶数。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="8372" class="ku jx hi jo b fi lv lw l lx ly"><em class="js">val  df = Seq</em>(<em class="js">Seq</em>(2,4,6),<em class="js">Seq</em>(5,10,3)).toDF("int_array")<br/>df.withColumn("flag",<em class="js">forall</em>($"int_array",(x:Column)=&gt;(<em class="js">lit</em>(x%2==0))))<br/>.show</span></pre><h2 id="fc44" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">变换</strong></h2><p id="b757" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">将函数应用于数组中的所有元素后，返回一个新数组。</p><p id="67bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="cfc2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将数组中的所有元素加“1”。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="110e" class="ku jx hi jo b fi lv lw l lx ly">val df = <em class="js">Seq</em>((<em class="js">Seq</em>(2,4,6)),(<em class="js">Seq</em>(5,10,3))).toDF("num_array")<br/>df<br/>.withColumn("num_array",<em class="js">transform</em>($"num_array",x=&gt;x+1))<br/>.show</span></pre><h2 id="38bf" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">叠加</strong></h2><p id="2bd8" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">用从指定字节位置到可选指定字节长度的实际替换内容替换列的内容。</p><p id="f0b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="070c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将特定人的问候语改为传统的“Hello World”</p><p id="012b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们用world替换人名，因为姓名的起始位置是7，我们想在替换内容之前删除完整的姓名，需要删除的字节位置的长度应该大于或等于列中姓名的最大长度。</p><p id="64a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们将替换单词作为“World”传递，替换内容的特定起始位置为“7”，从指定起始位置移除的位置数为“12”(这是可选的，如果没有指定，函数将使用指定起始位置的替换内容替换源内容)。</p><blockquote class="jp jq jr"><p id="d3f3" class="im in js io b ip iq ir is it iu iv iw jt iy iz ja ju jc jd je jv jg jh ji jj hb bi translated">Overlay替换StringType、TimeStampType、IntegerType等的内容，但是不管列的输入类型是什么，列的返回类型总是StringType。</p></blockquote><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="6f7b" class="ku jx hi jo b fi lv lw l lx ly">val <em class="js">greetingMsg </em>= "Hello Arun"::"Hello Mohit Chawla"::"Hello Shaurya"::<em class="js">Nil</em></span><span id="77ce" class="ku jx hi jo b fi lz lw l lx ly">val <em class="js">greetingDF </em>= <em class="js">greetingMsg</em>.toDF("greet_msg")</span><span id="31d0" class="ku jx hi jo b fi lz lw l lx ly"><em class="js">greetingDF</em>.withColumn("greet_msg",<em class="js">overlay</em>($"greet_msg",<em class="js">lit</em>("World"),<em class="js">lit</em>("7"),<em class="js">lit</em>("12")))<br/>.show</span></pre><h2 id="7b3c" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">拆分</strong></h2><p id="a347" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">根据给定的正则表达式和指定的限制拆分字符串表达式，指定的限制指示对给定的字符串表达式应用正则表达式的次数。</p><p id="b87f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果指定的限制小于或等于零，正则表达式将多次应用于字符串，结果数组将根据给定的正则表达式包含所有可能的字符串拆分。</p><p id="8fd6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果指定的限制大于零，则应用的正则表达式不会超过该限制</p><p id="ee6b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">例如:</em> </strong></p><p id="0230" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根据正则表达式将给定的字符串表达式一分为二。即字符串分隔符。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="ed48" class="ku jx hi jo b fi lv lw l lx ly">val <em class="js">num </em>= "one~two~three"::"four~five"::<em class="js">Nil<br/></em>val <em class="js">numDF </em>= <em class="js">num</em>.toDF("numbers")<br/><em class="js">numDF<br/></em>.withColumn("numbers",<em class="js">split</em>($"numbers","~",2))<br/>.show</span></pre><p id="2397" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将同一个字符串表达式拆分成多个部分，拆分次数与分隔符出现的次数一样多</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="3ef2" class="ku jx hi jo b fi lv lw l lx ly"><em class="js">numDF<br/></em>.withColumn("numbers",<em class="js">split</em>($"numbers","~",0))<br/>.show</span></pre><h2 id="fbff" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><em class="ma">地图_条目</em></h2><p id="6240" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">将映射键值转换成无序的条目数组。</p><p id="7058" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="496e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">获取数组中地图的所有键和值。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="f072" class="ku jx hi jo b fi lv lw l lx ly">val <em class="js">df </em>= <em class="js">Seq</em>(<em class="js">Map</em>(1-&gt;"x",2-&gt;"y")).toDF("key_values")<br/><em class="js">df</em>.withColumn("key_value_array",<em class="js">map_entries</em>($"key_values"))<br/>.show</span></pre><h2 id="daf1" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak"> map_zip_with </strong></h2><p id="5213" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">使用函数根据关键字将两个地图合并成一个地图。</p><p id="a2dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="cde9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">计算跨部门雇员完成的总销售额，并通过传递一个函数来获得单个映射中特定雇员的总销售额，该函数将根据键对两个不同映射列的总销售额进行求和。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="1665" class="ku jx hi jo b fi lv lw l lx ly">val <em class="js">df </em>= <em class="js">Seq</em>((<em class="js">Map</em>("EID_1"-&gt;10000,"EID_2"-&gt;25000),<br/>             <em class="js">Map</em>("EID_1"-&gt;1000,"EID_2"-&gt;2500)))   .toDF("emp_sales_dept1","emp_sales_dept2")<br/><br/><em class="js">df</em>.<br/>withColumn("total_emp_sales",<em class="js">map_zip_with</em>($"emp_sales_dept1",$"emp_sales_dept2",(k,v1,v2)=&gt;(v1+v2)))<br/>.show</span></pre><h2 id="9771" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">地图_过滤器</strong></h2><p id="9c0a" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">返回只包含满足给定谓词函数的映射值的新键值对。</p><p id="dac3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="bfd3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">只过滤掉销售额高于20000的雇员</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="15c6" class="ku jx hi jo b fi lv lw l lx ly">val <em class="js">df </em>= <em class="js">Seq</em>(<em class="js">Map</em>("EID_1"-&gt;10000,"EID_2"-&gt;25000))<br/>          .toDF("emp_sales")<br/><br/><em class="js">df<br/></em>.withColumn("filtered_sales",<em class="js">map_filter</em>($"emp_sales",(k,v)=&gt;(v&gt;20000)))<br/>.show</span></pre><h2 id="b0f7" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">转换值</strong></h2><p id="915f" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">根据给定的函数操作映射列中所有元素的值。</p><p id="389d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="c6cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过给每个雇员增加5000来计算雇员薪金</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="224e" class="ku jx hi jo b fi lv lw l lx ly">val <em class="js">df </em>= <em class="js">Seq</em>(<em class="js">Map</em>("EID_1"-&gt;10000,"EID_2"-&gt;25000))<br/>         .toDF("emp_salary")<br/><br/><em class="js">df<br/></em>.withColumn("emp_salary",<em class="js">transform_values</em>($"emp_salary",(k,v)=&gt;(v+5000)))<br/>.show</span></pre><h2 id="44ac" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">变换_键</strong></h2><p id="d382" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">根据给定的函数操作地图列中所有元素的键。</p><p id="3f90" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="9838" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将公司名称“XYZ”添加到员工id中。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="3c21" class="ku jx hi jo b fi lv lw l lx ly">val df = <em class="js">Seq</em>(<em class="js">Map</em>("EID_1" -&gt; 10000, "EID_2" -&gt; 25000))<br/>        .toDF("employees")<br/>df<br/>.withColumn("employees", <em class="js">transform_keys</em>($"employees", (k, v) =&gt; <em class="js">concat</em>(k,<em class="js">lit</em>("_XYZ"))))<br/>.show</span></pre><h2 id="3c5e" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak"> xhash64 </strong></h2><p id="f843" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">使用64位xxhash算法计算给定列内容的哈希代码，并将结果返回为long。</p><h1 id="1676" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">Spark 3.0中从Spark SQL移植到Scala API的函数，用于数据帧转换</strong></h1><p id="1d60" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">大多数Spark SQL函数都以Scala API的形式提供，这使得相同的函数可以作为DataFrame操作的一部分使用。但是仍然有一些功能不能作为编程功能使用。要使用这些函数，必须进入Spark SQL模式，并将这些函数作为SQL表达式的一部分使用，或者使用Spark“call UDF”函数来使用相同的函数。随着函数的流行和使用的不断发展，这些函数中的一些曾经被移植到较新版本的编程spark API中。以下是从以前版本的Spark SQL function移植到Scala API的函数(org.spark.apache.sql.functions)</p><h2 id="2172" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">日期_子</strong></h2><p id="a9c2" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">从日期、时间戳和字符串数据类型中减去天数。如果数据类型为字符串，则数据类型应为可转换为日期的格式“yyyy<em class="js">-MM-DD”</em><em class="js">或“</em> yyyy <em class="js"> -MM-dd HH:mm:ss”。SSSS" </em></p><p id="cc76" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="be68" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从事件日期时间中减去“1天”。</p><blockquote class="jp jq jr"><p id="11b8" class="im in js io b ip iq ir is it iu iv iw jt iy iz ja ju jc jd je jv jg jh ji jj hb bi translated">如果要减去的天数为负数，该函数将给定的天数加到实际日期上。</p></blockquote><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="4cb9" class="ku jx hi jo b fi lv lw l lx ly">var <em class="js">df </em>= <em class="js">Seq</em>(<br/>        (1, Timestamp.<em class="js">valueOf</em>("2020-01-01 23:00:01")),<br/>        (2, Timestamp.<em class="js">valueOf</em>("2020-01-02 12:40:32")),<br/>        (3, Timestamp.<em class="js">valueOf</em>("2020-01-03 09:54:00")),<br/>        (4, Timestamp.<em class="js">valueOf</em>("2020-01-04 10:12:43"))<br/>         )<br/>     .toDF("typeId","eventDateTime")<br/><br/> <em class="js">df</em>.withColumn("Adjusted_Date",<em class="js">date_sub</em>($"eventDateTime",1)).show()</span></pre><h2 id="d2df" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">日期_添加</strong></h2><p id="f011" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">与date_sub相同，但将天数添加到实际天数中。</p><p id="6958" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">例如:</em> </strong></p><p id="fced" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将“1天”添加到事件日期时间</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="47f4" class="ku jx hi jo b fi lv lw l lx ly">var <em class="js">df </em>= <em class="js">Seq</em>(<br/>         (1, Timestamp.<em class="js">valueOf</em>("2020-01-01 23:00:01")),<br/>         (2, Timestamp.<em class="js">valueOf</em>("2020-01-02 12:40:32")),<br/>         (3, Timestamp.<em class="js">valueOf</em>("2020-01-03 09:54:00")),<br/>         (4, Timestamp.<em class="js">valueOf</em>("2020-01-04 10:12:43"))<br/>         )<br/>    .toDF("Id","eventDateTime")</span><span id="99a3" class="ku jx hi jo b fi lz lw l lx ly"><em class="js">df<br/></em>.withColumn("Adjusted Date",<em class="js">date_add</em>($"eventDateTime",1))<br/>.show()</span></pre><h2 id="6a87" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">月份_添加</strong></h2><p id="8876" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">像date_add和date_sub一样，这个函数有助于添加月份到日期。</p><blockquote class="jp jq jr"><p id="0063" class="im in js io b ip iq ir is it iu iv iw jt iy iz ja ju jc jd je jv jg jh ji jj hb bi translated">要减去月份，请将要减去的月份数指定为负数，因为没有单独的减去月份的减法函数</p></blockquote><p id="e04e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">例如:</em> </strong></p><p id="f5d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从eventDateTime中加减一个月。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="a1a4" class="ku jx hi jo b fi lv lw l lx ly">var <em class="js">df </em>= <em class="js">Seq</em>(<br/>    (1, Timestamp.<em class="js">valueOf</em>("2020-01-01 23:00:01")),<br/>    (2, Timestamp.<em class="js">valueOf</em>("2020-01-02 12:40:32")),<br/>    (3, Timestamp.<em class="js">valueOf</em>("2020-01-03 09:54:00")),<br/>    (4, Timestamp.<em class="js">valueOf</em>("2020-01-04 10:12:43"))<br/>     ).toDF("typeId","eventDateTime")<br/>//To add one months<br/> <em class="js">df<br/></em>.withColumn("Adjusted Date",<em class="js">add_months</em>($"eventDateTime",1))<br/>.show()<br/>//To subtract one months<br/><em class="js">df<br/></em>.withColumn("Adjusted Date",<em class="js">add_months</em>($"eventDateTime",-1))<br/>.show()</span></pre><h2 id="7ff2" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak"> zip_with </strong></h2><p id="990e" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">通过应用函数来合并左右数组。</p><p id="a131" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该函数期望两个数组长度相同，以防其中一个数组比另一个短，将添加null来匹配较长的数组长度。</p><p id="75eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="16be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将两个数组的内容相加并合并成一个数组</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="b259" class="ku jx hi jo b fi lv lw l lx ly">val df = <em class="js">Seq</em>((<em class="js">Seq</em>(2,4,6),<em class="js">Seq</em>(5,10,3)))<br/>         .toDF("array_1","array_2")<br/>  <br/> df<br/>.withColumn("merged_array",<em class="js">zip_with</em>($"array_1",$"array_2",(x,y)=&gt;(x+y)))<br/> .show<br/></span></pre><p id="2f58" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将谓词应用于所有元素，并检查数组中至少有一个或多个元素符合谓词函数。</p><p id="9da6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="7dd8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">检查数组中是否至少有一个元素是偶数。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="9d6b" class="ku jx hi jo b fi lv lw l lx ly"><em class="js">val df= Seq</em>(<em class="js">Seq</em>(2,4,6),<em class="js">Seq</em>(5,10,3)).toDF("num_array")<br/>df.withColumn("flag",exists($"num_array", x =&gt;<em class="js">lit</em>(x%2===0)))<br/>.show</span></pre><h2 id="a60f" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">过滤器</strong></h2><p id="2317" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">将给定的谓词应用于数组中的所有元素，并过滤出谓词为真的元素。</p><p id="b412" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="js">示例:</em></p><p id="4d57" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">只过滤掉数组中的偶数元素。</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="4586" class="ku jx hi jo b fi lv lw l lx ly"><em class="js">val df = Seq</em>(<em class="js">Seq</em>(2,4,6),<em class="js">Seq</em>(5,10,3)).toDF("num_array")<br/>df.withColumn("even_array",<em class="js">filter</em>($"num_array", x =&gt;<em class="js">lit</em>(x%2===0)))<br/>.show</span></pre><h2 id="8e56" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">聚合</strong></h2><p id="dd69" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">用给定函数将给定数组和另一个值/状态缩减为单个值，并应用可选的finish函数将缩减后的值转换为另一个状态/值。</p><p id="4e02" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="9b85" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将数组的总和加10，然后将结果乘以2</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="75d0" class="ku jx hi jo b fi lv lw l lx ly">val <em class="js">df </em>= <em class="js">Seq</em>((<em class="js">Seq</em>(2,4,6),3),(<em class="js">Seq</em>(5,10,3),8))<br/>  .toDF("num_array","constant")<br/><em class="js">df</em>.withColumn("reduced_array",<em class="js">aggregate</em>($"num_array", $"constant",(x,y)=&gt;x+y,x =&gt; x*2))<br/>  .show</span></pre><h1 id="39eb" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">Spark 3.0中为Spark SQL模式引入的功能</strong></h1><p id="d902" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">以下是新的SQL函数，您只能在Spark SQL模式下利用这些函数。</p><h2 id="c09f" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated">acosh </h2><p id="e73f" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">求给定表达式的双曲余弦的倒数。</p><h2 id="8194" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated">阿辛</h2><p id="55b2" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">求给定表达式的双曲正弦的倒数。</p><h2 id="fc63" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">阿坦赫</strong></h2><p id="8b83" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">求给定表达式的双曲正切的倒数。</p><h2 id="f8c0" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">位与、位或和位异或</strong></h2><p id="8d8c" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">要计算逐位AND、OR和XOR值</p><h2 id="8f45" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">位计数</strong></h2><p id="8de3" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">返回位数计数。</p><h2 id="575e" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">布尔_与和布尔_或</strong></h2><p id="118e" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">验证表达式的所有值是否为真，或者验证至少一个表达式为真。</p><h2 id="9b68" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak"> count_if </strong></h2><p id="0fc9" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">返回列中真值的数量</p><p id="d988" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">示例:</p><p id="b9e6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">找出给定列中偶数的个数</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="dd80" class="ku jx hi jo b fi lv lw l lx ly">var <em class="js">df </em>= <em class="js">Seq</em>((1),(2),(4)).toDF("num")<br/><br/> <em class="js">df</em>.createOrReplaceTempView("table")<br/><em class="js">spark</em>.sql("select count_if(num %2==0) from table").show</span></pre><h2 id="a2dd" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">日期_部分</strong></h2><p id="5905" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">提取日期/时间戳的一部分，如小时、分钟等…</p><h2 id="2ece" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak"> div </strong></h2><p id="6841" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">用于将表达式或列与另一个表达式/列相除</p><h2 id="7dbf" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">每一个和一些</strong></h2><p id="69ac" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">如果给定表达式对每个的所有列值求值为true，并且至少有一个值对某些列值求值为true，则此函数返回true</p><h2 id="0fb4" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">制造日期、制造间隔和制造时间戳</strong></h2><p id="7e4e" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">构建日期、时间戳和特定的时间间隔。</p><p id="fda5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="e2cb" class="ku jx hi jo b fi lv lw l lx ly">SELECT make_timestamp(2020, 01, 7, 30, 45.887)</span></pre><h2 id="fa75" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">最大值和最小值</strong></h2><p id="4ab1" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">比较两列并返回左列的值，该值与右列的最大/最小值相关联</p><p id="8759" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="0fdc" class="ku jx hi jo b fi lv lw l lx ly">var <em class="js">df </em>= <em class="js">Seq</em>((1,1),(2,1),(4,3)).toDF("x","y")<br/><br/> <em class="js">df</em>.createOrReplaceTempView("table")<br/><em class="js">spark</em>.sql("select max_by(x,y) from table").show</span></pre><h2 id="ac54" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">类型</strong></h2><p id="d980" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">返回列值的数据类型</p><h2 id="d757" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">版本</strong></h2><p id="553f" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">返回Spark版本及其git版本</p><h2 id="8863" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">调整天数、调整小时数和调整时间间隔</strong></h2><p id="b472" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">新引入的justify函数用于调整时间间隔。</p><p id="adcf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="js">举例:</em> </strong></p><p id="a66e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将30天表示为一个月，</p><pre class="ln lo lp lq fd lr jo ls lt aw lu bi"><span id="3020" class="ku jx hi jo b fi lv lw l lx ly">SELECT justify_days(interval '30 day')</span></pre><h2 id="8164" class="ku jx hi bd jy kv kw kx kc ky kz la kg ix lb lc kk jb ld le ko jf lf lg ks lh bi translated"><strong class="ak">分区变换函数</strong></h2><p id="28a5" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">从<a class="ae jk" rel="noopener" href="/swlh/5-free-online-courses-to-learn-big-data-hadoop-and-spark-in-2019-a553e6ccfe30"> Spark 3.0 </a>开始，出现了一些有助于数据分区的新功能，我将在另一篇文章中介绍。</p><p id="af31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总的来说，我们已经分析了spark 3.0中的所有数据转换和分析功能。希望本指南有助于理解这些新功能。这些功能肯定会加速spark开发工作，并有助于建立坚实有效的spark管道。</p><p id="bd68" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你有任何疑问，请在twitter上向我提出。</p></div></div>    
</body>
</html>