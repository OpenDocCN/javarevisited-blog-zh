<html>
<head>
<title>Understanding OOP.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解OOP。</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/understanding-oop-the-real-way-5832f57afd9c?source=collection_archive---------1-----------------------#2021-08-14">https://medium.com/javarevisited/understanding-oop-the-real-way-5832f57afd9c?source=collection_archive---------1-----------------------#2021-08-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b21d5b298e150f119b1f9166a80d61d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RkqQ66IEYGBdNjQSLAHFHg.png"/></div></div></figure><p id="b2a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OOP是每个软件工程师作为Java程序员进入软件工程世界时必须掌握的最基本的软件工程范例之一。让它成为任何基于OOP的语言:Python，c#；我们必须明确我们的OOP原则。OOP工作在类和对象的基础上:类是一个定义好的模板，对象被实例化以创建类的模板。</p><p id="656b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“理解这些原则将有助于您编写更精简、更清晰和可重用的代码，帮助您维护您的代码库，并在不破坏代码其余部分的情况下轻松进行更改。”—这个概念也被称为<strong class="is hj">解耦</strong>。这就是你的代码不相互依赖的地方。</p><p id="9627" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们深入代码，让我们演练这些OOP原则。出于演示的目的，我将使用Java作为我的编程语言。但是这些原则对于任何基于OOP的语言都是一样的。所以试着用你喜欢的OOP语言。</p><h1 id="023e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">1.包装</h1><p id="3d78" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">封装是这样一个概念:类中的数据成员(变量)被类包装起来，使得它可以在类中直接访问，而其他类不能直接访问数据成员。为了实现这一点，我们创建了数据成员<code class="du kr ks kt ku b">private</code>，并使用<code class="du kr ks kt ku b">accessors</code>和<code class="du kr ks kt ku b">modifiers</code>从类外部访问数据成员。</p><p id="cf95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如下图所示。</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div><p class="lb lc et er es ld le bd b be z dx translated">封装演示</p></figure><p id="ef4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中，我们可以看到一个类——<code class="du kr ks kt ku b">Cat</code>。这个类有私有的数据成员，确保任何类都不能直接访问这个类的数据成员。这种访问只能通过每个属性的<code class="du kr ks kt ku b">setter</code>方法来提供。如果你仔细观察，你会发现有一个变量<code class="du kr ks kt ku b">animalFamily</code>被标记为<code class="du kr ks kt ku b">readonly</code>。这是通过在构造函数中初始化变量，然后只为它提供<code class="du kr ks kt ku b">getter</code>来实现的。</p><h1 id="d2f4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">2.抽象</h1><p id="cec8" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">抽象类似于封装，但并不相同。抽象是一种原则，其中某些实现细节对客户是隐藏的，只有需要的细节才暴露给客户。</p><p id="3ddb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在OOP中，当一个类被声明为抽象时，它不能被实例化，因为它没有“真实世界”的应用。因此，这些类必须遵循另一个原则:继承，以提供一个真实世界的应用程序。</p><p id="88b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽象可以通过以下方式实现:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div><p class="lb lc et er es ld le bd b be z dx translated">抽象演示</p></figure><p id="2e4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图展示了一个抽象类。动物类在现实世界中没有实现。这些允许我们对客户端隐藏某些数据，只暴露需要的数据。</p><p id="ae93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一个概念中，我们将看看如何利用这个抽象类。</p><h1 id="5f53" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">3.遗产</h1><p id="64e9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">遗产。这也被称为亲子关系。子类扩展父类并检索父类的所有非私有属性和方法。</p><p id="584e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，为什么使用继承呢？假设我们有一组具有相同属性的类。例如:猫、狗、羊都有一些共同的属性:年龄、性别、血统、名字。如果我们将这些映射到单独的类中，我们将不得不创建3个单独的类。但是这样效率不高。因此，我们可以将所有公共属性添加到父类— <code class="du kr ks kt ku b">Animal</code>中，并让其他类扩展<strong class="is hj"> Animal </strong>类，使它们无需代码复制就能获得所需的数据成员。</p><p id="b850" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么这实际上看起来怎么样呢？</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div><p class="lb lc et er es ld le bd b be z dx translated">继承演示</p></figure><p id="1c18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中，抽象类— <strong class="is hj"> Animal </strong>正在被使用。我们可以看到，已经创建了一个类— <code class="du kr ks kt ku b">Cat</code>“扩展”了Animal类。这表明<strong class="is hj">猫是一种动物</strong>。因为我们正在扩展一个抽象类，所以我们必须覆盖我们已经声明的任何抽象方法。这允许我们从用户那里抽象出实现细节，并为相同的方法提供定制的实现。这就是“makeSound()”方法被覆盖的地方，它被赋予了一个对猫来说唯一的自定义实现。</p><p id="fa30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它是如何工作的？很简单。我们创建一个Child对象，同时引用它的父类。</p><p id="57e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kr ks kt ku b">Animal theCat = new Cat();</code></p><p id="9744" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这允许<code class="du kr ks kt ku b">theCat</code>对象获得被覆盖的实现。</p><p id="2b11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，这就是继承的工作方式。</p><h1 id="4527" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">4.多态性</h1><p id="51d8" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们已经达成了最后的原则。这就是所谓的多态性。</p><p id="0717" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是多态性？</strong></p><p id="b1f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是任何事物可以有不同形式的方式。那么，我们如何在代码中实现这一点呢？</p><p id="22de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两种方法可以实现多态性。</p><ol class=""><li id="a8bf" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated">方法重载</li><li id="ed09" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">方法覆盖</li></ol><h2 id="defc" class="lt jp hi bd jq lu lv lw ju lx ly lz jy jb ma mb kc jf mc md kg jj me mf kk mg bi translated"><strong class="ak">方法重载</strong></h2><p id="47e8" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">方法重载是这样一个概念:在一个类中，一个具有相同名称<strong class="is hj">和相同返回类型<strong class="is hj">的方法具有不同的实现和不同的输入参数。</strong></strong></p><p id="e3af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div><p class="lb lc et er es ld le bd b be z dx translated">过载演示</p></figure><p id="7af1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个超载的例子。这表明有三个<code class="du kr ks kt ku b">add</code>方法被声明。所有这些方法都有不同的输入参数和不同数量的输入参数。对于重载，方法必须在<strong class="is hj">相同的类</strong>中声明</p><p id="417a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这有助于维护更清晰、更容易理解的代码。</p><h2 id="5811" class="lt jp hi bd jq lu lv lw ju lx ly lz jy jb ma mb kc jf mc md kg jj me mf kk mg bi translated">方法覆盖</h2><p id="d86e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如果您在继承期间记得很清楚，我谈到了在扩展子类时“覆盖”父类中声明的方法。重写意味着:为不同类中的方法提供新的实现。这意味着覆盖只在父子关系中使用。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><blockquote class="mo mp mq"><p id="0342" class="iq ir mr is b it iu iv iw ix iy iz ja ms jc jd je mt jg jh ji mu jk jl jm jn hb bi translated">维奥拉。。</p><p id="9ce4" class="iq ir mr is b it iu iv iw ix iy iz ja ms jc jd je mt jg jh ji mu jk jl jm jn hb bi translated">如果你读到了这篇文章的结尾，你已经成功地理解了OOP的基本原理。我希望这篇文章对每个读过它的人都有用。</p><p id="2980" class="iq ir mr is b it iu iv iw ix iy iz ja ms jc jd je mt jg jh ji mu jk jl jm jn hb bi translated">感谢您花时间阅读本文。</p><p id="dbec" class="iq ir mr is b it iu iv iw ix iy iz ja ms jc jd je mt jg jh ji mu jk jl jm jn hb bi translated">在那之前，</p><p id="08f0" class="iq ir mr is b it iu iv iw ix iy iz ja ms jc jd je mt jg jh ji mu jk jl jm jn hb bi translated">快乐编码。</p></blockquote></div></div>    
</body>
</html>