<html>
<head>
<title>Value Objects: Design heuristics for modelling value objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">价值对象:为价值对象建模的设计启发法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/value-objects-design-heuristics-for-modelling-value-objects-4ba807e39d52?source=collection_archive---------2-----------------------#2022-08-16">https://medium.com/javarevisited/value-objects-design-heuristics-for-modelling-value-objects-4ba807e39d52?source=collection_archive---------2-----------------------#2022-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="0e9a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">序言</h1><p id="b659" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">价值对象是领域驱动设计的构建模块，在Eric Evans DDD中有很好的定义。这背后的想法是更深入地挖掘值对象的用途，定义建模它们的标准方法，并研究支持这种设计考虑的解决方案。</p><h1 id="7597" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">设计考虑</h1><p id="570e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">值对象是由它们的属性值定义的，并且是模型驱动的设计架构中的关键构建块之一。值对象没有概念上的同一性，它描述对象的本来面目。</p><blockquote class="kb kc kd"><p id="6639" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated">设计启发<strong class="jf hj"> #1 </strong>:如果两个值对象的属性具有相同的值，则它们相等。</p></blockquote><p id="48e4" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><a class="ae kn" rel="noopener" href="/javarevisited/10-best-places-to-learn-java-online-for-free-ce5e713ab5b2"> Java </a>是一种强类型语言，所以值对象的相等性在于属性值，而不是它们的引用。值对象的一个关键目的是人们必须能够共享它们，知道它的状态在被创建和传递后不会改变。</p><blockquote class="kb kc kd"><p id="ed49" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated">设计启发<strong class="jf hj"> #2 </strong>:值对象本质上应该是不可变的。</p></blockquote><p id="7d53" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">将值对象视为不可变的，不要给它附加任何标识。这让我们可以自由简化设计和优化性能。但是为什么需要使它不可变，它会增加项目的价值并使事情变得更容易吗？我们需要理解这里的目的。</p><p id="cb7c" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><a class="ae kn" href="https://javarevisited.blogspot.com/2012/12/does-java-pass-by-value-or-pass-by-reference.html" rel="noopener ugc nofollow" target="_blank"> Java通过值、</a>传递<em class="ke">引用，所以你得到一个引用的副本，但是被引用的对象是相同的。因此，可能发生的情况是，被调用者更改了传递给方法的引用对象的值，然后调用者可能会得到意外的结果。</em></p><p id="75dc" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">考虑下面的例子。这里，我们在<em class="ke"> processSavings() </em>中构造了一个account对象，并将其传递给<em class="ke"> checkValid()。</em>在<em class="ke"> checkValid()中，</em>我们错误地更新了账户类型，最后，我们已经将账户引用传递给<em class="ke"> postAccount() </em>进行处理。</p><p id="c5b6" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">但是，我们犯了一个错误，我们更新了账户类型，这不是我们的本意，因此储蓄账户被错误地转换为活期账户并被处理。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="96ce" class="kx ig hi kt b fi ky kz l la lb">public class Account{<br/>   String accountNumber;<br/>   String accountType;  <br/>   public Account(String accountNumber, String accountType){<br/>       this.accountNumber =accountNumber;<br/>       this.accountType=accountType;<br/>   }   <br/>   public String getAccountNumber(){<br/>      return this.accountNumber;<br/>   }<br/>   public void setAccountNumber(String accountNumber){<br/>      this.accountNumber=accountNumber<br/>   }<br/>   public String getAccountType(){<br/>      return this.accountType;<br/>   }<br/>   public void setAccountType(String accountType){<br/>      this.accountType=accountType;<br/>   }<br/>}<br/>public class TestImmutability {<br/>  public void processSavings(){<br/>    Account account = new Account("a0123", "savings");<br/>    checkValid(account);<br/>    postAccount(account);<br/>    /////.....<br/>  }<br/>  public boolean checkValid(Account account){<br/>    // run valid checks<br/>    account.setAccountType("current"); <br/>    return true;  <br/>  }<br/>}</span></pre><p id="cfbd" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">在这里跟踪这样的错误可能看起来很容易，也可能不会发生，但是想想看，如果这是一个大规模的项目，具有跨模块共享和传递的复杂值对象，那么定位和修复这样的错误并不容易。</p><p id="d28b" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">这是应该将值对象设计成不可变的的主要原因之一，这样一旦初始化，它们就不应该被改变。不变性还确保线程安全和同步数据的有效性，这有利于这种考虑。</p><p id="d76f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">有人可能会认为这可能会导致内存限制，因为这可能会导致内存中同一对象的太多副本可以共享。但是人们需要考虑我们在性能方面的权衡，其次，如果我们有<a class="ae kn" href="https://www.java67.com/2020/02/50-garbage-collection-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank">有效的垃圾收集</a>，删除和内存可用性只是时间问题。</p><p id="e0b2" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">将值对象设计为不可变的是遵循一般规则的一个例子。如果一个属性的值改变了，那么我们创建一个不同的值对象，而不是修改现有的值对象。但是也有可能值对象被设计成可变的。</p><blockquote class="kb kc kd"><p id="641b" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated">设计启发<strong class="jf hj"> #3 </strong>:出于性能原因，值对象可能是可变的。</p></blockquote><p id="9bb9" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">如果它是可变的，确保它不是共享的，因为它会在模型中产生意外的结果和完整性问题。决定值对象可变实现的因素(引用Eric Evans的DDD):</p><ol class=""><li id="7bea" class="lc ld hi jf b jg kf jk kg jo le js lf jw lg ka lh li lj lk bi translated">如果值经常变化。</li><li id="1b7a" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated">如果对象创建或删除开销很大。</li><li id="9a32" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated">如果替换会扰乱聚类。</li></ol><h1 id="ba4c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">设计不可变值对象</h1><p id="67a6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">假设下面的类被定义为不可变的:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="032f" class="kx ig hi kt b fi ky kz l la lb">public class Account {<br/>   <strong class="kt hj">private final int id</strong>;<br/>   <strong class="kt hj">private final </strong>String <strong class="kt hj">type</strong>;<br/>   <strong class="kt hj">private final </strong>String <strong class="kt hj">currency</strong>;<br/>   <strong class="kt hj">private final </strong>LocalDateTime <strong class="kt hj">createdDate</strong>;<br/>   <strong class="kt hj">private final </strong>List&lt;Entry&gt; <strong class="kt hj">entries</strong>;</span><span id="fe61" class="kx ig hi kt b fi lq kz l la lb"><strong class="kt hj">   private </strong>Account(<br/>    <strong class="kt hj">int </strong>id,<br/>    String type,<br/>    String currency,<br/>    LocalDateTime createdDate,<br/>    List&lt;Entry&gt; entries) {<br/>     <strong class="kt hj">this</strong>.<strong class="kt hj">id </strong>= id;<br/>     <strong class="kt hj">this</strong>.<strong class="kt hj">type </strong>= type;<br/>     <strong class="kt hj">this</strong>.<strong class="kt hj">currency </strong>= currency;<br/>     <strong class="kt hj">this</strong>.<strong class="kt hj">createdDate </strong>= createdDate;<br/>     <strong class="kt hj">this</strong>.<strong class="kt hj">entries </strong>= entries;<br/>   }<br/>    <br/>    <strong class="kt hj">public int </strong>getId() { <br/>      <strong class="kt hj">return id; <br/>    </strong>}<br/>    <strong class="kt hj">public </strong>String getType() { <br/>      <strong class="kt hj">return type</strong>; <br/>    }<br/>    <strong class="kt hj">public </strong>String getCurrency() { <br/>      <strong class="kt hj">return currency</strong>; <br/>    }<br/>    <strong class="kt hj">public </strong>LocalDateTime getCreatedDate() { <br/>      <strong class="kt hj">return createdDate</strong>; <br/>    }<br/>    <strong class="kt hj">public </strong>List&lt;Entry&gt; getEntries() { <br/>      <strong class="kt hj">return Collections.unmodifiableList(entries)</strong>;<br/>    }<br/>   <br/>    <strong class="kt hj">public </strong>String toString() {<br/>      <strong class="kt hj">return "Account{"<br/>      </strong>+ <strong class="kt hj">"id=" </strong>+ <strong class="kt hj">id<br/>      </strong>+ <strong class="kt hj">", type=" </strong>+ <strong class="kt hj">type<br/>      </strong>+ <strong class="kt hj">", currency=" </strong>+ <strong class="kt hj">currency<br/>      </strong>+ <strong class="kt hj">", createdDate=" </strong>+ <strong class="kt hj">createdDate<br/>      </strong>+ <strong class="kt hj">", entries=" </strong>+ <strong class="kt hj">entries<br/>      </strong>+ <strong class="kt hj">"}"</strong>;<br/>    }<br/>     <br/>    <strong class="kt hj">public int </strong>hashCode() {<br/>      return Objects.hash(<strong class="kt hj">id,type,currency,createdDate,entries)</strong>;<br/>    }</span><span id="c02a" class="kx ig hi kt b fi lq kz l la lb"><strong class="kt hj">    public boolean </strong>equals(Object another) {<br/>      <strong class="kt hj">if </strong>(<strong class="kt hj">this </strong>== another) <strong class="kt hj">return true</strong>;<br/>        <strong class="kt hj">return </strong>another <strong class="kt hj">instanceof </strong>ImmutableAccount<br/>          &amp;&amp; <strong class="kt hj">id </strong>== another.<strong class="kt hj">id<br/>          </strong>&amp;&amp; <strong class="kt hj">type</strong>.equals(another.<strong class="kt hj">type</strong>)<br/>          &amp;&amp; <strong class="kt hj">currency</strong>.equals(another.<strong class="kt hj">currency</strong>)<br/>          &amp;&amp; <strong class="kt hj">createdDate</strong>.equals(another.<strong class="kt hj">createdDate</strong>)<br/>          &amp;&amp; <strong class="kt hj">entries</strong>.equals(another.<strong class="kt hj">entries</strong>);<br/>    }</span><span id="aa8e" class="kx ig hi kt b fi lq kz l la lb">}</span></pre><p id="b06e" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">这实现了我们的目标，但是如果我们仔细观察，这里有许多样板代码，如<em class="ke"> getter </em>、<em class="ke">构造器</em>、<a class="ae kn" href="https://javarevisited.blogspot.com/2012/12/3-example-to-print-array-values-in-java.html" rel="noopener ugc nofollow" target="_blank">、T13】 toString() 、</a>、<a class="ae kn" href="https://javarevisited.blogspot.com/2013/08/10-equals-and-hashcode-interview.html#axzz7D1K8JL8x" rel="noopener ugc nofollow" target="_blank">、<em class="ke"> equals() </em>、</a><a class="ae kn" href="http://www.java67.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html" rel="noopener ugc nofollow" target="_blank">、T21【hashcode()、</a>。除此之外，我们还必须为每个数据类重复同样繁琐的过程，单调地为每条数据创建一个新的字段，创建<em class="ke"> equals() </em>、<em class="ke"> hashCode() </em>和<em class="ke"> toString() </em>方法；并创建一个接受每个字段的构造函数。</p><blockquote class="kb kc kd"><p id="79c3" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated">设计启发<strong class="jf hj"> #4 </strong>:尽可能使用值对象的自动代码生成器来处理锅炉板代码。</p></blockquote><p id="7b07" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><strong class="jf hj"> Lombok </strong>、<strong class="jf hj"> AutoValue </strong>、<strong class="jf hj"> Immutables </strong>和<strong class="jf hj"> Java Records </strong>是一些广泛使用的工具，用于处理域值对象的样板代码。但是哪一个是正确的工具呢？如果我们从高层看他们的目的，很难做出决定，因为无论如何，他们做同样的工作，但寻找精细的事实，然后做出决定。</p><h1 id="2a4e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">lombok vs AutoValue vs Immutables vs Java记录</h1><p id="c588" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kn" href="https://javarevisited.blogspot.com/2021/08/how-to-use-lombok-library-in-java.html" rel="noopener ugc nofollow" target="_blank"> Lombok </a>、AutoValue和Immutables使用标准的java注释处理来处理数据类的公共代码生成。让我们看一个例子。假设我们有一个值对象<em class="ke">帐户</em>，如下所示，看看它在每个帐户中是如何表示的</p><h2 id="34f6" class="kx ig hi bd ih lr ls lt il lu lv lw ip jo lx ly it js lz ma ix jw mb mc jb md bi translated">龙目岛:</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="317e" class="kx ig hi kt b fi ky kz l la lb">@Value<br/>@Builder<br/><strong class="kt hj">public class </strong>Account {<br/>    <strong class="kt hj">private int id</strong>;<br/>    <strong class="kt hj">private </strong>String <strong class="kt hj">type</strong>;<br/>    <strong class="kt hj">private </strong>String <strong class="kt hj">currency</strong>;<br/>    <strong class="kt hj">private </strong>LocalDateTime <strong class="kt hj">createdDate</strong>;<br/>    <strong class="kt hj">private </strong>List&lt;Entry&gt; <strong class="kt hj">entries</strong>;<br/>}</span></pre><h2 id="cb42" class="kx ig hi bd ih lr ls lt il lu lv lw ip jo lx ly it js lz ma ix jw mb mc jb md bi translated">自动赋值:</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c45f" class="kx ig hi kt b fi ky kz l la lb">@AutoValue<br/><strong class="kt hj">public abstract class </strong>Account {<br/><br/>    <strong class="kt hj">public abstract int </strong>id();<br/>    <strong class="kt hj">public abstract </strong>String type();<br/>    <strong class="kt hj">public abstract </strong>String currency();<br/>    <strong class="kt hj">public abstract </strong>LocalDateTime createdDate();<br/><br/>    @AutoValue.Builder<br/>    <strong class="kt hj">public abstract static class </strong>Builder {<br/>        <strong class="kt hj">public abstract </strong>Builder setId(<strong class="kt hj">int </strong>id);<br/>        <strong class="kt hj">public abstract </strong>Builder setType(String type);<br/>        <strong class="kt hj">public abstract </strong>Builder setCurrency(String currency);<br/>        <strong class="kt hj">public abstract </strong>Builder setCreatedDate(LocalDateTime createdDate);<br/>        <strong class="kt hj">public abstract </strong>Account build();<br/>    }<br/>}</span></pre><h2 id="d4b8" class="kx ig hi bd ih lr ls lt il lu lv lw ip jo lx ly it js lz ma ix jw mb mc jb md bi translated">不变的:</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9c26" class="kx ig hi kt b fi ky kz l la lb">@Value.Immutable<br/>@Value.Style(jdkOnly = <strong class="kt hj">true</strong>)<br/><strong class="kt hj">public interface </strong>Account {<br/>    <strong class="kt hj">int </strong>getId();<br/>    String getType();<br/>    String getCurrency();<br/>    LocalDateTime getCreatedDate();<br/>    List&lt;Entry&gt; getEntries();<br/>}</span></pre><h2 id="d9df" class="kx ig hi bd ih lr ls lt il lu lv lw ip jo lx ly it js lz ma ix jw mb mc jb md bi translated">Java记录:</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a6ce" class="kx ig hi kt b fi ky kz l la lb">public record <strong class="kt hj">Account</strong>(<strong class="kt hj">int </strong>id,<br/>    String type,<br/>    String currency,<br/>    LocalDateTime createdDate,<br/>    List&lt;Entry&gt; entries) {}</span></pre><p id="0010" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">但是他们处理的方式有一些细微的不同。</p><ol class=""><li id="e4ad" class="lc ld hi jf b jg kf jk kg jo le js lf jw lg ka lh li lj lk bi translated">Lombok使用一种非标准的方法来生成代码，也称为破解java编译器，这使它变得脆弱，并且可能在未来的java evolution中不受支持。另外，Lombok在运行时依赖于字节码操作库，如<em class="ke"> asm </em>。另一方面，AutoValue和Immutables不使用这样的攻击和依赖，从定义的模板生成代码，并使用标准的java注释。</li><li id="e1d9" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated">AutoValue看起来有点冗长，而Lombok和Immutables看起来简洁明了。AutoValue也是严格不可变的，这意味着无法定义可变对象。</li><li id="92f5" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated">构造函数中字段的顺序取决于AutoValue中的源，而在不变量中，可以定义构造函数中字段的顺序。</li><li id="46fd" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><em class="ke">账户</em>被定义为一个接口，在不变量中只有getters。通过将值对象声明为一个接口，我们封装了值对象，避免了任何副作用，并将其构建为模型，揭示了这是一个不可变类的明确意图，客户端将只能访问值。这是不变的USP。Lombok和AutoValue不支持。</li><li id="6d86" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka lh li lj lk bi translated"><a class="ae kn" href="https://javarevisited.blogspot.com/2022/03/how-to-use-record-in-java-example.html" rel="noopener ugc nofollow" target="_blank"> Java记录</a>超级干净。就我个人而言，我总是推荐使用这个而不是任何第三方库或工具。但是到目前为止，这还存在一些限制。<a class="ae kn" href="https://www.java67.com/2021/08/how-to-use-record-in-java-example.html" rel="noopener ugc nofollow" target="_blank">记录</a>是纯粹不可变的透明数据载体，你没有办法改变记录中的数据。Lombok和Immutables定义了将类声明为可变的方法。到目前为止，Record的另一个限制是它在Java 14中处于预览模式，在Java 17之前不可用。</li></ol><blockquote class="kb kc kd"><p id="c181" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated">设计启发<strong class="jf hj"> #5 </strong>:设计价值对象作为接口，实现真正的不变性。</p></blockquote><p id="8739" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">比较Lombok、AutoValue和Immutables特性的完整代码可以在这里找到:<a class="ae kn" href="https://github.com/rohsin47/lombok-autovalue-immutables" rel="noopener ugc nofollow" target="_blank">https://github.com/rohsin47/lombok-autovalue-immutables</a></p><p id="268c" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">下表比较了Lombok、AutoValue和Immutables在各种参数上的特性。</p><figure class="ko kp kq kr fd mf er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/08/how-to-use-lombok-library-in-java.html"><div class="er es me"><img src="../Images/7c8560cc3fc404946b3f3b454d294cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aoTQGFvoSihVqacFFX9-g.png"/></div></a><p class="mi mj et er es mk ml bd b be z dx translated">龙目岛vs自动价值vs不变</p></figure><h1 id="9b69" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="c783" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">理想情况下，值对象应该是<em class="ke">类型安全的</em>，<em class="ke">空安全的</em>，<em class="ke">线程安全的</em>，<em class="ke"> API不可见的</em>(封装的)，没有<em class="ke">运行时依赖，</em>并且应该有<em class="ke">可以忽略的性能成本</em>。</p><p id="4dd9" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">Lombok和Immutables是创建不可变值对象的好选择，但是建议只使用Lombok的稳定特性，如@Value、@Builder和@Data来实现，并避免实验特性。另一方面，不变量可以实现的定制和优化的数量令人印象深刻。</p><p id="d39d" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">诸如属性的自动空处理、确保强制属性、声明构建器、定义修饰符数据类以及<a class="ae kn" href="https://javarevisited.blogspot.com/2013/02/how-to-convert-json-string-to-java-object-jackson-example-tutorial.html" rel="noopener ugc nofollow" target="_blank"> JSON序列化对Jackson绑定的支持</a>等特性使得不可变成为值对象的更好选择。</p><p id="9594" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><strong class="jf hj">参考文献</strong>:</p><ul class=""><li id="35c9" class="lc ld hi jf b jg kf jk kg jo le js lf jw lg ka mm li lj lk bi translated">Eric Evans的领域驱动设计(蓝皮书)</li><li id="609a" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka mm li lj lk bi translated"><a class="ae kn" href="https://www.martinfowler.com/bliki/ValueObject.html" rel="noopener ugc nofollow" target="_blank">https://www.martinfowler.com/bliki/ValueObject.html</a></li><li id="4a4a" class="lc ld hi jf b jg ll jk lm jo ln js lo jw lp ka mm li lj lk bi translated"><a class="ae kn" href="https://immutables.github.io/immutable.html" rel="noopener ugc nofollow" target="_blank">https://immutables.github.io/immutable.html</a></li></ul></div></div>    
</body>
</html>