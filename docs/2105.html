<html>
<head>
<title>Advance Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级数据结构</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/advance-data-structures-f611f0cc9049?source=collection_archive---------1-----------------------#2022-05-11">https://medium.com/javarevisited/advance-data-structures-f611f0cc9049?source=collection_archive---------1-----------------------#2022-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="d610" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">高级数据结构</h2><div class=""/><div class=""><h2 id="90bb" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">软件工程师需要知道的一些高级数据结构</h2></div><p id="02bc" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">大家好👋,</p><p id="bb11" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在这一集里，我们将会看到一些基本数据结构模块中通常不会涉及的高级数据结构。但它肯定会帮助每个人在复杂问题中以更有效的方式设计我们的程序。我们将会看到二叉查找树树、树莓树、T2树、红黑树和八字树。BST可能包含在基本数据结构中。但是我将在这里再次讨论它，以便更好地理解其他主题，因为这些数据结构是从BST发展而来的。不再拖延，让我们进入主题。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><a href="https://www.java67.com/2020/02/top-40-binary-tree-interview-questions.html"><div class="er es kd"><img src="../Images/c2f8d1bb77c742edb0b4471d5c67e43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bJcRJpNuBp4MQ4XJ"/></div></a><p class="kl km et er es kn ko bd b be z dx translated">照片由<a class="ae kc" href="https://unsplash.com/es/@vimarovi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维克多·罗德里格兹</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="b142" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jp la lb lc jt ld le lf jx lg lh li ho bi translated"><strong class="ak">二叉查找树</strong></h2><p id="ceb8" class="pw-post-body-paragraph jg jh hi ji b jj lj is jl jm lk iv jo jp ll jr js jt lm jv jw jx ln jz ka kb hb bi translated">BST又名<a class="ae kc" rel="noopener" href="/javarevisited/20-binary-tree-algorithms-problems-from-coding-interviews-c5e5a384df30">二叉查找树</a>是一个基于节点的数据结构，有一些基本的属性需要遵循。BST的每个节点都应遵循以下属性。</p><ul class=""><li id="6512" class="lo lp hi ji b jj jk jm jn jp lq jt lr jx ls kb lt lu lv lw bi translated">在左侧子树中只能找到键低于节点键的节点。</li><li id="d018" class="lo lp hi ji b jj lx jm ly jp lz jt ma jx mb kb lt lu lv lw bi translated">只有键大于节点键的节点才会出现在节点的右子树中。</li><li id="4fa5" class="lo lp hi ji b jj lx jm ly jp lz jt ma jx mb kb lt lu lv lw bi translated">左侧和右侧的每个子树也必须是二叉查找树。</li></ul><p id="f7d0" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">下图将让您更好地理解BST的属性。所有大于3的数字都在树的右侧，而较小的元素在树的右侧。下面的树是按照3，6，5，10，2，1的键插入顺序生成的。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><a href="https://www.java67.com/2016/07/how-to-implement-preorder-traversal-of-binary-tree-in-java.html"><div class="er es mc"><img src="../Images/00f7ac98298fd772beff941d695dae5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*WklPHgOoY7mB04mujws98A.png"/></div></a><p class="kl km et er es kn ko bd b be z dx translated">图1</p></figure><p id="a2d1" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">插入顺序将决定BST的形状。如果我们插入10，5，6，1，2，3。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><a href="https://javarevisited.blogspot.com/2016/10/post-order-binary-tree-traversal-in-java-iteration-recursion.html#axzz7DyRjLUX9"><div class="er es md"><img src="../Images/42817881070fde073bed69d710fa3ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*C4tF_RNEQ76l25JFMscECw.png"/></div></a><p class="kl km et er es kn ko bd b be z dx translated">图2</p></figure><p id="800b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">BST的效率取决于BST 的<strong class="ji hs">高度。但是我们不能确定，因为它可能没有适当的平衡，并且比必要的高度要高。让我们比较一下图1和图2。尽管两者具有相同的元素，但图1中的BST更有效，因为其高度低于图2中的BST。</strong></p><p id="8dea" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">BST支持多种操作，如插入、删除、搜索等。在每次操作之后，BST树中必须满足上述每个BST属性。插入、删除和查询需要O(h)时间。这里h表示树的高度。第一棵树的高度是二，而第二棵树的高度是四。如果你想进一步了解英国夏令时，你可以观看下面的视频。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="me mf l"/></div><p class="kl km et er es kn ko bd b be z dx translated">BST树插入和删除说明</p></figure><h2 id="75ba" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jp la lb lc jt ld le lf jx lg lh li ho bi translated">Treap</h2><p id="6aec" class="pw-post-body-paragraph jg jh hi ji b jj lj is jl jm lk iv jo jp ll jr js jt lm jv jw jx ln jz ka kb hb bi translated">Treaps是一种数据结构，具有树和堆的属性(<strong class="ji hs"> Tree + Heap = Treap </strong>)。堆属性用于节点的随机排序。Treap是一个BST，它以随机的方式对节点进行排序。treap中的节点有两个属性。首先是类似于BST的密钥。第二个是优先级属性(独立选择的随机数)。在Treap中，键服从二叉搜索树属性，而优先级服从堆顺序属性。如果我们考虑一个treap的最小堆实现，必须保持以下属性。</p><ul class=""><li id="c98c" class="lo lp hi ji b jj jk jm jn jp lq jt lr jx ls kb lt lu lv lw bi translated">如果v是u的左孩子，那么v.key u.key</li><li id="4649" class="lo lp hi ji b jj lx jm ly jp lz jt ma jx mb kb lt lu lv lw bi translated">如果v是u的右子，那么v.key &gt; u.key</li><li id="70a0" class="lo lp hi ji b jj lx jm ly jp lz jt ma jx mb kb lt lu lv lw bi translated">如果v是u的孩子，那么v.priority &gt; u.priority</li></ul><p id="7a18" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">诸如插入、删除、搜索等处理操作的预期时间复杂度是O(h)。这是对数n的顺序。</p><p id="6443" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在开始treap操作之前，你必须清楚地理解树的旋转。树旋转是一种改变节点/子树的位置而不违反任何树或堆属性的操作。</p><p id="5182" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">树的旋转以恒定的时间发生。下面的视频给出了一个更好的树木旋转清晰的看法。在进入以下部分之前，请确保您清楚了解以下视频的内容。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="me mf l"/></div><p class="kl km et er es kn ko bd b be z dx translated">来自Youtube的树旋转</p></figure><p id="2de7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我给了下面一个treap插入视频，让你更好地理解treap上的插入。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="me mf l"/></div><p class="kl km et er es kn ko bd b be z dx translated">从Youtube上截取插入内容</p></figure><p id="df87" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果你清楚地理解了treaps中的插入。理解treaps中的删除会更容易。如果您想在treap中延迟一个节点，您需要将它向下旋转到叶节点。然后把它从树上扔下来。搜索和BST一模一样。</p><h2 id="e870" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jp la lb lc jt ld le lf jx lg lh li ho bi translated">红色黑色的树</h2><p id="26eb" class="pw-post-body-paragraph jg jh hi ji b jj lj is jl jm lk iv jo jp ll jr js jt lm jv jw jx ln jz ka kb hb bi translated">一棵红黑树是一个<a class="ae kc" rel="noopener" href="/javarevisited/20-binary-tree-algorithms-problems-from-coding-interviews-c5e5a384df30">平衡的BST </a>。因此对于n个节点，操作的时间复杂度为O(log2 n)。红黑树中的每个节点除了类似于BST的key属性之外，还有一个color属性。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mg"><img src="../Images/a876a1fd67c95a5fda00c0c65b877731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ll6cspLnUNekHE12"/></div></div><p class="kl km et er es kn ko bd b be z dx translated">安妮·斯普拉特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6cab" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">以下是红黑树必须具备的主要属性。</p><ul class=""><li id="292e" class="lo lp hi ji b jj jk jm jn jp lq jt lr jx ls kb lt lu lv lw bi translated">RBT中的每个节点不是黑色就是红色。</li><li id="0b45" class="lo lp hi ji b jj lx jm ly jp lz jt ma jx mb kb lt lu lv lw bi translated">RBT的根和叶是黑色的。</li><li id="7ee5" class="lo lp hi ji b jj lx jm ly jp lz jt ma jx mb kb lt lu lv lw bi translated">如果RBT中的节点是红色的，则其父节点是黑色的。</li><li id="ac5a" class="lo lp hi ji b jj lx jm ly jp lz jt ma jx mb kb lt lu lv lw bi translated">从任何节点到其后代叶子的所有简单路径都有相同数量的黑色节点。</li></ul><p id="6e48" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">你需要很好地理解树的旋转来理解<a class="ae kc" href="https://javarevisited.blogspot.com/2011/12/treemap-java-tutorial-example-program.html" rel="noopener ugc nofollow" target="_blank">红黑树</a>中的删除和插入。由于旋转需要恒定的时间，红黑树任务中的操作对于n个节点来说需要O(log2 n)的时间。下面的视频将解释插入和删除是如何在红黑树中发生的。</p><p id="915a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">插在红黑色的树上</strong></p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="023c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">红色黑树上的缺失</strong></p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="me mf l"/></div></figure><ul class=""><li id="48de" class="lo lp hi ji b jj jk jm jn jp lq jt lr jx ls kb lt lu lv lw bi translated">下面的红黑树是用10，5，6，1，2，3的键插入顺序生成的。让我们将它与图2中的BST进行比较。两者具有相同的钥匙插入顺序。但是红黑树更平衡。</li></ul><figure class="ke kf kg kh fd ki er es paragraph-image"><a href="https://www.java67.com/2019/10/difference-between-binary-tree-avl-red-black-binary-search-tree.html"><div class="er es ml"><img src="../Images/9f81527d68d17337fac1a230a69033d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sozB-cnUQo_0Tagw3FIRQ.png"/></div></a><p class="kl km et er es kn ko bd b be z dx translated">图3 —红色黑色树</p></figure><ul class=""><li id="463e" class="lo lp hi ji b jj jk jm jn jp lq jt lr jx ls kb lt lu lv lw bi translated">当我们在红黑树中搜索一个键时，树的结构没有变化。</li></ul><h2 id="2d2e" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jp la lb lc jt ld le lf jx lg lh li ho bi translated">八字树</h2><p id="7955" class="pw-post-body-paragraph jg jh hi ji b jj lj is jl jm lk iv jo jp ll jr js jt lm jv jw jx ln jz ka kb hb bi translated">二分搜索法树并不总是平衡的(如图2所示)。因此运算的时间复杂度甚至可能达到O(n)。八字树也是BST。但是，在展曲树的顶部执行每个操作之后，它是平衡的。它会自我调节以保持平衡。m个操作的序列的时间复杂度为O(m log n)。但是，每个操作的摊余成本为O(log n)。</p><p id="8f66" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">张开树在每次操作后通过旋转将期望的节点带到根。随着节点被访问，八字树随着时间的推移变得更加平衡(自我调整，高度降低)。展曲树上的每个操作都有助于利用时间局部性。它有助于当前项目在不久的将来被再次访问，而无需花费太多成本。</p><p id="c4b0" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">让我们看看在下面的gif图像中以同样的顺序在一个八字形树中插入7，3，9。7首先被插入到一个空的spaly树中，它是根，所以那里没有变化。则相对于BST属性插入3。然后3被旋转到根，因为它是被访问的最后一个元素。那么9被插入到关于BST属性的输出展曲树中。然后9也旋转，直到它成为根。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es mm"><img src="../Images/c2ffb47ba2f0b12abba629e02da879f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*WQoYk-a3e9KwDf9GeTCZ9A.gif"/></div><p class="kl km et er es kn ko bd b be z dx translated">来源:<a class="ae kc" href="https://brilliant.org/wiki/splay-tree/" rel="noopener ugc nofollow" target="_blank">https://brilliant.org/wiki/splay-tree/</a></p></figure><p id="45da" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">在八字树中插入</strong></p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="2899" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">红黑树中的缺失</strong></p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="me mf l"/></div></figure><ul class=""><li id="2174" class="lo lp hi ji b jj jk jm jn jp lq jt lr jx ls kb lt lu lv lw bi translated">在展开树中搜索一个键时，如果找到该键，它将作为根键旋转。如果没有找到，最后访问的元素将作为根元素旋转。您可以在下面的视频中查看所有的展开树操作，以了解更多关于展开树的信息。</li></ul><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="me mf l"/></div></figure><ul class=""><li id="0dae" class="lo lp hi ji b jj jk jm jn jp lq jt lr jx ls kb lt lu lv lw bi translated">所有类型的高级数据结构操作都可以在这里<a class="ae kc" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" rel="noopener ugc nofollow" target="_blank">可视化</a>。动画将有助于更多的理解。</li></ul></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="5f64" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我相信你学了一些高级数据结构。如果您有任何问题或任何澄清，不要犹豫，通过回复部分与我联系。感谢你花宝贵的时间阅读这篇博客，我相信这将激励你继续阅读我的其他博客<a class="ae kc" href="https://sthenusan.medium.com/" rel="noopener">这里</a>。</p><p id="146f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><em class="mu">喜欢这篇文章吗？成为</em> <a class="ae kc" href="https://sthenusan.medium.com/membership" rel="noopener"> <em class="mu">中等会员</em> </a> <em class="mu">继续学习没有任何限制。如果你使用上面的链接，我会收到你的一部分会员费，不需要你额外付费。提前感谢。</em></p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mv"><img src="../Images/c1181f767a09a5c3395beab97ad07dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-FTiyZXN04cqtcBG"/></div></div><p class="kl km et er es kn ko bd b be z dx translated"><a class="ae kc" href="https://unsplash.com/@calebchen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Caleb Chen </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div></div>    
</body>
</html>