<html>
<head>
<title>Eclipse Collections Now Supports Indirect Sorting of Primitive Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Eclipse集合现在支持原语列表的间接排序</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/eclipse-collections-now-supports-indirect-sorting-of-primitive-lists-e2447ca5dbc3?source=collection_archive---------1-----------------------#2020-07-30">https://medium.com/javarevisited/eclipse-collections-now-supports-indirect-sorting-of-primitive-lists-e2447ca5dbc3?source=collection_archive---------1-----------------------#2020-07-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="040f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">有时候获得结果的最好方式是间接的</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9e09505c6edd19e796f9663258970c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rg7LfNQR1BCTPRPDTpYKJg.jpeg"/></div></div></figure><p id="9bea" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我最近在基本列表类型上实现了间接排序功能，这是由<a class="ae kf" href="https://www.eclipse.org/collections/" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a> <a class="ae kf" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank">项目</a>支持的许多集合类型中的一部分。</p><p id="f8c1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">之前在原始集合上有一个排序功能，即<code class="du kg kh ki kj b">sortThis()</code>方法，它是Java JDK <code class="du kg kh ki kj b">Arrays.sort</code>方法的包装器。原始列表实现的局限性是，它只能通过元素和元素的自然顺序对数组进行排序，而不是通过元素的函数和/或一些定制的比较器。</p><p id="010f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除了元素值的自然顺序之外，为什么还要进行排序呢？以下是一些可能的原因:</p><ul class=""><li id="08bb" class="kk kl hi jl b jm jn jp jq js km jw kn ka ko ke kp kq kr ks bi translated">反向排序</li><li id="66fc" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">按绝对值排序</li><li id="3ab9" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">将索引构建到不可能或不切实际重新排序的有序数据结构中(例如，在内存列存储中实现的表格数据集)</li></ul><p id="320f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这也支持在旧的开放特征请求中描述的用于JDK的功能(参见"<em class="ky"> (coll) Arrays.sort不能用比较器</em>"<a class="ae kf" href="https://bugs.openjdk.java.net/browse/JDK-4709823" rel="noopener ugc nofollow" target="_blank">https://bugs.openjdk.java.net/browse/JDK-4709823</a>)对原始数组进行排序)。</p><p id="d555" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kg kh ki kj b">sortThis</code>方法有三个新版本:支持比较器的常规版本，支持采用提取器函数的“by”模式的版本，以及两者的组合。这填补了原语和对象集合API之间存在的对称空白。</p><p id="f4b9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果单词“by”pattern和“symmetry gap”对你来说没什么意义，请查看唐纳德·拉布的博客以获得解释:</p><ul class=""><li id="282d" class="kk kl hi jl b jm jn jp jq js km jw kn ka ko ke kp kq kr ks bi translated">介绍对称的概念:<a class="ae kf" rel="noopener" href="/@donraab/symmetric-sympathy-2c59d4541d60">对称共鸣</a></li><li id="4ecc" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">关于对称性的更多信息:<a class="ae kf" rel="noopener" href="/oracledevs/finding-symmetry-27944c74b6d4">寻找对称性</a></li><li id="f5f3" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">【靠】方法:<a class="ae kf" rel="noopener" href="/javarevisited/by-yourself-some-time-e16c0f488847">靠自己一些时间</a></li></ul><p id="9658" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是在旧的<code class="du kg kh ki kj b">sortThis()</code>方法之后列出的<code class="du kg kh ki kj b">MutableIntList</code>上的三个新的排序API方法:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="689e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除了不支持排序的<code class="du kg kh ki kj b">MutableBooleanList</code>之外，其他所有可变原始列表类型都引入了等效的API。</p><p id="684f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以下是一些使用新API的示例:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="6cc4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">新的<code class="du kg kh ki kj b">sort</code>方法从<a class="ae kf" href="https://www.eclipse.org/collections/" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>的10.3版本开始可用。</p></div></div>    
</body>
</html>