<html>
<head>
<title>Starvation Of Threads In Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中线程的匮乏</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/starvation-of-threads-in-java-e3d6bcfeb770?source=collection_archive---------1-----------------------#2020-10-18">https://medium.com/javarevisited/starvation-of-threads-in-java-e3d6bcfeb770?source=collection_archive---------1-----------------------#2020-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5c5ffcf7ae2cb9ffcc5e4974356efc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*6UKywanXwULKtLuIoAZbPA.png"/></div></figure><p id="76c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">定义:</strong>Java中的线程饥饿据说发生在某个特定的线程无法访问对象或资源，导致等待和执行时间增加的时候。</p><p id="e047" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当两个或更多线程被分配给CPU(中央处理器)并在执行中花费大量时间时，就会发生饥饿，因为其他等待线程无法获得CPU来继续执行。</p><p id="c54d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">饿死的原因:</strong></p><p id="3d7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">java中线程饥饿的原因有很多，下面介绍了其中一些原因:</p><ul class=""><li id="5782" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">高优先级运行线程:</strong>可能会有这样的情况，高优先级线程通过占用CPU运行，并且需要大量处理，这需要大量时间来完成，因此为了完全执行这项工作，具有低优先级顺序的其他线程必须等待很长时间，这将导致资源匮乏。</li><li id="a258" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj">Java中的Synchronized Block:</strong>可能会出现这样的情况，线程被允许进入<a class="ae jy" href="https://www.java67.com/2013/01/difference-between-synchronized-block-vs-method-java-example.html" rel="noopener ugc nofollow" target="_blank"> synchronized block </a>的顺序与它们被编程调度的顺序相同，这导致另一个线程等待资源和对象，从而导致饥饿，其中除了特定线程之外的其他线程被给予C.P.U .用于其执行。</li><li id="4eb2" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><strong class="io hj">等待对象的线程永远等待:</strong>Java中的<a class="ae jy" href="https://javarevisited.blogspot.com/2015/07/how-to-use-wait-notify-and-notifyall-in.html#axzz6e8hmwujv" rel="noopener ugc nofollow" target="_blank"> notify()方法无法跟踪线程，如果有多个线程，哪个特定的线程正在被唤醒，因此可能存在任何线程正在被处理而其他线程从未被调用执行的风险。</a></li></ul><p id="3794" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">线程饥饿示例</strong></p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="5cef" class="ki kj hi ke b fi kk kl l km kn">class Starvation extends Thread { <br/> static int count = 1; <br/> public void run() { <br/>  System.out.println(count + " Thread execution starts"); <br/>  System.out.println("Thread execution completes"); <br/>  count++; <br/> } <br/> public static void main(String[] args) throws InterruptedException { <br/>  System.out.println("Parent thread execution starts"); <br/><br/>  /* Priority of each thread given. */<br/>        /* Thread 1 with priority 7. */<br/>  Starvation thread1 = new Starvation(); <br/>  thread1.setPriority(7); <br/>        /* Thread 2 with priority 6. */<br/>  Starvation thread2 = new Starvation(); <br/>  thread2.setPriority(6); <br/>        /* Thread 3 with priority 5. */<br/>  Starvation thread3 = new Starvation(); <br/>  thread3.setPriority(5);<br/>        /* Thread 4 with priority 4. */<br/>  Starvation thread4 = new Starvation(); <br/>  thread4.setPriority(4); <br/>        /* Thread 5 with priority 3. */<br/>  Starvation thread5 = new Starvation(); <br/>  thread5.setPriority(3); <br/><br/>  thread1.run(); <br/>  thread2.run(); <br/>  thread3.run(); <br/>  thread4.run(); <br/><br/>  /* Here thread 5 have to wait because of the <br/>     other threads */<br/>  thread5.run(); <br/><br/>  System.out.println("Parent thread execution completes"); <br/> } <br/>}</span></pre><p id="fd04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">上述代码的输出将是:</strong></p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="f2a8" class="ki kj hi ke b fi kk kl l km kn">Parent thread execution starts<br/>1 Thread execution starts<br/>Thread execution completes<br/>2 Thread execution starts<br/>Thread execution completes<br/>3 Thread execution starts<br/>Thread execution completes<br/>4 Thread execution starts<br/>Thread execution completes<br/>5 Thread execution starts<br/>Thread execution completes<br/>Parent thread execution completes.</span></pre><p id="840c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">消除饥饿的要点:</strong></p><p id="636c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">消除线程匮乏的一些要点如下:</p><ul class=""><li id="25c1" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">通过<code class="du ko kp kq ke b">Thread.yield()</code>方法的实现，当线程在进程中释放锁后获得一个公平的机会来占用CPU，并可以获得一些时间来完成它的执行，直到原始线程再次获得对CPU的控制</li><li id="2ef9" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">还可以使用<a class="ae jy" href="http://www.java67.com/2015/06/how-to-pause-thread-in-java-using-sleep.html" rel="noopener ugc nofollow" target="_blank"> Thread.sleep() </a>方法将机会给予其他线程执行。</li></ul><h2 id="935c" class="ki kj hi bd kr ks kt ku kv kw kx ky kz ix la lb lc jb ld le lf jf lg lh li lj bi translated">你可能喜欢的其他线程文章</h2><div class="lk ll ez fb lm ln"><a href="https://javarevisited.blogspot.com/2020/01/what-is-happens-before-in-java-concurrency.html" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab dw"><div class="lp ab lq cl cj lr"><h2 class="bd hj fi z dy ls ea eb lt ed ef hh bi translated">Java并发中的先发制人是什么？一个例子</h2><div class="lu l"><h3 class="bd b fi z dy ls ea eb lt ed ef dx translated">几天前，我的一位读者在LinkedIn上给我发消息，谈到他最近面临的一个Java面试问题…</h3></div><div class="lv l"><p class="bd b fp z dy ls ea eb lt ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb ik ln"/></div></div></a></div><div class="lk ll ez fb lm ln"><a href="https://javarevisited.blogspot.com/2020/04/difference-between-atomic-volatile-and-synchronized-in-java-multi-threading.html" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab dw"><div class="lp ab lq cl cj lr"><h2 class="bd hj fi z dy ls ea eb lt ed ef hh bi translated">Java中原子、易变和同步的区别？</h2><div class="lu l"><h3 class="bd b fi z dy ls ea eb lt ed ef dx translated">大家好，很多人问我关于Java并发中的易变、同步和易变变量…</h3></div><div class="lv l"><p class="bd b fp z dy ls ea eb lt ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="lw l"><div class="mc l ly lz ma lw mb ik ln"/></div></div></a></div><div class="lk ll ez fb lm ln"><a rel="noopener follow" target="_blank" href="/javarevisited/java-threadlocal-the-boon-and-the-bane-18263fa4f64"><div class="lo ab dw"><div class="lp ab lq cl cj lr"><h2 class="bd hj fi z dy ls ea eb lt ed ef hh bi translated">Java线程本地——好处和坏处</h2><div class="lu l"><h3 class="bd b fi z dy ls ea eb lt ed ef dx translated">最近，我和我的团队正在对某段代码进行一些性能测试(特别是一个HTTP…</h3></div><div class="lv l"><p class="bd b fp z dy ls ea eb lt ed ef dx translated">medium.com</p></div></div><div class="lw l"><div class="md l ly lz ma lw mb ik ln"/></div></div></a></div></div></div>    
</body>
</html>