# Java 多线程中的线程干扰

> 原文：<https://medium.com/javarevisited/thread-interference-in-java-multi-threading-latest-534746003441?source=collection_archive---------4----------------------->

## JAVA 多线程——JAVA 中的线程干扰

## 通过示例了解竞争条件、线程堆栈和堆内存。

![](img/445328e1d3d41356e1a382199e958fef.png)

在 [Unsplash](https://unsplash.com/s/photos/programming?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上由 [Max Duzij](https://unsplash.com/@max_duz?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍照

线程干扰或竞态条件是多线程面试中被问得最多的问题之一。当您开始学习多线程时，您的重点应该是基础知识，而不是难懂的概念。在了解任何东西之前，你必须知道如何使用**线程**类、**可运行**接口和**匿名类线程**来创建线程。

一旦你清楚了如何创建和运行自己的线程，你就可以继续学习一些更复杂的概念，比如 ***线程干扰、死锁、线程同步、锁定机制、ArrayBlockingQueue、线程饥饿等*** *。*

通过这篇文章，我将解释一些重要的概念，如*线程堆栈、堆内存*，然后借助例子解释*线程干扰*。

## 什么是线程栈和堆内存？

当我们运行一个 java 应用程序时，操作系统会给这个应用程序分配一些堆内存来存储和执行程序。这个应用程序在执行时被称为**进程**。现在，在同一个应用程序中，我们可以有多个线程，每个线程可以执行不同的任务，如 IO、数据库操作等。

同一个进程(应用程序)的所有线程共享这个进程的堆内存。另一方面，该应用程序的每个线程都有自己的名为 ***线程堆栈*** 的内存，并在其中存储 ***局部变量*** 。

> 请注意，当我们创建一个类的对象时，该对象存储在堆中，而不是在线程堆栈中。线程堆栈是分配给每个线程的私有内存，只存储局部变量。

我已经写了一篇关于过程和线程的详细文章。如果你还没有看完这篇文章，我建议你看一遍。

</javarevisited/process-and-thread-context-switching-do-you-know-the-difference-updated-8fd93877dff6>  

## 进程及其多线程:

现在让我们利用到目前为止所学的知识。下面我写了一个 java 程序(应用程序),因此当它正在执行时，我们可以称它为**进程**。这个进程将被分配一些堆内存。在同一个应用程序中，我创建了两个最终调用 **run** 方法的线程。此外，每个线程通过 run 方法调用另一个类的`**doCountDown()**` 方法，因为每个线程有一个字段`**countDown**`。

注意，每个线程都有自己的线程堆栈来存储`**doCountDown()**` 方法的任何局部变量。

现在浏览一遍程序。你能试着预测或猜测可能的产量吗？

当变量“I”不是共享的(它在线程堆栈上)时的线程干扰/竞争情况

你得到输出了吗？如果没有，也没关系。

您可以查看下面的输出。

## 输出:

```
Thread-1 i = 5
Thread-2 i = 5
Thread-2 i = 4
Thread-2 i = 3
Thread-2 i = 2
Thread-2 i = 1
Thread-1 i = 4
Thread-1 i = 3
Thread-1 i = 2
Thread-1 i = 1
```

现在我来解释一下为什么每个数字要打印两次，为什么不维持顺序。

1.  好了，现在你已经知道有两个线程，这两个线程都调用了`***run()***` 方法，然后调用了`***doCountDown()***` 方法。在`***doCountDown()***` 中有一个局部变量***'***`***i***`***'***'，它是由每个线程存储在线程栈中，而不是堆中。现在两个线程都有自己的**变量***'***`***i***`***'***的副本，因此每个数字都打印两次，因为循环执行了两次。**
2.  **因为这两个线程不停地一个接一个地切换，所以没有保持顺序。现在让我们假设最初，两个线程都有一个值***'***`***i***`***'****作为 ***5*** 。现在，第一个线程将该值打印为`**[5]**`，并且发生了上下文切换，然后第二个线程也打印其自身***'***`***i***`***'***的值作为`**[5]**`，并且通过递减***'***'***`***i***`***'***的值来保持打印一旦第二个线程完成了它的执行，第一个线程就开始打印它自己的***’***`***i***`***’***的值，方法是将它递减→ `**[4,3,2,1]**`。******

> *一个非常重要的注意事项:每次运行程序时，我都会得到不同的输出，因为上下文切换可以发生在 doCountDown 方法中的任何地方。*

# *可能发生上下文切换的点有:*

1.  ***for 循环中的初始化***
2.  ***循环中的条件检查***
3.  ***减量操作***
4.  *最后，打印行语句，因为这一行包含一个**字符串连接***

*这是这两个线程之间可能发生上下文切换的 4 个点，并且不保证每次执行时的顺序相同。*

# *如果我们把局部变量‘I’改成倒计时对象的一个字段变量会怎么样？*

*检查下面的程序，我刚刚把局部变量' I '改成了一个字段变量，现在这一次试着预测/猜测输出。*

*共享变量“I”时的线程干扰/竞争情况(它在堆上)*

*得到输出了吗？不，没关系。只需查看下面可能的输出之一。*

## *输出:*

```
*Thread-1 i = 5
Thread-2 i = 5
Thread-1 i = 4
Thread-2 i = 3
Thread-2 i = 1
Thread-1 i = 2*
```

*在上面的输出中，`**thread1**`和`**thread2**`都从堆中读取整数***‘I’***的值作为 **5** 。`**thread1**`执行打印语句并打印 5，然后上下文切换到`**thread2**`。然后`**thread2**`执行 print 语句，打印 5，并从 5 减为 4。现在，上下文再次切换回`**thread1**`，它打印 4 并将其递减到 3，然后上下文切换到`**thread2**`。然后`**thread2**` 打印 3 并将其递减为 2，再次上下文切换到`**thread1**`，然后`**thread1**`准备打印 2 的打印语句，但是在上下文切换到`**thread2**`之前，它将【T19’‘I’递减为 1 并打印 1，最后上下文切换到已经准备好打印语句的`**thread1**`，以将**‘I’**的值打印为 2。因此输出 `**[5,5,4,3,1,2]**`*

## *另一个可能的输出:*

```
*Thread-2 i = 5
Thread-2 i = 4
Thread-2 i = 3
Thread-2 i = 2
Thread-2 i = 1
Thread-1 i = 0*
```

*对于上面的输出，我建议您像我在第一个输出中那样跟踪它。另外，请注意，该程序的每次执行都会导致不同的输出，并且不保证任何固定的输出。这是因为这两个线程之间发生了线程上下文切换。*

> *这个概念也被称为竞争条件。*

****目前就这些。我希望这篇文章能澄清你对线程干扰和竞争条件的概念。****

****你可以在这里*** ***跟我联系*** [***。***](/@basecs101)*