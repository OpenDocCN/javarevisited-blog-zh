<html>
<head>
<title>Getting started with RabbitMQ in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot rabbit MQ入门</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/getting-started-with-rabbitmq-in-spring-boot-6323b9179247?source=collection_archive---------0-----------------------#2022-04-09">https://medium.com/javarevisited/getting-started-with-rabbitmq-in-spring-boot-6323b9179247?source=collection_archive---------0-----------------------#2022-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f58608a5aa16e186b9e3231a1f115dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPQzjC2Q5mEIe4kBcPprfg.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">这只是我出于审美目的拍摄的一张照片，:D</p></figure><p id="7bec" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">RabbitMQ是部署最广泛的开源消息代理。它为您提供了一些很好的特性，帮助您使您的应用程序异步，并卸载一些关键逻辑，以便您可以专注于您的业务代码。在本文中，我已经展示了在<a class="ae js" rel="noopener" href="/javarevisited/10-best-java-microservices-courses-with-spring-boot-and-spring-cloud-6d04556bdfed?source=rss-bb36d8439904------2&amp;utm_source=dlvr.it&amp;utm_medium=linkedin"> spring boot项目</a>中开始使用RabbitMQ、自动创建队列和交换、在消费者上配置重试能力、处理错误和分布式跟踪的最简单方法。</p><p id="8c65" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我来分享一个搞笑的事件。当我第一次开始使用rabbitMQ时，我去了网站，发现了那个<a class="ae js" href="https://www.rabbitmq.com/getstarted.html" rel="noopener ugc nofollow" target="_blank">教程</a>页面。在那个页面上有6个不同语言的常见场景的教程。嘿！Java教程就在python下面。它看起来还是一样的…</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2014/03/top-10-websphere-mq-series-interview-questions-answers-active-rabbit.html"><div class="er es jt"><img src="../Images/dd815f3bc658f50935506af379f971c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SvCZA53AJkkYysrj"/></div></a></figure><p id="3ed0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后我浏览了几页java教程，惊讶于它的易用性。只需要创建一个连接工厂，声明通道，用channels basicPublish方法发布，用delivery回调接收。</p><p id="02d5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">是的，这些步骤帮助我整合了我的用例，甚至将我的应用程序部署到生产中。然后在另一个项目中，我也以这种方式开始，在我脑海中的某个地方，我不断听到一个声音..“应该有更干净的办法！，应该有更好的办法！!"。相信我，更好的方法总是在我眼前，但我却看不见。在同一个教程页面上有…</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/05/top-16-jms-java-messaging-service-interview-questions-answers.html"><div class="er es jt"><img src="../Images/e0b31b9067d5d77d0fcb6f4fbeb05eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lywixs1ydMhucNEj"/></div></a></figure><p id="6956" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">每个教程的春季AMQP </strong>版本正是我所需要的，但从来不知道它的存在。</p><p id="991d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://spring.io/projects/spring-amqp" rel="noopener ugc nofollow" target="_blank"> Spring AMQP </a>让RabbitMQ的开发更有弹性。它提供了监听器容器、rabbitTemplate和rabbitAdmin。所以让我们来看看一些行动吧！</p><h1 id="1a71" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置RabbitMQ</h1><p id="425b" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">因此，在做任何事情之前，我们需要有一个RabbitMQ实例运行，以便与它进行交互，如果您没有这样的实例的话。你可以使用下面的docker compose快速得到一个。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="c76f" class="lg jz hi lc b fi lh li l lj lk">version: '3.1'<br/><br/>services:<br/> rabbitmq:<br/>   image: rabbitmq:management<br/>   restart: no<br/>   ports:<br/>     - "5672:5672"<br/>     - "15672:15672"</span></pre><p id="709f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里5672端口由应用程序使用，在15672上我们得到一个用于管理的web界面。</p><p id="1bdf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">打开你的浏览器，点击localhost:15672，你会看到下面的页面:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/11/why-devops-engineer-learn-docker-kubernetes.html"><div class="er es jt"><img src="../Images/5acabb992b36a605cd6b81f109b1d5cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t_OcFbxhYUOdHkJV"/></div></a></figure><p id="e02a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用guest/guest作为用户名和密码。如果您正在将rabbitmq部署到生产环境中，那么更改默认凭证总是一个好主意。但是现在应该没事了。</p><h1 id="5835" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在Spring boot应用程序中添加依赖关系</h1><p id="77a6" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">要使用rabbitMQ，我们需要添加<strong class="iw hj"> spring-boot-starter-amqp </strong>依赖项。由于我使用的是maven，我将在pom.xml中添加以下内容:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="4630" class="lg jz hi lc b fi lh li l lj lk">&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="a880" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我还需要在配置文件中添加以下配置:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="c402" class="lg jz hi lc b fi lh li l lj lk">spring:<br/> rabbitmq:<br/>   host: localhost<br/>   port: 5672<br/>   username: guest<br/>   password: guest</span></pre><p id="92dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在spring amqp知道我们的rabbitMQ在哪里，以及使用哪个凭证来连接它。</p><p id="851b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了让我在这里展示的例子有关联，我们要做的是。我们将公开一个<strong class="iw hj">用户注册</strong> <a class="ae js" href="https://javarevisited.blogspot.com/2021/09/how-to-return-different-http-status-from-sprnig-mvc-controller.html" rel="noopener ugc nofollow" target="_blank">控制器</a>，接收包含姓名、电子邮件等的有效载荷，然后在队列中发布。我们假设注册一个用户需要调用一些其他的服务和<a class="ae js" href="https://javarevisited.blogspot.com/2018/01/top-20-libraries-and-apis-for-java-programmers.html" rel="noopener ugc nofollow" target="_blank">API</a>，所以我们把它做成异步的，消费者会做所有这些。</p><h1 id="ff01" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将消息发布到队列</h1><p id="c76c" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">现在我已经创建了一个控制器类，并为此添加了其他相关的类。控制器看起来是这样的:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/903278411a2c17ff736f8db07b84af03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BEaUjcXaL7EKBP-B"/></div></div></figure><p id="e264" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意，我已经在控制器中添加了RabbitTemplate，并在createUser方法中使用它来发布消息。现在我们需要创建一个队列。为此，我登录了rabbitMQ管理控制台。导航到队列选项卡，有一个<strong class="iw hj">添加新队列</strong>选项。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/02/-stack-and-queue-data-structure-interview-questions.html"><div class="er es jt"><img src="../Images/169add82c7a50e4bb597154c8052fcb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VcXg09TeO6q_DhEV"/></div></a></figure><p id="789d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">只需保持其他字段为默认，并将名称设置为<strong class="iw hj">用户注册</strong>。</p><p id="f7b8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在启动应用程序，并使用适当的有效负载访问api。对我来说是这样的:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="8651" class="lg jz hi lc b fi lh li l lj lk">curl --location --request POST 'http://localhost:8091/api/user' \</span><span id="34ed" class="lg jz hi lc b fi ll li l lj lk">--header 'Content-Type: application/json' \</span><span id="1f56" class="lg jz hi lc b fi ll li l lj lk">--data-raw '{</span><span id="4574" class="lg jz hi lc b fi ll li l lj lk">"username":"Johnson",</span><span id="1e75" class="lg jz hi lc b fi ll li l lj lk">"email":"johnsn@mail.com",</span><span id="8c37" class="lg jz hi lc b fi ll li l lj lk">"mobileNumber": "017000000111"</span><span id="bbe4" class="lg jz hi lc b fi ll li l lj lk">}'</span></pre><p id="f6a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果一切正常，我们将能够在队列中看到1条就绪消息:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/02/top-5-postman-tutorials-and-courses-for-web-developers.html"><div class="er es jt"><img src="../Images/55024d3b75af8071b4b5e143b568e7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_DLNXE7AH4HUtcO3"/></div></a></figure><p id="f48a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要查看消息，单击队列名称并点击获取<strong class="iw hj">消息</strong>选项，哦！有效负载不可读。它在base64 forma中。我保证稍后我们会处理它。现在回到编码上来。我用这句话发布了我的信息:</p><p id="665c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">rabbitTemplate.convertAndSend("，"用户注册"，请求)；</p><p id="30ee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里第一个参数是<strong class="iw hj">交换</strong>，第二个是<strong class="iw hj">路由关键字</strong>，最后一个是有效载荷。但是队列在哪里呢？</p><p id="af70" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在rabbitMQ世界中，交换就像一个邮局，队列就像物理位置，路由关键字就是该位置的地址。当我们创建队列并且不与任何交换绑定时，默认的交换会自动与它绑定，并将路由关键字作为队列的名称。这种使用空字符串和队列名作为路由关键字的方法将消息发布到队列中。生产者从不直接向队列发送消息。</p><h1 id="6973" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">自动创建队列</h1><p id="acc2" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">目前，通过管理控制台创建和配置队列工作正常。但在现实世界中，这并不理想。想象一下，有10个不同的队列。</p><p id="5047" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每当一个新的队友上船，或者你改变你的设备，你需要创建队列。应用程序从开发环境进入测试环境，您需要创建队列。应用程序进入生产阶段，需要有人来创建它们。这将变得乏味且容易出错。Spring AMQP为我们提供了rabbitMQ admin来自动化这些任务。</p><p id="16ec" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最好的部分是，您只需要创建一个返回包含队列名称的队列对象的<a class="ae js" href="https://javarevisited.blogspot.com/2022/03/how-autowiring-of-beans-works-in-spring.html" rel="noopener ugc nofollow" target="_blank"> Bean </a>。将所有与rabbitMQ相关的beans保存在同一个配置文件中是一个很好的做法。现在我的RabbitMQConfig看起来像这样:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="a3bb" class="lg jz hi lc b fi lh li l lj lk">@Configuration<br/>public class RabbitMQConfig {<br/>    @Bean<br/>    public Queue createUserRegistrationQueue() {<br/>        return new Queue("q.user-registration");<br/>    }<br/>}</span></pre><p id="49bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以<strong class="iw hj"> q. </strong>开始命名队列是rabbitMQ的惯例。</p><p id="b505" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">继续操作，从管理门户中删除任何以前的队列，然后重启应用程序并点击api，应该会创建队列并传递消息。</p><h1 id="89a2" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">添加消费者以处理消息</h1><p id="76cf" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">如果发布的消息没有消费者，那么只有发布者也只是一半的乐趣。拥有一个消费者就像用<em class="lm"> @RabbitListener </em>注释一个方法并提到队列一样简单。我的用户注册请求看起来像这样:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="dcba" class="lg jz hi lc b fi lh li l lj lk">@Service<br/>@Slf4j<br/>public class UserRegistrationListener {<br/>          @RabbitListener(queues = {"q.user-registration"})<br/>    public void onUserRegistration(UserRegistrationRequest event) {<br/>            log.info("User Registration Event Received: {}", event);<br/>    }<br/>}</span></pre><p id="fcd9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您点击api端点进行注册，然后检查日志，您将能够看到以下内容:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/04/top-5-tools-to-test-rest-apis-in-java.html#axzz7CGBoUS1n"><div class="er es jt"><img src="../Images/686c6900171b636ceb3867aee39c924a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6qv2Nx7X556iI6bo"/></div></a></figure><p id="e750" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看起来不错！我在消费者中接收预期的有效载荷，rabbitMQ在内部处理序列化和反序列化，这样我就可以使用一个漂亮的java对象。但是，如果我们想直接从管理门户查看消息，我们仍然会看到base64格式的消息。这对于开发和故障排除来说并不理想。我们希望看到人类可读格式的信息。</p><p id="f372" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了实现这一点，我们需要声明一个<strong class="iw hj">Jackson 2 jsonmessageconverter</strong>bean，并将其设置为rabbitTemplate中需要转换的消息。需要在我们的RabitMQConfig文件中添加这些beans:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/03/3-examples-to-parse-json-in-java-using.html"><div class="er es jt"><img src="../Images/8657caead4ddfef9dbd9f7930e5446bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HiGLQbBaHxbgtCMf"/></div></a></figure><p id="ae15" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意，我们在构造rabbitTemplate时使用了默认的cachingConnectionFactory。为此，我们需要通过构造函数注入cachingConnectionFactory。之后，注释掉侦听器以检查门户中的消息。否则，它将在我们有机会看到之前就在消费者方法中被交付。</p><p id="8ee6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们现在点击api，并检查队列，我们将能够从管理门户看到有效负载的文本。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/04/top-5-courses-to-learn-java-collections-and-streams.html"><div class="er es jt"><img src="../Images/87033a3faa28722b21edf39d99dff823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xmwX3IsJ5KrDoVYn"/></div></a></figure><h1 id="6213" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">注册后通过电子邮件和短信通知用户</h1><p id="1d91" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">假设在完成用户注册后，我们想通过电子邮件和短信通知用户。当然，我们可以编写相应的服务，并在注册后调用它们。那么我们的代码可能如下所示:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="211c" class="lg jz hi lc b fi lh li l lj lk">@RabbitListener(queues = {"q.user-registration"})<br/>public void onUserRegistration(UserRegistrationRequest event) {<br/><br/>        log.info("User Registration Event Received: {}", event);<br/><br/>        /*<br/>        Relevant business logic for user registration<br/>        */<br/><br/>        emailService.sendEmail(event.getEmail());<br/>        smsService.sendSms(event.getMobileNumber());<br/><br/>}</span></pre><p id="d32c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是这种方法存在一些问题。您的通知系统与注册系统紧密结合在一起。如果处理不当，senEmail方法中的异常也可能会中断sms传递。您可能不希望将执行用户注册等繁重任务的同一应用程序的计算资源用于发送电子邮件等轻量级任务。我们在这里能做什么？兔子来了。</p><p id="b589" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将创建两个队列，用RabbitListener注释我们的方法，提到指定的队列。然后，我们将创建一种特殊类型的交换，称为扇出交换，以绑定队列。这个交换的特点是:不管路由关键字是什么，绑定到这个交换的每个队列都接收消息。</p><p id="da92" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们需要在rabbitMQ配置中添加以下Bean。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="0d3d" class="lg jz hi lc b fi lh li l lj lk">@Bean<br/>public Declarables createPostRegistartionSchema(){<br/>        <br/>return new Declarables(<br/>                new FanoutExchange("x.post-registration"),<br/>                new Queue("q.send-email" ),<br/>                new Queue("q.send-sms"),<br/>                new Binding("q.send-email", Binding.DestinationType.QUEUE, "x.post-registration", "send-email", null),<br/>                new Binding("q.send-sms", Binding.DestinationType.QUEUE, "x.post-registration", "send-sms", null));<br/>    <br/>}</span></pre><p id="4176" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里的第一行，我们声明交换，按照惯例交换的名字以x开头。</p><p id="197f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在接下来的两行中，我们声明了队列。然后在最后两行中，我们用这个<em class="lm"> x.post-registration </em>交换声明了队列的绑定。</p><p id="9c72" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">重启应用程序后，转到管理门户的<strong class="iw hj">交易所</strong>选项卡，您会看到有一个以我们给定的名称创建的交易所以及其他交易所。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/b76463885ff5a75489867b3086e5abbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kVl8hGR7WvOnI9m2"/></div></div></figure><p id="a701" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">点击它，你会看到绑定:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/5756682c342b86ec8c5f7974f222dae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cZaDclUvLCPATG36"/></div></div></figure><p id="190c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我添加了两个消费者，一个用于短信，一个用于邮件:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="eea2" class="lg jz hi lc b fi lh li l lj lk">@Service<br/>@Slf4j<br/>public class SendSmsService {<br/>    @RabbitListener(queues = "q.send-sms")<br/>    public void sendSms(UserRegistrationRequest request) {<br/><br/>        log.info("Sending sms to {} ", request.getMobileNumber());<br/>    }<br/>}<br/>--------------------------------------------------------------------<br/>@Service<br/>@Slf4j<br/>public class SendEmailService {<br/><br/>    @RabbitListener(queues = "q.send-email")<br/>    public void sendEmail(UserRegistrationRequest request) {<br/>        <br/>        log.info("Sending email to {}", request.getEmail());<br/>    }<br/>}</span></pre><p id="a8cf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，在userRegistrationListener中添加以下行:</p><p id="1bdc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">rabbit template . convertandsend(" x . post-registration "，""，event)；</p><p id="ba8c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后重新启动应用程序并点击api，应该可以看到以下日志:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/4c4ec3487555da9e9e7b710dd0186f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*73CFmrD5SKVWWpxc"/></div></div></figure><p id="b8a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">酷吧？提交一次并在多个消费者中接收。现在，这些看起来已经正确解耦了。</p><h1 id="a1f2" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">启用正常重试机制</h1><p id="5ccb" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">如前所述，注册用户是一个极其复杂的过程。在某些情况下，可能会引发一些异常，对于这些异常，重试可能是一个好的选择。您可以通过抛出该异常来解决重试rabbitMQ的问题。让我们模拟一下这个场景:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="6eb0" class="lg jz hi lc b fi lh li l lj lk">@RabbitListener(queues = {"q.user-registration"})<br/>public void onUserRegistration(UserRegistrationRequest event)  {<br/>    log.info("User Registration Event Received: {}", event);<br/><br/>    executeRegistration(event);<br/><br/><br/>    rabbitTemplate.convertAndSend("x.post-registration","", event);<br/>}<br/><br/>private void executeRegistration(UserRegistrationRequest event) {<br/>    log.info("Executing User Registration Event: {}", event);<br/><br/>    throw new RuntimeException("Registration Failed");<br/><br/>}</span></pre><p id="dae2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们从侦听器中调用<strong class="iw hj"> executeRegistration </strong>方法，在这个方法中，我们生成一个RunTimeException。现在重启应用程序并点击api。哇！正在重试…问题已解决！但是等等…..它会重试多长时间？直到例外消失。在这种情况下，我们可以更改代码并重启，但在现实世界中这是不可能的。如果异常持续发生，我们需要在某个点停止，并在两次尝试之间等待。你注意到了吗，现在重试太快了？</p><p id="bcd3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了解决这个问题，我们需要声明两个beans。一个<strong class="iw hj">SimpleRabbitListenerContainerFactory</strong>和另一个<strong class="iw hj">retryoperations interceptor</strong>。然后将这个拦截器添加到listenerContainerFactory的通知链中。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="7a29" class="lg jz hi lc b fi lh li l lj lk">@Bean<br/>public RetryOperationsInterceptor retryInterceptor(){<br/>    return RetryInterceptorBuilder.stateless().maxAttempts(3)<br/>            .backOffOptions(2000, 2.0, 100000)<br/>            .build();<br/>}<br/><br/><br/>@Bean<br/>public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer) {<br/>    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();<br/>    configurer.configure(factory, cachingConnectionFactory);<br/>    factory.setAcknowledgeMode(AcknowledgeMode.AUTO);<br/>    factory.setAdviceChain(retryInterceptor());<br/>    return factory;<br/>}</span></pre><p id="43a5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在重启应用程序并点击api。它应该只在初次尝试后重试2次。两秒后第一次，四秒后第二次。</p><p id="8935" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里有一个问题，命名bean<strong class="iw hj">rabbitListenerContainerFactory</strong>覆盖默认的监听器容器工厂。因此，这个重试机制将为所有侦听器激活。如果您不希望这样，并且希望这种机制仅用于UserRegistrationListener，请执行以下操作。将工厂重命名为其他名称..like:registrationListenerContainerFactory然后在RabbitListener注释行中提到它:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="8727" class="lg jz hi lc b fi lh li l lj lk">@RabbitListener(queues = {"q.user-registration"}, containerFactory = "registrationListenerContainerFactory")</span></pre><p id="7c91" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，在重试程序耗尽之后，消息将被丢弃。因此，如果在重试过程中不断出现异常，消息将会丢失。对于许多情况来说，这可能不是理想的情况。我们可能希望跟踪故障，以便将来进行进一步的处理或调查。</p><h1 id="1be9" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为失败的注册添加死信队列</h1><p id="e287" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">死信队列只是另一个队列，它的特别之处在于我们何时或如何使用它。首先，我们将为此声明一个模式。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="eec1" class="lg jz hi lc b fi lh li l lj lk">@Bean<br/>public Declarables createDeadLetterSchema(){<br/>    return new Declarables(<br/>        new DirectExchange("x.registration-failure"),<br/>        new Queue("q.fall-back-registration"),<br/>        new Binding("q.fall-back-registration", Binding.DestinationType.QUEUE,"x.registration-failure", "fall-back", null)<br/>    );<br/>}</span></pre><p id="473c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">只是一个正常的交换，队列和它们的绑定。我已经将路由键设置为“fall-back ”,稍后会用到它。</p><p id="1e74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们将配置我们的<strong class="iw hj"> q.user-registration </strong>，以便它知道它有一个死信队列。最好删除之前的队列。否则更新的配置可能不会反映。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="cd66" class="lg jz hi lc b fi lh li l lj lk">@Bean<br/>public Queue createUserRegistrationQueue() {<br/><br/>    return QueueBuilder.durable("q.user-registration")<br/>        .withArgument("x-dead-letter-exchange","x.registration-failure")<br/>        .withArgument("x-dead-letter-routing-key","fall-back")<br/>        .build();<br/>}</span></pre><p id="a061" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里我们用死信配置声明了队列。这里的论点是不言自明的。</p><p id="7184" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">拼图的最后一块。为了确保rabbitMQ将消息传达给DLX，我们需要从侦听器中抛出一个<strong class="iw hj">amqprechectanddontrequeueexception</strong>。但是我们不能现在就扔掉它，因为我们正在使用一个重试拦截器。相反，我们将告诉重试拦截器在用尽时抛出这个异常。像这样:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="e9b4" class="lg jz hi lc b fi lh li l lj lk">@Bean<br/>public RetryOperationsInterceptor retryInterceptor(){<br/>    return RetryInterceptorBuilder.stateless().maxAttempts(3)<br/>            .backOffOptions(2000, 2.0, 100000)<br/>            .recoverer(new RejectAndDontRequeueRecoverer())<br/>            .build();<br/>}</span></pre><p id="91c0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们必须添加一个侦听器来接收队列中的消息:</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="492c" class="lg jz hi lc b fi lh li l lj lk">@Service<br/>@Slf4j<br/>public class FallBackRegistrationService {<br/><br/>    @RabbitListener(queues = {"q.fall-back-registration"})<br/>    public void onRegistrationFailure(UserRegistrationRequest failedRegistration){<br/>        log.info("Executing fallback for failed registration {}", failedRegistration);<br/>  }<br/><br/>}</span></pre><p id="dff1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在重启应用程序并检查日志。在重试尝试的条目之后，将会出现如下新行:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/6f12093f8d7203b85d3ea091b5cb322a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7Lx8yV2GbnWMqxy6"/></div></div></figure><p id="32dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在就看你想在这里做什么了。您可以将它保存在数据库中，调用其他服务，或者在另一个队列中重新排队。</p><h1 id="61c1" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">添加分布式跟踪</h1><p id="3725" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">这是最简单的部分。只需在您的依赖项中添加sleuth，您将看到跟踪id在所有日志中传播。</p><pre class="ju jv jw jx fd lb lc ld le aw lf bi"><span id="46e1" class="lg jz hi lc b fi lh li l lj lk">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="6bbe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果涉及不同的应用程序或微服务，这尤其有用。</p><p id="e2b0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">今天到此为止。</p><p id="ee6e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个演示的所有代码都可以在<a class="ae js" href="https://github.com/Ruhshan/rabbitmq-spring-demo" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="16d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">支持我👇</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://www.buymeacoffee.com/ruhshan"><div class="er es lv"><img src="../Images/3fa25c02bfae703b847436bfda7ce946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*7Pq-C6d0si0t4vv-j8TGqg.png"/></div></a></figure></div></div>    
</body>
</html>