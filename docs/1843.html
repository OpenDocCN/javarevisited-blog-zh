<html>
<head>
<title>Using metrics for crafting a better software architecture — the Java and Maven approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用度量来打造更好的软件架构Java和Maven方法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/using-metrics-for-crafting-maintainable-solutions-on-the-long-run-the-maven-way-1a2d84508bf0?source=collection_archive---------1-----------------------#2021-12-27">https://medium.com/javarevisited/using-metrics-for-crafting-maintainable-solutions-on-the-long-run-the-maven-way-1a2d84508bf0?source=collection_archive---------1-----------------------#2021-12-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/63053cd4168ea3b4ca987882beaf7633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOLLqbyfYaJwy8wB1q555Q.jpeg"/></div></div></figure><p id="91f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您是否发现自己处于这样一种情况:更改一行简单的代码会导致整个应用程序出现一系列编译错误？或者在你至少会想到的地方引入一个bug？如果你没去过那里，我去过，让我告诉你那并不愉快。<br/>不是。在。全部。</p><p id="63e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，我们作为一个团队问的问题是，我们是如何做到这一点的？回顾过去，我们遵循了一些通用的指导方针，有一个良好的测试覆盖率，确保事先建立一些良好的实践，然而我们设法到达了一个地方，在那里改变一行变成了整整三天的努力。</p><p id="02f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">祝你能向你的经理解释清楚！</p><p id="b44e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我从头开始。你开始了一个新项目，开始很简单，但事情很快开始升级，在你知道之前，你必须建立一些基本规则。<br/>你可能有一些业务逻辑，所以你创建了一个模块来包装这些逻辑，我们称之为<strong class="is hj">核心</strong>模块。您可能还需要一个API，因此您还将添加一个<strong class="is hj"> API </strong>模块。你需要安全，所以你增加了一个<strong class="is hj">安全</strong>模块。更不用说如果你和DDD一起工作，或者有一个CQRS或六边形的架构，那么你可能会以一堆不同的模块结束，谁知道最后是什么。</p><p id="6480" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不要误解我的意思，如果你想有一个长期可维护和可伸缩的解决方案，这可能是正确的方法。这绝对是一个很好的方法，可以将不同的关注点分开，将共同的关注点组合在一起。</p><p id="8ff0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，我们到底做错了什么，才落得如此下场？</p><p id="11cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实证明，不仅创建不同的模块和分离关注点很重要，如何连接这些模块，如何引入它们之间的依赖关系也很重要。</p><p id="fe7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Robert C.Martin在他的《干净的建筑》一书中提到了这个问题，并提出了一个解决方案。他提出的是引入某种完全基于系统模块之间连接方式的度量标准。这些度量的目的是能够确定系统的可伸缩性和可维护性。</p><p id="7dc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文的下一部分，在开始更实际的工作之前，我将尝试对罗伯特·马丁在他的书的章节中更详细解释的度量背后的理论做一个非常简短的总结(是的，显然我强烈建议在接下来的两分钟长的TL中阅读那个；DR部分)。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="f173" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">依赖性管理指标</h1><p id="491b" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">依赖性管理指标由两个原则组成:</p><ul class=""><li id="72af" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">稳定依赖原则</li><li id="97d2" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">稳定抽象原则</li></ul><p id="2ef3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在接下来的部分中，我们将提到术语<strong class="is hj">组件</strong>，它实际上相当于Java和Maven生态系统中的Maven模块。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="d661" class="ln jx hi bd jy lo lp lq kc lr ls lt kg jb lu lv kk jf lw lx ko jj ly lz ks ma bi translated">稳定依赖原则</h2><p id="2f17" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated"><em class="mb">“任何我们认为不稳定的组件，都不应该依赖于一个很难改变的组件。否则，挥发性成分也将难以改变。”</em></p><p id="a4b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是什么让一个组件变得难以改变(也叫“稳定”)？<br/>许多因素可能会使软件组件难以更改(大小、复杂性、清晰性、依赖于它的组件数量……)。<br/>我们特别感兴趣的是最后一种情况，即一个组件有许多其他组件依赖于它。具有大量引入依赖项的组件很难更改，因此被称为“稳定”组件:</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/4917f81a8c8799af75d8c6f35280a2eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*e58NTfrtaMR7zyjnoxGrIw.png"/></div></figure><p id="d914" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能已经猜到了，一个“不稳定”的组件是完全相反的。<br/>“不稳定”组件是指依赖于其他组件但没有其他组件依赖于它的组件:</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/74c0d40b32619a72d7083aecb386ccf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*ydczgxX8qO8W-kaqOiYqMw.png"/></div></figure><p id="c566" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">组件不稳定</strong></p><p id="852b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以将组件的术语<strong class="is hj">不稳定性</strong> <em class="mb"> </em>定义如下:</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/d5fd364e74cd686ccc877c1c42eb0644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*TfX66zfdedC7yyzohJccuA.png"/></div></figure><p id="f678" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经定义了<strong class="is hj">不稳定性</strong>，我们可以定义<strong class="is hj">稳定依赖性</strong> <em class="mb"> : </em>的实际原理</p><p id="4205" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mb">“一个组件应该总是依赖于一个更稳定的组件。”</em></p><p id="1a07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下图中，我们可以看到明显违反了该原则:</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/f9168065b17ce35439866aba685006a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*H9H1QSS0bPkpgVMF810bQw.png"/></div></figure><p id="d994" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<strong class="is hj">稳定组件</strong>(依赖于两个组件)依赖于不稳定组件<strong class="is hj"> </strong>(仅依赖于一个组件——稳定组件)。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="b972" class="ln jx hi bd jy lo lp lq kc lr ls lt kg jb lu lv kk jf lw lx ko jj ly lz ks ma bi translated"><strong class="ak">稳定抽象原则</strong></h2><p id="c776" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">为了能够定义<strong class="is hj">稳定抽象</strong>原则，我们首先需要建立术语的定义— <strong class="is hj">抽象组件</strong>。</p><p id="da7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mb">“抽象组件是只持有接口或抽象类的组件。”</em></p><p id="936b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些抽象组件非常稳定，非常适合不太稳定的组件依赖。</p><p id="0126" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过以下方式定义单个组件的抽象级别:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/f1fe4578556447bce9bc6143d3471b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4E-QMk5-D-gzY2CxQ_pdg.png"/></div></div></figure><p id="9aee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们已经定义了组件抽象这个术语，我们可以定义<strong class="is hj">稳定抽象</strong>原则:</p><p id="0297" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">组件应该总是依赖于更抽象的组件</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="ce8c" class="ln jx hi bd jy lo lp lq kc lr ls lt kg jb lu lv kk jf lw lx ko jj ly lz ks ma bi translated">主序列</h2><p id="6938" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">我们已经定义了两个原则，那么下一步是什么？<br/>让我们尝试在x-y轴上定义<strong class="is hj">不稳定性</strong>和<strong class="is hj">抽象性</strong>指标之间的联系:</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/41f305ab79163d599ed8701c3e0a3bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*-fwhMiFm8Fki7SVt8pH8Rw.png"/></div><p class="mm mn et er es mo mp bd b be z dx translated">X-Y轴，其中X轴是不稳定性，Y轴是组件的抽象性</p></figure><p id="0e4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们在上述x-y轴上的<em class="mb"> (0，1) </em>和<em class="mb"> (1，0) </em>点之间画一条线，我们得到一条线，叫做<strong class="is hj">主序列</strong>线:</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/459e052b1c922ddfdc370086a869b217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*DWjTZWl-OjDKhT29mfSXPw.png"/></div></figure><p id="abe6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这条线代表所有组件应该在的地方。位于<strong class="is hj">主序列</strong>上的组件既不太抽象，也不太不稳定。</p><p id="a084" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经定义了组件应该在哪里，是时候定义它们不应该在哪里了，在所谓的<strong class="is hj">排除区</strong>:</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/8662a6c71ddb41dafe4847f9932a33d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*EWlftTrmYjIBAkBTW_QWKQ.png"/></div><p class="mm mn et er es mo mp bd b be z dx translated">排除区</p></figure><p id="6702" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所看到的，有两个区域是我们不希望组件出现的:</p><p id="4183" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">疼痛区<br/>和</strong>高度稳定的混凝土构件。这是不希望的，因为该区域中的部件非常坚硬。它们不能被扩展，因为它们缺乏抽象性，并且由于它们的高稳定性，它们很难被改变。</p><p id="ea62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">无用区<br/> </strong>高度抽象的组件，没有任何依赖，即无用组件。</p><p id="e2f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">距主序列的距离<br/> </strong>现在是时候定义与组件距<strong class="is hj">主序列</strong>的距离相对应的度量了:</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/30329fe7e66a5430dc6707368b1f0f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*kyZYGmM67Nyxqyf8EU3lnA.png"/></div></figure><p id="c0a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任何具有不接近零的<strong class="is hj"> D </strong>度量值的组件，都可以被进一步重新检查和重构。</p><p id="c449" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过计算组件的所有<strong class="is hj"> D </strong>度量的<strong class="is hj">均值</strong>和<strong class="is hj">方差</strong>也可以对设计进行统计分析。<br/>符合要求的设计应该具有接近于零的<strong class="is hj">均值</strong>和<strong class="is hj">方差</strong>值。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="7861" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">依赖性管理指标Maven插件</h1><p id="3203" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">希望您已经从理论部分得到了这个想法，现在是时候看看我们如何在使用Java和Maven的项目中更实际地从这些指标中获益了。</p><p id="717d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/ignatij/dependency-management-metrics-maven-plugin" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">依赖管理度量</strong> </a>是一个Maven插件，它计算并输出Java多模块项目中每个Maven模块的依赖管理度量。该插件只考虑内部的和特定于项目的依赖，不考虑外部的依赖(如Spring)。</p><p id="f19e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个Maven模块都考虑了以下指标:</p><ul class=""><li id="b5a1" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">稳定性度量</li><li id="6245" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">抽象度量</li><li id="3dbb" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">与主序列的距离</li></ul><p id="5ab5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">插件还在单独的部分<strong class="is hj">排除区</strong>中输出<strong class="is hj">痛苦区</strong>和<strong class="is hj">无用区</strong>中存在的模块。</p><p id="e2ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，如果违反了<strong class="is hj">稳定依赖</strong>或<strong class="is hj">稳定抽象</strong>原则，插件可能会破坏Maven的构建。</p><h2 id="9218" class="ln jx hi bd jy lo lp lq kc lr ls lt kg jb lu lv kk jf lw lx ko jj ly lz ks ma bi translated">结果</h2><p id="1fbf" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在多模块Java项目中运行插件会产生以下输出:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/87fbd8cc5080e4d7461f73be2c590612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZvSAA5p0LAbmYW3Yveu6A.png"/></div></div></figure><p id="0653" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从输出中我们可以看到，一些被放错地方最多的模块属于<strong class="is hj">痛苦区</strong>部分，这意味着它们是高度稳定的模块，明显缺乏抽象。</p><p id="86c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这对我们意味着什么？这实际上意味着这些模块中的变化应该尽可能小，尽可能少，这样我们就不会意外地引入一些bug、构建问题或者只是增加开发人员(以及稍后的管理人员)的头痛因素。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="278c" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="49c6" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">插件本身并没有为我们解决问题，它的目的是指出我们可以进一步行动和改进的地方。</p><p id="cec6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它既可以作为当前架构的总体概述，更重要的是，作为未来计划工作的指南——能够预先识别是否需要一些重构或重组，希望从长远来看，它将有助于开发更好、更具可扩展性和可维护性的软件。</p></div></div>    
</body>
</html>