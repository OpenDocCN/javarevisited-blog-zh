<html>
<head>
<title>Java - Runnable vs Callable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java -可运行与可调用</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-runnable-vs-callable-786aa706775d?source=collection_archive---------0-----------------------#2021-05-02">https://medium.com/javarevisited/java-runnable-vs-callable-786aa706775d?source=collection_archive---------0-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a123" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将讨论两个多线程概念，runnable和callable。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/c459ee1e69c4847147359934e655ac09.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*dQ12TylPtWH5fsEqVKv-sQ.png"/></div></figure><h2 id="bf86" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">1-什么是可运行的？</h2><p id="d47c" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">Runnable是一个接口，实现它的类将在线程中执行。在这里，您可以看到Runnable接口。所有需要在线程中执行的逻辑都在被覆盖的run方法中。你会注意到它是一个void方法。</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="92ba" class="jl jm hi km b fi kq kr l ks kt">@FunctionalInterface<br/>public interface Runnable {<em class="ku"><br/>    </em>public abstract void run();<br/>}</span></pre><h2 id="f9a4" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">2-什么是可赎回的？</h2><p id="246c" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">我写的关于<a class="ae kv" href="http://javarevisited.blogspot.sg/2012/01/difference-thread-vs-runnable-interface.html#axzz59pNoKNHl" rel="noopener ugc nofollow" target="_blank"> Runnable </a>的所有内容对<a class="ae kv" href="https://javarevisited.blogspot.com/2016/08/useful-difference-between-callable-and-Runnable-in-Java.html#axzz6e8hmwujv" rel="noopener ugc nofollow" target="_blank"> Callable </a>接口都有效，除了一点，<strong class="ih hj">返回类型。</strong>方法<em class="ku">调用</em>完成执行后会返回任意类型。</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="6d5d" class="jl jm hi km b fi kq kr l ks kt">@FunctionalInterface<br/>public interface Callable&lt;V&gt; {<em class="ku"><br/>    </em>V call() throws Exception;<br/>}</span></pre><h2 id="f7b1" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">Runnable和Callable的区别是什么？</h2><p id="a679" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">正如我们之前谈到的，这两个接口的主要区别在于Callable接口的call方法会返回值。当您希望跟踪线程的结果时，这在许多情况下会很有用。我们来看看以下场景。</p><p id="d20b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，我们实现了Runnable接口，并在<a class="ae kv" href="https://javarevisited.blogspot.com/2012/03/difference-between-start-and-run-method.html#axzz6vPUwyVzv" rel="noopener ugc nofollow" target="_blank"> run方法</a>中监听消息。因为不需要返回任何东西，所以在这里使用Runnable接口很方便。</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="a85c" class="jl jm hi km b fi kq kr l ks kt">public class RunnableClass implements Runnable {<br/>    private MessageListener messageListener;<br/>    <br/>    public RunnableClass(MessageListener messageListener) {<br/>        this.messageListener = messageListener;<br/>    }<br/>    <br/>    @Override<br/>    public void run() {<br/>        messageListener.subscribe(message -&gt; {<br/>           // handle message <br/>        });<br/>    }<br/>}</span></pre><p id="14b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面，你可以看到一个<a class="ae kv" href="http://www.java67.com/2013/01/difference-between-callable-and-runnable-java.html" rel="noopener ugc nofollow" target="_blank">可调用接口</a>的例子。我们将原始字符串作为构造函数参数和内部调用方法，我们将它传递给StringValidator的isValid方法，其内部实现现在并不重要(考虑它是一个耗时的字符串验证器)。在这种情况下，我们可能需要知道验证是否成功完成，所以我们使用implemented Callable来了解它。</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="f3d9" class="jl jm hi km b fi kq kr l ks kt">public class CallableClass implements Callable&lt;Boolean&gt; {<br/>    private String raw;<br/><br/>    public CallableClass(String raw) {<br/>        this.raw = raw;<br/>    }<br/><br/>    @Override<br/>    public Boolean call() {<br/>        return StringValidator.isValid(raw);<br/>    }<br/>}</span></pre><p id="0582" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有另一个重要的区别，我们处理异常的方式。正如您在前两个片段中看到的，run方法不会抛出任何东西，而call方法会抛出Exception。所以，这意味着我们可以在调用方法中传播任何异常，但是我们必须在运行方法中处理所有异常。</p><p id="c6fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们将看看线程是如何执行它们的。对于runnables，</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="15f6" class="jl jm hi km b fi kq kr l ks kt">ExecutorService executorService = Executors.newSingleThreadExecutor(); // or any other executor<br/>Runnable r = new RunnableClass(new MessageListener());</span><span id="279f" class="jl jm hi km b fi kw kr l ks kt">// you can pick one of the following<br/>new Thread(r).start();<br/>CompletableFuture.runAsync(r);<br/>executorService.execute(r);</span></pre><p id="b225" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于可调用的，</p><pre class="je jf jg jh fd kl km kn ko aw kp bi"><span id="d198" class="jl jm hi km b fi kq kr l ks kt">ExecutorService executorService = Executors.<em class="ku">newSingleThreadExecutor</em>();<br/>Callable&lt;Boolean&gt; callable = new CallableClass("sometext");</span><span id="5a71" class="jl jm hi km b fi kw kr l ks kt">Future&lt;Boolean&gt; result = executorService.submit(callable);<br/>System.out.println(result.get().booleanValue()); // result future will return result when ready, this will also throws InterruptedException, ExecutionException but omitted here for clean sight. </span></pre><p id="38af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程中，我谈到了什么是Runnable和Callable接口，以及它们之间的区别。我希望你喜欢它。</p><div class="kx ky ez fb kz la"><a href="https://github.com/kurular4/medium-java/tree/master/runnable-callable" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">medium-Java/runnable-可在主kurula 4/medium-Java上调用</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">关于Java的文章中的代码。在GitHub上创建一个帐户，为kurura 4/medium-Java开发做贡献。</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">github.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo jj la"/></div></div></a></div></div></div>    
</body>
</html>