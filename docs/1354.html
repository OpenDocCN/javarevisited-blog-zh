<html>
<head>
<title>Thread Pools in Java — Why use multiple Thread Pools in an application!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的线程池——为什么要在一个应用程序中使用多个线程池！</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/thread-pools-in-java-why-use-multiple-thread-pools-in-an-application-2d06d0fa4d79?source=collection_archive---------0-----------------------#2021-07-02">https://medium.com/javarevisited/thread-pools-in-java-why-use-multiple-thread-pools-in-an-application-2d06d0fa4d79?source=collection_archive---------0-----------------------#2021-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e7c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线程允许程序同时并行处理不同的任务。在单线程应用程序中，只有一个线程可以执行，这意味着在任何时间点只有一个任务可以运行。</p><p id="f041" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例子</strong>:</p><p id="7b68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想想任何可以处理多个请求的服务器。以一个数据库服务器为例，它可以并发处理多个请求。如果为数据库服务器的每个请求创建一个线程，那么这个数据库将花费更多的时间来管理线程，而不是像执行sql那样计算业务操作。JVM为每个请求创建线程会导致系统内存不足。</p><p id="bfd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑一个web服务器应用程序，其中每个HTTP请求由一个单独的线程处理。如果应用程序只是为每个新的HTTP请求创建一个新的线程，而系统收到的请求超过了它的处理能力，那么当所有这些线程的开销超过了系统的容量时，应用程序将立即停止对所有请求的响应。由于对可以创建的线程数量的限制，应用程序不会像处理HTTP请求那样快地处理这些请求，但是它会以系统能够承受的速度处理这些请求。</p><p id="d6bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这就是我们有线程池的原因，这样我们可以最小化线程的管理，专注于我们的业务逻辑。</strong></p><p id="e24a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线程池是线程的集合，可以直接处理我们分配的任务。线程也被重用来处理队列中等待的任务。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/362a985adce19b8e267c01b2a7b8b84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LlDdVNkwLLpF8C2G"/></div></div></figure><p id="4546" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中。线程池中有4个线程，队列中定义了5个任务。线程并行处理不同的任务。在任何时间点，都可能有4个任务在运行，因为我们有4个线程。因此队列中的一个任务实际上会等待被拾取。只有当4个线程中的任何一个在完成它们的任务后空闲时，它才会被拾取。</p><p id="92d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，应用程序中的线程越多，应用程序就越耗时，因为线程管理也是一项任务。因此，线程的创建应该是一个深思熟虑的过程。</p><p id="a642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过多种方式创建线程池:</p><p id="36b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。使用执行者框架:</strong></p><p id="99ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在下一篇技术文章中详细介绍Executor框架。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="8dc5" class="ju jv hi jq b fi jw jx l jy jz">ExecutorService executorService = Executors.newFixedThreadPool(10);<br/>// creates a thread pool with 10 fixed threads</span><span id="4a33" class="ju jv hi jq b fi ka jx l jy jz"><br/>ExecutorService executorService = Executors.newCachedThreadPool() <br/>// Creates a thread pool that creates new threads as needed. This will reuse previously constructed threads when they are available.</span><span id="cdc6" class="ju jv hi jq b fi ka jx l jy jz">ExecutorService executorService =Executors.newSingleThreadExecutor() <br/>// Creates a single thread.</span></pre><p id="35fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。ThreadPoolExecutor </strong></p><p id="5552" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个类提供了许多可调参数和可扩展性挂钩。程序员通常使用Executor框架，因为一切都是为常见场景预先配置的。</p><p id="5f97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该类中的主要配置参数是corePoolSize、maximumPoolSize和keepAliveTime。</p><p id="a7c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">corePoolSize参数是将被实例化并保存在池中的核心线程的数量。当新任务到来时，如果所有核心线程都很忙，并且内部队列已满，则允许池增长到maximumPoolSize。</p><p id="97e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住——默认情况下，即使是核心线程也是在新任务到达时才创建和启动的。</p><p id="cb31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能会有这样的情况，在激增期间，命中服务器的请求数量更多，这意味着将创建更多的线程来处理任务。一旦请求数量恢复正常，线程就会闲置，没有任何任务可以执行。在这种情况下，如果线程空闲的时间超过了keepAliveTime，那么多余的线程将被终止。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/a51f424dd40263bf0a1a5a49e698eb04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LWQb4YxEYt6dNPZz"/></div></div></figure><p id="7dee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请阅读本文了解更多信息:<a class="ae kc" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/7/docs/API/Java/util/concurrent/threadpoolexecutor . html</a></p><p id="6ef2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的截图中，BlockingQueue是跟踪要完成的任务的队列。</p><p id="c2ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何一个<a class="ae kc" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html" rel="noopener ugc nofollow" target="_blank">阻塞队列</a>都可以用来转移和挂起提交的任务。此队列的使用与池大小调整相互影响:</p><ul class=""><li id="8d8e" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">如果运行的线程少于corePoolSize，执行器总是倾向于添加一个新线程，而不是排队。</li><li id="d0b2" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">如果corePoolSize或更多线程正在运行，执行器总是更喜欢将请求排队，而不是添加一个新线程。</li><li id="492b" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">如果请求无法排队，将创建一个新线程，除非它超过maximumPoolSize，在这种情况下，任务将被拒绝。</li></ul><p id="32c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。ForkJoinPool </strong></p><p id="ebd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它提供了一些工具，通过尝试使用所有可用的处理器内核来帮助加速并行处理，这是通过分而治之的方法实现的。</p><p id="d154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个框架将一个任务分成多个子任务进行异步处理，然后使用join聚集来自所有子任务的响应。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="00d6" class="ju jv hi jq b fi jw jx l jy jz">public static ForkJoinPool forkJoinPool = new ForkJoinPool(2);<br/>// creates a pool with 2 threads</span></pre><blockquote class="kr ks kt"><p id="7755" class="if ig ku ih b ii ij ik il im in io ip kv ir is it kw iv iw ix kx iz ja jb jc hb bi translated">为什么以及何时我们需要在一个应用中使用多线程池？</p></blockquote><p id="a734" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当问题是如何在多处理器系统上实现许多短暂的CPU密集型任务的并行执行时，线程池通常是答案。</p><p id="4c3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们经常为一个应用程序创建不同的线程池。在应用程序中可能会有这样的情况，为一个业务逻辑进行繁重的计算需要花费大量的时间。在这种情况下，所有其他请求将在队列中等待被拾取，因为我们的默认线程池正在处理繁重的计算。因此，在这种情况下，我们为不同的业务逻辑创建单独的线程池，以便不同的任务可以在不同的线程池中执行，而不是等待单个线程池完成其繁重的计算。</p><p id="a8bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拥有单独的专用线程池的目的是为了使一个活动不会因为其他活动占用了所有线程而缺乏线程。如果某个服务有自己的线程池，那么它肯定会有一定数量的线程供自己使用，并且对其他服务的需求不敏感。</p><p id="d81b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以有不同的线程池来接受连接、运行批处理作业、与远程api的数据库对话。它确实在某种程度上降低了效率，但是<strong class="ih hj">使我们的系统健壮并且容错</strong>。</p><p id="d8ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个例子是处理两个不同的操作，例如:</p><p id="bc1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.下载文件</p><p id="71db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.在AWS中处理文件和上传</p><p id="a3f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以这样有效地解决这个问题:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="66f2" class="ju jv hi jq b fi jw jx l jy jz">ExecutorService executorDownload = Executors.newSingleThreadExecutor();// 1st thread pool</span><span id="832e" class="ju jv hi jq b fi ka jx l jy jz">executorDownload.execute(task-to-download);</span><span id="e73c" class="ju jv hi jq b fi ka jx l jy jz">ExecutorService executorProcessAndUpload = Executors.newSingleThreadExecutor(); // 2nd thread pool</span><span id="2a9a" class="ju jv hi jq b fi ka jx l jy jz">executorDownload.execute(task-to-process-and-upload-on-AWS);</span></pre><p id="07f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建多线程池的缺点:</p><ol class=""><li id="9094" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ky kj kk kl bi translated">死锁—所有正在执行的线程都在等待阻塞任务的解决。被阻塞的任务将继续在队列中等待，因为所有线程都被占用，而执行线程依赖于被阻塞的任务。</li><li id="3f79" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ky kj kk kl bi translated">线程泄漏—如果线程从池中移除以执行任务，但在任务完成后没有返回，则会发生线程泄漏。例如，如果线程抛出一个异常，而池类没有捕捉到这个异常，那么线程将简单地退出，将线程池的大小减少一。</li><li id="10ea" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ky kj kk kl bi translated">资源颠簸——拥有超过最佳数量的线程可能会导致饥饿问题，从而浪费线程间上下文切换的时间。</li></ol><p id="8763" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样。接下来，我们将创建线程来并行调用多个端点</p><p id="d2f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唱出可完成的未来。</p><p id="b37b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请联系我在vivek.sinless@gmail.com的任何工作或任何富有成效的谈话！</p></div></div>    
</body>
</html>