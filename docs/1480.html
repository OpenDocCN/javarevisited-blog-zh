<html>
<head>
<title>Some thoughts on using LinkedList in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于在Java中使用LinkedList的几点思考</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/consider-linkedlist-in-java-2fed1b945b48?source=collection_archive---------2-----------------------#2021-08-18">https://medium.com/javarevisited/consider-linkedlist-in-java-2fed1b945b48?source=collection_archive---------2-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="87c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将是一篇不同的文章，因为在我的机器上测试了一些之后，我的假设被证明是稍微错误的。这是我的发现。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="0338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；<br/> </strong>博士使用<a class="ae jk" href="https://javarevisited.blogspot.com/2011/05/example-of-arraylist-in-java-tutorial.html#axzz6qVaG06bu" rel="noopener ugc nofollow" target="_blank">数组列表</a>在大多数标准情况下，你简单地添加到列表中，然后迭代它。这会节省你的时间和记忆。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="8d01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>本文并没有讨论其中一些操作的复杂性，我们知道其中一个操作的性能会更好(例如，在列表的开头添加元素或者随机访问)。这里讨论的用例只是简单地添加项目，以便在以后的某个时刻对其进行迭代。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="ec0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的假设是，在所有情况下，当简单地将元素添加到列表末尾时，<a class="ae jk" href="https://www.java67.com/2012/12/difference-between-arraylist-vs-LinkedList-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> LinkedList </strong> </a>会比<strong class="ih hj"> ArrayList </strong>执行得更好。然后我会建议我们应该放弃默认输入</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="2140" class="ju jv hi jq b fi jw jx l jy jz">List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span></pre><p id="091a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，写下</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="122b" class="ju jv hi jq b fi jw jx l jy jz">List&lt;Object&gt; list = new LinkedList&lt;&gt;();</span></pre><p id="8d0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ka">为什么？</em> </strong></p><p id="fc4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为一旦内部容器填满，<a class="ae jk" href="https://javarevisited.blogspot.com/2015/07/java-arraylist-tutorial.html" rel="noopener ugc nofollow" target="_blank"> ArrayList </a>就必须执行调整大小操作，而<a class="ae jk" href="http://www.java67.com/2016/02/how-to-sort-linkedlist-in-java-example.html" rel="noopener ugc nofollow" target="_blank"> LinkedList </a>只需追加一个新节点(无论大小如何都是相同的操作)。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="9c6f" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">测试</h2><p id="34f1" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">所以我做了一个小测试，给每种类型的列表添加1000万个元素，如下所示。</p><figure class="jl jm jn jo fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="90b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个虚拟的例子，但类似的设置在生产中并非不可能见到。我的结果是他们的表现非常相似。</p><p id="36ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试使用以下<a class="ae jk" href="https://www.java67.com/2016/08/10-jvm-options-for-java-production-application.html" rel="noopener ugc nofollow" target="_blank"> VM选项</a>运行，以消除自适应堆大小调整或GC的任何问题。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="e381" class="ju jv hi jq b fi jw jx l jy jz">-Xms5G -Xmx5G -XX:+UnlockExperimentalVMOptions -XX:+AlwaysPreTouch -XX:+UseEpsilonGC</span></pre><figure class="jl jm jn jo fd kz er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/11/hotspot-jvm-options-java-examples.html#axzz54oJiRW8k"><div class="er es lc"><img src="../Images/c3bffab2417ff6298ac5ef461f21f67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*iQDOebOp2ByZluSiWy2x6Q.png"/></div></a><p class="lf lg et er es lh li bd b be z dx translated">epsilon GC的首次测试结果。</p></figure><p id="9f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然这与现实相差甚远，所以我决定修改测试，只指定<a class="ae jk" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686?source=---------8------------------"> G1垃圾收集器</a>。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="5d9b" class="ju jv hi jq b fi jw jx l jy jz">-XX:+UseG1GC</span></pre><p id="ac6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新的测试见下文。</p><figure class="jl jm jn jo fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="24a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同之处在于，我对引入一些额外预热的时间进行了平均，因此编译器有更多的时间进行优化，我们可以获得更真实的结果。</p><figure class="jl jm jn jo fd kz er es paragraph-image"><div class="er es lj"><img src="../Images/1a78dfd536913c6f3796d58bb3c61ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*gmxHTbOnRDHCECUCXoPgCw.png"/></div><p class="lf lg et er es lh li bd b be z dx translated">更真实的结果。</p></figure><p id="8c23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ka">发生了什么事？</em> </strong></p><p id="2217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很难说最后一个例子中ArrayList和LinkedList之间的差异是因为编译器优化对ArrayList更有效，还是GC的影响，还是因为<a class="ae jk" href="https://www.java67.com/2020/07/how-to-get-first-and-last-element-of-linkedlist-in-java.html" rel="noopener ugc nofollow" target="_blank"> LinkedList </a>需要更多内存。要想弄清楚这一点，必须深入研究编译器的GC日志。</p><p id="52fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是现在，我们可以得出结论，由于这些影响中的任何一个，<a class="ae jk" href="https://javarevisited.blogspot.com/2012/01/how-to-sort-arraylist-in-java-example.html" rel="noopener ugc nofollow" target="_blank"> ArrayList </a>似乎比LinkedList使用一个更真实的设置和一个实际的GC运行来执行要好得多。</p><h2 id="58bf" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">最后一些内存方面的考虑</h2><p id="b066" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我执行了以下测试，并记录了内存差异。</p><figure class="jl jm jn jo fd kz er es paragraph-image"><a href="https://www.java67.com/2012/08/how-to-sort-arraylist-in-java-list.html"><div class="er es lk"><img src="../Images/d03330b7e89fad79bc2aab336bb05930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUHsWvce7ObHCaB-yJ1NUA.png"/></div></a><p class="lf lg et er es lh li bd b be z dx translated">100个元素的记忆测试。</p></figure><p id="5a91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下表说明了使用MAT [2]报告的100个和1000个整数元素(需要16B，因为int需要4个字节，header info需要12 [1])进行上述测试时保留的堆中的结果。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="6f7b" class="ju jv hi jq b fi jw jx l jy jz">+--------------+----------------+-----------------+----------------+<br/>|     Type     |  100 elements  |  1000 elements  |  Overhead (*)  |<br/>+--------------+----------------+-----------------+----------------+<br/>|  LinkedList  |     4032B      |      40032B     |      24B       |<br/>|  ArrayList   |     2040B      |      20040B     |       4B       |<br/>+--------------+----------------+-----------------+----------------+</span></pre><p id="c53c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的开销就是每个条目保留的堆减去16B，由MAT减去实际列表的一些头信息提供。不出所料，与<a class="ae jk" href="https://javarevisited.blogspot.com/2014/01/ow-to-remove-objects-from-collection-arraylist-java-iterator-traversing.html" rel="noopener ugc nofollow" target="_blank">数组列表</a>相比，LinkedList占用了大约两倍的内存。然而，这是给定的一个小元素，更大的元素的开销将可以忽略不计。</p><h2 id="7ce7" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">外卖食品</h2><p id="affb" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我从这里学到的是在大多数标准的情况下<strong class="ih hj">更喜欢ArrayList而不是LinkedList，用例是简单地添加到末尾并迭代列表。</strong></p><p id="e7b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><p id="95df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[1]如何计算Java对象的内存使用量<br/><a class="ae jk" href="https://www.javamex.com/tutorials/memory/object_memory_usage.shtml" rel="noopener ugc nofollow" target="_blank">https://www . javax . com/tutorials/memory/object _ memory _ usage . shtml</a></p><p id="e551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2]内存分析器(MAT)<br/><a class="ae jk" href="https://www.eclipse.org/mat/" rel="noopener ugc nofollow" target="_blank">https://www.eclipse.org/mat/</a></p></div></div>    
</body>
</html>