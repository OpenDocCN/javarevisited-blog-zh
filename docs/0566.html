<html>
<head>
<title>Fusing methods for productivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高生产率的融合方法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/fusing-methods-for-productivity-c15c9eb2d666?source=collection_archive---------3-----------------------#2020-07-03">https://medium.com/javarevisited/fusing-methods-for-productivity-c15c9eb2d666?source=collection_archive---------3-----------------------#2020-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ac5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个迭代模式如此普遍时，你给它一个名字。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/27064ff54caeb9c81abc644fde172b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCInXYd_1vi7VCixjLxl5g.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">欢迎来到天空湾，这里的海湾与天空融合在一起，用码头做拉链</p></figure><h1 id="8a02" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">当任何满足都不满足时</h1><p id="ae0e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">有时，您希望查看集合中是否包含与某个属性值相匹配的元素。在下面的例子中，我使用来自<a class="ae la" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>的方法<code class="du kw kx ky kz b">anySatisfy</code>来查看是否有任何对在<code class="du kw kx ky kz b">getTwo</code>属性中具有“2”或“3”。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="0a22" class="lf ju hi kz b fi lg lh l li lj">@Test<br/>public void anySatisfyContains()<br/>{<br/>    MutableList&lt;Pair&lt;Integer, String&gt;&gt; list =<br/>            Lists.<strong class="kz hj"><em class="lk">mutable</em></strong>.with(<br/>                    Tuples.<em class="lk">pair</em>(1, <strong class="kz hj">"1"</strong>), <br/>                    Tuples.<em class="lk">pair</em>(2, <strong class="kz hj">"2"</strong>));<br/><br/>    Assert.<em class="lk">assertTrue</em>(<br/>            list.anySatisfy(pair -&gt; pair.getTwo().equals(<strong class="kz hj">"2"</strong>)));<br/>    Assert.<em class="lk">assertFalse</em>(<br/>            list.anySatisfy(pair -&gt; pair.getTwo().equals(<strong class="kz hj">"3"</strong>)));<br/>}</span></pre><p id="faad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用将<code class="du kw kx ky kz b">Function</code>指定为方法引用的<code class="du kw kx ky kz b">collect</code>方法来提取<code class="du kw kx ky kz b">pair.getTwo()</code>的值。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="e3c2" class="lf ju hi kz b fi lg lh l li lj">@Test<br/>public void eagerCollectAnySatisfy()<br/>{<br/>    MutableList&lt;Pair&lt;Integer, String&gt;&gt; list =<br/>            Lists.<strong class="kz hj"><em class="lk">mutable</em></strong>.with(<br/>                    Tuples.<em class="lk">pair</em>(1, <strong class="kz hj">"1"</strong>),<br/>                    Tuples.<em class="lk">pair</em>(2, <strong class="kz hj">"2"</strong>));<br/><br/>    Assert.<em class="lk">assertTrue</em>(<br/>            list.collect(Pair::getTwo)<br/>                    .anySatisfy(each -&gt; each.equals(<strong class="kz hj">"2"</strong>)));<br/>    Assert.<em class="lk">assertFalse</em>(<br/>            list.collect(Pair::getTwo)<br/>                    .anySatisfy(each -&gt; each.equals(<strong class="kz hj">"3"</strong>)));<br/>}</span></pre><p id="6b3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，这是更多的代码，并且在调用<code class="du kw kx ky kz b">collect</code>之后创建了一个临时的<code class="du kw kx ky kz b">List</code>。方法<code class="du kw kx ky kz b">anySatisfy</code>用于等式测试时，可简化为<code class="du kw kx ky kz b">contains</code>。我就用<code class="du kw kx ky kz b">contains</code>代替<code class="du kw kx ky kz b">anySatisfy</code>。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="6877" class="lf ju hi kz b fi lg lh l li lj">@Test<br/>public void eagerCollectContains()<br/>{<br/>    MutableList&lt;Pair&lt;Integer, String&gt;&gt; list =<br/>            Lists.<strong class="kz hj"><em class="lk">mutable</em></strong>.with(<br/>                    Tuples.<em class="lk">pair</em>(1, <strong class="kz hj">"1"</strong>),<br/>                    Tuples.<em class="lk">pair</em>(2, <strong class="kz hj">"2"</strong>));<br/><br/>    Assert.<em class="lk">assertTrue</em>(<br/>            list.collect(Pair::getTwo).contains(<strong class="kz hj">"2"</strong>));<br/>    Assert.<em class="lk">assertFalse</em>(<br/>            list.collect(Pair::getTwo).contains(<strong class="kz hj">"3"</strong>));<br/>}</span></pre><p id="3ebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在代码更加简洁易读，但是我们仍然有额外的临时<code class="du kw kx ky kz b">List</code>创建要删除。这可以通过添加对<code class="du kw kx ky kz b">asLazy</code>的调用来解决。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="5fa3" class="lf ju hi kz b fi lg lh l li lj">@Test<br/>public void lazyCollectContains()<br/>{<br/>    MutableList&lt;Pair&lt;Integer, String&gt;&gt; list =<br/>            Lists.<strong class="kz hj"><em class="lk">mutable</em></strong>.with(<br/>                    Tuples.<em class="lk">pair</em>(1, <strong class="kz hj">"1"</strong>),<br/>                    Tuples.<em class="lk">pair</em>(2, <strong class="kz hj">"2"</strong>));<br/><br/>    Assert.<em class="lk">assertTrue</em>(<br/>            list.asLazy()<br/>                    .collect(Pair::getTwo)<br/>                    .contains(<strong class="kz hj">"2"</strong>));<br/>    Assert.<em class="lk">assertFalse</em>(<br/>            list.asLazy()<br/>                    .collect(Pair::getTwo)<br/>                    .contains(<strong class="kz hj">"3"</strong>));<br/>}</span></pre><p id="fa9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了一个可读的解决方案，它不会产生太多垃圾，但有三个方法调用来查看集合是否包含具有等于特定值的属性的元素。</p><p id="12d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以做得更好。</p><h1 id="ef48" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">融合方法</h1><p id="11eb" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">让我们给<code class="du kw kx ky kz b"><a class="ae la" href="https://www.eclipse.org/collections/javadoc/10.2.0/org/eclipse/collections/api/RichIterable.html" rel="noopener ugc nofollow" target="_blank">RichIterable</a></code>添加一个默认方法来提供这个功能。</p><p id="c2a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是首先，让我们写一个测试。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="2fda" class="lf ju hi kz b fi lg lh l li lj">@Test<br/>public void collectContains()<br/>{<br/>    MutableList&lt;Pair&lt;Integer, String&gt;&gt; list =<br/>            Lists.<strong class="kz hj"><em class="lk">mutable</em></strong>.with(<br/>                    Tuples.<em class="lk">pair</em>(1, <strong class="kz hj">"1"</strong>),<br/>                    Tuples.<em class="lk">pair</em>(2, <strong class="kz hj">"2"</strong>),<br/>                    Tuples.<em class="lk">pair</em>(3, null));<br/><br/>    Assert.<em class="lk">assertTrue</em>(<br/>            list.collectContains(Pair::getTwo, <strong class="kz hj">"2"</strong>));<br/>    Assert.<em class="lk">assertFalse</em>(<br/>            list.collectContains(Pair::getTwo, <strong class="kz hj">"3"</strong>));<br/>    Assert.<em class="lk">assertTrue</em>(<br/>            list.collectContains(Pair::getTwo, null));<br/>    Assert.<em class="lk">assertFalse</em>(<br/>            list.collectContains(Pair::getOne, null));<br/>}</span></pre><p id="af2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们想要融合<code class="du kw kx ky kz b">collect</code>和<code class="du kw kx ky kz b">contains</code>方法，所以我一开始就称之为<code class="du kw kx ky kz b">collectContains</code>。我还添加了一些测试，以确保我们可以与<code class="du kw kx ky kz b">null</code>进行比较。</p><p id="eef8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kw kx ky kz b">RichIterable</code>上的方法<code class="du kw kx ky kz b">collectConains</code>将是急切的，因为它返回一个<code class="du kw kx ky kz b">boolean</code>。我将使用<code class="du kw kx ky kz b">anySatisfy</code>实现该方法，这也是一个返回<code class="du kw kx ky kz b">boolean</code>的方法。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="23c8" class="lf ju hi kz b fi lg lh l li lj">default &lt;V&gt; boolean collectContains(<br/>        Function&lt;? super T, ? extends V&gt; function,<br/>        V value)<br/>{<br/>    if (null == value)<br/>    {<br/>        return this.anySatisfy(<br/>                each -&gt; null == <em class="lk">function</em>.valueOf(each));<br/>    }<br/>    return this.anySatisfy(<br/>            each -&gt; <em class="lk">value</em>.equals(<em class="lk">function</em>.valueOf(each)));<br/>}</span></pre><p id="5e32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我对支持<code class="du kw kx ky kz b">null</code>值的实现的初步尝试。测试通过了。赢了！</p><p id="e8ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我看看使用三元运算符是什么样子的。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="802d" class="lf ju hi kz b fi lg lh l li lj">default &lt;V&gt; boolean collectContains(<br/>        Function&lt;? super T, ? extends V&gt; function,<br/>        V value)<br/>{<br/>        return this.anySatisfy(null == value ?<br/>                each -&gt; null == <em class="lk">function</em>.valueOf(each) :<br/>                each -&gt; <em class="lk">value</em>.equals(<em class="lk">function</em>.valueOf(each)));<br/>}</span></pre><p id="37d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试通过。赢了！</p><p id="0af5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我更喜欢三元运算符方法，但通过将<code class="du kw kx ky kz b">Predicate</code>提取到一个变量中，会使它在下一次迭代中更容易解析。</p><p id="ef1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">更新:</strong>另一位Eclipse Collections的贡献者(<a class="ll lm ge" href="https://medium.com/u/7db07b72520d?source=post_page-----c15c9eb2d666--------------------------------" rel="noopener" target="_blank">弗拉基米尔·扎哈罗夫</a>)阅读了博客的最初版本，并建议对<code class="du kw kx ky kz b">collectContains</code>方法可能有一个更好的名字，基于我们以前对采用<code class="du kw kx ky kz b">Function</code>的融合方法使用的类似模式。如果我们添加<code class="du kw kx ky kz b">By</code>作为方法的后缀，去掉<code class="du kw kx ky kz b">collect</code>前缀，我们将得到<code class="du kw kx ky kz b">containsBy</code>。</p><p id="e28d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">2020年7月23日更新</strong>:我今天想到了一个更简单的解决方案，更新如下。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="d99c" class="lf ju hi kz b fi lg lh l li lj">default &lt;V&gt; boolean containsBy(<br/>        Function&lt;? super T, ? extends V&gt; function,<br/>        V value)<br/>{<br/>    Objects.<em class="lk">requireNonNull</em>(function);<br/>    return this.anySatisfy(<br/>            each -&gt; Objects.<em class="lk">equals</em>(<em class="lk">value</em>, <em class="lk">function</em>.valueOf(each)));<br/>}</span></pre><p id="feca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将导致测试中的代码如下所示。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="7adb" class="lf ju hi kz b fi lg lh l li lj">@Test<br/>public void containsBy()<br/>{<br/>    MutableList&lt;Pair&lt;Integer, String&gt;&gt; list =<br/>            Lists.<strong class="kz hj"><em class="lk">mutable</em></strong>.with(<br/>                    Tuples.<em class="lk">pair</em>(1, <strong class="kz hj">"1"</strong>),<br/>                    Tuples.<em class="lk">pair</em>(2, <strong class="kz hj">"2"</strong>),<br/>                    Tuples.<em class="lk">pair</em>(3, null));<br/><br/>    Assert.<em class="lk">assertTrue</em>(<br/>            list.containsBy(Pair::getTwo, <strong class="kz hj">"2"</strong>));<br/>    Assert.<em class="lk">assertFalse</em>(<br/>            list.containsBy(Pair::getTwo, <strong class="kz hj">"3"</strong>));<br/>    Assert.<em class="lk">assertTrue</em>(<br/>            list.containsBy(Pair::getTwo, null));<br/>    Assert.<em class="lk">assertFalse</em>(<br/>            list.containsBy(Pair::getOne, null));<br/>}</span></pre><p id="0b7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我觉得这样好多了。谢谢你的建议<a class="ll lm ge" href="https://medium.com/u/7db07b72520d?source=post_page-----c15c9eb2d666--------------------------------" rel="noopener" target="_blank">弗拉基米尔扎哈罗夫</a>！</p><p id="a023" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">带有<code class="du kw kx ky kz b">By</code>后缀并以<code class="du kw kx ky kz b">Function</code>作为参数的其他方法的例子有<code class="du kw kx ky kz b">aggregateBy</code>、<code class="du kw kx ky kz b">groupBy</code>、<code class="du kw kx ky kz b">countBy</code>、<code class="du kw kx ky kz b">minBy</code>、<code class="du kw kx ky kz b">maxBy</code>等。几年前，我写了一篇博客，谈论介词<code class="du kw kx ky kz b">By</code>带来的生产率提高。</p><div class="ln lo ez fb lp lq"><a rel="noopener follow" target="_blank" href="/javarevisited/by-yourself-some-time-e16c0f488847"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">一个人呆一会儿</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">介词By，及其对生产力的积极贡献。</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">medium.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me jn lq"/></div></div></a></div><h1 id="fd06" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">那么该不该加这个方法呢？</h1><p id="22d0" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我认为我们应该将<code class="du kw kx ky kz b">containsBy</code>添加到<a class="ae la" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a> <code class="du kw kx ky kz b"><a class="ae la" href="https://www.eclipse.org/collections/javadoc/10.2.0/org/eclipse/collections/api/RichIterable.html" rel="noopener ugc nofollow" target="_blank">RichIterable</a></code>类型中。这是一种常见的模式，其好处将大大超过实施和支持成本。除了添加一些额外的测试之外，没有什么需要做的，所以我可能很快就会提交一个pull请求。</p><h1 id="b6f5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们能把这个加入Java流吗？</h1><p id="02b2" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">答案既是“当然”，也是“看情况”。我不认为我们今天可以在<code class="du kw kx ky kz b">Stream</code>上调用<code class="du kw kx ky kz b">contains</code>，因为它不存在。你自己看看吧。您当然可以使用<code class="du kw kx ky kz b">anyMatch</code>实现相同的代码。最大的问题是，这种方法是否被认为有足够高的价值来增加JDK。方法名可以是<code class="du kw kx ky kz b">mapContains</code>或<code class="du kw kx ky kz b">containsBy</code>，也可以简单到将这个默认方法添加到流中。</p><pre class="je jf jg jh fd lb kz lc ld aw le bi"><span id="049d" class="lf ju hi kz b fi lg lh l li lj">default &lt;V&gt; boolean containsBy(<br/>        Function&lt;? super T, ? extends V&gt; function,<br/>        V value)<br/>{<br/>    Objects.<em class="lk">requireNonNull</em>(function);<br/>    return this.anyMatch(<br/>            each -&gt; Objects.<em class="lk">equals</em>(<em class="lk">value</em>, <em class="lk">function</em>.apply(each)));<br/>}</span></pre><p id="4159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能是添加到Java <code class="du kw kx ky kz b">Stream</code>中的更有价值的方法，而不仅仅是<code class="du kw kx ky kz b">contains</code>本身。</p><p id="ff5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你怎么想呢?</p><p id="ce6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk">我是</em><a class="ae la" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="lk">Eclipse Collections</em></a><em class="lk">OSS项目在</em><a class="ae la" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="lk">Eclipse Foundation</em></a><em class="lk">的项目负责人。</em> <a class="ae la" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="lk">月食收藏</em> </a> <em class="lk">开作</em> <a class="ae la" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="lk">投稿</em> </a> <em class="lk">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div></div>    
</body>
</html>