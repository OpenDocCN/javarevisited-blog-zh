# 端到端调试对象建模。构建 DDTJ 的第一个难题—第 4 天

> 原文：<https://medium.com/javarevisited/end-to-end-debug-object-modeling-first-hard-problem-in-building-ddtj-day-4-77c2d10874c7?source=collection_archive---------0----------------------->

![](img/0d5812a8312ff4e73195512c4456060b.png)

昨天我拿到了第二份 PR(T1)(第三份是自动的)。今天没那么有成效…

这些地区的冬天刚刚开始，昨天，一切都被淹没了。这拖慢了我的一些工作，尤其是在我儿子的幼儿园被洪水淹没后，他不得不呆在家里。

尽管如此，我还是可以取得进步，这要感谢代码现在是端到端运行的。这意味着我可以通过使用命令行并在后端设置断点来开始调试整个事情。非常方便。

我现在终于可以开始收集数据了。我也遇到了我的第一个“难题”,我已经在心理上回避了一段时间了…

# 问题是

调试应用程序大多是琐碎的。假设我们调用一个方法并得到一个事件。具体来说，是一个 MethodEntryEvent。在这种情况下，我们可以获取参数的值，等等。当我们调用需要模拟的 API 时，情况也是如此。但那是以后的事了…现在，让我们把注意力放在那上面。

调试器返回了一个有点问题的值类型。我们需要把所有的数据都拉到本地(调试器是一个远程虚拟机)来进行调试。核心问题是深度对象图。例如，假设我有一个方法，比如:

```
void method(Root obj) {
    //...
}
```

现在 Root 包含了对系统中每个对象的引用。如果我们想在将来的执行中正确地调用这个方法，我们需要拉 Root 和它的所有数据吗？
这太疯狂了。一定有更好的方法…

但这是个小问题。假设我们在本地有一个对象的数据。我们如何用正确的值创建一个实例来传递给一个方法呢？我们使用构造函数了吗？一个[建筑商](https://javarevisited.blogspot.com/2012/06/builder-design-pattern-in-java-example.html)？还是都是百分百嘲讽？

如果是后者，代码可读吗？

我们生成的测试会通过吗？

在过去的一天里，我对此进行了更多的思考，在这里我有点矛盾。在这种情况下，我有时采取的一种方法是从头到尾观察这些事情，然后将结果提炼为我喜欢的东西。有时候，随着我们越来越接近，解决方案就会显现出来。

以下是我解决这个问题的一些想法…

# “疯狂”的想法

我的一个想法是:

*   观察每个对象的创建并记录下来
*   如果创建了一个新类型的对象，或者它是以一种新的方式创建的，我们可以将创建过程连接到字段
*   如果构造函数是公共的，我们可以使用它
*   如果是一个构建器，我们可以从那里开始遵循这个过程

当我写这篇文章的时候，这个想法似乎比在我脑海中听起来更疯狂，但它可能是可行的。至少部分是。

# 不是疯狂的想法——启发式

这个疯狂的想法确实有点过分。但是对于最常见的代码，我们可以做一些事情来达到类似的效果。

我认为 98%的对象都属于非常常见的创建和约定模式。通过编写最常见的试探法，我们大概可以正确地自动生成 98%的测试，剩下的 2%也可以……这可能是一个很小的修正。

*   如果一个类有一个匹配字段名的 setter 问题就解决了
*   如果类没有默认构造函数[但是有一个接受匹配字段的参数的构造函数。如果名称不匹配，则根据参数名称或类型传递字段](https://javarevisited.blogspot.com/2014/01/why-default-or-no-argument-constructor-java-class.html)
*   如果两者都不匹配，则检查返回类实例的静态方法
*   最后，寻找构建器调用

如果我选择这条路线，我可能会为 MVP 实现前两条。

# 黑客

另一种方法是完全跳过这一步并序列化对象。我们可以分配和注入磁场。不幸的是，我怀疑代码会看起来很棒。我认为这是上述观点如此吸引人的主要原因。

然而，对于纯数据对象，这可能不是一个可怕的想法。

# 明显的想法(嘲讽)

显然，嘲笑所有传入的对象是有其价值的。但我不确定这是否是我们真正想要做的。模仿代码相当冗长。也没有增加嘲讽类的覆盖面。

即使我们使用模仿的方法，这仍然不是微不足道的，并且最终会嵌套很多，因为模仿的对象可能需要返回另一个(模仿的)对象，等等。筑巢会变得相当困难。

# 我现在正在做的事情

我还处于收集数据的早期阶段，所以我只是将值对象数据收集到一个简化的对象中。本质上，一种类型的字符串和一个对象。如果是原值，那就简单了。我只是存储值。
最初，我试图简化对象的方法。我想，如果它是一个对象，我可以用该对象的非瞬态字段创建一个映射。我会有一个嵌套常数和一个递归阻塞器来阻止我深入对象层次结构。这将允许我检测到同一个对象的链接，并在内部使用相同的引用来避免问题。我可能还需要最后一部分。我还有一个阻止递归的计划，所以默认情况下不会超过 3 层。

但是我认为那不是一个可行的解决办法。当我们试图基于此生成代码时，我们会遇到问题。我认为我们需要实施“不那么疯狂”的想法，我认为这是一个可行的方法。为了让这个工作，我需要一个额外的数据点。我需要缓存我们能创建的类对象和不能创建的类对象。如果我们能创建一个类，我们将标记它。假设有一个创建类的过程，我们将知道需要保存的字段。

如果我们不能创建一个类，我们仍然可以选择为那个类生成一个模拟，所以测试仍然是可能的。

当我写这篇文章的时候，我也在编写逻辑代码，这将是很广泛的。明天可能会发现我实现了完全不同的东西…

# 扩大覆盖面

我把我昨天做的公关和像样的报道合并了。原来我丢失了`lombok.config`文件。这不是必需的，但是您需要添加条目:

```
lombok.addLombokGeneratedAnnotation=true
```

否则， [Lombok](https://javarevisited.blogspot.com/2021/08/how-to-use-lombok-library-in-java.html) 生成的代码不会被标记为生成的代码，而是包含在覆盖率统计中。我有 30%的覆盖率，有 11 行没有覆盖……加上这个就把动态变成了 83%。

# 今天

昨天一天结束的时候有一件事很糟糕…结果是我在过去几天的文档标题中复制粘贴了一个错别字，它说 DDJT 而不是 DDTJ。呃。我不能修理它。它在 URL 中，它是辛迪加的等等。拼写检查器真的应该检查标题，但公平地说，他们甚至根本不检查缩写。

希望今天会更好。我计划在我们单步调试代码时取出对象状态和字段。我希望能在周末之前有所进展，但那可能只会发生在下周。

如果你觉得这很有趣/有用，如果你[在推特上关注我](https://twitter.com/debugagent)那就太好了……