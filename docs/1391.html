<html>
<head>
<title>Java: Creating and Using Custom Annotations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java:创建和使用定制注释</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-creating-and-using-custom-annotations-a792f3d9962f?source=collection_archive---------0-----------------------#2021-07-19">https://medium.com/javarevisited/java-creating-and-using-custom-annotations-a792f3d9962f?source=collection_archive---------0-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9c4081dd015970c53ec570da93b7925a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzhVkbgTIb7SUr6AQK-xkA.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">我对注释的Java徽标的看法</p></figure><p id="a57e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">🍎在我的<a class="ae js" href="https://utkjain.medium.com/java-annotations-101-cd4d01e1470a" rel="noopener">上一篇文章</a>中，我解释了什么是注释以及如何在Java中使用预构建的注释。Java还为我们提供了创建自己的注释来增强代码的选项。要生成任何自定义注释，我们也必须使用元注释。本文解释了如何创建元注释和自定义注释，并用它们来装饰对象。请继续阅读！</p><h1 id="6deb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">自定义注释</h1><p id="73dd" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">☕️除了Java提供的大量预定义注释，我们还可以定义自己的自定义注释。自定义注释帮助:</p><ul class=""><li id="52c4" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">通过向方法添加默认行为，减少编写代码的工作量</li><li id="b0a6" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">向类和接口添加自定义行为</li><li id="630d" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">省去编写XML描述符和标记接口的工作</li></ul><p id="ae8e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">✍🏽要定义任何自定义注释，我们首先需要使用一个<code class="du lk ll lm ln b">@interface</code>标签来声明它。然后，我们使用元注释定义目标和范围。我已经在本文的后半部分解释了元注释(Retention、Target、Inherited)的使用。自定义注释可以在三个级别上定义:</p><ul class=""><li id="43dd" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">班级水平</li><li id="d406" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">现场水平</li><li id="ee02" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">方法级别</li></ul><h2 id="17a1" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jf lv lw kh jj lx ly kl jn lz ma kp mb bi translated">班级水平</h2><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="ad92" class="lo ju hi ln b fi mk ml l mm mn">@Retention(RetentionPolicy.RUNTIME)<br/>@Target(ElementType.Type)<br/>public @interface CustomAnnotation{ ... }</span></pre><p id="e809" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">🧑🏽‍🏫上面的<code class="du lk ll lm ln b">CustomAnnotation</code>有一个运行时保留策略，我们可以将它应用于所有的类。因为它没有方法，所以它作为一个简单的标记来标记我们需要的类。这里需要注意的一点是，任何类级别的自定义注释都不能有任何参数，也不能抛出任何异常。另外，返回值类型仅限于<a class="ae js" href="https://javarevisited.blogspot.com/2015/09/difference-between-primitive-and-reference-variable-java.html" rel="noopener ugc nofollow" target="_blank">原语</a>，<a class="ae js" rel="noopener" href="/javarevisited/top-21-string-programming-interview-questions-for-beginners-and-experienced-developers-56037048de45">字符串</a>，<a class="ae js" href="https://www.java67.com/2017/08/difference-between-abstract-class-and-interface-in-java8.html" rel="noopener ugc nofollow" target="_blank">类</a>，<a class="ae js" href="https://javarevisited.blogspot.com/2011/08/enum-in-java-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">枚举</a>，注释，它们的<a class="ae js" rel="noopener" href="/javarevisited/20-array-coding-problems-and-questions-from-programming-interviews-869b475b9121">数组</a>，默认值不能为空。</p><h2 id="9572" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jf lv lw kh jj lx ly kl jn lz ma kp mb bi translated">现场水平</h2><p id="6730" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">🏟类似于类级别，我们可以定义字段级别的注释并将范围限制到它们。</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="e33c" class="lo ju hi ln b fi mk ml l mm mn">@Retention(RetentionPolicy.RUNTIME)<br/>@Target(ElementType.FIELD)<br/>public @interface CustomAnnotation{ ... }</span></pre><h2 id="674e" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jf lv lw kh jj lx ly kl jn lz ma kp mb bi translated"><strong class="ak">方法级别</strong></h2><p id="a7b6" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">👨🏾‍🔧我们还可以声明一个带有运行时保留的注释，以应用于我们的类的方法，如下所示:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="0d07" class="lo ju hi ln b fi mk ml l mm mn">@Retention(RetentionPolicy.RUNTIME)<br/>@Target(ElementType.METHOD)<br/>public @interface CustomAnnotation{ ... }</span></pre><h2 id="1de6" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jf lv lw kh jj lx ly kl jn lz ma kp mb bi translated">使用自定义注释</h2><p id="8151" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">这里有一个🪛的例子来演示自定义注释的使用。</p><p id="5e49" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">大概是2类，汽车和发动机。假设我们有一个要求，即BasicEngine需要适用于所有类型的汽车。在这种情况下，我们可以开发像<code class="du lk ll lm ln b">@BasicEngine</code>这样的定制注释，并注释所有种类的汽车实现(例如，掀背车、跑车、轿车等)。，)带<code class="du lk ll lm ln b">BasicEngine</code>。</p><blockquote class="mo mp mq"><p id="3fec" class="iu iv mr iw b ix iy iz ja jb jc jd je ms jg jh ji mt jk jl jm mu jo jp jq jr hb bi translated">自定义注释类(接口):</p></blockquote><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="874f" class="lo ju hi ln b fi mk ml l mm mn">import java.lang.annotation.*;<br/>@Inherited<br/>@Documented<br/>@Target(ElementType.TYPE)<br/>@Retention(RetentionPolicy.RUNTIME)<br/><br/>@interface Basic<!-- -->Engine<!-- --> {<br/>    String mileage() default "20";<br/>    String fuelType() default "<!-- -->Gasoline<!-- -->";<br/>}</span></pre><blockquote class="mo mp mq"><p id="aee5" class="iu iv mr iw b ix iy iz ja jb jc jd je ms jg jh ji mt jk jl jm mu jo jp jq jr hb bi translated">使用自定义批注初始化(无需导入):</p></blockquote><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="0cfa" class="lo ju hi ln b fi mk ml l mm mn">@Basic<!-- -->Engine<!-- -->(bId="30", bName="BioDiesel")<br/>public class Car {<br/>    String make;<br/>    String model;</span><span id="8c87" class="lo ju hi ln b fi mv ml l mm mn">    public Car(String make, String model){<br/>        this.make = make;<br/>        this.model = model;<br/>    }<br/><br/>    public void getCarDetails(){<br/>        System.out.println("Car Manufacturer: " + make);<br/>        System.out.println("Car Model: " + model);<br/>    }<br/>}</span></pre><blockquote class="mo mp mq"><p id="e579" class="iu iv mr iw b ix iy iz ja jb jc jd je ms jg jh ji mt jk jl jm mu jo jp jq jr hb bi translated">测试上述内容的驱动程序类:</p></blockquote><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="4b38" class="lo ju hi ln b fi mk ml l mm mn">import java.lang.annotation.Annotation;<br/>public class TestCustomAnnotationBasic<!-- -->Engine<!-- --> {</span><span id="330a" class="lo ju hi ln b fi mv ml l mm mn">public static void main(String[] args) throws Exception{<br/>        Car car = new Car("32", "<!-- -->Diesel<!-- -->");<br/>        car.getCarDetails();<br/>        Class carClass = car.getClass();</span><span id="3c6f" class="lo ju hi ln b fi mv ml l mm mn">        Annotation testAnn = carClass.getAnnotation(BasicEngine.class);</span><span id="f05b" class="lo ju hi ln b fi mv ml l mm mn">        Basic<!-- -->Engine<!-- --> engine = (Basic<!-- -->Engine<!-- -->)testAnn;</span><span id="ce15" class="lo ju hi ln b fi mv ml l mm mn">        System.out.println("Mileage: " + engine.mileage());<br/>        System.out.println("Fuel Type: " + engine.fuelType());<br/>    }<br/>}</span></pre><h1 id="16f5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">元注释</h1><p id="a0a2" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">🏴元注释是应用于其他注释以增加其范围的注释。这非常重要，因为它允许我们使用其他注释来描述注释，并编写注释。</p><p id="afa2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">♨️ Java直接在语言蓝图中加入了重要的元注释:</p><h2 id="a7c4" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jf lv lw kh jj lx ly kl jn lz ma kp mb bi translated">@继承</h2><p id="11a8" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">👨‍👦默认情况下，批注不能从其超类继承。然而，如果我们需要从超类继承一个注释到子类，我们使用<code class="du lk ll lm ln b">@Inherited</code>注释。</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="3984" class="lo ju hi ln b fi mk ml l mm mn">@Inherited<br/>public @interface CustomAnnotation { ... }</span><span id="2dd0" class="lo ju hi ln b fi mv ml l mm mn">@CustomAnnotation<br/>public class ParentClass { ... }</span><span id="294c" class="lo ju hi ln b fi mv ml l mm mn">public class ChildClass extends ParentClass { ... }</span></pre><p id="2a23" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，ChildClass类将自动获取CustomAnnotation，因为它是从ParentClass继承而来的。ChildClass将能够调用任何CustomAnnotations功能</p><h2 id="c6a5" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jf lv lw kh jj lx ly kl jn lz ma kp mb bi translated">@目标</h2><p id="fb3f" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">🎯注释的作用域是基于方法或文件的需求，就像构造函数或声明一样。我们可以使用<code class="du lk ll lm ln b">@Target</code>注释将注释限制为应用于特定的目标。</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="5899" class="lo ju hi ln b fi mk ml l mm mn">@Target(ElementType.METHOD)<br/>public @interface CustomAnnotation{ ... }</span></pre><p id="8c20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码中，<code class="du lk ll lm ln b">CustomAnnotation</code>只限于方法，也就是说，字段、包等不会用它来注释。</p><blockquote class="mo mp mq"><p id="ff64" class="iu iv mr iw b ix iy iz ja jb jc jd je ms jg jh ji mt jk jl jm mu jo jp jq jr hb bi translated">如果没有定义目标类型，注释可以用于任何元素。</p></blockquote><h2 id="42cf" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jf lv lw kh jj lx ly kl jn lz ma kp mb bi translated">@保留</h2><p id="176f" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">🤔<code class="du lk ll lm ln b">@Retention</code>指定注释可用的级别。<br/>Java允许我们定义三个级别的保留策略:</p><ul class=""><li id="7222" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated"><code class="du lk ll lm ln b"><strong class="iw hj">RetentionPolicy.SOURCE</strong></code> —在源代码级别可用，被编译器忽略</li><li id="42ae" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><code class="du lk ll lm ln b"><strong class="iw hj">RetentionPolicy.CLASS</strong></code> —在编译时对编译器可用，但被JVM忽略</li><li id="2d2d" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated"><code class="du lk ll lm ln b"><strong class="iw hj">RetentionPolicy.RUNTIME</strong></code> —适用于<a class="ae js" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686?source=---------8------------------"> JVM </a></li></ul><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="8b27" class="lo ju hi ln b fi mk ml l mm mn">@Retention(RetentionPolicy.RUNTIME)<br/>public @interface CustomAnnotation{ ... }</span></pre><p id="d677" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">🍏总之，注释是Java提供的一个方便的工具，学习它们对于成为一个更好更聪明的开发人员是至关重要的！</p></div></div>    
</body>
</html>