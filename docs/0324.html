<html>
<head>
<title>Spring: Searching For Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">春天:寻找背景</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-searching-for-context-df08d5b562e?source=collection_archive---------0-----------------------#2020-03-05">https://medium.com/javarevisited/spring-searching-for-context-df08d5b562e?source=collection_archive---------0-----------------------#2020-03-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1662babb27be295919688ecc3eabe913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35DRm_SSFTwVPBYM4V1D8Q.jpeg"/></div></div></figure><p id="db84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几个月前，我分享了一份关于 Java 虚拟机上<a class="ae jo" rel="noopener" href="/swlh/tools-for-launching-and-developing-products-on-jvm-94a29d502d11">类加载的详细指南。报告结束后，我的同事问 Spring 使用什么机制来解析配置，以及它如何从上下文中加载类。</a></p><p id="50ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过几个小时的 Spring 源代码调试，我的同事实验性地了解了这个非常简单明了的事实。</p><h1 id="9aad" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一点理论</h1><p id="09ed" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj"> ApplicationContext </strong>是 Spring app 中的主接口，为应用程序提供配置信息。</p><p id="c7cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在直接进行演示之前，让我们看一下<em class="ks">应用上下文</em>创建的步骤:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/ab75ce3e0c92421cd54d56960387d0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7Sdqdfrzbog5pry9.jpg"/></div></div></figure><p id="49ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将分析第一个阶段，因为我们对读取配置文件和创建<em class="ks"> BeanDefinition </em>感兴趣。</p><p id="52d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> BeanDefinition </strong>是一个描述 bean、其属性、构造函数参数和其他元信息的接口。</p><p id="a1e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至于 beans 本身的配置，Spring 有 4 种配置方法:</p><ol class=""><li id="2c3d" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated"><strong class="is hj"> XML 配置</strong>—<em class="ks">classpathmlaplicationcontext(" context . XML ")；</em></li><li id="812c" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj"> Groovy 配置</strong>—<em class="ks">GenericGroovyApplicationContext(" context . Groovy ")；</em></li><li id="2020" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj">基于注释的配置</strong>，其中您指定要扫描的包—<em class="ks">AnnotationConfigApplicationContext(" package . name ")；</em></li><li id="8f7f" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated"><strong class="is hj"> JavaConfig </strong> —基于注释的配置，指示用<strong class="is hj">@ Configuration</strong>—<em class="ks">AnnotationConfigApplicationContext(Java config . class)注释的(Java)类(或类的数组)。</em></li></ol><div class="lm ln ez fb lo lp"><a href="https://javarevisited.blogspot.com/2018/08/how-to-crack-spring-core-professional-certification-exam-java-latest.html#axzz5j90KOik7" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">如何破解 Spring Core Professional v5.0 认证 Java 最新 Spring 认证…</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">自从 Pivotal 之后，Spring framework 背后的公司将强制的 Spring 培训变成了可选的(参见这里)，我已经…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md io lp"/></div></div></a></div><h1 id="075d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">XML 配置</h1><p id="4105" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们以一个简单的项目为基础:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="7ddf" class="mj jq hi mf b fi mk ml l mm mn">public class SpringContextTest{<br/>       private static String classFilter = "film.";<br/>       <br/>       public static void main(String[] args){<br/>            <br/>             printLoadedClasses(classFilter);<br/>             /* Classloader: sun.misc.Launcher$AppClassLoader@18b4aac2<br/>                All - 5 : 0 - Filtered      /*<br/>            doSomething(MainCharacter.num); doSomething(FilmMaker.class);<br/>            printLoadedClasses(classFilter);<br/>            /* Classloader: sun.misc.Launcher$AppClassLoader@18b4aac2<br/>                   class film.MainCharacter<br/>                   class film.FilmMaker<br/>                All - 7 : 2 - Filtered     /*</span></pre><p id="20f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们应该解释使用了什么方法以及它们的用途:</p><ul class=""><li id="4a5d" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn mo le lf lg bi translated"><em class="ks">printLoadedClasses(String…filters)</em>方法显示从包中加载的加载程序和 JVM 类的名称，作为参数传输到控制台。此外，还有关于所有已加载类的数量的信息</li><li id="7f53" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated"><em class="ks"> doSomething(Object o) </em>是一种执行原始工作的方法，但不允许在编译阶段的优化过程中排除所提到的类</li></ul><p id="13d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将 Spring 连接到我们的项目(以下使用 Spring 4):</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="8117" class="mj jq hi mf b fi mk ml l mm mn">    11 public class SpringContextTest{<br/>    12    private static String calssFilter = "film.";<br/>    13    <br/>    14    public static void main(String[] args){<br/>    15        <br/>    16        printLoadedClasses(classFilter);<br/>    17       /* Classloader: sun.misc.Launcher$AppClassLoader@18b4aac2<br/>    18           All - 5 : 0 - Filtered      /*<br/>    19        doSomething(MainCharacter.num); doSomething(FilmMaker.class);<br/>    20        printLoadedClasses(classFilter);<br/>    21        /* Classloader: sun.misc.Launcher$AppClassLoader@18b4aac2<br/>    22               class film.MainCharacter<br/>    23               class film.FilmMaker<br/>    24               All - 7 : 2 - Filtered   /*<br/>    25        ApplicationContext context = new ClassPathXmlApplicationContext(<br/>    26         configLocation: "applicationContext.xml");<br/>    27        printLoadedClasses(classFilter);</span></pre><p id="4176" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第 25 行是通过 XML 配置对 ApplicationContext 的声明和初始化</p><p id="2ee8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">配置 XML 文件如下所示:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="ac9a" class="mj jq hi mf b fi mk ml l mm mn">&lt;beans xmlns = "<a class="ae jo" href="http://www.spingframework.org/schema/beans" rel="noopener ugc nofollow" target="_blank">http://www.spingframework.org/schema/beans</a>" xmlns:xsi = "link"&gt;<br/>    &lt;bean id = "villain" class = "film.Villain" lazy-init= "true"&gt;<br/>    &lt;property name = "name" value = "Vasily"/&gt;<br/>    &lt;/bean&gt;</span></pre><p id="8211" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当配置一个 bean 时，我们指定一个真正存在的类。注意给定的属性<em class="ks"> lazy-init = "true" </em>:在这种情况下，只有在从上下文中请求 bean 之后，才会创建它。</p><p id="1a0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看 Spring 在解析上下文时如何处理配置文件中声明的类的情况:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="e4a6" class="mj jq hi mf b fi mk ml l mm mn">public class SpringContextTest {<br/>    private static String classFilter = "film.";<br/>    <br/>    public static void main(String[] args) {<br/>        <br/>           printLoadedClasses(classFilter);<br/>        /* Classloader: sun.misc.Launcher$AppClassLoader@18b4aac2<br/>           All - 5 : 0 - Filtered      /*<br/>        doSomething(MainCharacther.num); doSomething(FilmMaker.class);<br/>        printLoadedClasses(classFilter);<br/>        /* Classloader: sun.misc.Launcher$AppClassLoader@18b4aac2<br/>               class film.MainCharacter<br/>               class film.FilmMaker<br/>            All - 7 : 2 - Filtered     /*<br/>        ApplicationContext context = new ClassPathXmlApplicationContext(<br/>                  configLocation: "applicationContext.xml");<br/>        printLoadedClasses(classFilter);<br/>        /* Classloader: sun.misc.Launcher$AppClassLoader@18b4aac2<br/>               class film.MainCharacter<br/>               class film.FilmMaker<br/>               class film.Villain<br/><br/>            All - 343 : 3- Filtered     /*</span></pre><p id="aaa9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在执行<em class="ks">printLoadedClasses(calss filter)</em>之后，343 个类与上下文一起被加载，其中 3 个是我们的包中的类。这意味着在以前使用的类中又增加了一个类，在配置 XML 文件中被称为<em class="ks">电影。薇莉安</em>级。</p><p id="5f33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看看 XML 配置的细节:</p><ul class=""><li id="949a" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn mo le lf lg bi translated">配置文件由<strong class="is hj"> XmlBeanDefinitionReader </strong>类读取，该类实现了<em class="ks"> BeanDefinitionReader </em>接口。</li><li id="d2b2" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated"><strong class="is hj">XmlBeanDefinitionReader</strong>在输入端接收 InputStream，并通过<em class="ks"> DefaultDocumentLoader </em>加载<em class="ks">文档</em>:</li></ul><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="30b7" class="mj jq hi mf b fi mk ml l mm mn">Document doc = doLoadDocument(inputSource, resource);<br/>    return registerBeanDefinitions(doc, resource);</span></pre><ul class=""><li id="079c" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn mo le lf lg bi translated">之后，处理该文档的每个元素，如果是 bean，则根据填充的数据(id、名称、类、别名、init-method、destroy-method 等)创建 BeanDefinition。):</li></ul><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="ac44" class="mj jq hi mf b fi mk ml l mm mn">this.beanDefinitionMap.put(beanName, beanDefinition);<br/>        this.beanDefinitionNames.add(beanName);</span></pre><ul class=""><li id="ad32" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn mo le lf lg bi translated">每个<em class="ks"> BeanDefinition </em>都放在 Map 中，Map 存储在<em class="ks">DefaultListableBeanFactory</em>类中:</li></ul><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="d7dd" class="mj jq hi mf b fi mk ml l mm mn">this.beanDefinitionMap.put(beanName, beanDefinition);<br/>        this.beanDefinitionNames.add(beanName);</span></pre><p id="cb13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码中的 Map 如下所示:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="a3dc" class="mj jq hi mf b fi mk ml l mm mn">/** Map of bean definition objects, keyed by bean name */<br/>    private final Map beanDefinitionMap = new ConcurrentHashMap(64);</span></pre><p id="24fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们添加另一个包含 film 的 bean 声明。bad 小人类添加到同一个配置文件:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="c01a" class="mj jq hi mf b fi mk ml l mm mn">&lt;beans xmlns = "<a class="ae jo" href="http://www.spingframework.org/schema/beans" rel="noopener ugc nofollow" target="_blank">http://www.spingframework.org/schema/beans</a>" xmlns:xsi = "link"&gt;<br/>    &lt;bean id = "goodVillain" class = "film.Villain" lazy-init= "true"&gt;<br/>    &lt;property name = "name" value = "Good Vasily"/&gt;<br/>    &lt;/bean&gt;<br/>    &lt;bean id = "badVillain" class = "film.BadVillain" lazy-init= "true"&gt;<br/>    &lt;property name = "name" value = "Bad Vasily"/&gt;<br/>    &lt;/bean&gt;</span></pre><p id="fd8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将会看到如果打印一个创建的<em class="ks">bean defension names</em>和加载的类的列表会发生什么:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="c712" class="mj jq hi mf b fi mk ml l mm mn">ApplicationContext context = new ClassPathXmlApplicationContext(<br/>    configLocation: "applicationContext.xml");<br/>System.out.println(Arrays.asList(context.getBeanDefinitionNames()));<br/>    <br/>printLoadedClasses(calssFilter);</span></pre><p id="f7d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管那班<em class="ks">电影。配置文件中指定的 bad victor</em>不存在，Spring 工作正常，没有错误:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="655b" class="mj jq hi mf b fi mk ml l mm mn">ApplicationContext context = new ClassPathXmlApplicationContext(<br/>    configLocation: "applicationContext.xml");<br/>System.out.println(Arrays.asList(context.getBeanDefinitionNames()));<br/>//  [goodVillain, badVillain]<br/>printLoadedClasses(calssFilter);<br/>/* Classloader: sun.misc.Launcher$AppClassLoader@18b4aac2<br/>           class film.MainCharacter<br/>           class film.FilmMaker<br/>           class film.Villain<br/>All - 343 : 3- Filtered   /*</span></pre><p id="b67a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ks">bean defension names</em>的列表包含 2 个元素；也就是说，我们的文件中配置的那两个 bean 定义已经创建。</p><p id="065c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两个 beans 的配置基本相同。但是，加载了现有的类，没有出现任何问题。这就是为什么我们可以得出结论，也有人试图加载一个不存在的类，但失败的尝试不会影响任何事情。</p><p id="9854" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们试着用它们的名字得到豆子本身:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="ba8f" class="mj jq hi mf b fi mk ml l mm mn">ApplicationContext context = new ClassPathXmlApplicationContext(<br/>    configLocation: "applicationContext.xml");<br/>System.out.println(Arrays.asList(context.getBeanDefinitionNames()));<br/>//  [goodVillain, badVillain]<br/>System.out.println(context.getBean( name: "goodVillain"));<br/><br/>System.out.println(context.getBean( name: "badVillain"));</span></pre><p id="303c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是我们得到的结果:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/244bb1cab84181b1da6814f485fb9c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9uSDcqu19qvGoa29.png"/></div></div></figure><p id="f5ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在第一种情况下收到了有效的 bean，那么在第二种情况下我们会遇到一个异常。</p><p id="7c3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意堆栈跟踪:惰性加载开始起作用了。为了在以前加载的类中找到我们要找的类，所有的类加载器都被绕过了。并且在没有找到必要的类之后，有人试图使用<em class="ks"> Utils.forName </em>方法来找到一个不存在的类，这导致了一个逻辑错误。</p><p id="cbd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当提升上下文时，只加载了一个类，但是，试图加载一个不存在的文件不会导致错误。为什么会这样？</p><p id="d4db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是因为我们声明了<em class="ks"> lazy-init:true </em>并禁止 Spring 创建一个 bean 实例，之前收到的异常就是在这个实例中生成的。如果我们从配置中删除这个属性，或者将它的值改为<em class="ks"> lazy-init:false </em>，那么上面描述的错误也会出现，但是不会被忽略，应用程序会停止。在我们的例子中，上下文被初始化，但是我们不能创建一个 bean 实例，因为没有找到指定的类。</p><div class="lm ln ez fb lo lp"><a rel="noopener follow" target="_blank" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">我最喜欢的 2020 年学习 Spring Boot 的课程——最好的</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">大家好，如果你有兴趣学习 Spring Boot 并寻找一些很棒的资源，如书籍，教程…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">medium.com</p></div></div><div class="ly l"><div class="mq l ma mb mc ly md io lp"/></div></div></a></div><h1 id="dabe" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Groovy 配置</h1><p id="de1f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在借助 Groovy-file 配置上下文时，需要形成<em class="ks">groovybeanditionreader</em>，它在输入上接收带有上下文配置的字符串。在这种情况下，<em class="ks">groovybean definition reader</em>类参与了上下文的读取。事实上，这种配置与 XML 的工作方式相同，只是使用 Groovy 文件。此外，<em class="ks">groovyaplicationcontext</em>也能很好地处理 XML 文件。</p><p id="119c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个简单的配置 Groovy 文件示例:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="7b8c" class="mj jq hi mf b fi mk ml l mm mn">beans {<br/>    goodOperator(film.Operator){bean - &gt;<br/>            bean.lazyInit = 'true' &gt;<br/>            name = 'Good Oleg' <br/>         }<br/>    badOperator(film.BadOperator){bean - &gt;<br/>            bean.lazyInit = 'true' &gt;<br/>            name = 'Bad Oleg' / &gt;<br/>        }<br/>  }</span></pre><p id="0ff8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们试着用 XML 做同样的事情:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/91d2f31f446f2f082bd651f2d64a8a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aNstzdY-ez2Nc6oD.png"/></div></div></figure><p id="6231" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">错误立即出现:Groovy 和 XML 一样，创建 bean 定义，但是在这种情况下，后处理器立即给出错误。</p><div class="lm ln ez fb lo lp"><a rel="noopener follow" target="_blank" href="/javarevisited/top-5-books-to-learn-spring-boot-and-microservices-for-experienced-java-developers-499a9d921d18"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">有经验的 Java 开发人员学习 Spring Boot 和微服务的前 5 本书</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">如果您是一名 Java 开发人员，并且想了解更多关于 Spring Boot 和 Spring Cloud 框架的知识，那么您已经来到了…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">medium.com</p></div></div><div class="ly l"><div class="ms l ma mb mc ly md io lp"/></div></div></a></div><h1 id="3380" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">基于注释的配置，指示要扫描的包或 JavaConfig</h1><p id="f61d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这种配置不同于以前的配置。在基于注释的配置中使用了两种变体，即 JavaConfig 和类上的注释。</p><p id="edea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里使用了相同的上下文:<em class="ks">AnnotationConfigApplicationContext(" package "/javaconfig . class)</em>。它的工作取决于传递给构造函数的内容。</p><p id="82b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<em class="ks">AnnotationConfigApplicationContext</em>中有两个私有字段:</p><ul class=""><li id="e9c3" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn mo le lf lg bi translated">private final<em class="ks">annotatedbeanditionreader</em>reader(与 JavaConfig 一起使用)</li><li id="4391" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">私有最终<em class="ks">classpathbeanditionscanner</em>扫描仪(扫描包裹)</li></ul><p id="81f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">annotatedbeanditionreader</strong>的独特之处在于它分几个阶段工作:</p><ol class=""><li id="e458" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">注册<em class="ks">@配置文件</em>用于进一步解析；</li><li id="3036" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">注册特殊的<em class="ks">bean factorypostprocessor</em>，即<em class="ks">BeanDefinition registry postprocessor</em>，使用<em class="ks">configuration classparser</em>类解析 JavaConfig 并创建 bean definition。</li></ol><p id="7c97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个简单的例子:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="4b13" class="mj jq hi mf b fi mk ml l mm mn">@Configuration<br/>    public class JavaConfig {<br/>        <br/>        @Bean<br/>        @Lazy<br/>        public MainCharacter mainCharacter(){<br/>            MainCharacter mainCharacter = new MainCharacter();<br/>            mainCharacter.name = "Patric";<br/>            return mainCharacter;        <br/>       }    <br/>    }</span><span id="631f" class="mj jq hi mf b fi mt ml l mm mn">public static void main(String[] args) {<br/>        <br/>             ApplicationContext javaConfigContext = <br/>                       new AnnotationConfigApplicationContext(JavaConfig.class);<br/>             for (String str : javaConfigContext.getBeanDefinitionNames()){<br/>                  System.out.println(str);<br/>             }<br/>             printLoadedClasses(classFilter);</span></pre><p id="faf1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们用最简单的 bean 创建一个配置文件。看看会加载什么:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/ef628654703ede947789b8170f12f8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c1-kvdK9AnF2E7vT.png"/></div></div></figure><p id="403c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在 XML 和 Groovy 的情况下，加载的 bean 定义与声明的一样多，那么在这种情况下，声明的和附加的 bean 定义都在提升上下文的过程中加载。在通过 JavaConfig 实现的情况下，所有的类都被立即加载，包括 JavaConfig 本身的类，因为它是一个 bean。</p><p id="9e6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，还有一件事。在 XML 和<a class="ae jo" href="https://javarevisited.blogspot.com/2017/08/top-5-books-to-learn-groovy-for-java.html#axzz5dPh77Fzl" rel="noopener ugc nofollow" target="_blank"> Groovy </a>配置的情况下，上传了 343 个文件；这里出现了 631 个额外文件的更“沉重”的负载。</p><div class="lm ln ez fb lo lp"><a rel="noopener follow" target="_blank" href="/javarevisited/10-advanced-spring-boot-courses-for-experienced-java-developers-5e57606816bd"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">面向有经验的 Java 开发人员的 10 门高级 Spring Boot 课程</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">高级 Spring Boot 课程为有经验的 Java 开发人员学习 Spring Boot 测试，云和容器…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">medium.com</p></div></div><div class="ly l"><div class="mv l ma mb mc ly md io lp"/></div></div></a></div><p id="2854" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">classpathbeanditionscanner</strong>操作阶段:</p><ul class=""><li id="786a" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn mo le lf lg bi translated">指定的包决定了要扫描的文件列表。所有文件都放在目录中；</li><li id="0664" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">扫描器遍历每个文件，接收输入流，并使用<em class="ks">org . spring framework . ASM . class reader . class 扫描它们；</em></li><li id="5a34" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">在第三阶段，扫描器检查找到的对象是否通过了<em class="ks">org . spring framework . core . type . filter . annotationtypefilter</em>批注的过滤器。Spring 搜索用<em class="ks"> @Component </em>注释的类，或者默认包含<em class="ks"> @Component </em>的任何其他注释；</li><li id="0b2b" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">如果验证成功，将创建并注册新的 BeanDefinition。</li></ul><p id="1d80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与 XML 和 Groovy 一样，使用注释的所有“魔力”恰恰在于来自<em class="ks"> springframework.asm </em>包的<em class="ks"> ClassReader.class </em>。这个阅读器的特殊性在于它可以处理字节码。也就是说，阅读器从字节码中获取 InputStream，扫描它并在那里寻找注释。</p><p id="52b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用一个简单的例子来看看扫描仪是如何工作的。我们创建一个自定义注释来查找适当的类:</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="626d" class="mj jq hi mf b fi mk ml l mm mn">import org.springframework.stereotype.Component<br/>    import java.lang.annotation.*;<br/>    @Target({ElementType.TYPE})<br/>    @Retention(RetentionPolicy.RUNTIME)<br/>    @Documented<br/>    @Component<br/>    public @interface MyBeanLoader{<br/>           String value() default "";</span></pre><p id="63ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们创建两个类:一个带有标准的@Component 注释，另一个带有自定义注释。</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="d57d" class="mj jq hi mf b fi mk ml l mm mn">MyBeanLoader("makerFilm")<br/>    @Lazy <br/>    public class FilmMaker {<br/>          public static int staticInt = 1;<br/>          @Value("Silence")<br/>          public String filmName;<br/>          public FilmMaker(){}</span><span id="0fac" class="mj jq hi mf b fi mt ml l mm mn">@Component <br/>    public class MainCharacter {<br/>          public static int num = 1;<br/>          @Value("Silence")<br/>          public String name;<br/>          public MainCharacter() { }</span></pre><p id="0df1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果，我们得到了为这些类生成的 bean 定义，并且成功地加载了类。</p><pre class="ku kv kw kx fd me mf mg mh aw mi bi"><span id="014f" class="mj jq hi mf b fi mk ml l mm mn">ApplicationContext annotationConfigContext =<br/>           new AnnotationConfigApplicationContext(...basePackages: "film");<br/>    for (String str : annotationConfigContext.getBeanDefinitionNames()){<br/>         System.out.println(str);<br/>    }<br/>    printLoadedClasses(classFilter);</span></pre><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/be13f853a223987c784ec37e40e9acab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FEmgsJLK9fy1fuqg.png"/></div></div></figure><h1 id="768d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="554c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">综上所述，提出的问题可以回答如下:</p><h2 id="5fcd" class="mj jq hi bd jr mx my mz jv na nb nc jz jb nd ne kd jf nf ng kh jj nh ni kl nj bi translated">1.Spring 使用什么机制来解析配置？</h2><p id="8e33" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">每个上下文实现都有自己的工具包，但主要使用扫描。在创建 BeanDefinition 之前，我们不会尝试加载类:首先，根据指定的参数进行扫描，然后根据扫描结果创建合适的 bean 定义。然后，后处理器试图自己“调整”BeanDefinition，向它加载一个类，等等。</p><h2 id="8696" class="mj jq hi bd jr mx my mz jv na nb nc jz jb nd ne kd jf nf ng kh jj nh ni kl nj bi translated">2.Spring 如何从上下文中加载类？</h2><p id="78e5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">使用标准的 Java 类加载机制:类加载器被绕过，试图在先前加载的类中找到所需的类，如果找不到该类，就尝试加载它。</p><div class="lm ln ez fb lo lp"><a href="https://javarevisited.blogspot.com/2018/06/top-6-spring-framework-online-courses-Java-programmers.html" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">2020 年深入学习 Spring 框架的前 5 门课程——最佳课程</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">Spring Framework 是 Java 开发人员的一项基本技能，不仅是为了获得一份 Java 开发人员的工作，也是为了你的…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="ly l"><div class="nk l ma mb mc ly md io lp"/></div></div></a></div><p id="b2f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能喜欢的其他<strong class="is hj"> Java 和 Spring 文章</strong></p><ul class=""><li id="3e00" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn mo le lf lg bi translated">每个 Java 开发者都应该知道的 5 个 Spring Boot 特性(<a class="ae jo" href="https://javarevisited.blogspot.com/2018/11/top-5-spring-boot-features-java.html#axzz5YFjHrt5j" rel="noopener ugc nofollow" target="_blank">特性</a>)</li><li id="55e2" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">学习春天和 Spring Boot 的五大免费课程(<a class="ae jo" href="http://www.java67.com/2017/11/top-5-free-core-spring-mvc-courses-learn-online.html" rel="noopener ugc nofollow" target="_blank">课程</a>)</li><li id="a4ef" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">掌握 Spring Boot 在线课程(<a class="ae jo" href="https://javarevisited.blogspot.com/2018/05/top-5-courses-to-learn-spring-boot-in.html" rel="noopener ugc nofollow" target="_blank">课程</a>)</li><li id="f92b" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">Java 开发人员应该学习的 10 件事(<a class="ae jo" href="https://javarevisited.blogspot.com/2017/12/10-things-java-programmers-should-learn.html#axzz5atl0BngO" rel="noopener ugc nofollow" target="_blank">目标</a>)</li><li id="97d8" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">Java 开发人员在日常生活中使用的 10 个工具(<a class="ae jo" href="http://javarevisited.blogspot.sg/2017/03/10-tools-used-by-java-programming-Developers.html#axzz55lrMRnNC" rel="noopener ugc nofollow" target="_blank">工具</a>)</li><li id="4795" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">成为更好的 Java 开发人员的 10 个技巧</li><li id="5fd1" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">学习 Java 微服务的 Top 5 课程？(<a class="ae jo" rel="noopener" href="/javarevisited/top-5-courses-to-learn-microservices-in-java-and-spring-framework-e9fed1ba804d">课程</a>)</li><li id="c678" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">Java 程序员可以从 Spring 学习的 3 个最佳实践(<a class="ae jo" href="https://javarevisited.blogspot.com/2018/06/3-best-practices-java-programmers-can-learn-from-spring-framework.html#axzz5K0PIOpHD" rel="noopener ugc nofollow" target="_blank">最佳实践</a>)</li><li id="343a" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">学习 Spring Boot 和春云的 5 门课程(<a class="ae jo" href="https://javarevisited.blogspot.com/2018/07/top-5-books-to-learn-spring-boot-and-spring-cloud-java.html" rel="noopener ugc nofollow" target="_blank">门课程</a>)</li><li id="8c09" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">改变 Spring Boot Tomcat 端口的 3 种方法(<a class="ae jo" href="https://www.java67.com/2019/07/spring-boot-3-ways-to-change-port-of-tomcat.html" rel="noopener ugc nofollow" target="_blank">教程</a>)</li><li id="a2df" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">Java 程序员的 10 门高级 Spring Boot 课程(<a class="ae jo" rel="noopener" href="/javarevisited/10-advanced-spring-boot-courses-for-experienced-java-developers-5e57606816bd">课程</a>)</li><li id="18a1" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">Java 开发者应该学习的 10 个 Spring MVC 注解(<a class="ae jo" href="https://www.java67.com/2019/04/top-10-spring-mvc-and-rest-annotations-examples-java.html" rel="noopener ugc nofollow" target="_blank">注解</a>)</li><li id="6668" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn mo le lf lg bi translated">15 Spring Boot Java 程序员面试问题(<a class="ae jo" href="https://www.java67.com/2018/06/top-15-spring-boot-interview-questions-answers-java-jee-programmers.html" rel="noopener ugc nofollow" target="_blank">问题</a>)</li></ul><p id="9013" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您阅读本文。如果你觉得这篇文章有用，那么请与你的朋友和同事分享。如果您有任何问题或反馈，请留言。</p></div><div class="ab cl nl nm gp nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hb hc hd he hf"><p id="a9ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">【https://intexsoft.com】原载于 2020 年 3 月 5 日<a class="ae jo" href="https://intexsoft.com/" rel="noopener ugc nofollow" target="_blank"><em class="ks"/></a><em class="ks">。</em></p></div></div>    
</body>
</html>