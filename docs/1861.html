<html>
<head>
<title>Google OAuth 2.0: Securing your mail scraping application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google OAuth 2.0:保护您的邮件抓取应用</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/google-oauth-2-0-securing-your-mail-scraping-application-b5520ef0f390?source=collection_archive---------0-----------------------#2022-01-03">https://medium.com/javarevisited/google-oauth-2-0-securing-your-mail-scraping-application-b5520ef0f390?source=collection_archive---------0-----------------------#2022-01-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b7f243b5bd0adadcc9b427ae56e76020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nBaRmEhA14BlwHQ7"/></div></div><p class="iq ir et er es is it bd b be z dx translated">来自谷歌官方博客的截图</p></figure><blockquote class="iu iv iw"><p id="7a55" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">免责声明:本文是对该解决方案的严格概述。详细的实现和设计超出了本文的范围。</p><p id="3d1e" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">嘿伙计们！谢谢你阅读这篇文章。我将发表一系列文章，一步步指导你将Gmail抓取应用从不太安全的应用程序迁移到安全的应用程序。</p></blockquote><p id="4c27" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">对于所有的软件专业人士，尤其是与提供SaaS解决方案的组织一起工作的人来说，这是为你们所有人准备的。我相信我的假设没有错，你们所有在运营后端工作的人，在职业生涯中都曾敬畏地注视着客户的数据在几秒钟内自动进入你们的系统。认为这很酷，然后你会发现这只是一个<a class="ae jz" href="https://www.java67.com/2017/08/how-to-backup-and-load-crontab-from-file-Linux-example.html" rel="noopener ugc nofollow" target="_blank"> cron工作</a>定期抓取邮件服务器，或者充其量是一个<a class="ae jz" href="https://en.wikipedia.org/wiki/Webhook" rel="noopener ugc nofollow" target="_blank"> webhook </a>注册，触发抓取服务。</p><p id="7d85" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">几乎所有邮件抓取的工作方式都是存储客户端的加密凭证，并用解密的凭证访问邮件服务器进行身份验证和授权。这是一种不太安全的方式。</p><p id="4a47" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj"> 🛈 </strong> <em class="iz">本文讨论了</em> <strong class="ja hj"> <em class="iz"> Google作为服务提供商</em> </strong> <em class="iz">和</em> <strong class="ja hj"> <em class="iz"> Gmail服务作为用例</em> </strong> <em class="iz">在其范围内。</em></p><h1 id="02f4" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">不太安全的应用程序！什么？</h1><p id="48c9" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">正如这个词所描述的，这些应用程序(或服务)以一种<strong class="ja hj"> <em class="iz">不太安全的方式</em> </strong>连接到服务提供商的(这里是谷歌的Gmail)服务器(这里是邮件服务器)。主要问题:</p><ul class=""><li id="6305" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><em class="iz">在你端存储客户凭证</em>:</li></ul><p id="7257" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">这实际上让您负责他们凭证的安全性。在云上工作，一切都归结为一个保存客户端凭证的网络调用(内部网或互联网)。够脆弱！现在你需要管理一个<strong class="ja hj"> <em class="iz">开销的加密流</em> </strong> ( <strong class="ja hj"> <em class="iz">带密钥轮换</em> </strong>)来保护原始凭证。</p><ul class=""><li id="3e88" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><em class="iz">申请无处不在</em>:</li></ul><p id="9746" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">一旦使用凭证进行了身份验证，应用程序就可以控制一个真实的人所能做的一切。<strong class="ja hj"> <em class="iz">无粒度授权</em> </strong>限制应用程序访问用户GSuite数据的特定区域。</p><p id="dcb4" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">默认情况下，Gmail会阻止这些类型的连接请求，Gmail域的管理员必须手动允许不太安全的应用程序(LSA)连接。</p><h1 id="e948" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">LSA呼叫冲锋队。为什么？</h1><p id="8c96" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">这是让我们感谢疫情的为数不多的事情之一。我的心以任何方式触及受疫情影响的灵魂。我之所以这么说，是因为谷歌准备从2020年6月开始<strong class="ja hj"> <em class="iz">关闭对LSA</em></strong><strong class="ja hj"><em class="iz"/></strong>的支持，并将2021年2月作为所有LSA迁移到安全应用的最后期限。</p><p id="09e0" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">值得庆幸的是，作为对疫情效应的回应，谷歌将过渡推迟到“另行通知”。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/20dd9223656ead5debc204e86d86f3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JzUCjU83LQzkIELk"/></div></div><p class="iq ir et er es is it bd b be z dx translated">来自谷歌官方博客的截图</p></figure><h1 id="b765" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">让我们迁徙吧！</h1><p id="1a10" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">多亏了Google，我们现在有了一个完整的路线图来为上述用例迁移到更安全的替代方案。</p><p id="407a" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj"> <em class="iz"> OAuth 2.0是解决这一问题的方法</em>！</strong></p><p id="d018" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">对于我们这些不知道OAuth是什么的人来说，<a class="ae jz" href="https://www.blogger.com/blog/post/edit/1146479294431978500/8482043211346360669#" rel="noopener ugc nofollow" target="_blank"> <em class="iz">这篇文章</em> </a>将带你深入了解它。显然不是每个人都有时间深入研究，所以让我在这里给你所有要点。</p><h1 id="6dbe" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">OAuth！什么？</h1><p id="9c7c" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">OAuth是一种<strong class="ja hj"> <em class="iz">认证和授权协议</em> </strong>，是几乎所有科技行业都遵循的标准。基本上，应用程序<strong class="ja hj"> <em class="iz">代表最终客户与第三方供应商建立信任</em> </strong>的一种方式。这与之前应用程序向第三方供应商发送终端客户端凭证时建立的信任相同。我想这会让你对我们要解决的问题有一个大致的了解。</p><p id="ec79" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">为了对我们刚刚讨论的内容有一个真实的了解，您可以想象一个SSO框架。同一个单点登录，使我们能够享受所有的谷歌服务，如驱动器，Gmail等，只需一次登录到我们的帐户。现在，澄清一下，SSO和OAuth是两个不同的东西，讨论超出了本文的范围。</p><p id="288f" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">基本上就是试图<strong class="ja hj"> <em class="iz">冒充最终用户</em> </strong>，就是这样！</p><h2 id="7f90" class="lr kb hi bd kc ls lt lu kg lv lw lx kk jw ly lz ko jx ma mb ks jy mc md kw me bi translated">行动中的OAuth</h2><p id="4fe9" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">OAuth的灵魂只是两个代币。是的，就是它，只要两个代币，你就大功告成了。OAuth的机制依赖于<strong class="ja hj"> <em class="iz">访问和刷新令牌</em> </strong>。这些令牌是代表终端客户端的应用程序的成功认证和授权的结果。请记住这4个角色/实体，以便更好地理解工作:</p><ul class=""><li id="3e40" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><strong class="ja hj"> <em class="iz">资源所有者</em> </strong>:</li></ul><p id="57ff" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">能够授权访问受保护资源的实体。当资源所有者是一个人时，它被称为最终用户。</p><ul class=""><li id="6cbf" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><strong class="ja hj"> <em class="iz">资源服务器</em> </strong>:</li></ul><p id="3ff1" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">托管受保护资源的服务器，能够使用访问令牌接受和响应受保护资源请求。</p><ul class=""><li id="360e" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><strong class="ja hj"> <em class="iz">客户端</em> </strong>:</li></ul><p id="1c6e" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">代表资源所有者并经其授权发出受保护资源请求的应用程序。术语“客户端”并不暗示任何特定的实现特征(例如，应用程序是在服务器、桌面还是其他设备上执行)。</p><ul class=""><li id="20e9" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><strong class="ja hj"> <em class="iz">授权服务器</em> </strong>:</li></ul><p id="be6d" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">在成功认证资源所有者并获得授权后，服务器向客户端颁发访问令牌。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/01/how-http-basic-authentication-works-in.html#axzz6hB6A1qlY"><div class="er es mf"><img src="../Images/f4cd06b901b4d3869e489691b70801a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/0*WGYz7IbqaAbmJJIT"/></div></a></figure><p id="a71c" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">等等，刷新令牌呢？</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/5aa70fe5be81542b3ac90351e76fb712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/0*vkUCjFwCoa2eYQO9"/></div></figure><h2 id="2a5b" class="lr kb hi bd kc ls lt lu kg lv lw lx kk jw ly lz ko jx ma mb ks jy mc md kw me bi translated">安全了吗？</h2><p id="2fdf" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">回到我们的主题，现在我们知道应该遵循什么标准，让我们试着理解Google OAuth中的类比。我们将互换使用以下术语，您将看到它们各自的意义。</p><ul class=""><li id="99f4" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><strong class="ja hj"> <em class="iz">客户端</em> </strong> →您的应用</li><li id="b253" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><strong class="ja hj">T13】资源服务器T15】→Gmail</strong></li><li id="4ef7" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><strong class="ja hj"> <em class="iz">资源所有者</em> </strong> →您的最终客户</li><li id="e223" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><strong class="ja hj"> <em class="iz">授权服务器</em> </strong> →谷歌</li></ul><p id="3dfc" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">现在，有两种广泛的方法来实现OAuth设置。</p><ol class=""><li id="30cb" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv mm lj lk ll bi translated">首先是通过一个<strong class="ja hj"> <em class="iz"> OAuth客户端</em> </strong></li><li id="366d" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv mm lj lk ll bi translated">第二次通过<strong class="ja hj"> <em class="iz">服务账号</em> </strong></li></ol><p id="0a27" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">这两种方法都是特定于Google OAuth实现的，并没有推广这个概念。</p><p id="f077" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">为了简单和更好地理解，服务帐户方法超出了本文的范围。只是为了避免到处都是，我们将采取这一次。到目前为止，本文将严格关注OAuth 2.0迁移的高级路线图，将具体的实现留给后面的文章！</p><h2 id="cd46" class="lr kb hi bd kc ls lt lu kg lv lw lx kk jw ly lz ko jx ma mb ks jy mc md kw me bi translated">初步设置</h2><p id="96d6" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">为了能够开始迁移，需要进行以下设置。让我们一个一个来看:</p><ul class=""><li id="e182" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">通过您的公司Gmail id创建一个<a class="ae jz" href="https://www.blogger.com/blog/post/edit/1146479294431978500/8482043211346360669#" rel="noopener ugc nofollow" target="_blank"> <em class="iz"> GCP开发者控制台</em> </a>帐户。</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/06/top-5-course-to-crack-google-cloud-professional-data-engineer-certification.html"><div class="er es mn"><img src="../Images/541c17b6553b990df7f446793a05c651.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*qS8xZc_00z70kNY2"/></div></a><p class="iq ir et er es is it bd b be z dx translated"><em class="mo">一切都应该在项目的背景下</em></p></figure><ul class=""><li id="c095" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">你现在需要一个<a class="ae jz" href="https://www.blogger.com/blog/post/edit/1146479294431978500/8482043211346360669#" rel="noopener ugc nofollow" target="_blank"> <em class="iz">谷歌开发者控制台项目</em> </a>。</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/05/top-5-course-to-crack-google-cloud-associate-cloud-engineer-certification-exam.html?m=1"><div class="er es mp"><img src="../Images/e531625455d3a6e9d0efeac8d99dee14.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/0*VLylkOhfVrGViYpW"/></div></a><p class="iq ir et er es is it bd b be z dx translated"><em class="mo">使用个人账户后未显示组织</em></p></figure><ul class=""><li id="0430" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">创建一个项目并跟踪单个项目 中一个用例<strong class="ja hj"> <em class="iz">所需的所有资源，这始终是一个最佳实践。例如，将客户端迁移到<a class="ae jz" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-security-and-oauth2-with-spring-boot-for-java-developers-8f0222d6066d"> OAuth 2.0 </a>是一个用例，为客户端提供云计算解决方案是使用Google cloud developer console的另一个用例。对于我们的用例，我们将需要来自控制台的API &amp;服务部分的资源，我们将在单个项目中维护这些资源。</em></strong></li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><a href="https://www.java67.com/2020/07/5-free-courses-to-learn-google-cloud-platform-and-concepts.html"><div class="er es mq"><img src="../Images/76306155228156e0a589e2dac7b80bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/0*1iddv3u12rqpFBbp"/></div></a><p class="iq ir et er es is it bd b be z dx translated"><em class="mo">项目名称不言自明</em></p></figure><ul class=""><li id="05bc" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">给你的项目起一个有意义的名字。</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/36dc523d799c366d4f83263eb9a841b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*Tje2YYsDFTrJYFlq"/></div><p class="iq ir et er es is it bd b be z dx translated"><em class="mo">您的项目名称应该显示在这里</em></p></figure><ul class=""><li id="dc07" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">一旦您有了控制台访问权限和项目设置，您将需要为您的项目启用API(此处为Gmail API ),以便当您的应用程序尝试通过此控制台项目连接到Gmail API时，请求不会立即被阻止:</li><li id="0ea8" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated">转到控制台上“API和服务”部分下的“仪表板”部分。</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><a href="https://medium.com/javarevisited/8-free-google-cloud-data-engineer-certification-courses-and-practice-tests-594f31643b58"><div class="er es ms"><img src="../Images/4a19f3c8408037769caba6c802560ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*0t3LsLxmglUTAOIV"/></div></a><p class="iq ir et er es is it bd b be z dx translated"><em class="mo">“API&amp;服务”是云控制台</em>的特定部分</p></figure><ul class=""><li id="a89a" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">单击顶部的“启用API和服务”按钮。</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/fca3caae0dba1a87c6c421830fb28427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/0*yGM8sItkoG4wbnl5"/></div></figure><ul class=""><li id="ff64" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">将Gmail API添加到列表中，并为您的项目启用它。</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/cf74fa6a6e20df109a08e0d9128aa117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*ioG-dMxpzlraTBei"/></div></figure><p id="82a4" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">到现在为止，你一定已经开始凭直觉猜测我们将走向何方，我可以毫不害羞地说，你的直觉实际上是正确的。到目前为止，所有这些工作都是为了让<strong class="ja hj"> <em class="iz">授权服务器</em> </strong>做好准备。现在，我们将启动服务器。</p><h2 id="9624" class="lr kb hi bd kc ls lt lu kg lv lw lx kk jw ly lz ko jx ma mb ks jy mc md kw me bi translated">OAuth客户端方法</h2><p id="23dd" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">既然您已经知道了“API和服务”仪表板，那么您一定会在屏幕上看到一个叫做凭证的东西。导航到该部分，您会注意到您可以创建大致3个类别的凭据。显然，这些凭证是为你在<a class="ae jz" rel="noopener" href="/javarevisited/5-best-courses-to-learn-google-cloud-platform-gcp-in-2021-169093a3771a">谷歌云</a>上的资源准备的(比如电子邮件)。不管怎样，其中之一是OAuth客户端ID。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/54f26f6bb235f498640473acb0277e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fB8czn-d9pCS6u_C"/></div></div><p class="iq ir et er es is it bd b be z dx translated"><em class="mo">我们将继续使用OAuth 2.0客户端</em></p></figure><p id="60d3" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">OAuth客户端ID代表我们类比中的<strong class="ja hj"> <em class="iz">客户端</em> </strong>，即您的应用程序。它唯一地识别和验证试图连接到google APIs的应用程序。</p><p id="71e0" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj">设置</strong></p><p id="ce13" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">现在让我们追溯到我们发现OAuth类似于SSO的那一部分。我希望你现在明白了。当有一个OAuth客户端设置供应用程序访问最终客户端的资源时，必须有一种最终客户端可以授权应用程序这样做的方法。试着回想一下我们是如何在SSO框架中通过像Google这样的授权提供者来授权应用程序的。</p><p id="93cc" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">同样，为此我们也需要提供一种方式，通过这种方式，最终客户可以同意将他们的资源访问到我们的应用程序。为此，我们在同一个控制台中有一个叫做<strong class="ja hj"> <em class="iz">的同意屏幕</em> </strong>。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/c6321df77d9cb4f3eebcef0f888f321e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*irDdcxKFzB1r1gIv"/></div></div></figure><p id="e845" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">同意屏幕是由谷歌为最终客户制作的现成可用的屏幕，其中将有所有必要的细节，如范围，他们的行动按钮，应用程序的名称等。因此，他们知道他们实际上登录的是什么。这些信息必须由您(开发人员)提供，这就是你所做的“配置同意屏幕”。</p><p id="7e7f" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">一旦你点击上面的按钮，你将被引导通过一个表格，你必须填写所有必要的信息。虽然这个表格不言自明，但我还是会给你它的要点。请注意，所有这些信息对最终客户都是可见的:</p><p id="f1d2" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">选择您的应用 的<strong class="ja hj"> <em class="iz">性质:</em></strong></p><ul class=""><li id="2c38" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><strong class="ja hj"> <em class="iz">【内部(推荐)</em> </strong>:这表示您的应用程序将只对您组织内部的用户可用。</li><li id="f89e" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated">外部:这意味着任何拥有google帐户的用户都有资格使用您的应用程序。</li></ul><blockquote class="iu iv iw"><p id="d905" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="hi"> 🛈为了演示的目的，我把我的应用程序放到了外部。因此，我需要添加测试用户，只有这些用户的应用程序将可用。此外，默认情况下，我的应用程序将处于“测试”阶段，因为它没有被谷歌验证。<em class="hi">一旦通过验证，我就可以将我的应用程序置于“生产”阶段。</em></em></p></blockquote><ul class=""><li id="e8fb" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">填写您的申请信息:</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/c59abb817ea8b0d1b01d4596b2145447.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*mjLIoQ6xxa4Usvv7"/></div></figure><ul class=""><li id="aa51" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">填写开发商联系人，即您的联系人:</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/9d2dcf7864250a3fb492516e53faf66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*6UPZXrOknk0HHuUq"/></div></figure><ul class=""><li id="3730" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">为您的应用程序添加作用域(我建议阅读关于<a class="ae jz" href="https://www.blogger.com/blog/post/edit/1146479294431978500/8482043211346360669#" rel="noopener ugc nofollow" target="_blank"> <em class="iz"> Google OAuth作用域</em> </a>):</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/6027d3520980b3961c934846428bc78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*t8kGueQsKplS8WON.png"/></div><p class="iq ir et er es is it bd b be z dx translated"><em class="mo">我更喜欢给</em> <a class="ae jz" href="https://www.blogger.com/blog/post/edit/1146479294431978500/8482043211346360669#" rel="noopener ugc nofollow" target="_blank"> <em class="mo">增量访问</em> </a> <em class="mo">。从添加只读范围</em>开始</p></figure><ul class=""><li id="e2d6" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">(可选)添加测试用户(如果您的应用程序类型为外部)。</li></ul><p id="708b" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">那好吧！你差不多准备好了。</p><p id="9d80" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">这是一个样本同意屏幕的快照:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/fdd845eec316d4747e02ab4e651554dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VhbiK0ARskgxNK45"/></div></div></figure><p id="138a" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj">我们来创造吧！</strong></p><p id="3986" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">在一些操作之前，最后一步是从控制台创建一个OAuth客户机ID。为此，我们从凭证列表中选择OAuth客户端ID选项，如上图所示。记住，这样生成的OAuth客户机ID是您的应用程序 到认证过程的<strong class="ja hj"> <em class="iz">入口点。让我们深入了解一下:</em></strong></p><ul class=""><li id="fcf5" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">为您的应用程序选择应用程序类型:</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/e1000a935831f3266b03abd8253df462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/0*aqmycmZzAPAA0rng"/></div><p class="iq ir et er es is it bd b be z dx translated"><em class="mo">理想情况下，应该选择Web应用</em></p></figure><ul class=""><li id="7f1a" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">为OAuth 2.0客户端命名:</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es na"><img src="../Images/6fb56ac22a73459ffb38ac76b9d53c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/0*taLlwQuZinFihu6c"/></div></figure><ul class=""><li id="5033" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">添加可信的重定向URL:</li><li id="8288" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated">这是什么？重定向URL是您的web应用程序中的一个页面的地址，它可以<strong class="ja hj"> <em class="iz">理解由Google OAuth 2.0服务器生成的</em> </strong> <strong class="ja hj"> <em class="iz">授权代码</em> </strong>作为对成功授权的响应。如果您还记得，这是我们需要与授权服务器交换的代码，以便接收访问和刷新令牌。</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/21acc599913b64ff84a6a7bbb2e96502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*4kyMbpCMt8lV329W"/></div></figure><p id="0107" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">至此，您已经成功地创建了OAuth 2.0客户端。现在，您应该会在屏幕上弹出一个客户端ID和客户端密码对。下载JSON文件并妥善保管。这将用于识别您的应用程序。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/30d4be3804b70a886310d71b89c8273c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RvomA5-shpwl9zNY"/></div></div></figure><p id="f1b4" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><strong class="ja hj">行动！</strong></p><p id="11f8" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">设置好OAuth 2.0客户端id后，您现在只需使用正确的参数集点击正确的Google API，您的应用程序就安全了。</p><ul class=""><li id="be5f" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">向Google OAuth 2.0服务器发出授权请求:</li><li id="5025" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated">谷歌OAuth的端点是<a class="ae jz" href="https://accounts.google.com/o/oauth2/v2/auth" rel="noopener ugc nofollow" target="_blank">https://accounts.google.com/o/oauth2/v2/auth</a></li></ul><p id="a2d0" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">推荐参数包括:</p><ul class=""><li id="6b5f" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><em class="iz">范围</em> = &lt;逗号分隔的范围&gt;</li><li id="5345" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><em class="iz">访问_类型</em> = &lt;离线/在线&gt;</li><li id="2abf" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><em class="iz">响应_类型</em>=代码</li><li id="18b1" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><em class="iz">重定向_uri </em> = &lt;重定向URI &gt;</li><li id="21fe" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><em class="iz">客户端id </em> = &lt;客户端ID &gt;</li></ul><blockquote class="iu iv iw"><p id="3961" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="hi">这里是🛈，</em> <strong class="ja hj"> scope </strong> <em class="hi">接受应用程序需要的OAuth作用域，</em> access_type <em class="hi">接受离线/在线值(离线的访问类型表示应用程序可以在终端客户端不在浏览器上的情况下刷新访问令牌，反之亦然，值在线时亦然)，</em> response_type <em class="hi">接受“code”作为web应用程序的值，</em> redirect_uri <em class="hi">接受同意屏幕中提到的完全相同的URL，</em></p></blockquote><p id="1233" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">点击后，终端将在浏览器上显示同意屏幕。不言而喻，终端客户必须使用正确的Gmail ID登录。</p><p id="100b" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">如果终端客户点击“Allow”，授权码将作为参数发送回重定向URI，在请求中标记。URL看起来像这样:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/8e5866dc9d4961debffff3bd3aceeba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/0*g1g-cAMCO7bqgHPT.png"/></div></figure><blockquote class="iu iv iw"><p id="50ef" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="hi"> 🛈需要注意的一件重要事情是，访问和刷新令牌对特定于终端客户端，即物理用户。可以直观地认为它们是特定于应用程序的。</em></p></blockquote><p id="b7ec" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">如果请求参数中的值与同意屏幕中输入的值不匹配，浏览器屏幕上会显示错误。</p><p id="372e" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">现在您已经有了授权码，您需要用它来交换访问和刷新令牌。由于<strong class="ja hj"> <em class="iz"> access_type </em> </strong>被设置为离线，所以在您的应用程序第一次用授权码交换令牌时，Google授权服务器将被指示返回一个刷新和一个访问令牌。</p><ul class=""><li id="f263" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">谷歌令牌端点:【https://oauth2.googleapis.com/token T4】</li></ul><p id="03c7" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">包括适当的参数:</p><ul class=""><li id="df08" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated"><em class="iz">代码</em> = &lt;授权代码&gt;</li><li id="26a5" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><em class="iz">客户端id </em> = &lt;客户端ID &gt;</li><li id="f421" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><em class="iz">客户端_秘密</em> = &lt;客户端秘密&gt;</li><li id="1d64" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><em class="iz"> redirect_uri </em> = &lt;重定向URL &gt;</li><li id="8cef" class="ld le hi ja b jb mh jf mi jw mj jx mk jy ml jv li lj lk ll bi translated"><em class="iz">授权类型</em>=授权代码</li></ul><blockquote class="iu iv iw"><p id="1355" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="hi"> 🛈在这里，</em> code <em class="hi">接受先前接收的授权码，</em> client_id <em class="hi">接受来自下载的JSON的客户端id，</em> client_secret <em class="hi">接受来自下载的JSON的客户端秘密值，</em> redirect_uri <em class="hi">接受同意屏幕中提到的确切重定向URL，</em> grant_type <em class="hi">根据</em> <a class="ae jz" href="https://www.blogger.com/blog/post/edit/1146479294431978500/8482043211346360669#" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0规范</a>接受值“authorization_code”</p></blockquote><p id="138b" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">是啊！您现在已经成功地保护了您的应用程序。这可以通过观察服务器的最终响应来确定，下面是一个示例:</p><pre class="ln lo lp lq fd ne nf ng nh aw ni bi"><span id="dce8" class="lr kb hi nf b fi nj nk l nl nm">{</span><span id="d236" class="lr kb hi nf b fi nn nk l nl nm">“access_token”: “1/fFAGRNJru1FTz70BzhT3Zg”,</span><span id="4c45" class="lr kb hi nf b fi nn nk l nl nm">“expires_in”: 3920,</span><span id="2dda" class="lr kb hi nf b fi nn nk l nl nm">“token_type”: “Bearer”,</span><span id="19ed" class="lr kb hi nf b fi nn nk l nl nm">“scope”: “https://www.mail.google.com/",</span><span id="a65c" class="lr kb hi nf b fi nn nk l nl nm">“refresh_token”: “1//xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI”</span><span id="0b68" class="lr kb hi nf b fi nn nk l nl nm">}</span></pre><blockquote class="iu iv iw"><p id="db2e" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="hi"> 🛈需要记住的一件重要事情是，访问令牌寿命较短，而刷新令牌寿命较长。您不应该假设相同的访问令牌将在整个应用程序会话中起作用。使用响应中提供的到期时间来跟踪到期时间，并相应地使用相应的刷新令牌来刷新访问令牌。</em></p></blockquote><h1 id="b343" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">漏洞检查</h1><p id="dfdb" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">现在让我们回到开始时的主要问题，陈述迁移的原因:</p><ul class=""><li id="f26d" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">存储原始凭据:</li></ul><p id="cb74" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">显然，在我们的整个讨论中，我们没有讨论任何关于客户的用户名和密码的问题。即使我们仍然依赖于暴露在互联网上的网络调用，我们也在传输客户端ID，或者充其量是客户端机密作为其中的数据。无论如何，这是由最终客户给出的同意书支持的。所以你在这里很好！</p><ul class=""><li id="5ae4" class="ld le hi ja b jb jc jf jg jw lf jx lg jy lh jv li lj lk ll bi translated">粒度访问:</li></ul><p id="6521" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">你现在知道它的重要性了。我们定义了应用程序访问的确切范围。现在，您的最终客户完全知道他们登录的目的。</p><h1 id="5ad9" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">潜在的挫折</h1><p id="7833" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">好吧，你想出的每一个解决方案，都有自己的方式让你失望。这也不例外。在这里，我们看到了我们的应用程序如何需要最终客户的同意来代表他们获取资源。</p><p id="b19a" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">这可以是一把<strong class="ja hj"> <em class="iz">双刃剑</em> </strong>。这是怎么回事:</p><p id="c7bf" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated">虽然只有在应用程序第一次访问终端客户端的资源时才需要同意，但是有一个警告。每当您的终端客户决定更改他们的密码时(一般的经验法则是每90天更换一次密码)，您就陷入了困境。我这样说是因为这将需要为终端客户重新发放刷新令牌，这只有在他们的<strong class="ja hj"> <em class="iz">手动干预</em> </strong>给予同意之后才有可能。现在，这对一家公司来说可能是一个挫折，因为它扰乱了客户的无缝体验。</p><h1 id="69e5" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">下一步是什么？</h1><p id="d17a" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated">接下来，我将使用<a class="ae jz" href="https://www.blogger.com/blog/post/edit/1146479294431978500/8482043211346360669#" rel="noopener ugc nofollow" target="_blank"><em class="iz">Google API client library for Java</em></a>编写一个使用Google OAuth 2.0客户端方法的示例应用程序的实际实现。小心那个！</p><h1 id="20e0" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">参考</h1><p id="3fe6" class="pw-post-body-paragraph ix iy hi ja b jb ky jd je jf kz jh ji jw la jl jm jx lb jp jq jy lc jt ju jv hb bi translated"><a class="ae jz" href="https://www.blogger.com/blog/post/edit/1146479294431978500/8482043211346360669#" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/identity/protocols/oauth 2/we B- server</a></p><p id="9762" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv hb bi translated"><a class="ae jz" href="https://datatracker.ietf.org/doc/html/rfc6749" rel="noopener ugc nofollow" target="_blank">https://datatracker.ietf.org/doc/html/rfc6749</a></p></div></div>    
</body>
</html>