<html>
<head>
<title>Git Stash — When and How to Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">git Stash——何时以及如何使用</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/git-stash-when-and-how-to-use-6f5dc1bb2ee0?source=collection_archive---------0-----------------------#2022-03-27">https://medium.com/javarevisited/git-stash-when-and-how-to-use-6f5dc1bb2ee0?source=collection_archive---------0-----------------------#2022-03-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="b325" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">GIT贮藏</h2><div class=""/><div class=""><h2 id="64a4" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">详细研究git stash派上用场的一些常见用例。这是一个非常有用的特性，应该放在您的git知识库中。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><a href="https://www.java67.com/2019/04/top-5-courses-to-learn-git-and-github.html"><div class="er es jg"><img src="../Images/88899a64c8152538e302a2cc644bb480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxhWsEdvZaAV_wHMGNFGQw.png"/></div></a><p class="jo jp et er es jq jr bd b be z dx translated">图片属于atlassian.com的<a class="ae js" href="https://www.atlassian.com/git/tutorials/saving-changes/git-stash" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="38aa" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">Git Stash是我经常使用的最喜欢的Git特性之一，它将工作目录的当前状态存储在一个堆栈中，您可以随时在任何分支上重新应用这个堆栈。它给你一个干净的工作目录，指向你的工作分支中最近的提交。</p><blockquote class="kp kq kr"><p id="8cde" class="jt ju ks jv b jw jx is jy jz ka iv kb kt kd ke kf ku kh ki kj kv kl km kn ko hb bi translated">通常，当你一直在做项目的一部分时，事情处于一种混乱的状态，你想换个分支做点别的事情。问题是，你不想做半途而废的工作。这个问题的答案是<code class="du kw kx ky kz b">git stash</code>命令。<br/>—<a class="ae js" href="https://git-scm.com/docs/git-stash" rel="noopener ugc nofollow" target="_blank">git藏匿的正式文件</a></p></blockquote><h1 id="7823" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated">那么，何时以及如何使用git stash呢？</h1><p id="a02e" class="pw-post-body-paragraph jt ju hi jv b jw ls is jy jz lt iv kb kc lu ke kf kg lv ki kj kk lw km kn ko hb bi translated">现在我们已经定义了git stash的作用，让我们看看一些常见的使用情况，git stash在这些情况下非常有用。</p><h2 id="c2d6" class="lx lb hi bd lc ly lz ma lg mb mc md lk kc me mf lm kg mg mh lo kk mi mj lq ho bi translated">在分支之间或任务之间切换</h2><p id="74d2" class="pw-post-body-paragraph jt ju hi jv b jw ls is jy jz lt iv kb kc lu ke kf kg lv ki kj kk lw km kn ko hb bi translated">你正在处理一项任务，这时另一项任务出现了，需要你的注意力，你不得不停止当前的工作。到目前为止，您对工作目录所做的所有修改对于新任务来说都是多余的，所以您不想提交它们。</p><p id="01f9" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">在指向您的工作目录的终端中，运行命令</p><pre class="jh ji jj jk fd mk kz ml mm aw mn bi"><span id="76d5" class="lx lb hi kz b fi mo mp l mq mr">&gt; git stash</span></pre><p id="0a7a" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">这将为您的工作副本创建一个快照，并建立一个干净的工作目录，指向您当前分支的最近提交。从这里，你可以开始写下一个故事。</p><p id="e121" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">当您完成了这个新任务，将修改提交并推送到远程存储库，并希望返回继续处理之前的任务时，您需要-</p><pre class="jh ji jj jk fd mk kz ml mm aw mn bi"><span id="cf2b" class="lx lb hi kz b fi mo mp l mq mr">&gt; git stash pop</span></pre><p id="68f5" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">这将把前一个任务中尚未完成的修改恢复到您的工作目录中，允许您继续工作。您不必回到您执行的分支，并且可以<code class="du kw kx ky kz b">pop</code>在更新的分支或者任何您想要用作您的变更的基础的分支上存储。</p><p id="722e" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">就像这样，您可以在不同的任务之间转换，而不必先撤消再重做更改。</p><h2 id="1d28" class="lx lb hi bd lc ly lz ma lg mb mc md lk kc me mf lm kg mg mh lo kk mi mj lq ho bi translated">获取最新的远程更改</h2><p id="e4d7" class="pw-post-body-paragraph jt ju hi jv b jw ls is jy jz lt iv kb kc lu ke kf kg lv ki kj kk lw km kn ko hb bi translated">另一个用例是，如果您一直在处理一个文件，并且想要获取其他人对同一个文件所做的修改。如果你同事的输入修改在文件的不同行上，一个<code class="du kw kx ky kz b">git pull</code>会添加修改。然而，如果在同一行上有您可能已经更改的输入修改，那么<code class="du kw kx ky kz b">git pull</code>将不会直接工作。</p><p id="74af" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated"><a class="ae js" rel="noopener" href="/javarevisited/11-best-online-places-to-learn-git-for-beginners-in-2021-6dc2b7c6ef48"> Git </a>会投诉<code class="du kw kx ky kz b">error: Your local changes to the following files would be overwritten by merge:</code>。别担心，<code class="du kw kx ky kz b">git stash</code>来救援了！</p><p id="7ff9" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">在终点站，做-</p><pre class="jh ji jj jk fd mk kz ml mm aw mn bi"><span id="df18" class="lx lb hi kz b fi mo mp l mq mr">&gt; git stash</span><span id="e2f3" class="lx lb hi kz b fi ms mp l mq mr">&gt; git pull</span><span id="1d35" class="lx lb hi kz b fi ms mp l mq mr">&gt; git stash pop</span><span id="b3ae" class="lx lb hi kz b fi ms mp l mq mr">** <em class="ks">Resolve the conflicts</em> **</span></pre><p id="16d6" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">如果你执行了一个<code class="du kw kx ky kz b">git pull</code>并且由于冲突而失败了，那么<code class="du kw kx ky kz b">git stash</code>你的工作目录。<code class="du kw kx ky kz b">git pull</code>现在允许你毫无问题地从远程引入修改。</p><p id="c74b" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">一旦你同事的修改在你的工作区，一个<code class="du kw kx ky kz b">git stash pop</code>将恢复你的修改到你的工作目录。当然，<code class="du kw kx ky kz b">git stash pop</code>不会因为存在冲突而简单地放置您的更改，它会提示您手动解决git无法自动解决的冲突。</p><h2 id="1b58" class="lx lb hi bd lc ly lz ma lg mb mc md lk kc me mf lm kg mg mh lo kk mi mj lq ho bi translated">保留个性化或无关的修改以备后用</h2><p id="c112" class="pw-post-body-paragraph jt ju hi jv b jw ls is jy jz lt iv kb kc lu ke kf kg lv ki kj kk lw km kn ko hb bi translated">我使用<code class="du kw kx ky kz b">git stash</code>的一个用例是保存我的个性化更改，特别是需要用本地环境值修改的配置文件，以便在本地运行应用程序。</p><p id="7bd8" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">为了清楚起见，让我们将一个文件<code class="du kw kx ky kz b">application.properties</code>可视化，我们将它个性化为引用我们的本地数据库来连接应用程序，同时添加与任务相关的新属性。</p><p id="1307" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">我们希望提交新添加的更改，而不提交我们的个性化更改。我们也不想为了提交新的变更而放弃我们的个性化变更。再一次，<code class="du kw kx ky kz b">git stash</code>！</p><p id="90dc" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">这里我们要做的不是将所有的更改都存储在所有的文件中，而是只存储那些包含我们个性化更改的文件。对于这些个性化更改的任何未来使用，我们可以从存储中恢复它们。</p><pre class="jh ji jj jk fd mk kz ml mm aw mn bi"><span id="086e" class="lx lb hi kz b fi mo mp l mq mr">&gt; git add application.properties</span><span id="93f4" class="lx lb hi kz b fi ms mp l mq mr">&gt; git stash -k -m "My app properties" -- application.properties</span><span id="fe8e" class="lx lb hi kz b fi ms mp l mq mr"><em class="ks">** Edit file to remove your personalized changed **</em></span><span id="26c5" class="lx lb hi kz b fi ms mp l mq mr">&gt; git commit -m "Added new properties"</span><span id="1362" class="lx lb hi kz b fi ms mp l mq mr">&gt; git stash apply</span></pre><p id="7fdf" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">我们在这里做的是首先用<code class="du kw kx ky kz b">git add</code>暂存文件。然后用<code class="du kw kx ky kz b">-k</code>(T3的简写)选项<code class="du kw kx ky kz b">git stash</code>保存文件，同时在我们的工作目录中保留更改，因为我们想要提交新添加的修改。在提交新的更改之前，我们需要编辑文件以删除我们的个性化更改。<code class="du kw kx ky kz b">-m</code>为隐藏的条目提供了一个有意义的名称，通过这个名称，我们可以在任何时候使用我们的个性化更改时再次引用它。在这种情况下，我们用<code class="du kw kx ky kz b">git stash apply</code>代替<code class="du kw kx ky kz b">git stash pop</code>。当两者都将隐藏的更改恢复到工作目录时，<code class="du kw kx ky kz b">pop</code>从stash stack中删除条目，而<code class="du kw kx ky kz b">apply</code>保留stash条目，只要我们决定将它保留在那里，我们就可以在将来引用它。</p><h2 id="25fb" class="lx lb hi bd lc ly lz ma lg mb mc md lk kc me mf lm kg mg mh lo kk mi mj lq ho bi translated">在多次提交下拆分更改</h2><p id="95e8" class="pw-post-body-paragraph jt ju hi jv b jw ls is jy jz lt iv kb kc lu ke kf kg lv ki kj kk lw km kn ko hb bi translated">您可能同时在同一个文件中处理两个或多个任务，但是您希望对每个任务执行单独的提交。假设你正在做<code class="du kw kx ky kz b">Tasks A</code>和<code class="du kw kx ky kz b">Task B</code> -</p><pre class="jh ji jj jk fd mk kz ml mm aw mn bi"><span id="1ceb" class="lx lb hi kz b fi mo mp l mq mr">&gt; git stash push -k</span><span id="be0e" class="lx lb hi kz b fi ms mp l mq mr"><em class="ks">** Edit files, remove changes of Task B, keep changes of Task A. **</em></span><span id="837a" class="lx lb hi kz b fi ms mp l mq mr">&gt; git add &lt;files&gt;</span><span id="dc51" class="lx lb hi kz b fi ms mp l mq mr">&gt; git commit -m "Task A" </span><span id="38c8" class="lx lb hi kz b fi ms mp l mq mr">&gt; git stash pop</span><span id="62cf" class="lx lb hi kz b fi ms mp l mq mr">&gt; git commit -m "Task B"</span></pre><p id="0b27" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">最初，您隐藏所有的修改，同时使用<code class="du kw kx ky kz b">-k</code>选项保持工作目录中的更改不变，如前面的用例中所述。然后编辑两个任务之间的共享文件，删除对<code class="du kw kx ky kz b">Task B</code>的修改。将保留对<code class="du kw kx ky kz b">Task A</code>的修改。在根据<code class="du kw kx ky kz b">Task A</code>提交修改之前，对其进行测试。在提交了<code class="du kw kx ky kz b">Task A</code>的变更后，您将恢复隐藏的条目——它们包括<code class="du kw kx ky kz b">Task B</code>和<code class="du kw kx ky kz b">Task A</code>的变更。但是，由于工作目录已经包含了<code class="du kw kx ky kz b">Task A</code>的变更，<code class="du kw kx ky kz b">git stash pop</code>将自动合并它们。如果您在提交<code class="du kw kx ky kz b">Task A</code>之前对公共文件进行了更多的修改，将会产生冲突，您必须手动解决。工作目录中未提交的更改来自<code class="du kw kx ky kz b">Task B</code>。您应该在根据<code class="du kw kx ky kz b">Task B</code>提交之前测试它们。</p></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><p id="1cae" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">对于用例#3和#4，您可能希望将您的更改拆分成一个小的补丁，其中只包含您要提交的任务的修改，而不是将所有更改隐藏到已修改的文件中，然后在提交之前编辑它们以删除不需要的更改。包含您要提交的更改的修补程序将被存放，而您不想提交的其余修补程序将保留在未存放部分。这是从一个大的变更中生成几个提交的一种更加微妙而优雅的方式。对此有两种方法。</p><ol class=""><li id="980e" class="na nb hi jv b jw jx jz ka kc nc kg nd kk ne ko nf ng nh ni bi translated">最简单的方法是使用<code class="du kw kx ky kz b">git add --patch</code>命令。然而，这可能很难理解。你可以参考这个视频<a class="ae js" href="https://www.youtube.com/watch?v=_AH3bzMUsbg" rel="noopener ugc nofollow" target="_blank"> Git教程——添加和编辑提交(Hunks) </a>来看看实现这个的实用方法。</li><li id="70a9" class="na nb hi jv b jw nj jz nk kc nl kg nm kk nn ko nf ng nh ni bi translated">如果你使用IntelliJ IDEA作为你的IDE，你可以创建一个叫做<strong class="jv hs"> Shelve </strong>的东西，它相当于上面步骤中的<code class="du kw kx ky kz b">git stash</code>或<code class="du kw kx ky kz b">git add --patch</code>。使用<a class="ae js" rel="noopener" href="/javarevisited/7-best-courses-to-learn-intellij-idea-for-beginners-and-experienced-java-programmers-2e9aa9bb0c05"> IntelliJ IDEA </a>的交互式编辑器，这是掌握和完成的更简单的方法。您可以阅读IntelliJ文档<a class="ae js" href="https://www.jetbrains.com/help/idea/2021.3/shelving-and-unshelving-changes.html" rel="noopener ugc nofollow" target="_blank">搁置更改</a>来了解更多，我将在另一篇文章中演示。</li></ol></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><p id="8c93" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">它包装了git stash用例。如果你已经读到这里，我希望它对你有所帮助。</p><p id="417f" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">在我的下一篇文章中，作为这方面的延续，我将介绍<code class="du kw kx ky kz b">git stash</code>命令的变体和许多选项，在使用git stash时，您可以使用它们来提高生产率。</p><p id="5d4a" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">让我知道你是如何使用git stash的，如果你遇到了它派上用场的任何其他用例。</p><h2 id="8be6" class="lx lb hi bd lc ly lz ma lg mb mc md lk kc me mf lm kg mg mh lo kk mi mj lq ho bi translated"><strong class="ak">附加参考文献</strong></h2><p id="8a31" class="pw-post-body-paragraph jt ju hi jv b jw ls is jy jz lt iv kb kc lu ke kf kg lv ki kj kk lw km kn ko hb bi translated"><a class="ae js" href="https://git-scm.com/docs/git-stash" rel="noopener ugc nofollow" target="_blank">git藏匿的官方文件</a></p></div></div>    
</body>
</html>