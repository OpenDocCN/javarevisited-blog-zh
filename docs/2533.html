<html>
<head>
<title>Object Cloning in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的对象克隆</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/object-cloning-in-java-e6c7d5707579?source=collection_archive---------2-----------------------#2022-12-01">https://medium.com/javarevisited/object-cloning-in-java-e6c7d5707579?source=collection_archive---------2-----------------------#2022-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div></figure><p id="19b2" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">因此，在理解对象克隆之前，让我们先了解一下克隆这个词。根据谷歌字典，<strong class="in hj"> <em class="jj">“一个</em> </strong> <a class="ae jk" href="https://javarevisited.blogspot.com/2013/09/how-clone-method-works-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="in hj"> <em class="jj">克隆体</em> </strong> </a> <strong class="in hj"> <em class="jj">是用科学方法从一个植物或动物的细胞中产生的一个精确的复制品”</em> </strong>。现在在java中，我们有一个对象类，它是java.lang包中预定义的类。它是所有java类的默认超类，这意味着您可以在程序中引用对象类的所有成员，而无需扩展对象类。</p><p id="c055" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">当我们说<a class="ae jk" href="https://javarevisited.blogspot.com/2014/03/how-to-clone-collection-in-java-deep-copy-vs-shallow.html" rel="noopener ugc nofollow" target="_blank">对象克隆</a>时，意味着我们正在创建该对象的精确副本。当你想创建一个原始变量的副本时，你可以使用赋值操作=</p><pre class="jl jm jn jo fd jp jq jr bn js jt bi"><span id="abf1" class="ju jv hi jq b be jw jx l jy jz">class CloneVar{<br/>public static void main(String args[]){<br/>    int x = 25 ;<br/>    int y = x;<br/>    y = y++;<br/>  }<br/>}</span></pre><p id="2137" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">这里从上面的代码中，你可以清楚地看到，在创建了原始变量的副本后，如果我们对复制的变量做一些修改，那么原始变量值不会受到影响。那么当我们使用赋值操作符时会发生什么呢？当我们使用赋值操作符创建引用变量的副本时，现有对象的地址将被复制到引用变量中。</p><p id="42d0" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">当我们使用复制的引用变量修改对象数据时，原始对象值将被修改，因为两个引用变量指向同一个对象。</p><pre class="jl jm jn jo fd jp jq jr bn js jt bi"><span id="2097" class="ju jv hi jq b be jw jx l jy jz">class News{<br/>String newsHour;  <br/>public static void main(String args[]){<br/>  News news = new News();<br/>  news.newsHour = "9:00";<br/><br/>  News news2 = news;<br/>  news2.newsHour = "10:00";<br/>  }<br/>  <br/>}</span></pre><figure class="jl jm jn jo fd ii er es paragraph-image"><a href="https://www.java67.com/2013/05/difference-between-deep-copy-vs-shallow-cloning-java.html"><div class="er es ka"><img src="../Images/40bf415333013f8136b2c5ef2d02ea77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cweJhK1sXk38M4LJOgWNw.png"/></div></a><p class="kd ke et er es kf kg bd b be z dx translated">对象克隆</p></figure><p id="5805" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">java中有两种类型的对象克隆</p><ol class=""><li id="52a4" class="kh ki hi in b io ip is it iw kj ja kk je kl ji km kn ko kp bi translated">浅层克隆</li><li id="5c2f" class="kh ki hi in b io kq is kr iw ks ja kt je ku ji km kn ko kp bi translated">深度克隆</li></ol><figure class="jl jm jn jo fd ii er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/752f651dd1ac54727cf5716b2a8888b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZNWjd6c--O2oKWfuy8bMw.png"/></div></div><p class="kd ke et er es kf kg bd b be z dx translated">对象克隆的类型</p></figure><h1 id="02c2" class="la jv hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">浅层克隆</h1><p id="742c" class="pw-post-body-paragraph il im hi in b io lx iq ir is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji hb bi translated">所以从上面的解释中，我们可以说克隆是一个创建现有对象的副本的过程。现在是时候了解浅层克隆了，创建对象的按位副本的过程称为浅层克隆。现在让我们更深入地理解它。如果主对象包含原始变量，则将在克隆对象中创建精确的副本，但是如果主对象包含任何引用变量，则不会创建相应的对象，而是创建指向旧的包含对象的副本变量。所以我们可以说，上述克隆的例子只不过是肤浅的克隆。它是java.lang.Object类clone()方法的默认实现。</p><blockquote class="mc"><p id="f69b" class="md me hi bd mf mg mh mi mj mk ml ji dx translated"><strong class="ak">现在让我们理解object clone()方法是做什么的。</strong></p></blockquote><p id="3d7c" class="pw-post-body-paragraph il im hi in b io mm iq ir is mn iu iv iw mo iy iz ja mp jc jd je mq jg jh ji hb bi translated"><strong class="in hj">受保护的本机对象clone()抛出CloneNotSupportedException </strong></p><p id="f1f0" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">这里protected是访问修饰符，native是过去使用的关键字，显示了该方法的平台相关实现。clone()是一个内置的方法，它抛出一个内置的异常。</p><p id="11f3" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">所以当我们说clone方法是受保护的时，我们可以在java.lang包之外的子类中直接访问它，或者只使用子类对象。当我们想要克隆任何类对象时，我们需要实现一个名为java.lang.Cloneable的标记接口，这意味着我们需要覆盖该类中的clone()方法，以实现对象克隆。如果我们在没有实现可克隆接口的情况下克隆任何类对象，那么在这种情况下，JVM将抛出<strong class="in hj">“CloneNotSupportedException”</strong></p><h1 id="cc17" class="la jv hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">深度克隆</strong></h1><p id="68fc" class="pw-post-body-paragraph il im hi in b io lx iq ir is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji hb bi translated">现在我们来理解一下我们说的深度克隆是什么意思。创建完全相同的独立副本(包括所包含的对象)的过程称为深度克隆。深度克隆没有java.lang.Object类的默认实现，我们需要定义实现。在这种类型的克隆中，如果主对象包含任何原始变量，那么在克隆对象中，将创建一个重复的副本。</p><p id="ef1a" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">如果主对象包含任何引用变量，那么相应的对象也将在克隆副本中创建。这意味着如果我们修改克隆对象的数据，它不会影响实际的对象。如果我们要修改成员对象的数据，那么它也不会影响其他对象。现在问题出现在我们的脑海中，那么我们应该什么时候去进行深度克隆呢？答案很简单，当对象包含引用变量时，我们应该进行对象的深度克隆。</p><pre class="jl jm jn jo fd jp jq jr bn js jt bi"><span id="0fbb" class="ju jv hi jq b be jw jx l jy jz"><br/>import java.io.*;<br/>public class GFG implements Cloneable {<br/><br/>// Defining a method as clone method is protected<br/>// Defining within the class called cloneable interface<br/>public Object clone() throws CloneNotSupportedException<br/>{<br/>return (GFG)super.clone();<br/>}<br/><br/> // Main driver method<br/> public static void main(String[] args) throws CloneNotSupportedException<br/> {<br/>  // Creating first object of GFG class<br/>  GFG t1 = new GFG();<br/><br/>  // Using clone() method to create duplicate object<br/>  // of t1 reference variable<br/>  // else for every object manually object needs<br/>  // to be copied in deep copying<br/>  // clone() ease this manual effort<br/>  GFG t2 = (GFG)t1.clone();<br/><br/>  // Comparing two objects just after deep copying<br/>  // Returning true for shallow(by default) copying<br/>  // Returning false for deep copying<br/>  System.out.println(t1 == t2);<br/> }<br/>}</span></pre><p id="8422" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">这个例子取自Geeks for Geeks为了理解深度克隆。我希望你明白这个主题，如果你有任何困惑，请告诉我，以便我可以用一些更具互动性的例子来更深入地解释它。更多类似的话题，请关注，如果你喜欢这些内容，请鼓掌。敬请期待！</p><figure class="jl jm jn jo fd ii er es paragraph-image"><div class="er es mr"><img src="../Images/a7d8c1ca5201216f8856b10e902b2fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/1*L2RLgwJSAbkkDfTKTb5G8A.gif"/></div></figure></div></div>    
</body>
</html>