<html>
<head>
<title>Debugging Java Collections Framework Issues in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试生产中的Java集合框架问题</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/debugging-java-collections-framework-issues-in-production-a665241a074c?source=collection_archive---------5-----------------------#2022-05-18">https://medium.com/javarevisited/debugging-java-collections-framework-issues-in-production-a665241a074c?source=collection_archive---------5-----------------------#2022-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f105d8832c1a7206c671a0d9dc74950e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPQggPgIiZygdgof29U95g.jpeg"/></div></div></figure><p id="4020" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当Java集合框架作为Java 2 (JDK 1.2)的一部分被引入时，它是一个巨大的飞跃。多亏了包含的集合类，我们终于超越了<code class="du jo jp jq jr b"><a class="ae js" href="http://javarevisited.blogspot.sg/2011/09/difference-vector-vs-arraylist-in-java.html" rel="noopener ugc nofollow" target="_blank">Vector</a></code> <a class="ae js" href="http://javarevisited.blogspot.sg/2011/09/difference-vector-vs-arraylist-in-java.html" rel="noopener ugc nofollow" target="_blank"> </a>和<code class="du jo jp jq jr b"><a class="ae js" href="https://javarevisited.blogspot.com/2012/01/java-hashtable-example-tutorial-code.html" rel="noopener ugc nofollow" target="_blank">Hashtable</a></code>的限制，获得了更加成熟和通用的解决方案。随着流和函数概念在Java 8中的引入，这个框架把一切都带到了一个新的层次。</p><p id="3f7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">框架的核心原则之一是对接口进行编码。因此，您可以使用列表接口或集合接口，而不是具体的实现。这是一项伟大的工程，但是它使得调试Java集合更加具有挑战性。</p><p id="1e72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们调试一个典型的类时，我们可以检查变量或实现。在这种情况下，对象集合通常隐藏在一个<a class="ae js" href="https://javarevisited.blogspot.com/2010/10/abstraction-in-java.html" rel="noopener ugc nofollow" target="_blank">抽象</a>后面，该抽象掩盖了一个复杂的内部结构，例如<a class="ae js" href="https://www.java67.com/2019/10/difference-between-binary-tree-avl-red-black-binary-search-tree.html" rel="noopener ugc nofollow" target="_blank">红黑树</a>等。</p><h1 id="0cd5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">本地调试很容易</h1><p id="fe41" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">通过本地调试，我们可以添加一个检查，如<code class="du jo jp jq jr b">aslist.toArray()</code>。这将表现不佳，但仍将工作。然而，在生产环境中使用<a class="ae js" href="https://lightrun.com/" rel="noopener ugc nofollow" target="_blank"> Lightrun </a>时，这将会失败。当试图<a class="ae js" href="https://javarevisited.blogspot.com/2011/05/example-of-arraylist-in-java-tutorial.html" rel="noopener ugc nofollow" target="_blank">打印出一个复杂的列表</a>时，我们可能会在方法调用本身上失败(这可能会低于配额),或者只是输出的长度可能会被裁剪掉。</p><p id="03fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">打印元素集合的内容是有问题的。即使您有使用<code class="du jo jp jq jr b">Iterable</code>接口循环遍历整个列表的代码，避免配额限制的可能性也很低。打印一个<a class="ae js" href="https://www.java67.com/2014/03/how-to-print-array-in-java-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">原始类型数组</a>很容易，但是打印对象需要更多。</p><h1 id="0a0d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">集合元素的擦除</h1><p id="4fd0" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">在调试时，集合框架包括另一个挑战:擦除。在Java中，人们会期望这样的代码能够工作:</p><pre class="kw kx ky kz fd la jr lb lc aw ld bi"><span id="db4f" class="le ju hi jr b fi lf lg l lh li">List&lt;MyObject&gt; myList = new ArrayList&lt;&gt;();</span></pre><p id="1689" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么日志可能如下所示:</p><pre class="kw kx ky kz fd la jr lb lc aw ld bi"><span id="c23b" class="le ju hi jr b fi lf lg l lh li">The property value of the first element is {myList.get(0).getProperty()}</span></pre><p id="b9a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将失败。</p><p id="8ea3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java 中的泛型在编译过程中被移除，对字节码没有影响。因此，工作在字节码级别的Lightrun并不知道它们。解决方案是编写代码，就像泛型不存在一样，并将其转换为适当的类:</p><pre class="kw kx ky kz fd la jr lb lc aw ld bi"><span id="956e" class="le ju hi jr b fi lf lg l lh li">The property value of the first element is {((MyObject)myList.get(0)).getProperty()}</span></pre><h1 id="5095" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">绕过配额限制</h1><h1 id="4a97" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是配额？</h1><p id="16fb" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">Lightun在沙箱中执行用户代码。使用代码可以作为任何条件、表达式日志等。沙盒让我们保证:</p><ul class=""><li id="72fd" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">代码是只读的，不会以任何方式影响状态。即使你调用额外的方法也不行。</li><li id="25b6" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">代码没有失败(抛出异常等)。)</li><li id="c60b" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">该代码是高性能的，不会占用太多的CPU</li></ul><p id="30b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个沙箱有它自己的开销。这是“配额限制”分配给用户代码的CPU处理量。请注意，这可以基于每个代理进行配置。</p><p id="a6f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果对象依赖图很深并且需要访问许多类对象，配额可能会受到影响。然而，ֿThere是我们可以从集合接口中提取一些可调试值的两件事情。</p><h1 id="e5cc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用快照</h1><p id="7aba" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">快照提供了关于所有类型集合的更多细节。因为它们只需一次操作就能访问对象的内部状态，所以它们倾向于在类中获取大量适用的数据。例如，以Spring Boot宠物诊所演示的这张快照为例。它列出了一个向量和其中的10个元素。其中各个对象的值在快照中清晰可见，并且可以轻松遍历。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/07/java-debugging-tutorial-example-tips.html"><div class="er es lx"><img src="../Images/aac8eda5980d6a1324aa24aef2305cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9hjMMv04pG9h4A_t"/></div></a></figure><h1 id="3146" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用尺寸和相关方法</h1><p id="fccb" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">调试是做出假设并验证它们的过程。来自<a class="ae js" rel="noopener" href="/javarevisited/50-java-collections-interview-questions-for-beginners-and-experienced-programmers-4d2c224cc5ab"> java collections </a>的<code class="du jo jp jq jr b">size()</code>方法非常高效，几乎可以免费使用。如果您期望一个结果包含一组固定的元素，您可以很容易地使用<code class="du jo jp jq jr b"><a class="ae js" href="https://www.java67.com/2014/04/array-length-vs-arraylist-size-java.html" rel="noopener ugc nofollow" target="_blank">size()</a></code>或<code class="du jo jp jq jr b"><a class="ae js" href="https://javarevisited.blogspot.com/2013/02/5-ways-to-check-if-string-is-empty-in-java-examples.html" rel="noopener ugc nofollow" target="_blank">isEmpty()</a></code>方法来表明一个集合是否符合期望。这里的方法调用将非常高效。</p><p id="a5fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以将它作为一个条件或在日志格式本身中使用:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><a href="https://www.java67.com/2019/07/top-50-java-generics-and-collection-interview-questions.html"><div class="er es ly"><img src="../Images/f09a2c28fbdbbda286cef2355f04814f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mV5iCVt_1RJcVChq"/></div></a></figure><h1 id="4150" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">记录单个条目</h1><p id="83af" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">正如我们之前提到的，如果我们在一个循环中尝试记录所有的元素，我们会很快达到配额。但是如果我们只从collections类中记录我们需要的元素，我们将能够保持在配额之内。这也适用于位置访问，假设我们有元素的偏移量。</p><p id="233d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的代码使用<a class="ae js" rel="noopener" href="/javarevisited/7-best-java-tutorials-and-books-to-learn-lambda-expression-and-stream-api-and-other-features-3083e6038e14"> java streams API </a>来转换元素。在转换代码中，我可以粘贴一个日志，只有当兽医是我时才打印它。这是使用Vet类的getFirstName()方法的条件:</p><pre class="kw kx ky kz fd la jr lb lc aw ld bi"><span id="dcd9" class="le ju hi jr b fi lf lg l lh li">vet.getFirstName().equals("Shai")</span></pre><p id="8f79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果符合，我可以打印出条目的全部细节:<code class="du jo jp jq jr b">Current vet is {newVet}</code>。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/08/top-5-java-8-courses-to-learn-online.html"><div class="er es lz"><img src="../Images/9d5ad686174bc94bc1ef7292557e0d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*29P88BiDT-FnPgo3"/></div></a></figure><h1 id="764c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">准备</h1><p id="c9d3" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">当我们没有准备好的时候，调试Java集合会更加困难。好的一面是，准备也是为长期维护编写更好代码的第一步。它适用于所有类型的集合，也适用于集合和流操作。</p><p id="318a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，最大的错误是代码过于简洁。这里我也有错…例如，这段代码直接从方法返回:</p><pre class="kw kx ky kz fd la jr lb lc aw ld bi"><span id="7d8e" class="le ju hi jr b fi lf lg l lh li">return vets.findAllByOrderById(Pageable.ofSize(5).withPage(page)).stream().map(vet -&gt; {<br/>  VetDTO newVet = new VetDTO();<br/>  newVet.setId(vet.getId());<br/>  newVet.setLastName(vet.getLastName());<br/>  newVet.setFirstName(vet.getFirstName());<br/>  Set&lt;PetDTO&gt; pets = findPetDTOSet(vet.getId());<br/>  newVet.setPets(pets);<br/>  return newVet;<br/>}).collect(Collectors.toList());</span></pre><p id="3dfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这似乎比赋值后从方法返回的代码要酷得多:</p><pre class="kw kx ky kz fd la jr lb lc aw ld bi"><span id="ee28" class="le ju hi jr b fi lf lg l lh li">List&lt;VetDTO&gt; returnValue = vets.findAllByOrderById(Pageable.ofSize(5).withPage(page)).stream().map(vet -&gt; {<br/>  VetDTO newVet = new VetDTO();<br/>  newVet.setId(vet.getId());<br/>  newVet.setLastName(vet.getLastName());<br/>  newVet.setFirstName(vet.getFirstName());<br/>  Set&lt;PetDTO&gt; pets = findPetDTOSet(vet.getId());<br/>  newVet.setPets(pets);<br/>  return newVet;<br/>}).collect(Collectors.toList());<br/>return returnValue;</span></pre><p id="3b87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是第二种方法让我们可以在本地和远程调试集合。这也使得添加包含收集结果值的日志语句变得更加容易，这是您通常应该考虑的事情。</p><p id="47c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在处理强调这种简洁语法的Java流时尤其如此。</p><h1 id="82bb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">包括适当的toString方法</h1><p id="75be" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我怎么强调这一点都不为过:如果它进入集合框架，它应该在类中有一个<code class="du jo jp jq jr b"><a class="ae js" href="https://javarevisited.blogspot.com/2015/01/why-override-equals-hashcode-or-tostring-java.html" rel="noopener ugc nofollow" target="_blank">toString()</a></code>方法。这使得调试元素变得更加容易！</p><p id="c967" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们在快照或日志中包含该类时，就会调用<code class="du jo jp jq jr b">toString()</code>方法。如果类中没有实现，我们将看到没有用的对象ID。</p><h1 id="d03f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">摘要</h1><p id="5b0d" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">快照优于调试集合框架对象，因为它们显示了更多的层次结构。Java流可以被调试，但是由于它们默认的简洁特性，它们更具挑战性。我们应该尝试编写不那么简洁的代码，以便于日志记录和调试。</p><p id="73fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在一个<code class="du jo jp jq jr b">Iterable</code>界面中打印所有内容是行不通的，但是使用一个条件语句只打印重要的那一行就可以了。</p><p id="4c78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">集合中的标准方法对于配额CPU时间机制来说可能仍然过于昂贵。但是像<code class="du jo jp jq jr b">isEmpty()</code>或者<code class="du jo jp jq jr b">`size()</code>这样的API是高效的。</p></div></div>    
</body>
</html>