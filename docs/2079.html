<html>
<head>
<title>Spring Transaction Debugging in Production with Lightrun</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Lightrun在生产中调试Spring事务</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-transaction-debugging-in-production-with-lightrun-755cfb5dbba8?source=collection_archive---------2-----------------------#2022-04-26">https://medium.com/javarevisited/spring-transaction-debugging-in-production-with-lightrun-755cfb5dbba8?source=collection_archive---------2-----------------------#2022-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://www.java67.com/2021/04/5-free-microservice-courses-for-java.html"><div class="er es if"><img src="../Images/b5b0afe6510b853f5ecfa3e0ced9cb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xS-uRL_VZq5QJd8MUNA7Q.jpeg"/></div></a></figure><p id="c2bc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于其声明式事务管理，Spring使得构建可靠的应用程序变得更加容易。它还支持编程式事务管理，但这并不常见。在本文中，我想把重点放在声明性事务管理的角度，因为与编程方法相比，它似乎更难调试。</p><p id="3dc7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是部分正确的。我们不能在事务性注释上设置断点。但是我想得太多了。</p><h1 id="cc73" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Spring的方法声明式事务管理是什么？</h1><p id="4614" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在编写spring方法或类时，我们可以使用注释来声明一个方法或一个<a class="ae kn" href="https://javarevisited.blogspot.com/2022/03/how-autowiring-of-beans-works-in-spring.html" rel="noopener ugc nofollow" target="_blank"> bean </a>(类)是<a class="ae kn" href="https://javarevisited.blogspot.com/2021/08/spring-transactional-example-how-to.html" rel="noopener ugc nofollow" target="_blank">事务性的</a>。这个注释让我们可以使用属性来调整事务语义。这让我们可以定义如下行为:</p><ul class=""><li id="a531" class="ko kp hi io b ip iq it iu ix kq jb kr jf ks jj kt ku kv kw bi translated">事务隔离级别—让我们能够解决脏读、不可重复读、幻像读等问题。</li><li id="e24c" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">事务管理程序</li><li id="1e23" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">传播行为——我们可以定义事务是强制的还是必需的，等等。这显示了该方法是否期望接收一个事务以及它的行为方式</li><li id="9a6f" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">只读属性—数据库并不总是支持只读事务。但是当它被支持时，它是一个优秀的性能/可靠性调优特性</li></ul><p id="24b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有更多。</p><h1 id="c5c7" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">事务不是和数据库驱动有关吗？</h1><p id="ff5a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">事务方法的概念对于spring的新开发者来说是非常混乱的。事务是<a class="ae kn" href="https://javarevisited.blogspot.com/2012/05/different-types-of-jdbc-drivers-in-java.html" rel="noopener ugc nofollow" target="_blank">数据库驱动/JDBC连接</a>的一个特性，而不是一个方法。为什么要在方法中声明？</p><p id="6725" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有更多。其他特性，比如消息队列，也是事务性的。我们可能会使用多个数据库。在这些情况下，如果回滚一个事务，我们需要回滚所有底层的<a class="ae kn" href="https://javarevisited.blogspot.com/2011/11/database-transaction-tutorial-example.html" rel="noopener ugc nofollow" target="_blank">事务</a>。因此，我们在用户代码中进行事务管理，spring将它无缝地传播到各种底层事务资源中。</p><h1 id="867e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">如果不使用数据库API，如何编写编程式事务管理？</h1><p id="ff5e" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Spring包含了一个事务管理器，它公开了我们通常期望看到的API:begin、commit和rollback。这个管理器包括协调各种资源的所有逻辑。</p><p id="ab7d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以将该管理器注入到一个典型的spring类中，但是像这样编写声明性事务管理要容易得多:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="3180" class="ll jl hi lh b fi lm ln l lo lp">@Transactional<br/>public void myMethod() {<br/>    // ...<br/>}</span></pre><p id="1552" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在方法级别使用了注释，但是我也可以把它放在类级别。该类定义了默认值，方法可以<a class="ae kn" href="https://www.java67.com/2012/08/can-we-override-static-method-in-java.html" rel="noopener ugc nofollow" target="_blank">覆盖</a>它。</p><p id="b021" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这提供了极大的灵活性，对于将业务代码从低级JDBC事务细节中分离出来非常有用。</p><h1 id="5730" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">动态代理、面向方面的编程和注释</h1><p id="699e" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">调试事务的关键是spring实现这个逻辑的方式。<a class="ae kn" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25"> Spring </a>使用代理机制来实现<a class="ae kn" href="https://javarevisited.blogspot.com/2021/03/spring-aop-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank">面向方面编程</a>的声明能力。实际上，这意味着当您调用<code class="du lq lr ls lh b">MyObject</code>或<code class="du lq lr ls lh b">MyClass</code>上的<code class="du lq lr ls lh b">myMethod</code>时，spring会在它们之间创建一个代理类和一个代理对象实例。</p><p id="185f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Spring通过实现所有声明性注释的代理类型路由您的调用。因此，事务代理负责验证事务状态并执行它。</p><h1 id="23b9" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">使用Lightrun调试Spring事务管理</h1><p id="dc6b" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">重要提示:我假设你熟悉Lightrun的基础知识。如果没有，请阅读 <a class="ae kn" href="https://docs.lightrun.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">本</strong> </a> <strong class="io hj">。</strong></p><p id="b45e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">程序化的事务管理是琐碎的。我们可以将快照放在它开始或回滚的地方来获取状态。</p><p id="82f1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是如果一个注释失败了，这个方法就不会被调用，我们也不会得到回调。</p><p id="ab1a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，注释并不神奇。如前所述，Spring使用了一个代理对象。该代理机制调用通用代码，我们可以用它来绑定快照。一旦我们在那里绑定了快照，我们就可以检测堆栈中的代理类型。</p><p id="8f73" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不幸的是，调试代理机制是有问题的，因为没有要调试的物理代码。代理机制中的一切都是在运行时动态生成的。幸运的是，这没什么大不了的。没有这个，我们有足够的钩子来调试。</p><h1 id="f779" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">查找实际的事务处理类</h1><p id="edec" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我们需要做的第一件事是寻找实现事务功能的类。打开<a class="ae kn" rel="noopener" href="/javarevisited/7-best-courses-to-learn-intellij-idea-for-beginners-and-experienced-java-programmers-2e9aa9bb0c05"> IntelliJ/IDEA </a>类视图(Command-O或CTRL-O)让我们通过名字定位一个类。键入“Transaction”会出现以下视图:</p><figure class="lc ld le lf fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/07/java-debugging-tutorial-example-tips.html#axzz6bYzaddcE"><div class="er es lt"><img src="../Images/c8404f943938a106f2916cb44a4451e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*riLio4uWfGaMcJSo"/></div></a></figure><p id="c2e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这可能看起来很多，但是我们需要一个具体的公共类。所以注释和接口可以忽略。因为我们只关心Spring类，所以我们可以忽略其他包。尽管如此，我们要找的类在列表中相对较低，所以我花了一些时间才找到它。</p><p id="01cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这种情况下，有趣的类是<code class="du lq lr ls lh b">TransactionAspectSupport</code>。一旦我们打开类，我们需要选择下载类源代码的选项。</p><p id="f8ca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦这样做了，我们就可以寻找一个适用的公共方法。看起来很完美，但有点太光秃秃了。在那里放一张快照给了我一个提示:</p><figure class="lc ld le lf fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/12/ow-to-fix-spring-data-jpa-no-property-.html"><div class="er es lu"><img src="../Images/2a15c9aaa62ad5a1ae0b30e0b178543f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TXBsYG4Rufya_pWU"/></div></a></figure><p id="e0a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我这里没有太多的信息，但是栈上的<code class="du lq lr ls lh b">invokeWithinTransaction</code>方法是完美的！</p><p id="42a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">继续讨论这个方法，我想在<code class="du lq lr ls lh b">findById</code>方法上跟踪特定于事务的信息:</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/3ccca112bd74dbe94eaa1e3355a93be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ND_Z_5jjrWsXLzgw"/></div></div></figure><p id="814c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了将范围仅限于<code class="du lq lr ls lh b">findById</code>我们添加了条件:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="515d" class="ll jl hi lh b fi lm ln l lo lp">method.getName().equals("findById")</span></pre><p id="f2d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦方法被命中，我们可以在堆栈中看到事务的细节。</p><p id="4df3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您在方法中进一步滚动，您可以看到在线程中发生异常时设置快照的理想位置，等等。这是调试事务失败的一个很好的中心点。</p><p id="0de6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">快照的好处之一是它们可以很容易地调试并发事务。它们的非阻塞特性使它们成为实现这一目标的理想工具。</p><h1 id="1a53" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="9879" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Spring中的声明式配置使得事务性操作变得更加容易。这大大简化了应用程序的开发，并将对象逻辑与低级事务行为细节分离开来。</p><p id="082b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Spring使用基于类的代理来实现注释。因为它们是生成的，所以我们不能直接调试它们，但是我们可以调试它们内部使用的类。具体来说:<code class="du lq lr ls lh b">TransactionAspectSupport</code>就是一个很好的例子。</p><p id="673f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Lightrun的一个巨大优势是它不会挂起当前线程。这意味着与并发性相关的问题可以在Lightrun中重现。这里讨论的一切都可以用Lightrun 的免费版本<a class="ae kn" href="https://lightrun.com/free" rel="noopener ugc nofollow" target="_blank">来完成。</a></p></div></div>    
</body>
</html>