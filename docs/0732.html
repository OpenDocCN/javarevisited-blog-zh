<html>
<head>
<title>Immutable Collections in Java using Sealed Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用密封类型的Java不可变集合</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/immutable-collections-in-java-using-sealed-types-ae8eb580fc1e?source=collection_archive---------0-----------------------#2020-10-14">https://medium.com/javarevisited/immutable-collections-in-java-using-sealed-types-ae8eb580fc1e?source=collection_archive---------0-----------------------#2020-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何定义约定的、结构化的、可验证的不可变Java集合？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f2c88c4091af444cbf4dcd3d10708691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHUMcJS2IO6GpjTckpFODw.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">在JDK 15中使用密封类型设计不可变集合</p></figure><h1 id="9dc0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">引入密封类型</h1><p id="297e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">JDK 15号于2020年9月15日发布。<a class="ae kw" href="https://openjdk.java.net/jeps/360" rel="noopener ugc nofollow" target="_blank"> JEP 360 </a>密封类型作为预览功能包含在此版本中。密封类型是琥珀项目<a class="ae kw" href="https://openjdk.java.net/projects/amber/" rel="noopener ugc nofollow" target="_blank">的一部分。密封类或接口可用于限制允许扩展它们的接口或类。这是通过使用<code class="du kx ky kz la b">sealed</code>、<code class="du kx ky kz la b">non-sealed</code>和<code class="du kx ky kz la b">permits</code>修改器完成的。</a></p><h1 id="7250" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是契约不变性？</h1><p id="9ff0" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">如果可用的公共方法不允许实例在构造后发生变化，则接口或类在契约上是不可变的。一个契约式的<a class="ae kw" href="https://javarevisited.blogspot.com/2018/02/java-9-example-factory-methods-for-collections-immutable-list-set-map.html" rel="noopener ugc nofollow" target="_blank">不可变集合</a>不应该公开类似<code class="du kx ky kz la b">add</code>、<code class="du kx ky kz la b">addAll</code>、<code class="du kx ky kz la b">remove</code>、<code class="du kx ky kz la b">removeAll</code>、<code class="du kx ky kz la b">clear</code>和可变<code class="du kx ky kz la b">Iterator</code>的方法。这些方法在Java中的<code class="du kx ky kz la b">Collection</code>、<code class="du kx ky kz la b">List</code>和<code class="du kx ky kz la b">Set</code>类型上可用。实现这些接口的不可变集合不是契约不可变的。</p><h1 id="a085" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是结构不变性？</h1><p id="961e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">如果一个对象的所有数据成员都是<a class="ae kw" href="https://javarevisited.blogspot.com/2012/10/difference-between-private-protected-public-package-access-java.html#axzz6JDcu0RhH" rel="noopener ugc nofollow" target="_blank"> private </a>、<a class="ae kw" href="https://javarevisited.blogspot.com/2016/09/21-java-final-modifier-keyword-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank"> final </a>，那么这个对象在结构上就是不可变的，并且在对象被构造之后不能被修改。<code class="du kx ky kz la b">String</code>是Java中结构不变的类的一个很好的例子。一旦构造了一个<code class="du kx ky kz la b">String</code>，它就不能被改变。像<code class="du kx ky kz la b">String</code>这样的不可变对象有时会有像<code class="du kx ky kz la b">StringBuilder</code>这样的可变对应物。</p><h1 id="bb8e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是可验证的不变性？</h1><p id="b342" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">如果所有的实现在契约上和结构上都是不可变的，并且被限制在一组特定的可以被验证的类中，那么这个类或接口就是可验证的不可变的。这是一个功能，现在可以通过JDK 15中的密封类型更容易地实现。使用密封类型，开发人员可以将接口和类的实现限制为一组指定的类型。</p><h1 id="c3c9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Java中密封类型的完美用例</h1><p id="eeff" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Java的不可变集合实现在Java集合框架(从JDK 9开始)、Google Guava和Eclipse集合中可用。如今，没有一个不可变集合替代方案提供了<em class="lb">结构</em>、<em class="lb">契约</em>和<em class="lb">可验证</em>不变性的组合。</p><h2 id="2a55" class="lc ju hi bd jv ld le lf jz lg lh li kd iq lj lk kh iu ll lm kl iy ln lo kp lp bi translated">Java 9+版本</h2><p id="f7d4" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">通过<code class="du kx ky kz la b">List.of()</code>、<code class="du kx ky kz la b">Set.of()</code>、<code class="du kx ky kz la b">Map.of()</code>，在Java集合框架中有<em class="lb">结构上的</em>不可变集合可用。JDK不可变集合在合同上不是不可变的，因为它们实现了可变的接口。</p><h2 id="d9a2" class="lc ju hi bd jv ld le lf jz lg lh li kd iq lj lk kh iu ll lm kl iy ln lo kp lp bi translated">谷歌番石榴</h2><p id="812f" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">番石榴的集合类型在结构上<em class="lb">是不可变的，但在契约上<em class="lb">不是不可变的。Guava中的不可变集合实现了可变的JDK接口— <code class="du kx ky kz la b">List</code>、<code class="du kx ky kz la b">Set</code>、<code class="du kx ky kz la b">Map</code>。Guava通过使用带有<code class="du kx ky kz la b">package</code>私有构造函数的<code class="du kx ky kz la b">abstract</code>类来限制不可变集合类型的实现，这要求所有实现都在同一个包中。这种限制是一种新颖的设计方法，也是<em class="lb">可验证</em>不变性的关键组成部分，但仍然缺乏<em class="lb">契约</em>不变性。</em></em></p><h2 id="7348" class="lc ju hi bd jv ld le lf jz lg lh li kd iq lj lk kh iu ll lm kl iy ln lo kp lp bi translated">Eclipse集合</h2><p id="e53c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><a class="ae kw" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>具有契约上<em class="lb">和结构上<em class="lb">不可变的集合类型。不幸的是，Java 8中没有办法限制像<code class="du kx ky kz la b">ImmutableCollection</code>、<code class="du kx ky kz la b">ImmutableList</code>、<code class="du kx ky kz la b">ImmutableSet</code>这样的接口的实现，从而提供<em class="lb">可验证的</em>不变性。可以在Eclipse集合之外实现<code class="du kx ky kz la b">ImmutableCollection</code>接口及其子类型，因为它们是公共接口。从理论上讲，一个“坏角色”可能会实现<code class="du kx ky kz la b">ImmutableCollection</code>接口，并将一个可变的实现传递给一个期望有<code class="du kx ky kz la b">ImmutableCollection</code>的方法调用。在实践中，这可能是个问题，但这种可能性确实存在。</em></em></p><h2 id="0f0f" class="lc ju hi bd jv ld le lf jz lg lh li kd iq lj lk kh iu ll lm kl iy ln lo kp lp bi translated">密封类型</h2><p id="29a0" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">JDK 15中的密封类型预览版使开发人员能够最终在集合框架中提供三重功能:T21、契约性、结构性、可验证性和不变性。使用密封类型预览特性，我们可以使用<code class="du kx ky kz la b">sealed</code>和<code class="du kx ky kz la b">permits</code>修饰符来限制<code class="du kx ky kz la b">ImmutableCollection</code>接口的实现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/e97374c15caa4cb6623dffa7b87ae043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvOIPu_CihVoGRP4fHPmHA.png"/></div></div></figure><p id="1867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，我们可以限制<code class="du kx ky kz la b">ImmutableList</code>的实现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/3d9c8c989a71c4b406b000cddf727410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*md3mIyCP9X7pW27LXecENA.png"/></div></div></figure><p id="d489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后将<code class="du kx ky kz la b">ImmutableList</code>的<code class="du kx ky kz la b">ImmutableEmptyList</code>实现声明为<code class="du kx ky kz la b">final</code>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ls"><img src="../Images/f2f05ab436773fff86da3fb0cc4656be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UN6RGrWzg-fhPvixzfWdUw.png"/></div></div></figure><p id="1a4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在JDK 15号进行密封类型的实验很有趣，也很令人鼓舞。我希望十年前我们第一次在Eclipse集合中定义ImmutableCollection层次结构时就有这个特性。我已经能够扩展我们几年前在Eclipse集合中实现的设计思想，用一个特性提供更具限制性的建模能力。</p><h2 id="88aa" class="lc ju hi bd jv ld le lf jz lg lh li kd iq lj lk kh iu ll lm kl iy ln lo kp lp bi translated">纸牌卡塔:定制收藏</h2><p id="1d9d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">一个集合框架的实验性实现的源代码可以在<a class="ae kw" href="https://github.com/BNYMellon/CodeKatas/tree/master/deck-of-cards-kata" rel="noopener ugc nofollow" target="_blank">卡牌卡塔回购</a>中找到。这套卡形可以用来熟悉多种集合框架，包括最新版本的<a class="ae kw" rel="noopener" href="/javarevisited/7-best-java-collections-and-stream-api-courses-for-beginners-in-2020-3ad18d52c38"> Java集合+流框架</a>，Apache Commons集合，Google Guava和Eclipse集合。</p><p id="0c46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">定制集合框架接口和实现可以在线浏览<a class="ae kw" href="https://github.com/BNYMellon/CodeKatas/tree/master/deck-of-cards-kata/src/main/java/bnymellon/codekatas/deckofcards/custom/collections" rel="noopener ugc nofollow" target="_blank">这里</a>。下面的类图显示了框架中的接口，包括利用密封类型的不可变集合接口。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/adfd4735fb7846b079c0e2ebeffa9c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pW5H0RibKuIayUWpu3Zq1g.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">扑克牌中的自定义收藏框架</p></figure><p id="e45c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">kata中的实验收藏框架已经发展到使用<a class="ae kw" href="https://openjdk.java.net/projects/amber/" rel="noopener ugc nofollow" target="_blank">琥珀项目</a>的特性，因为它们在JDK中可以作为预览特性使用。卡塔在发行当天就升级到了JDK 15。该框架现在使用Amber项目的以下功能:</p><ul class=""><li id="88da" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated">局部变量式推理(<a class="ae kw" href="https://openjdk.java.net/jeps/286" rel="noopener ugc nofollow" target="_blank"> JEP 286 </a>)</li><li id="41c3" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">实例的模式匹配(<a class="ae kw" href="https://openjdk.java.net/jeps/375" rel="noopener ugc nofollow" target="_blank"> JEP 375 </a>)</li><li id="9956" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">密封类型(<a class="ae kw" href="https://openjdk.java.net/jeps/360" rel="noopener ugc nofollow" target="_blank"> JEP 360 </a>)</li></ul><p id="d975" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，默认方法和静态接口方法被广泛用于构建框架中的丰富接口。</p><h1 id="da0f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">对Java集合未来的展望</h1><p id="64e7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">定制集合框架最初的开发是为了探索和演示使用类似于<a class="ae kw" href="https://javarevisited.blogspot.com/2018/08/top-5-java-8-courses-to-learn-online.html" rel="noopener ugc nofollow" target="_blank"> Java Streams </a>的API名称在可变集合接口上直接拥有eager方法会是什么样子。</p><p id="ba49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其目的是使用Java最新版本中被证明有用的最新特性。最新的发展显示了利用密封类型实现不可变集合类型的可能性。到目前为止，这个专题的结果让我很受鼓舞。我希望这个用例可以作为密封类型特性实际应用的一个例子来使用和讨论。</p><p id="d095" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下博客解释了定制集合框架设计在过去六个月中的演变。</p><div class="mi mj ez fb mk ml"><a rel="noopener follow" target="_blank" href="/javarevisited/java-streams-are-great-but-its-time-for-better-java-collections-42d2c04235d1"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hj fi z dy mq ea eb mr ed ef hh bi translated">Java流很棒，但现在是更好的Java集合的时候了</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">25年后，Java是时候进行集合升级了。</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">medium.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jn ml"/></div></div></a></div><div class="mi mj ez fb mk ml"><a rel="noopener follow" target="_blank" href="/javarevisited/eager-is-easy-lazy-is-labyrinthine-b12605f13048"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hj fi z dy mq ea eb mr ed ef hh bi translated">渴望是容易的，懒惰是迷宫</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">从初始化到迭代，学渴望比学懒惰容易。</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">medium.com</p></div></div><div class="mu l"><div class="na l mw mx my mu mz jn ml"/></div></div></a></div><p id="1f56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你觉得这个博客有用。检查源代码，并尝试回购中包含的卡片组和其他代码。</p><p id="0c15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽情享受吧！</p><p id="0c2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lb">我是</em><a class="ae kw" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="lb">Eclipse Collections</em></a><em class="lb">OSS项目在</em><a class="ae kw" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="lb">Eclipse Foundation</em></a><em class="lb">的项目负责人。</em> <a class="ae kw" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="lb">月食收藏</em> </a> <em class="lb">是开投</em> <a class="ae kw" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="lb">投稿</em> </a> <em class="lb">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div></div>    
</body>
</html>