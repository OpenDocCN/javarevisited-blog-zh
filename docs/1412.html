<html>
<head>
<title>Custom HTTP Security Mechanisms with Java/Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java/Spring定制HTTP安全机制</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/custom-http-security-mechanisms-with-java-spring-30326110933b?source=collection_archive---------4-----------------------#2021-07-27">https://medium.com/javarevisited/custom-http-security-mechanisms-with-java-spring-30326110933b?source=collection_archive---------4-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f1c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，典型的HTTP安全性要么通过传递可以使用OAUTH2或JWT验证的不记名令牌来处理，要么有时甚至只是通过HTTP基本身份验证来保持简单。</p><p id="a30b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要使用替代的身份验证机制——因为您的客户有一些古怪的遗留需求，或者因为典型的基于令牌的凭证不适合集成范例——那么您可能需要实现一个定制的处理程序。</p><p id="430c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<a class="ae jd" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-security-and-oauth2-with-spring-boot-for-java-developers-8f0222d6066d"> Spring Security </a>，在Java中这样做相当简单。我们的例子将使用Java 11、<a class="ae jd" rel="noopener" href="/javarevisited/6-best-maven-courses-for-beginners-in-2020-23ea3cba89"> Maven </a>和<a class="ae jd" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e?source=---------39------------------"> Spring Boot </a>来构建。</p><p id="9169" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<a class="ae jd" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>创建一个带有Spring Web和Spring Security的新Maven项目——这将为您提供入门所需的一切:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/05/top-20-spring-boot-interview-questions-answers.html"><div class="er es je"><img src="../Images/760e49c9bde7b844d85d97e487340435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JvsbWD06EpnNWvW9wPZTQ.png"/></div></a><p class="jm jn et er es jo jp bd b be z dx translated">为您的工件和打包使用您想要的任何名称——但是使用Jar打包来保持它的简单。</p></figure><p id="fc33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下载项目并将其加载到您选择的IDE中。您将有一个开箱即用的工作REST服务器，所以现在我们只需要添加一些简单的API，我们可以使用我们的自定义安全性来保护它们。下面是一个返回当前时间的API的简单示例:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="1634" class="jv jw hi jr b fi jx jy l jz ka">package net.cambium.examples.rest;</span><span id="e7e6" class="jv jw hi jr b fi kb jy l jz ka">import java.text.SimpleDateFormat;<br/>import java.util.Date;</span><span id="f382" class="jv jw hi jr b fi kb jy l jz ka">import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;</span><span id="c0de" class="jv jw hi jr b fi kb jy l jz ka">/**<br/> * TimeController.<br/> * <br/> *  Simple example REST service that we plan on securing<br/> *  with a custom security mechanism.  <br/> *<br/> * <a class="ae jd" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a> Baruch Speiser, Cambium.<br/> */<br/><a class="ae jd" href="http://twitter.com/RestController" rel="noopener ugc nofollow" target="_blank">@RestController</a><br/><a class="ae jd" href="http://twitter.com/RequestMapping" rel="noopener ugc nofollow" target="_blank">@RequestMapping</a>("/api/time")<br/>public class TimeController {<br/>  <br/>  <a class="ae jd" href="http://twitter.com/GetMapping" rel="noopener ugc nofollow" target="_blank">@GetMapping</a><br/>  public String now() {<br/>    Date now = new Date();<br/>    SimpleDateFormat formatter = new SimpleDateFormat("hh:mm:ss");<br/>    String result = formatter.format(now);<br/>    return String.format("{ \"time\" : \"%s\" }", result);<br/>  }<br/> <br/>}</span></pre><p id="6c03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行您的应用程序并使用HTTP客户端(如<a class="ae jd" rel="noopener" href="/javarevisited/7-best-courses-to-learn-postman-tool-for-web-service-and-api-testing-f225c138fa5a"> Postman </a>)来查看您的API是否可访问:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kc"><img src="../Images/2a3a07cf6fe7f34575620f0939d30f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G6yRYMjiIDI-MWmsiGQeWw.png"/></div></div></figure><p id="6bbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们准备介绍我们的自定义安全方法。在我们的例子中，我们将使用一个简单的校验和验证作为例子——这显然不是一个保护API的好方法，但是我们更感兴趣的是如何将一个定制的例子应用到您的应用程序中，所以现在已经足够了。</p><p id="0042" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从创建一个定制的HTTP请求过滤器<a class="ae jd" href="https://javarevisited.blogspot.com/2021/02/spring-security-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank">开始，它将允许我们拒绝任何我们不想批准的HTTP请求。为了便于说明，我们将对其进行编码，以查看标准授权头，但使用非标准头值:</a></p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="9b91" class="jv jw hi jr b fi jx jy l jz ka">package net.cambium.examples.rest.security;</span><span id="130e" class="jv jw hi jr b fi kb jy l jz ka">import java.io.IOException;</span><span id="bf18" class="jv jw hi jr b fi kb jy l jz ka">import javax.servlet.Filter;<br/>import javax.servlet.FilterChain;<br/>import javax.servlet.ServletException;<br/>import javax.servlet.ServletRequest;<br/>import javax.servlet.ServletResponse;<br/>import javax.servlet.http.HttpServletRequest;<br/>import javax.servlet.http.HttpServletResponse;</span><span id="2425" class="jv jw hi jr b fi kb jy l jz ka">import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/>import org.springframework.http.HttpHeaders;<br/>import org.springframework.http.HttpStatus;</span><span id="23ef" class="jv jw hi jr b fi kb jy l jz ka">/**<br/> * CustomAuthorizationFilter.<br/> *<br/> *  Introduce our own custom security mechanism to determine access. <br/> *  We use a simple checksum verification as an oversimplified <br/> *  example. <br/> *<br/> * @author Baruch Speiser, Cambium.<br/> *<br/> */<br/>public class CustomAuthorizationFilter implements Filter {<br/>  private static final String AUTHORIZATION_TYPE_PREFIX = <br/>                                "X-Custom-Checksum ";<br/>  private static final Logger log LoggerFactory.getLogger(<br/>                                CustomAuthorizationFilter.class);<br/>  <br/>  /** Perform basic HTTP request filter handling. */<br/>  @Override<br/>  public void doFilter(<br/>    ServletRequest request, <br/>    ServletResponse response, <br/>    FilterChain chain) <br/>  throws IOException, ServletException <br/>  {<br/>    if(request instanceof HttpServletRequest) {<br/>      //We only care about HTTP requests, <br/>      // there isn't anything else here anyway<br/>      HttpServletRequest req = (HttpServletRequest)request;<br/>      if(!isAuthenticated(req)) {<br/>        //Not allowed in, reject the request:<br/>        HttpServletResponse res = (HttpServletResponse)response;<br/>        res.sendError(HttpStatus.UNAUTHORIZED.value());<br/>        return;<br/>      }<br/>      //otherwise, fall through and continue handling the request<br/>    } <br/>    chain.doFilter(request, response);<br/>  }</span><span id="8bee" class="jv jw hi jr b fi kb jy l jz ka">  /** <br/>   * Check to see if the request includes our <br/>   * custom authorization header. <br/>   */<br/>  private boolean isAuthenticated(HttpServletRequest request) {<br/>    try {<br/>      String authorization = request.getHeader(<br/>                               HttpHeaders.AUTHORIZATION);<br/>      //our custom authorization mechanism is here:<br/>      if(null != authorization <br/>      &amp;&amp; authorization.startsWith(AUTHORIZATION_TYPE_PREFIX)) <br/>      {<br/>        String numerical = authorization.substring(<br/>                             AUTHORIZATION_TYPE_PREFIX.length());<br/>        long number = Long.parseLong(numerical);<br/>        return isValidChecksum(number); <br/>      }<br/>      //otherwise:<br/>      return false;<br/>    } catch(Exception e) {<br/>      log.warn("Failure while parsing authorization header, " +<br/>               "could have been sent in an incorrect format", <br/>               e);<br/>      return false;<br/>    }<br/>  }</span><span id="51c8" class="jv jw hi jr b fi kb jy l jz ka">  /** <br/>   * Validate checksum, i.e. verify the <br/>   * supplied "credentials" to see if they are valid <br/>   */<br/>  private boolean isValidChecksum(long number) {<br/>    //Extract the last digit:<br/>    long last = number % 10;<br/>    //Add up all the other digits:<br/>    long sum = 0;<br/>    for(long num = (number /= 10); num &gt; 0; num /= 10) {<br/>      sum += num % 10;<br/>    }<br/>    //Now check if the last digit of the sum <br/>    // matches the last digit of the original number:<br/>    return (sum % 10 == last); <br/>  }<br/>  <br/>}</span></pre><p id="70d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的算法中，传递头值“X-Custom-Checksum 123”会被允许通过(因为1+2=3)，但是“X-Custom-Checksum 1234”会失败(因为1+2+3！= 4).</p><p id="5070" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一步是<a class="ae jd" href="https://javarevisited.blogspot.com/2017/05/how-to-enable-spring-security-in-java-web-application.html" rel="noopener ugc nofollow" target="_blank">配置Spring Security </a>来使用我们的过滤器作为安全过滤器链的一部分。因为我们不使用用户名和密码，所以我们将使用校验和验证来替换标准的Spring Security用户名/密码验证选项:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="95ff" class="jv jw hi jr b fi jx jy l jz ka">package net.cambium.examples.rest.security;</span><span id="e63f" class="jv jw hi jr b fi kb jy l jz ka">import org.springframework.context.annotation.Configuration;<br/>import org.springframework.security.config.annotation<br/>          .web.builders.HttpSecurity;<br/>import org.springframework.security.config.annotation<br/>          .web.configuration.EnableWebSecurity;<br/>import org.springframework.security.config.annotation<br/>          .web.configuration.WebSecurityConfigurerAdapter;<br/>import org.springframework.security<br/>          .web.authentication.UsernamePasswordAuthenticationFilter;</span><span id="0eaf" class="jv jw hi jr b fi kb jy l jz ka">/**<br/> * SecurityConfiguration.<br/> *<br/> *  Spring Security configuration for Spring Boot that <br/> *  will allow us to use a custom authorization mechanism.<br/> *  <br/> * <a class="ae jd" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a> Baruch Speiser, Cambium.<br/> */<br/><a class="ae jd" href="http://twitter.com/Configuration" rel="noopener ugc nofollow" target="_blank">@Configuration</a><br/><a class="ae jd" href="http://twitter.com/EnableWebSecurity" rel="noopener ugc nofollow" target="_blank">@EnableWebSecurity</a><br/>public class SecurityConfiguration <br/>     extends WebSecurityConfigurerAdapter <br/>{</span><span id="dbfd" class="jv jw hi jr b fi kb jy l jz ka">  <a class="ae jd" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>  protected void configure(HttpSecurity http) throws Exception {<br/>    //Use our custom security filter instead <br/>    // of username/password authentication:<br/>    http.addFilterAt(<br/>        new CustomAuthorizationFilter(), <br/>        UsernamePasswordAuthenticationFilter.class);<br/>  }<br/>  <br/>}</span></pre><p id="0d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们应该能够看到我们的自定义校验和验证在起作用:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/07/ldap-authentication-active-directory-authentication-java-spring-security-example.html"><div class="er es kh"><img src="../Images/eed1b0b476ab422c1c4505a7e42a7f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIYwP8eAGXuT-bWzkklkHQ.png"/></div></a><p class="jm jn et er es jo jp bd b be z dx translated">有效的校验和给你一个成功的响应。</p></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es ki"><img src="../Images/da7b4f4525c52ba5b9772832c6d3a198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULGS6lfOdlMnezgmnne3VA.png"/></div></div><p class="jm jn et er es jo jp bd b be z dx translated">如果校验和没有通过验证，那么请求将被拒绝，并显示401 Unauthorized。</p></figure><p id="1a42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们没有理由不能使用与常规令牌相同的约定来传递我们的数字，使用“Bearer 123”的头值，然后以相同的方式提取数值。</p><p id="1b07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一条规则，你应该尽可能地坚持惯例——但是如果需要的话，<a class="ae jd" rel="noopener" href="/javarevisited/3-best-spring-security-books-and-resources-for-java-programmers-653d05c8afd4"> Spring Security </a>提供了引入任何你需要的适合你的项目的机制的灵活性。</p></div></div>    
</body>
</html>