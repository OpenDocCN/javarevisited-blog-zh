# ReST API 设计:初学者指南

> 原文：<https://medium.com/javarevisited/rest-api-design-things-to-consider-96ac8a549aff?source=collection_archive---------0----------------------->

![](img/a8a6eb4a6b6dcbc03d85fedf916173eb.png)

[万花筒](https://unsplash.com/@kaleidico?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/white-boarding-code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

作为一名开发人员，您可能在职业生涯的某个阶段创建、使用(或两者都使用)过 API。如果你是一名移动/web/UI 开发人员，你肯定会与 API 交互，因为要显示的数据需要来自某个地方；如果你是一名[后端开发人员](https://javarevisited.blogspot.com/2019/02/the-2019-web-developer-roadmap.html)，你肯定会创建 API 来与其他服务交互(UI 和其他类似的后端服务)。

对于软件工程师，尤其是那些必须构建 API 的工程师来说，最好的事情之一就是提供一个 [RFC](https://tools.ietf.org/html/rfc2616) 来处理所有与 API 相关的事情:状态代码、标题、cookies、请求/响应体等等。也就是说，不太好的一点是，RFC 只是一个规范，也就是说，团队可以选择是否遵循它们。

如果后端服务对应用程序崩溃发送回一个成功的响应，没有什么会阻止它运行。当被遵循时，规范是伟大的，但是没有什么强迫团队或框架去遵循它们。

但是值得注意的是，像 [Spring](/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd) 这样的流行框架确实迫使使用它们的团队遵循其中的一些标准(例如:不能为 GET 请求指定请求体)。

回到 RFC，这些规范的存在是有原因的，并且为所有后端服务创建了一个标准。如果我致力于创建一个遵循 RFC 的后端服务“A ”,然后转而创建另一个服务“B”或者调用第三方 API，那么让所有这些服务都遵循一个预定义的规范将会非常有帮助。它确保了一致性，因为所有服务都使用相同的语言。

在这篇文章中，我想谈谈我是如何开始设计 API 的。无论如何，我都不会声称自己是专家，这篇文章的目的只是提供一个起点，而不是深入探讨。因此，抛开这些免责声明，下面是我开始设计 API 的方法:

# API 命名

API 路由是任何后端服务的入口点。下面是一些关于命名的注意事项:

## 识别资源

如果您的应用程序有用户帐户的概念，并且您正在创建捕获用户登录历史的 API(让我们假设应用程序需要这一点，并且用户喜欢这一特性)，建模登录历史 API 的一种方法是将登录历史嵌套在用户下，即/ `users/{userId}/loginHistory.`这是一个定义明确的 API，它定义了登录历史的层次结构。这很重要，因为现在您知道登录历史不是它自己的独立资源，而是用户资源的一部分，并且总是属于一个用户(由一个 userId 标识)。

## 提出一致的 API 命名策略

命名 API 有几种流行的方法。您可以使用连字符或骆驼大小写(在其他选项中，我敢肯定)。
如果我们使用连字符登录，历史将是这样的:

```
/users/{userId}/login-history
```

如果我们使用 camel case log in，History 将是这样的:

```
/users/{userId}/loginHistory
```

我不确定这里是否有一个硬性规定，除了选择一个并坚持下去。胜利的一致性！

## 识别操作

在我们确定了需要管理的资源之后，下一步是确定可以在这些资源上执行什么操作。通常这是 CRUD 的一个子集(创建、读取、更新、删除)。

有时，您只希望允许用户创建某些内容，而不希望更新它(可能您希望强制用户删除资源并重新创建它，而不允许他们更新它)。

在操作被识别之后，我们选择 HTTP 动词。因此，在我们想要管理用户登录历史的示例中，我们可以决定只允许创建和获取用户登录历史，而不允许更新和删除。

# HTTP 动词

HTTP 动词告诉 API 的消费者该 API 提供什么操作。最受欢迎的有:

*   获取:读取或获取资源
*   上传:更新或修改资源
*   删除:删除资源
*   发布:创建新资源

使用正确的动词很重要，因为这就像对 API 的响应中所期望的不言而喻的语言(例如:post 通常会在响应体中返回新创建的资源，带有 201 响应状态代码，其中 201 代表 created)。

动词还告诉用户他们可能需要在请求中提供什么，包括是否允许请求体(如果遵循 RFC)。例如，get 请求通常没有请求体(因为唯一标识和获取资源所需的任何标识符都应该是 GET 请求的请求体中 URI/API 路由 vs 的一部分)。

说到 HTTP 动词，我想快速地谈谈另外两个不常用的 HTTP 动词:HEAD 和 PATCH

## 头

HEAD 动词与 GET 动词非常相似，只是 HEAD 请求不能包含响应体。HEAD 请求用于测试给定的 URI 是否可用。例如，如果我们想检查 userId 为“123”的用户是否包含 loginHistory，我们可以向/users/123/loginHistory 发出 HEAD 请求，如果返回成功，我们可以向同一个 URI 发出 GET 请求。这在向某个 URI 发出请求时节省了带宽，尤其是在响应很大的情况下。

## 修补

修补动词非常类似于 PUT 请求，也用于更新资源。主要区别在于，PUT 请求替换了整个资源，这意味着在使用 PUT 动词时，资源的所有字段(无论是否正在更新)都需要传递给 API。但是当我们使用补丁请求时，我们只需要传递将用于更新资源的指令，包括需要做什么以及应该应用哪个字段更新。

在我们的例子中，假设我们已经决定只允许用户创建和获取他们的登录历史，我们的 API 可能如下所示:

```
POST  /users/{userId}/loginHistory
GET /users/{userId}/loginHistory
```

# 请求正文

下一步是确定是否会有请求体，如果有，那么就想出一个应该是什么样子的模式。根据 RFC，GET 请求不包含请求体，所以我们将遵循它，只为 post 请求创建一个请求体。因此， [JSON](https://javarevisited.blogspot.com/2017/02/how-to-consume-json-from-restful-web-services-Spring-RESTTemplate-Example.html) 中的登录历史 POST 请求体示例可能是:

```
{
 “time”: “1605202745”,
 “appVersion”: “5.2.0”
}
```

userId 被排除在请求主体之外，因为它应该从 API 路由中获取。此外，捕获所有登录历史相关信息所需的其他附加字段可以添加到上面的正文中。

# 响应状态

响应的响应状态应传达两件事:

*   手术成功了吗？
*   后续步骤(如果有)？

有许多状态代码可用(包括何时使用和使用什么的 RFC)。因为响应状态传达的第一件事是操作是成功还是失败，我认为不言而喻，当错误发生时使用 2xx(指示成功的 200 系列状态代码)是一个大的否定

当涉及到状态代码时，在响应中传递正确的子状态代码非常重要。例如，200 表示 OK，表示一切顺利，而 201 用于表示资源创建成功。所以 200 更适合 GET/PUT 请求，而 201 更适合 POST 请求(假设 POST 请求创建了一个对象)。POST 请求使用 200 不会有问题，主要是因为它也传达了成功。但是，201 将更适合，因为除了指示请求被成功接收和处理之外，它还指示新资源被创建。对于成功的删除，最好使用 204(无内容)状态代码向调用客户端表明，虽然请求成功，但没有预期的响应正文(即，如果没有响应正文)。

成功代码互换使用比失败代码互换使用影响更小。例如，使用 401(未授权)代替 403(禁止)是不好的，因为它向用户(或可能是 UI 组件的调用客户端)给出了错误的指示。401 表示提供的身份验证凭据与后端比较的记录不匹配。403 表示用户试图访问他们无权访问的资源。修复 401 的解决方案是更改提交给应用程序的身份验证凭证，而修复 403 的解决方案可能简单到“对不起，这里没有要修复的内容”。通常情况下，正确的错误状态代码将指示后续步骤。因此，使用正确的状态代码变得更加重要，尤其是在出现错误时。

一般来说，在选择状态代码时，严格遵循 RFC 是非常重要的，因为它们意味着一些东西(使用你的 API 的应用/服务希望它们与 RFC 一致，因为这是每个人的共同参考！)有时很容易把它们弄混。

# 响应正文

API 设计中下一个最重要的步骤是确定响应体。确保响应体包含调用客户端需要的所有内容是非常常见的做法(例如:如果一个 web 应用程序请求 API 获取用户的登录历史，我们确保从后端向它们提供 web 显示所需的所有信息)。在极少数情况下，我们可能需要比调用客户端所需的信息更多的信息，特别是如果后端没有利用任何缓存，额外的信息不是来自后端，后端将需要这些信息来处理传入的请求。举个例子会有帮助，对吗？绝对的。让我们考虑一个场景，其中后端调用服务提供者 X 获取一些信息，并将其作为响应的一部分传递回 UI，尽管(让我们假设)UI 根本不使用这些信息，但因为后端不缓存，并且服务 X 花费大量时间来响应请求(让我们继续假设)，那么将这些信息传递到 UI 并传递回 UI 将会很有帮助，以便后端可以使用这些信息来做它需要做的任何事情。

在最终确定 API 时，我喜欢考虑的另一个重要因素是确保响应不会比需要的大。如果你有非常大的响应体，一个很好的问题是询问是否有可能将单个 API 分解成多个 API。例如，如果您有一个消息应用程序，而不是有一个单一的 API 来提供与页面上显示的消息相关的所有信息(假设我们实现了分页，每页显示 20 条消息)。因此，一种选择是让 20 条消息包含所有消息信息，或者让 20 条消息只包含需要在消息列表页面上显示的信息，并使用另一个 API 在用户单击消息时在页面上显示更多信息。在两者之间做出决定可能需要考虑其他因素，如带宽考虑、处理时间、响应时间等。但是如果可以控制这些考虑因素，那么考虑后者可能是个好主意:为消息列表创建两个 API，其中一个 API 包含关于消息的最少信息(/messages？page=2)和另一个更具体的 API 来获取单个消息的附加信息(/messages/{messageId})。

当涉及到错误场景时，响应体必须以这样一种方式构造，即关于发生了什么的信息和关于如何修复错误的指示将是有帮助的。

# 查询参数与路径变量

API 开发人员可以自由决定某个字段是否需要出现在查询参数或路径变量中。根据实现的不同，我们可以让这两种变化都很好地工作。帮助我决定某个领域走向的两条经验法则是:

*   考虑请求变量是用于唯一标识资源，还是请求变量更像一个搜索标准。
*   如果所使用的变量可用于所有资源(如果我们考虑登录历史，并且说只有某些登录历史资源具有某个字段，那么使用该字段作为路径变量是不可取的，因为具有该变量的 URI 不能唯一地标识登录历史资源)。例如，我们需要一个 userId 来唯一地标识一个用户，但是像 isAccountActive 这样的搜索参数是一个搜索标准，没有办法只使用这个字段来获取特定的用户。但重要的是，我在此基础上添加了一条额外的规则。如果有多个字段可以用来标识一个资源，我更喜欢使用系统的最终用户无法控制的字段。例如，如果可以使用 userId 和用户名唯一地标识用户，我会选择 userId，因为用户名可以由用户更改，但 userId 不能更改(这是需要的方式，用户不应该有更改 userId 的选项)。

# 结论

API 设计充满了乐趣，因为围绕着普遍理解和期望的东西有规范和规则，同时也为创造性留有余地。我认为这条线很细，但是遵循规范或者至少诚实地尝试，对于确保一致性大有帮助，不仅对于包含 API 的应用程序，而且对于使用它的应用程序。