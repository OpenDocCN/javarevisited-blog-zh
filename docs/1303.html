<html>
<head>
<title>You are probably writing service classes wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能写错了服务类</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/you-are-probably-writing-service-classes-wrong-f3c65d5f77e9?source=collection_archive---------1-----------------------#2021-06-08">https://medium.com/javarevisited/you-are-probably-writing-service-classes-wrong-f3c65d5f77e9?source=collection_archive---------1-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1720a3d974721caed2ed42fd6ff9347d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qj4Z6m_wo_ZgCGh5"/></div></div><p class="iq ir et er es is it bd b be z dx translated">克拉克·范·德·贝肯在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ce6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java EE和Spring已经成为企业级Java应用程序的事实上的标准，尤其是web应用程序。但本文并不谈论<a class="ae iu" rel="noopener" href="/javarevisited/top-7-online-courses-to-learn-java-ee-jakarta-ee-in-2020-216c1a5eea99"> Java EE </a>或<a class="ae iu" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring </a>，而是一个标准应用程序的各层。</p><p id="426f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将挑战大多数人是如何设计他们的应用程序的，从<code class="du jt ju jv jw b">controller</code>层到<code class="du jt ju jv jw b">dao</code>层。然而，我的主要目标将是服务层，因为我经常看到这一层被滥用得最多。</p><p id="bfe1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了使它更有趣和相关，我将举一个例子。首先，我将向你展示一个传统的设计，并检查它。接下来，我将向您展示一个据称更好的设计，并指出它的优点。我们开始吧。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="0c0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它是一个银行系统，保存着人们的账户和钱。要求是，</p><ol class=""><li id="632c" class="ke kf hi ix b iy iz jc jd jg kg jk kh jo ki js kj kk kl km bi translated">账户需要维持最低余额。</li><li id="0056" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">资金可以通过符合账户余额的支票在账户间转移。</li></ol><h1 id="7d85" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">传统实现(贫血模型)</h1><p id="48c6" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">假设我们使用的是<a class="ae iu" rel="noopener" href="/javarevisited/5-best-spring-data-jpa-courses-for-java-developers-45e6438be3c9"> JPA </a>，让我们创建一个实体类。</p><pre class="lv lw lx ly fd lz jw ma mb aw mc bi"><span id="20da" class="md kt hi jw b fi me mf l mg mh">@Entity<br/>class Account {<br/>    Long accountNo;<br/>    Long balance;<br/>}</span></pre><p id="fa91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似的一个DTO类，</p><pre class="lv lw lx ly fd lz jw ma mb aw mc bi"><span id="7ee9" class="md kt hi jw b fi me mf l mg mh">class AccountDto {<br/>    Long accountNo;<br/>    Long balance;<br/>}</span></pre><p id="8a37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最重要的是服务类(业务逻辑)，</p><pre class="lv lw lx ly fd lz jw ma mb aw mc bi"><span id="d8a3" class="md kt hi jw b fi me mf l mg mh">class AccountService {</span><span id="a48a" class="md kt hi jw b fi mi mf l mg mh">    AccountDao accountDao;</span><span id="2411" class="md kt hi jw b fi mi mf l mg mh">    public void processCheque(ChequeDto cheque){<br/>        var fromAccount = accountDao.load(cheque.from());<br/>        var toAccount = accountDao.load(cheque.to());<br/>        if(fromAccount.balance-MIN_BALANCE &gt; cheque.amount){<br/>           fromAccount.balance -= cheque.amount;<br/>           toAccount.balance += cheque.amount;<br/>        }<br/>    }</span><span id="c3d0" class="md kt hi jw b fi mi mf l mg mh">}</span></pre><p id="2b47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果上面的设计对你来说没问题，让我问你下面的问题，</p><h2 id="1c13" class="md kt hi bd ku mj mk ml ky mm mn mo lc jg mp mq lg jk mr ms lk jo mt mu lo mv bi translated">这是面向对象的吗？</h2><p id="685c" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">从业务问题来看，我们是否同意“Account”是这里的主要域实体(我不是指hibernate实体)？但是在设计中，<code class="du jt ju jv jw b">Account</code>类没有任何行为。行为从领域实体中提取出来，并写入服务类中。</p><p id="38e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">balance</code>是域实体<code class="du jt ju jv jw b">Account</code>的属性，但是我们从外部操纵它。</p><p id="708e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个只有属性而没有行为的对象是完全可以的。比如说喜欢值对象(<code class="du jt ju jv jw b">AccountDTO</code>)。但是将一个对象的行为从该对象中部分或全部移除，是违背<a class="ae iu" href="https://javarevisited.blogspot.com/2018/07/10-object-oriented-design-principles.html" rel="noopener ugc nofollow" target="_blank">面向对象设计原则</a>的。</p><p id="5859" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">OOP有4个基本概念:<em class="mw"> APIE </em>！</p><ol class=""><li id="c09b" class="ke kf hi ix b iy iz jc jd jg kg jk kh jo ki js kj kk kl km bi translated">抽象</li><li id="993a" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">多态性</li><li id="01c2" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">遗产</li><li id="3b73" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">包装</li></ol><p id="db2b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这4个当中，我们已经成功地摧毁了抽象和封装。</p><p id="1e02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">a.<code class="du jt ju jv jw b">Account</code>类的<code class="du jt ju jv jw b">balance</code>属性应该被封装，但是它可以从外部公开访问。</p><p id="450c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b.如何更新<code class="du jt ju jv jw b">Account</code>类的封装属性<code class="du jt ju jv jw b">balance</code>，根本不是从<code class="du jt ju jv jw b">Account</code>类的用户中抽象出来的。更确切地说，行为是在类之外的，所以绝对没有抽象。</p><p id="1d5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能会说你不喜欢OOP，你不理解它。那很好。但是所有范例都鼓励抽象和封装。</p><h2 id="3d2d" class="md kt hi bd ku mj mk ml ky mm mn mo lc jg mp mq lg jk mr ms lk jo mt mu lo mv bi translated">什么是服务等级？</h2><p id="9d1a" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">服务类是一个无状态的单例，这是由设计决定的。它应该是编排业务的一个薄层。</p><p id="5e7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">控制器层</strong>:负责与web客户端通信。API公开了契约、HTTP响应代码等。这里不应该有任何商业逻辑。</p><p id="a329" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">存储库/ DAO层</strong>:与数据存储通信。没有商业逻辑。可以把它想象成数据存储的API。</p><p id="71f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">服务层</strong>:一个<em class="mw">瘦</em>无状态层，协调域层。它里面没有商业逻辑。</p><p id="8e02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种没有任何行为的厚服务层和域对象的设计被称为贫血模型。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="45fa" class="ks kt hi bd ku kv mx kx ky kz my lb lc ld mz lf lg lh na lj lk ll nb ln lo lp bi translated">领域驱动的设计</h1><p id="ce64" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">当我们看到传统贫血模型的缺点时，让我们按照<a class="ae iu" href="https://javarevisited.blogspot.com/2012/12/what-is-object-in-java-or-oops-example.html" rel="noopener ugc nofollow" target="_blank"> OOP范例</a>重写解决方案。</p><p id="2247" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">薄服务层。不知道任何商业逻辑。</p><pre class="lv lw lx ly fd lz jw ma mb aw mc bi"><span id="39af" class="md kt hi jw b fi me mf l mg mh">class ChequeService {</span><span id="ef18" class="md kt hi jw b fi mi mf l mg mh">   public void processCheque(ICheque cheque){<br/>       cheque.process();<br/>   }</span><span id="d91e" class="md kt hi jw b fi mi mf l mg mh">}</span></pre><p id="c087" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">Cheque</code>类、</p><pre class="lv lw lx ly fd lz jw ma mb aw mc bi"><span id="d25f" class="md kt hi jw b fi me mf l mg mh">class Cheque implements ICheque{</span><span id="d4ad" class="md kt hi jw b fi mi mf l mg mh">   public void process(){<br/>       var fromAccount = accountDao.load(from);<br/>       var toAccount = accountDao.load(to);<br/>       fromAccount.deductAmount(amount)<br/>       toAccount.depositAmount(amount)<br/>   }</span><span id="d2f8" class="md kt hi jw b fi mi mf l mg mh">}</span><span id="987a" class="md kt hi jw b fi mi mf l mg mh">interface ICheque {<br/>    void process();<br/>}</span></pre><p id="77d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有<code class="du jt ju jv jw b">Account</code>类，</p><pre class="lv lw lx ly fd lz jw ma mb aw mc bi"><span id="27d2" class="md kt hi jw b fi me mf l mg mh">class Account implements IAccount {</span><span id="d7a4" class="md kt hi jw b fi mi mf l mg mh">    static final Long MIN_BALANCE = 1000;<br/>    private Long balance;<br/>    private Long accountNo;</span><span id="0733" class="md kt hi jw b fi mi mf l mg mh">    public void depositAmount(Long amount){<br/>        balance += amount; <br/>    }</span><span id="a639" class="md kt hi jw b fi mi mf l mg mh">    public void deductAmount(Long amount){<br/>        if(balance-amount&lt;MIN_BALANCE)<br/>            throw new MinimumAccountBalanceException(balance, amount);<br/>        balance -= amount; <br/>    }</span><span id="ebc9" class="md kt hi jw b fi mi mf l mg mh">}</span><span id="7461" class="md kt hi jw b fi mi mf l mg mh">interface IAccount {<br/>    void depositAmount(Long amount);<br/>    void deductAmount(Long amount);<br/>}</span></pre><p id="4833" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">以下是本设计的基本变化，</strong></p><ol class=""><li id="7a73" class="ke kf hi ix b iy iz jc jd jg kg jk kh jo ki js kj kk kl km bi translated"><code class="du jt ju jv jw b">Account</code>类是<em class="mw">封装</em>的<code class="du jt ju jv jw b">balance</code>属性和<em class="mw">抽象</em>的<code class="du jt ju jv jw b">balance</code>更新过程。</li><li id="0400" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">处理支票的实现也在<code class="du jt ju jv jw b">Cheque</code>类中<em class="mw">抽象</em>。</li><li id="6558" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">服务类不受任何业务逻辑或规则的约束。</li></ol><p id="bfb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们来看看我们的新设计带来了什么好处，</p><h2 id="49fd" class="md kt hi bd ku mj mk ml ky mm mn mo lc jg mp mq lg jk mr ms lk jo mt mu lo mv bi translated"><strong class="ak">打开扩展-关闭修改</strong></h2><p id="8eb5" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">由于我们的领域对象现在功能非常强大，所以添加新特性变得非常容易。同时，域对象执行抽象和封装来保护外部行为。阅读更多关于<em class="mw">开合原理</em><a class="ae iu" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle</a>的信息。</p><p id="caf0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们推出更多的交易服务，如即期汇票服务、网上银行服务。所有这些服务都处理帐户余额。现在，如果余额存款/取款逻辑发生变化，我们将只在<code class="du jt ju jv jw b">Account</code>类中进行更改。</p><p id="a124" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种改变对这些服务来说是透明的。然而，对于一个不完善的设计，我们将单独地改变所有这些服务中的代码。这意味着更多的开发工作、测试工作和更多引入bug的机会。</p><h2 id="86e6" class="md kt hi bd ku mj mk ml ky mm mn mo lc jg mp mq lg jk mr ms lk jo mt mu lo mv bi translated"><strong class="ak">多态性和遗传</strong></h2><p id="5244" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">我们现在可以将多态和继承应用到我们的域对象中。既然我提到了继承，我想提一下https://en.wikipedia.org/wiki/Composition_over_inheritance</p><p id="3b10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你注意到我是如何在领域驱动设计中使用接口的吗？这是为了减少服务层和域层(域对象驻留的地方)之间以及域层内部的耦合。在大多数情况下，这些类通过接口相互认识，即<em class="mw">契约</em>(接口很漂亮，不是吗？).所以<code class="du jt ju jv jw b">Cheque</code>只要满足<code class="du jt ju jv jw b">IAccount</code>的契约，一个类可以使用任何种类的账户。并且可以有具有不同实现/业务逻辑的不同类型的账户。例如，活期账户每次扣款收取0.5%的费用，并且没有最低余额要求。</p><pre class="lv lw lx ly fd lz jw ma mb aw mc bi"><span id="5c7d" class="md kt hi jw b fi me mf l mg mh">class CurrentAccount implements IAccount {<br/>    private Long balance;<br/>    private Long accountNo;</span><span id="1f13" class="md kt hi jw b fi mi mf l mg mh">    public void depositAmount(Long amount){<br/>        balance += amount; <br/>    }</span><span id="c8a8" class="md kt hi jw b fi mi mf l mg mh">    public void deductAmount(Long amount){<br/>        balance -= amount + amount * 0.005;<br/>    }</span><span id="9fa3" class="md kt hi jw b fi mi mf l mg mh">}</span></pre><p id="d660" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现有的支票服务和<code class="du jt ju jv jw b">Cheque</code>类将与此无缝协作。这同样适用于<em class="mw">多变形</em>的<code class="du jt ju jv jw b">Cheque</code>类。</p><p id="e602" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，我们可以用balance和account创建一个抽象类<code class="du jt ju jv jw b">AbstractAccount</code>和我们的account类<code class="du jt ju jv jw b">extend</code>，即应用<em class="mw">继承</em>。但是使用继承有一些缺点，因此通常建议使用<em class="mw">合成而不是继承</em>。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="20c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而这仅仅是为了这个商业问题。坚持领域驱动设计的更大的项目在很多方面受益，例如，在团队之间用无处不在的语言更好的交流，最小的变化影响，灵活性，等等。</p><h1 id="a65e" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">什么是领域驱动设计？</h1><p id="47f2" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">上面的解决方案是领域驱动设计的一个例子，由Eric Evans在他的名著<em class="mw">领域驱动设计:解决软件核心的复杂性中创造并推广。</em></p><blockquote class="nc nd ne"><p id="b718" class="iv iw mw ix b iy iz ja jb jc jd je jf nf jh ji jj ng jl jm jn nh jp jq jr js hb bi translated">领域驱动设计是软件代码的结构和语言应该与业务领域相匹配的概念。—维基百科</p></blockquote><p id="c48f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个巨大的概念，这篇文章的目标不是覆盖领域驱动设计，而是让你体验一下。</p><h1 id="5715" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h1><p id="4e19" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">贫血模型基本上是一个<em class="mw">反模式</em>，大多数人不假思索地跟随它。我们应该更有意识地设计我们的应用程序。从长远来看，它肯定会回报我们。如果这篇文章让你对DDD感兴趣，那对我来说是一个胜利。</p></div></div>    
</body>
</html>