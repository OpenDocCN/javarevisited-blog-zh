<html>
<head>
<title>Spring Security: Develop a REST-Service Secured With OAuth2, Bitbucket and JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Security:用OAuth2、Bitbucket和JWT开发一个安全的REST服务</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-security-develop-a-rest-service-secured-with-oauth2-bitbucket-and-jwt-aab95dc0c55?source=collection_archive---------1-----------------------#2021-03-18">https://medium.com/javarevisited/spring-security-develop-a-rest-service-secured-with-oauth2-bitbucket-and-jwt-aab95dc0c55?source=collection_archive---------1-----------------------#2021-03-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="43eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何使用Spring Security开发一个由OAuth2、Bitbucket授权服务器和JWT保护的REST-service</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4088cdbc83a7da32a1174f00af5b7b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dks_Atlc2SwHyXct"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">飞:D </a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="63ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将开发一个小型的REST-service，使用OAuth2协议保护，使用Bitbucket作为授权服务器。起初，使用第三方授权服务器似乎不太常见，但是想象一下，您正在开发一个CI(持续集成)服务器，并且想要访问版本控制系统中的用户资源(例如项目、存储库)。比如在<a class="ae jt" href="https://www.drone.io" rel="noopener ugc nofollow" target="_blank"> Drone.io </a>和<a class="ae jt" href="https://travis-ci.com" rel="noopener ugc nofollow" target="_blank"> Travis CI </a>中使用了同样的方法。</p><h1 id="6caf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">理论</h1><p id="aac3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在开始之前，让我们回忆一下一些理论。</p><p id="ec1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">认证</strong>是识别用户身份的过程。这通常是通过要求一组凭证来完成的，比如用户名和密码。一旦通过验证，客户端将获得有关用户身份和访问权限的信息。</p><p id="a797" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">授权</strong>是授予或拒绝访问网络资源的过程，它允许用户基于用户的身份访问各种资源。</p><p id="7cd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">授权有两种类型:<strong class="ih hj">基于cookie的</strong>和<strong class="ih hj">基于令牌的</strong>。让我们详细看看每种类型的授权是如何工作的。</p><p id="ec9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于Cookie的授权是有状态的，这意味着服务器必须管理一个会话才能授权用户请求。基于Cookie的授权工作方式如下:</p><ul class=""><li id="4f56" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">用户通过提供凭据登录。</li><li id="abaa" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">服务器创建HTTP会话并将其与用户相关联。它还创建了一个名为<a class="ae jt" href="http://javarevisited.blogspot.sg/2012/08/what-is-jsessionid-in-j2ee-web.html#axzz5Dgr5hofT" rel="noopener ugc nofollow" target="_blank"> JSESSIONID </a>的cookie，用于存储会话标识符。</li><li id="e053" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">cookie被传递给客户机并存储在那里。</li><li id="35db" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">cookie被附加到对服务器的每个后续请求中。</li><li id="737c" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">服务器使用cookie找到一个会话，并检查用户是否有权访问所请求的资源。</li><li id="e626" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">当用户从应用程序中注销时，会从服务器中删除一个会话。</li></ul><p id="7341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为REST架构约束之一是无状态，所以基于cookie的授权不是我们示例的选项。让我们看看基于令牌的授权有何不同。</p><p id="b47b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于令牌的授权是无状态的，这意味着服务器不必存储任何会话信息来授权客户端请求。基于令牌的授权是这样工作的:</p><ul class=""><li id="3071" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">用户通过提供凭据登录。</li><li id="0c08" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">服务器发布用秘密密钥签名的访问令牌。然后将令牌返回给客户端。令牌包含用户标识符和用户角色。</li><li id="5e9f" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">令牌存储在客户端，并随每个后续请求一起传递给服务器。通常令牌在<code class="du ll lm ln lo b">Authorization</code> HTTP头中被传递给服务器。</li><li id="3c44" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">服务器验证签名，提取用户id、角色，并检查用户是否有执行呼叫的权限。</li><li id="c974" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">当用户注销时，只需从客户端删除一个令牌就足够了，甚至无需联系服务器。</li></ul><p id="a76c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JSON Web Token (JWT)是目前流行的令牌格式。它包含三个以逗号分隔的数据块:报头、有效载荷和签名。前两个块是base64编码的JSON文档。有效负载可以包含一些保留的键/值对，如<code class="du ll lm ln lo b">iss</code>、<code class="du ll lm ln lo b">iat</code>、<code class="du ll lm ln lo b">exp</code>，以及自定义的用户定义的键/值对。对称和非对称算法可用于对令牌进行签名。</p><p id="3c98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用<strong class="ih hj"> OAuth2 </strong>协议来授权我们的用户，所以让我们看一下它。OAuth2是一种协议，允许用户向第三方应用程序授予对用户受保护资源的访问权限，而不暴露他们的凭据。OAuth2协议定义了4个授权流:授权码、隐式、资源所有者密码凭证和客户端凭证。我们将使用授权代码流类型。授权代码流类型由两个后续请求组成:</p><ul class=""><li id="dcc6" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">授权请求；</li><li id="3e30" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">访问令牌请求。</li></ul><p id="063a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">授权请求用于对用户进行身份验证，并为我们的应用程序请求授权以访问资源服务器上的用户资源。这只是一个带有以下参数的GET请求:</p><ul class=""><li id="bcfc" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">response_type —必须设置为<code class="du ll lm ln lo b">code</code>；</li><li id="efd6" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">client_id —从授权服务器获得的值；</li><li id="cf1d" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">redirect_uri —回调uri</li><li id="7336" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">scope —可选参数，指定访问级别。</li><li id="134b" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">state用于响应验证的随机字符串。</li></ul><p id="e914" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请求示例:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="b1bf" class="lt jv hi lo b fi lu lv l lw lx">GET https://server.example.com/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;state=xyz&amp;redirect_uri=REDIRECT_URI</span></pre><p id="cdca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果授权成功，用户代理将被重定向到请求中提供的回调URL。<code class="du ll lm ln lo b">code</code>参数包含授权码，而<code class="du ll lm ln lo b">state</code>参数包含请求中提供的值。</p><p id="31aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">响应电话示例:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="7aff" class="lt jv hi lo b fi lu lv l lw lx">GET https://client.example.com/cb?code=AUTH_CODE_HERE&amp;state=xyz</span></pre><p id="e9f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">访问令牌请求用于交换授权码以访问令牌。这是一个带有以下参数的<a class="ae jt" href="https://www.java67.com/2019/03/7-examples-of-httpurlconnection-in-java.html" rel="noopener ugc nofollow" target="_blank"> POST请求</a>:</p><ul class=""><li id="aeb8" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">grant_type —必须是<code class="du ll lm ln lo b">authorization_code</code>；</li><li id="67c7" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">code —上一步获得的授权码；</li><li id="8c5d" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">redirect_uri —必须与上一步相同；</li><li id="4fd2" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">client_id —从授权服务器获得的值；</li><li id="f97c" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">client_secret —从授权服务器获得的值。</li></ul><p id="3551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请求示例:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="36d1" class="lt jv hi lo b fi lu lv l lw lx">POST https://server.example.com/token     grant_type=authorization_code&amp;<br/>code=AUTH_CODE&amp;<br/>redirect_uri=REDIRECT_URI&amp;<br/>client_id=CLIENT_ID&amp;<br/>client_secret=CLIENT_SECRET</span></pre><p id="7e37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">响应包含访问令牌及其生存期以及刷新令牌:</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="97c1" class="lt jv hi lo b fi lu lv l lw lx">{<br/>   "access_token": "2YotnFZFEjr1zCsicMWpAA",<br/>   "expires_in": 3600,<br/>   "refresh_token": "tGzv3JOkF0XG5Qx2TlKWIA"<br/>}</span></pre><p id="4b9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好消息是，所有这些流程都是由<a class="ae jt" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-security-and-oauth2-with-spring-boot-for-java-developers-8f0222d6066d?source=---------5-----------------------"> Spring Security </a>实现的，我们不必担心实现的问题。</p><h1 id="b219" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">履行</h1><p id="4b82" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们将开发一个REST服务，公开以下API:</p><ul class=""><li id="7adc" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">GET /auth/login —启动身份验证过程；</li><li id="baa2" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">POST /auth/token —请求一对新的访问/刷新令牌；</li><li id="fbdb" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">GET /api/repositories —请求当前用户的存储库列表。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/02/spring-security-interview-questions-answers-java.html#axzz6lIcZ8tnd"><div class="er es ly"><img src="../Images/db92e2fc52c09aa160d4b194c8a382e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VuQ_1cLYpOtw7IYeFXHjDg.jpeg"/></div></a><p class="jp jq et er es jr js bd b be z dx translated">解决方案的高级概述</p></figure><p id="72cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，因为应用程序由三个组件组成，所以不仅客户端对服务器的请求应该被授权，服务器对Bitbucket的请求也应该被授权。为了简化这个例子，我们不打算设置基于角色的授权。每个经过身份验证的客户端都被允许访问<code class="du ll lm ln lo b">/api/repositories</code>端点。允许服务器向Bitbucket发出在OAuth2客户端注册期间被授权的任何请求。我们将使用Spring Boot版本2.2.2.RELEASE和<a class="ae jt" href="https://www.java67.com/2017/12/top-5-spring-security-online-training-courses.html" rel="noopener ugc nofollow" target="_blank"> Spring Security </a>版本5.2.1.RELEASE</p><h2 id="1549" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">注册OAuth2消费者</h2><p id="e951" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">首先，我们必须在Bitbucket上将我们的应用程序注册为OAuth2消费者。为此，请打开您的用户帐户设置并添加一个消费者，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://www.java67.com/2017/11/top-5-free-core-spring-mvc-courses-learn-online.html"><div class="er es mm"><img src="../Images/d5da8d61269be9e52825adecf0416a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbOnOvNiS9fj2YPmJkoiYw.jpeg"/></div></a></figure><p id="0fc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">填写名称和回拨URL，然后授予以下权限:</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/04/top-5-spring-cloud-courses-for-java.html#axzz6jsdEHyTp"><div class="er es mn"><img src="../Images/e9fa327feb6ed49697f09066ebef2fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfMEn3A-RVrVA7V6JqmdVw.png"/></div></a></figure><p id="69f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将获得2个属性，将它们存储在<code class="du ll lm ln lo b">application.properties</code>文件中。</p><pre class="je jf jg jh fd lp lo lq lr aw ls bi"><span id="c181" class="lt jv hi lo b fi lu lv l lw lx">client_id=ZJsdANfWkJ7jcktw2x<br/>client_secret=28uUrJ9m43svbkcnXVNj8qeBjFtd8jaD</span></pre><h2 id="01b4" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">认证入口点</h2><p id="0921" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当在web应用程序中访问受保护的资源，并且在安全上下文中没有经过身份验证的用户时，用户被重定向到登录页面。然而，这种行为对于静止应用来说是不可接受的。在这种情况下，最好返回HTTP 401(未授权)错误。这就是我们<code class="du ll lm ln lo b">RestAuthenticationEntryPoint</code>班所做的。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="80a0" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">创建登录和刷新令牌端点</h2><p id="5179" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们将使用OAuth2授权代码流对用户进行身份验证，但是我们在上一步中覆盖了一个默认的AuthenticationEntryPoint，这就是为什么我们需要一种显式的方法来触发身份验证。我们将把用户重定向到<code class="du ll lm ln lo b">/auth/login</code>端点处理程序中的位桶认证页面。此端点需要在查询参数中传递一个回调URL，该参数将用于在成功身份验证后向客户端提供JWT。</p><p id="6917" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于安全目的，访问令牌的生命周期通常非常有限。在这种情况下，如果它被盗，第三方将无法使用它很长一段时间。为了不使用户在每次令牌到期时重新登录，使用刷新令牌来获得新的访问令牌。刷新令牌由服务器与访问令牌一起发出，并且它具有更长的寿命。存储和传输刷新令牌的推荐方法是使用HttpOnly cookies。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="6a26" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">认证成功处理程序</h2><p id="a86a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><code class="du ll lm ln lo b">AuthenticationSuccessHandler</code>认证成功后调用。这是生成一对访问/刷新令牌并将用户重定向到登录步骤中提供的回调URL的好地方。使用查询参数返回访问令牌，使用HttpOnly cookie返回刷新令牌。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="8f56" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">令牌认证过滤器</h2><p id="79de" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">该过滤器的目的是从授权头中提取访问令牌，并初始化安全上下文。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="a623" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">授权申请存储库</h2><p id="e4c0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Spring Security使用一个<code class="du ll lm ln lo b">AuthorizationRequestRepository</code>的实例在认证期间保存<code class="du ll lm ln lo b">OAuth2AuthorizationRequest</code>对象。默认实现是使用<code class="du ll lm ln lo b">HttpSession</code>作为存储器的<code class="du ll lm ln lo b">HttpSessionOAuth2AuthorizationRequestRepository</code>。这个实现不适合我们的需求，因为我们的服务是无状态的。这就是为什么我们必须实现我们自己的请求存储库，它将使用cookies作为存储。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="13bb" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">配置Spring安全性</h2><p id="c406" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">最后，让我们将所有部分组合在一起，创建一个配置类。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="099f" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">存储库端点</h2><p id="bec2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在，我们可以利用与Bitbucket集成的优势。让我们使用Bitbucket repositories API来获取用户的存储库列表。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="4286" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">测试</h2><p id="efcd" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们需要一个小的HTTP服务器来模拟一个真实的客户端。它将被用作返回令牌的目的地。</p><p id="a3a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们尝试在认证之前调用存储库端点，并检查我们是否得到了401错误。</p><p id="c18f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们执行认证。为此，我们需要启动我们的服务器，并在浏览器中打开<a class="ae jt" href="http://localhost:8080/auth/login" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/auth/log in</a>URL。</p><p id="a407" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">认证成功后，客户机将收到一个令牌，并将再次调用存储库端点。之后，请求一个新的令牌，然后用它来调用存储库端点。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="13c4" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">源代码</h2><p id="b861" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这个例子的源代码可以在<a class="ae jt" href="https://github.com/nbondarchuk/oauth2-bitbucket-jwt-example" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><h2 id="11b1" class="lt jv hi bd jw lz ma mb ka mc md me ke iq mf mg ki iu mh mi km iy mj mk kq ml bi translated">资源</h2><ul class=""><li id="6f65" class="kx ky hi ih b ii ks im kt iq mq iu mr iy ms jc lc ld le lf bi translated"><a class="ae jt" href="https://en.wikipedia.org/wiki/OAuth" rel="noopener ugc nofollow" target="_blank"> OAuth —维基百科</a></li><li id="8c4e" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jt" href="https://docs.spring.io/spring-security/site/docs/5.2.3.RELEASE/reference/htmlsingle/#oauth2login-advanced-userinfo-endpoint" rel="noopener ugc nofollow" target="_blank">春季安全参考</a></li><li id="f1f0" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jt" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌(JWT) </a></li><li id="bfcd" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jt" href="https://tools.ietf.org/html/rfc6749#section-4.1.1" rel="noopener ugc nofollow" target="_blank">OAuth 2.0授权框架</a></li></ul><p id="a70d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，这个例子通过HTTP连接工作。但是请注意，我们的令牌没有加密，一般来说，最好切换到安全连接(HTTPS)。</p></div></div>    
</body>
</html>