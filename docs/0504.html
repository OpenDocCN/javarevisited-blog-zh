<html>
<head>
<title>Static factory methods, an alternative to public constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">静态工厂方法，公共构造函数的替代方法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/static-factory-methods-an-alternative-to-public-constructors-73cbe8b9fda?source=collection_archive---------2-----------------------#2020-06-15">https://medium.com/javarevisited/static-factory-methods-an-alternative-to-public-constructors-73cbe8b9fda?source=collection_archive---------2-----------------------#2020-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c76821af5243552260afd9b2be2a90b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SytgnQ4HssmVE-nkEj4Ypw.jpeg"/></div></div></figure><p id="54e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">允许Java程序的其他部分获取某种类型的对象的最广泛使用的技术是创建公共构造函数。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div><p class="ju jv et er es jw jx bd b be z dx translated">一个具有公共空构造函数的java类</p></figure><p id="0167" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有另一种技术，它提供了各种优势，非常值得推荐给每一个程序员去了解。类可以提供<strong class="is hj"><em class="jy"/></strong><em class="jy">的静态工厂方法。</em>这种方法是返回实例的另一种方式。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div><p class="ju jv et er es jw jx bd b be z dx translated">使用静态工厂方法而不是公共构造函数的java类</p></figure><p id="4e8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更具描述性的命名是可能的<br/> 方法有名字，所以我们在构造对象时可以更具描述性。构造函数不能有名字，但是方法可以，所以通过拥有这种类型的方法，我们可以更流畅地表达对象是如何构造的。所以代替这个的是:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div><p class="ju jv et er es jw jx bd b be z dx translated">用构造函数初始化</p></figure><p id="3090" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以这样创建我们的对象:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div><p class="ju jv et er es jw jx bd b be z dx translated">用静态工厂方法初始化</p></figure><p id="ec61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">资源优化</strong> <br/>每次调用关键字<strong class="is hj"> <em class="jy"> new </em> </strong>都会创建一个新的实例。在很多场合，特别是在大型系统中，程序员需要小心使用资源。在一些<a class="ae jz" rel="noopener" href="/javarevisited/7-best-books-to-learn-design-patterns-for-java-programmers-5627b93eefdb">设计模式</a>中使用静态工厂方法并不少见。Singleton和fluent Builder模式将使用静态工厂方法:</p><ul class=""><li id="4e18" class="ka kb hi is b it iu ix iy jb kc jf kd jj ke jn kf kg kh ki bi translated">拥有缓存的对象，并确保它们被正确清理。(谷歌搜索<strong class="is hj"> <em class="jy">单胞模式</em> </strong>)。</li><li id="f315" class="ka kb hi is b it kj ix kk jb kl jf km jj kn jn kf kg kh ki bi translated">使用提供预定义状态的不可变对象。(谷歌搜索<strong class="is hj"> <em class="jy">生成器模式</em> </strong>)</li></ul><p id="12e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果需要，灵活性。在我们的例子中，我们通过使<em class="jy">Product.java</em>成为final来限制继承，但是如果我们愿意，我们可以通过使用use子类来拥有一个更灵活的工厂。这是一个非常有趣的特性，如果您愿意，它可以为您的静态工厂带来一点额外的灵活性。在下面这段代码中，您将看到一个缓存对象的非常简单的实现:</strong></p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/190ba186de514c8566fa778c6edaaa97.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/0*BkKxAk7Rjvt7yySe.jpg"/></div></figure><p id="8d11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此示例中，您可以看到如何使用静态工厂方法来创建不同类型或实现类型的实例:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div><p class="ju jv et er es jw jx bd b be z dx translated">稍微复杂一点的静态工厂方法</p></figure><pre class="jo jp jq jr fd kp kq kr ks aw kt bi"><span id="cd78" class="ku kv hi kq b fi kw kx l ky kz"><em class="jy">Originally posted at: </em><a class="ae jz" href="http://javing.blogspot.com/2012/10/static-factory-methods-have-many.html" rel="noopener ugc nofollow" target="_blank">http://javing.blogspot.com/2012/10/static-factory-methods-have-many.html</a></span></pre></div></div>    
</body>
</html>