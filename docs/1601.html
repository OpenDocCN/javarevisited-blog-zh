<html>
<head>
<title>Remove Duplicates From Sorted Array (Leetcode Problem #26)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从排序后的数组中删除重复项(Leetcode问题#26)</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/remove-duplicates-from-sorted-array-leetcode-problem-26-b7be6e0c2724?source=collection_archive---------1-----------------------#2021-09-29">https://medium.com/javarevisited/remove-duplicates-from-sorted-array-leetcode-problem-26-b7be6e0c2724?source=collection_archive---------1-----------------------#2021-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="48c3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用于<a class="ae ix" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/remove-duplicates-from-sorted-array/</a>的Java解决方案</h2></div><blockquote class="iy iz ja"><p id="82ee" class="jb jc jd je b jf jg ij jh ji jj im jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">最初发表于<a class="ae ix" href="https://asyncq.com/remove-duplicates-from-sorted-array-leetcode-problem-26" rel="noopener ugc nofollow" target="_blank">https://asyncq.com</a></p></blockquote><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es jy"><img src="../Images/9fa27516294dc5416713770d28e10aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QeezhzjJcDk4jOmu"/></div></figure></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h2 id="a62e" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">理解问题</h2><ul class=""><li id="aabe" class="ll lm hi je b jf ln ji lo ky lp lc lq lg lr jx ls lt lu lv bi translated">我们已经给出了整数数组<strong class="je hj">num</strong>，它们是按升序排列的。我们需要从<strong class="je hj"> nums </strong>数组中删除重复的元素，以便<strong class="je hj"> nums </strong>只包含唯一的元素，并且元素的相对顺序应该被保留。</li><li id="3bcf" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated">我们不能使用额外的内存，需要对输入的nums数组执行所有的操作。</li><li id="fac0" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated">如果我们的i <a class="ae ix" href="https://javarevisited.blogspot.com/2012/02/how-to-check-or-detect-duplicate.html#axzz6eho0TYnf" rel="noopener ugc nofollow" target="_blank"> nput数组包含k个副本</a>，那么最初的n-k个元素应该是输出，我们可以忽略输入中n-k个以外的元素。</li><li id="5093" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated">例如</li></ul><pre class="jz ka kb kc fd mb mc md me aw mf bi"><span id="1f5a" class="kn ko hi mc b fi mg mh l mi mj">nums = [2,2,3]<br/>output = [2,3,__]</span><span id="ed11" class="kn ko hi mc b fi mk mh l mi mj">nums = [ 1,1,1,2,2,2,3,4,4]<br/>output = [1,2,3,4,______]<br/>         | N-k  |   k   |</span></pre><ul class=""><li id="6684" class="ll lm hi je b jf jg ji jj ky ml lc mm lg mn jx ls lt lu lv bi translated">法官将只比较解的n-k个元素和忽略n-k后的元素</li></ul><h2 id="a382" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">我对解决方案的思考</h2><ul class=""><li id="98e8" class="ll lm hi je b jf ln ji lo ky lp lc lq lg lr jx ls lt lu lv bi translated">我对解决方案的第一个想法是，我们<a class="ae ix" href="https://javarevisited.blogspot.com/2016/02/how-to-loop-through-array-in-java-with.html#axzz6vIXZv0pN" rel="noopener ugc nofollow" target="_blank">遍历数组</a>中的每个元素，并检查下一个元素是否与当前元素相同，如果是，那么我们可以对该元素执行从下一个元素到结束数组的移位操作。</li><li id="3157" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated">我们还记录了变量中<a class="ae ix" href="https://www.java67.com/2019/11/3-ways-to-find-repeating-number-in-array.html" rel="noopener ugc nofollow" target="_blank">重复</a>的每一次出现。</li></ul><h2 id="c7ea" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">伪代码</h2><pre class="jz ka kb kc fd mb mc md me aw mf bi"><span id="4e05" class="kn ko hi mc b fi mg mh l mi mj">1: record traversed element in count variable &amp; duplicate in match variable;<br/>2: traverse each record in loop<br/>     if( current_element == next_element)<br/>     then perform left arrayshift operation by 1<br/>     <br/>     if( count == nums.length-1 )<br/>     then we have come to the end lets break the loop<br/>     <br/>     increase the counted element</span><span id="5e05" class="kn ko hi mc b fi mk mh l mi mj">      <br/>3: Return counted_elements-duplicates+1; </span></pre><h2 id="bf4e" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">解决方法</h2><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="db5e" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结果</h2><p id="ed6b" class="pw-post-body-paragraph jb jc hi je b jf ln ij jh ji lo im jk ky mq jn jo lc mr jr js lg ms jv jw jx hb bi translated">我们的解决方案通过了所有的测试用例，并被leetcode接受，但是运行时间不是很好。运行代码几乎需要150毫秒。我认为我们可以做得更好。在我们当前的解决方案中，我们的运行时间是o(n ),因为我们在循环内部调用循环，所以我们需要改进这一点。让我们以o(n)为目标</p><h2 id="78a1" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">解决方案2</h2><ul class=""><li id="0ceb" class="ll lm hi je b jf ln ji lo ky lp lc lq lg lr jx ls lt lu lv bi translated">当我们<a class="ae ix" href="https://www.java67.com/2013/08/how-to-iterate-over-array-in-java-15.html" rel="noopener ugc nofollow" target="_blank">遍历输入数组</a>并且我们遇到一个重复时，我们将用<code class="du mt mu mv mc b">Integer.MAX_VALUE</code>替换它</li><li id="a072" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated">然后我们可以对输入数组中的元素进行排序，通过这样做，我们将保持顺序并将所有重复的元素推到输入数组的末尾。</li><li id="15d5" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated">现在我们只需要返回输入数组的长度- <a class="ae ix" href="https://javarevisited.blogspot.com/2018/04/how-to-find-k-missing-numbers-in-array-java.html#axzz6e8hmwujv" rel="noopener ugc nofollow" target="_blank">结果重复计数</a></li></ul><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="3588" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结果</h2><p id="2e7b" class="pw-post-body-paragraph jb jc hi je b jf ln ij jh ji lo im jk ky mq jn jo lc mr jr js lg ms jv jw jx hb bi translated">我们的结果通过了所有的测试用例，并且运行时间从150 ms提高到2 ms，因为运行时间复杂度从O(n)提高到O(nlogn ),因为java排序需要O(nlogn)时间。<br/>但是我观察到它只胜过Leetcode java解决方案的28%,所以我认为我还有更大的改进空间。我认为O(n)解是存在的。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/06/top-20-array-interview-questions-and-answers.html"><div class="er es mw"><img src="../Images/9cd84e805db640f04aa05b86e6d6e780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7Z7sZEuAxKMf1qGCwPAow.png"/></div></a></figure><h2 id="0f6c" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">解决方案3 </strong></h2><ul class=""><li id="59ed" class="ll lm hi je b jf ln ji lo ky lp lc lq lg lr jx ls lt lu lv bi translated">我们将我们的解从O(nlogn)优化到O(n)。在这个解决方案中，我们遍历输入数组中的每个元素，并检查下一个元素是否与当前元素不同。如果为真，那么我们把它加到输入数组中</li><li id="74f7" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated">为什么这个逻辑行得通？<br/>我们保留输入数组的第一个元素，因为第一个元素本身不能重复，然后从第二个元素开始检查，并与前一个元素进行比较。如果它与前一个相同，那么它是重复的，我们忽略它，但如果它不是重复的，那么我们将它作为下一个元素添加到输入数组中。</li><li id="a826" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated">例如</li></ul><pre class="jz ka kb kc fd mb mc md me aw mf bi"><span id="2992" class="kn ko hi mc b fi mg mh l mi mj"> nums = [1,1,2]</span><span id="ca85" class="kn ko hi mc b fi mk mh l mi mj"><strong class="mc hj">first iteration</strong><br/>   nums  = [1,1,2] -&gt; check if num[0] != num[1]<br/>   in our case num[0]=num[1] so we ignore element num[1]</span><span id="b6d7" class="kn ko hi mc b fi mk mh l mi mj">State of nums = [1,1,2]</span><span id="c079" class="kn ko hi mc b fi mk mh l mi mj"><strong class="mc hj">Second iteration</strong><br/>   nums = [1,1,2] =&gt; check if num[0]=num[2]<br/>   in our case num[0] != num[2] , hence we can assign num[1]=num[2]<br/>State of nums = [1,2,2]</span><span id="df15" class="kn ko hi mc b fi mk mh l mi mj"><strong class="mc hj">iteration finished</strong></span><span id="9ed2" class="kn ko hi mc b fi mk mh l mi mj">Since we dont care about element after nums.length-duplicate i.e 3-1 = 2 would be returned as output ,<br/>Judge will only compare 2 elements from out modified input array.</span><span id="16ea" class="kn ko hi mc b fi mk mh l mi mj">i.e nums = [1,2,_] and 3rd element will be ignored</span></pre><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="977b" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结果</h2><p id="d772" class="pw-post-body-paragraph jb jc hi je b jf ln ij jh ji lo im jk ky mq jn jo lc mr jr js lg ms jv jw jx hb bi translated">我们这次的结果提高了很多，运行时间几乎是0毫秒，我们击败了100%的java提交。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><a href="https://www.java67.com/2018/06/data-structure-and-algorithm-interview-questions-programmers.html"><div class="er es mx"><img src="../Images/a01910d2a95b2226563faa9497192fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ew_ICl95lUakZnyFklT_ug.png"/></div></a></figure><h2 id="06c5" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h2><p id="1a64" class="pw-post-body-paragraph jb jc hi je b jf ln ij jh ji lo im jk ky mq jn jo lc mr jr js lg ms jv jw jx hb bi translated">这个Leetcode问题教会我们如何思考和改进代码的运行时，这是<a class="ae ix" rel="noopener" href="/javarevisited/20-array-coding-problems-and-questions-from-programming-interviews-869b475b9121">编码面试</a>中的一个关键方面，因为面试官总是问我们如何改进现有的解决方案，无论是运行时复杂度还是空间复杂度。</p><p id="dec3" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk ky jm jn jo lc jq jr js lg ju jv jw jx hb bi translated">如果你对评论区的解决方案有什么看法，请告诉我！</p><h2 id="fd3a" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">奖金</h2><ul class=""><li id="f1ab" class="ll lm hi je b jf ln ji lo ky lp lc lq lg lr jx ls lt lu lv bi translated">如果你想升级你的编码面试游戏，你绝对应该看看这个畅销课程<a class="ae ix" href="https://click.linksynergy.com/link?id=FAaRt1BJn8w&amp;offerid=1060092.1419186&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fdata-structures-and-algorithms-deep-dive-using-java%2F" rel="noopener ugc nofollow" target="_blank"><strong class="je hj"><em class="jd"/></strong></a>(这是Java语言)</li></ul><p id="b15f" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk ky jm jn jo lc jq jr js lg ju jv jw jx hb bi translated">Leetcoding快乐！</p><blockquote class="iy iz ja"><p id="2192" class="jb jc jd je b jf jg ij jh ji jj im jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">下面我们连线上<a class="ae ix" href="https://www.linkedin.com/in/suraj-mishra-16b515a4" rel="noopener ugc nofollow" target="_blank"><strong class="je hj">LinkedIn</strong></a><strong class="je hj"><br/></strong>如果你喜欢这篇文章，请查看更多@【https://asyncq.com/】<strong class="je hj"/></p></blockquote></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="5e9e" class="my ko hi bd kp mz na nb kt nc nd ne kx io nf ip lb ir ng is lf iu nh iv lj ni bi translated">其他Leetcode问题</h1><ul class=""><li id="dfdf" class="ll lm hi je b jf ln ji lo ky lp lc lq lg lr jx ls lt lu lv bi translated"><a class="ae ix" href="https://mishrasuraj.medium.com/solve-with-me-leetcode-problem-9-1666a577bddd" rel="noopener"> Leetcode问题#9 </a></li><li id="fa3b" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated"><a class="ae ix" href="https://mishrasuraj.medium.com/solve-with-me-leetcode-problem-13-df876bd0e2b1" rel="noopener">读取代码问题#13 </a></li><li id="5f1a" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated"><a class="ae ix" href="https://mishrasuraj.medium.com/solve-with-me-leetcode-problem-20-3f43dc8a914f" rel="noopener">密码问题#20 </a></li><li id="7609" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated"><a class="ae ix" href="https://mishrasuraj.medium.com/solve-with-me-leetcode-problem-7-1d362bb441e7" rel="noopener">读取代码问题#7 </a></li><li id="33d7" class="ll lm hi je b jf lw ji lx ky ly lc lz lg ma jx ls lt lu lv bi translated"><a class="ae ix" href="https://mishrasuraj.medium.com/solve-with-me-leetcode-problem-21-f37a6fe1766c" rel="noopener">密码问题#21 </a></li></ul></div></div>    
</body>
</html>