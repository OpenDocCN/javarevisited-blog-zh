<html>
<head>
<title>Applying “Java Aspects” at Load Time: Java Instrumentation API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加载时应用“Java方面”: Java Instrumentation API</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/applying-java-aspects-at-load-time-java-instrumentation-api-232b39622b32?source=collection_archive---------3-----------------------#2022-04-18">https://medium.com/javarevisited/applying-java-aspects-at-load-time-java-instrumentation-api-232b39622b32?source=collection_archive---------3-----------------------#2022-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="54b7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用Java代理和AspectJ Weaver进行Java方面的加载时编织</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/dca802af1241620a940cf75951bb97c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*tzxEFU0LJZ2UttAZ6W2ueA.jpeg"/></div><p class="jf jg et er es jh ji bd b be z dx translated">图片来源:DZone</p></figure><p id="c386" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我打赌你在想，伙计！这个形象和标题不相称。有趣的是，这是真的，但只是对那些不能在应用程序加载时描述Java方面工作的人而言。幸运的是，这对我来说是个好兆头，因为这正是我要通过这篇文章来解读的。</p><p id="3a9e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以让我们从另一张图片开始:</p><blockquote class="kf kg kh"><p id="549b" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated"><strong class="jl hj">上图展示了使用一种工具定制编织多根棉纱的过程，该工具通过将纱线集合在一起简化了编织过程。</strong></p></blockquote><p id="2ab9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么这和我们的动机有什么相似之处呢:</p><blockquote class="kf kg kh"><p id="ef93" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated"><strong class="jl hj">在本文中，我将演示如何在一个Java应用程序中自定义编织多个类(在我们的例子中是</strong><a class="ae km" rel="noopener" href="/javarevisited/13-topics-you-should-prepare-for-your-next-spring-boot-interview-5f2993a04ff5"><strong class="jl hj"/></a><strong class="jl hj">)，其中至少有一个类是</strong> <a class="ae km" href="https://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html#:~:text=Aspect%3A%20a%20modularization%20of%20a,concern%20in%20enterprise%20Java%20applications." rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj"> Java方面</strong> </a> <strong class="jl hj">(在我们的例子中是AspectJ)，使用一个名为Java Agent的工具，通过将类集合在一起简化这个过程，允许操作编译后的Java类的字节码。</strong></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="http://www.java67.com/2018/06/5-best-courses-to-learn-spring-boot-in.html"><div class="er es kn"><img src="../Images/78fb1c665e66eacff99809a0e1a35ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x75YLts8Jw6CTgDZWgFmlA.jpeg"/></div></a></figure><h2 id="8efb" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">什么是Java方面？</h2><p id="f82d" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">当谈到面向方面编程(AOP)时，这真的是另一个世界。尽管从根本上正确理解AOP很重要，但这超出了本文的范围。但我会给出概念的症结所在。</p><blockquote class="kf kg kh"><p id="afce" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated"><strong class="jl hj"> AOP是一种编程标准，旨在通过提供一种声明性架构，从Java应用程序中抽象出模板代码(重复使用的公共代码片段),开发人员可以通过该架构抽象模板代码，并在应用程序中需要的任何地方提供模板代码。</strong></p></blockquote><p id="3585" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">方面只不过是抽象的锅炉板代码，作为类(方面类)中的方法编写。直观地说，Java方面是用Java编写的方面类。</p><h2 id="ff73" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">好吧！那么什么是Java Instrumentation API呢？</h2><p id="cc32" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">我知道有很多很棒的文章描述了这个Java API。我最近看到了Ruby Valappil 写的一个全面的例子，她展示了一个全功能的例子。</p><p id="a696" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我在这里要做的是抓住这个概念的关键，并将其类比，以符合我们的动机。</p><blockquote class="kf kg kh"><p id="8330" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">Java插装是JVM改变已经编译好的Java类的字节码的能力。</p></blockquote><p id="45e7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="ki">这个API暴露的是底层</em></strong><a class="ae km" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686"><strong class="jl hj"><em class="ki">JVM</em></strong></a><strong class="jl hj"><em class="ki">的应用。</em>T15】</strong></p><p id="9b0a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以现在我们知道我们需要将我们的Java方面应用到我们的Java应用程序中的一些地方，我们也知道Java Instrumentation API可以改变编译后的Java类的字节码。</p><p id="ff51" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好吧，我承认，现在什么都不说得通。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h2 id="7319" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">将这些点连接起来</h2><p id="745b" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">现在明显的问题是:</p><blockquote class="kf kg kh"><p id="3fc9" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated"><strong class="jl hj">“我如何利用以上两个概念:在我的Java应用程序中抽象出锅炉板代码，并在加载时在任何需要的地方应用它？”</strong></p></blockquote><p id="ff87" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们一个一个来。</p><h2 id="7b2b" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">方面是如何应用于组件的？</h2><p id="e7ec" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">在Java中，方面只能应用于方法。所以当我们说"<em class="ki">将方面应用到方法</em>时，我们的意思是<strong class="jl hj">方面方法的逻辑</strong>应该合并到<strong class="jl hj">被调用方法的逻辑</strong>中，因为它最初是被调用方法的抽象部分。</p><p id="6099" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以JVM <strong class="jl hj">通过在被调用方法之前或之后调用方面方法，用方面方法的逻辑</strong>包装被调用方法的逻辑，无论何时调用。从而保持完整性完好无损。</p><h2 id="0c55" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">为什么我首先需要在“加载时”应用它？</h2><p id="0087" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">是的，在加载时找出原因是非常重要的。就此而言，有人可能会想知道有多少种方法可以将Java方面应用到我的应用程序中。如果你有同样的问题，恭喜你！</p><p id="c79b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">基本上，将方面应用于Java应用程序有两种方式:</p><ol class=""><li id="1976" class="lx ly hi jl b jm jn jp jq js lz jw ma ka mb ke mc md me mf bi translated">运行时<strong class="jl hj"><em class="ki"/></strong>:抽象的代码片段(方面)在运行时被应用程序组件调用。在运行时，AOP通过创建类代理来工作，阅读更多关于它的内容<a class="ae km" href="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch08s08.html" rel="noopener ugc nofollow" target="_blank">在这里</a>。</li><li id="bb8d" class="lx ly hi jl b jm mg jp mh js mi jw mj ka mk ke mc md me mf bi translated"><strong class="jl hj"> <em class="ki">加载时</em> </strong>:这是指Java应用程序生命周期中所有编译好的<em class="ki">的阶段。Java类加载器正在将类</em>文件加载到JVM中。这里，我们试图将方面应用到目标类文件的字节码中。</li></ol><blockquote class="kf kg kh"><p id="4b76" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">这两种方法听起来都不错，但是使人们能够选择一种而不是另一种的警告是这个方面必须应用到的应用程序组件的性质。</p></blockquote><p id="684d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您理解Java是如何工作的，那么您可以感觉到，在运行时，如果必须应用方面的方法是不可访问的，那么方面就不能被应用。这意味着<strong class="jl hj">在运行时，只有公共方法</strong>可以应用方面，而私有方法不能。</p><p id="17f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另一方面，仅仅因为你想对一个方法应用一个方面，就把它公开，这违反了Java的核心原则，比如<em class="ki">抽象和封装</em>。自然，必须有一种方法将方面应用到私有方法上。请注意，私有方法不能从它们各自的类之外调用。</p><p id="88ce" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输入加载时间编织。</p><p id="1d3d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="ki">加载时织入(LTW)是指将方面的字节码织入另一个需要该方面的类的字节码中，而不干扰应用程序的实际Java源代码。</em> </strong></p><h2 id="ee04" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">Java工具在这方面有什么帮助？</h2><p id="b9df" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">现在已经很清楚了。我们知道，在加载时，我们需要修改应用方面的类的字节码。</p><p id="5fdf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Java Instrumentation API，就像任何其他API一样，是一组需要实现的接口。<strong class="jl hj"> Java代理是这个API的具体实现</strong>。例如<a class="ae km" href="https://mvnrepository.com/artifact/org.springframework/spring-instrument/5.3.15" rel="noopener ugc nofollow" target="_blank">弹簧工具</a>的<a class="ae km" href="https://www.javadoc.io/doc/org.springframework/spring-instrument/latest/index.html" rel="noopener ugc nofollow" target="_blank">工具<em class="ki">工具</em>工具</a>。</p><p id="c10b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个Java代理类，由这个API的实现提供，帮助我们<strong class="jl hj">截取一个类的字节码，并修改它</strong>以将方面的字节码编入其中。</p><p id="5002" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">行动吧！</strong></p><p id="e066" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">说起来容易做起来难，对吗？</p><p id="49cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以我最近在为我以前的教程系列之一构建一个演示项目时了解到了这一点，这个系列是关于使用Google OAuth 2.0来抓取邮件服务器的:</p><div class="ml mm ez fb mn mo"><a rel="noopener follow" target="_blank" href="/javarevisited/oauth-2-0-with-google-client-libraries-java-sdk-e5439accdf7a"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">带有Google客户端库的OAuth 2.0:Java SDK</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">免责声明:本实施指南旨在增强用户对概念的理解，而不是构建一个完整的…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jd mo"/></div></div></a></div><h2 id="0aa5" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">用例</h2><p id="40e2" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">在基于web的应用程序中，通常会有很多对第三方API的网络调用。我们的用例是<strong class="jl hj">在出现间歇性网络问题</strong>的情况下，自动重试对第三方API的任何API网络调用，严格来说是一次。</p><blockquote class="kf kg kh"><p id="020d" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated"><strong class="jl hj"><em class="hi"/></strong>:每次API网络调用的重试机制。<br/> <strong class="jl hj"> <em class="hi"> LTW场景</em> </strong>:所有的API网络调用都是通过应用中的私有方法进行的。</p></blockquote><h2 id="fed5" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">步骤1:创建所需的方面</h2><p id="82f3" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">我们将使用<a class="ae km" href="https://search.maven.org/artifact/org.aspectj/aspectjrt/1.9.7/jar" rel="noopener ugc nofollow" target="_blank"> AspectJ </a>库来创建一个方面类(关于AspectJ的细节不在本文讨论范围之内):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="5d93" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们使用AspectJ库中的“<em class="ki"> @Aspect </em>”注释，将一个Java类标记为一个方面。</p><p id="bf3e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过在周围使用“<em class="ki">@”注释，我们指定了方面的<a class="ae km" href="https://www.eclipse.org/aspectj/doc/released/progguide/starting-aspectj.html#advice" rel="noopener ugc nofollow" target="_blank">建议</a>。<a class="ae km" href="https://www.eclipse.org/aspectj/doc/released/progguide/starting-aspectj.html#pointcuts" rel="noopener ugc nofollow" target="_blank">切入点</a>表达式作为参数传递给该注释。基本上，我们正在做的是<strong class="jl hj">为JVM提供一种方法，以确定在我们的Java应用程序</strong>中的确切位置应用这个特定方面。</em></p><blockquote class="kf kg kh"><p id="1e67" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">在这里阅读更多关于AspectJ <a class="ae km" href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p></blockquote><p id="4c52" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个方面类抽象出了<em class="ki">重试</em>方法中的重试机制。</p><h2 id="71bb" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">步骤2:创建一个编织器</h2><p id="db5a" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">一旦我们创建了方面，我们需要必要的<strong class="jl hj">配置和工具</strong>来将它编织到我们的应用程序中所选择的地方。</p><p id="061c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们为此需要的工具是<a class="ae km" href="https://search.maven.org/artifact/org.aspectj/aspectjweaver/1.9.7/jar" rel="noopener ugc nofollow" target="_blank"> AspectJ weaver </a>。这个罐子<strong class="jl hj">能够理解哪些类要被编织</strong>。用作AspectJ weaver jar中的weaver的默认类是“<em class="ki">DefaultContextLoadTimeWeaver”。</em></p><p id="6022" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们向weaver提供该信息的方式是提供以下配置:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nd ne l"/></div></figure><blockquote class="kf kg kh"><p id="c5cd" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">务必将上述文件的名称保留为<em class="hi"> aop.xml </em>，并将其放在项目文件夹<em class="hi">src/main/resources/META-INF/</em>下</p></blockquote><h2 id="1974" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">步骤3:为您的应用程序启用加载时编织</h2><p id="f516" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">在<a class="ae km" href="https://www.java67.com/2018/05/difference-between-springbootapplication-vs-EnableAutoConfiguration-annotations-Spring-Boot.html" rel="noopener ugc nofollow" target="_blank"> spring boot应用</a>中，我们只需要在主类上添加一个注释，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="d638" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请注意“<em class="ki"> @EnableLoadTimeWeaving </em>”注释。这使得spring boot应用程序能够在src/main/resource项目文件夹下的META-INF文件夹中查找<em class="ki"> aop.xml </em>。</p><h2 id="f808" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">步骤4:使用Java代理</h2><p id="3e62" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">正如已经讨论过的，Java代理是完成编织部分的真正实体。我们需要<strong class="jl hj">为我们的应用程序提供这个Java代理</strong>(另一个Java类)，这样它<strong class="jl hj">甚至在我们的应用程序的主方法被调用</strong>之前就可用了。</p><p id="3fa7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们通过用一个特定的JVM参数启动我们的应用程序来做到这一点:</p><pre class="iy iz ja jb fd nf ng nh ni aw nj bi"><span id="2abc" class="ko kp hi ng b fi nk nl l nm nn">java -javaagent:&lt;path_to_java_agent&gt; cp &lt;path_to_our_application_jar&gt; &lt;main_class_name&gt;</span></pre><p id="9c63" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如我们前面讨论的，这个代理类是Java Instrument API附带的。所以我们需要获得API的实现。在我们的例子中，我们将使用<a class="ae km" href="https://search.maven.org/artifact/org.springframework/spring-instrument/5.3.19/jar" rel="noopener ugc nofollow" target="_blank">弹簧乐器</a>震击器。这个spring-instrument jar的路径将作为上面的“<em class="ki"> -javaagent: </em>”参数的值。</p><h2 id="9144" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">步骤5:确保aspectjweaver.jar在类路径中</h2><p id="8e6e" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">除了spring-instrument jar，我们还需要提供aspectjweaver.jar，如下所示:</p><pre class="iy iz ja jb fd nf ng nh ni aw nj bi"><span id="6a3c" class="ko kp hi ng b fi nk nl l nm nn">java -javaagent:&lt;path_to_java_agent&gt; -javaagent:&lt;path_to_aspectj-weaver_jar&gt; cp &lt;path_to_our_application_jar&gt; &lt;main_class_name&gt;</span></pre><h2 id="d9aa" class="ko kp hi bd kq kr ks kt ku kv kw kx ky js kz la lb jw lc ld le ka lf lg lh li bi translated">结论</h2><p id="63cc" class="pw-post-body-paragraph jj jk hi jl b jm lj ij jo jp lk im jr js ll ju jv jw lm jy jz ka ln kc kd ke hb bi translated">这就是我们如何在加载时使用Java Instrumentation API将Java方面编织到我们的应用程序类中。</p><p id="91f8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请注意，<a class="ae km" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25"> Spring框架</a>的<strong class="jl hj"> Spring-AOP </strong>模块，只有<strong class="jl hj">能够进行基于代理的面向方面编程</strong>。LTW是一个成熟的AspectJ支持，不需要类的代理。</p><div class="ml mm ez fb mn mo"><a rel="noopener follow" target="_blank" href="/javarevisited/21-spring-mvc-rest-interview-questions-answers-for-beginners-and-experienced-developers-21ad3d4c9b82"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">10大春季MVC + REST面试问题解答适合初学者和有经验的开发者</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">大家好。如果你正在准备Java和Spring面试或Spring认证，并经常寻找一些…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">medium.com</p></div></div><div class="mx l"><div class="no l mz na nb mx nc jd mo"/></div></div></a></div><div class="ml mm ez fb mn mo"><a rel="noopener follow" target="_blank" href="/javarevisited/top-10-rest-interview-questions-for-java-and-spring-developers-1611e3b78029"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">Java和Spring开发人员的10大REST面试问题</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">这些是Java和Spring开发者快速准备的最好的REST面试问题</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">medium.com</p></div></div><div class="mx l"><div class="np l mz na nb mx nc jd mo"/></div></div></a></div></div></div>    
</body>
</html>