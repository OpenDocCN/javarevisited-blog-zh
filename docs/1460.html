<html>
<head>
<title>Three Smart Collections in Java Everyone Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中每个人都应该知道的三个智能集合</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/three-smart-collections-in-java-everyone-should-know-ad1c32720358?source=collection_archive---------5-----------------------#2021-08-10">https://medium.com/javarevisited/three-smart-collections-in-java-everyone-should-know-ad1c32720358?source=collection_archive---------5-----------------------#2021-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f393245e0a31fe85d9f7399ac26f93a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*eg10ywR7Tpq1fHkwhKi8dQ.jpeg"/></div></figure><blockquote class="im"><p id="2aba" class="in io hi bd ip iq ir is it iu iv iw dx translated">集合是软件项目中不可或缺的结构。Java有一些神奇的集合，可以让你的项目更强大，更易于管理。</p></blockquote><p id="f13d" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt iw hb bi translated">在本文中，我将用一些例子来处理Java中的三个高级集合。它们是<strong class="iz hj">地图</strong>、<strong class="iz hj">集合</strong>和<strong class="iz hj">队列</strong>。了解这些可以节省你的时间，让你的项目更强大。</p><p id="8403" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">我将使用<a class="ae jz" rel="noopener" href="/javarevisited/7-best-courses-to-learn-intellij-idea-for-beginners-and-experienced-java-programmers-2e9aa9bb0c05"> <strong class="iz hj"> IntelliJ IDEA </strong> </a>作为IDE。</p><h2 id="7de6" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ji kl km kn jm ko kp kq jq kr ks kt ku bi translated">地图</h2><p id="d45d" class="pw-post-body-paragraph ix iy hi iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt iw hb bi translated">一个<strong class="iz hj">映射</strong>使得在一个集合中检索一个对象变得容易。它做的事情是用唯一的键来标记对象，你可以决定它们是怎样的。然后，从<em class="la">地图</em>集合中调用一个对象所要做的事情就是通过<em class="la">调用它的关键字</em>。它使<strong class="iz hj">中的时间</strong>保持不变。时间的长短并不取决于集合中有多少对象。听起来很酷！</p><p id="453e" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">让我们通过示例深入主题:</p><p id="f91f" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">我们有一个名为<code class="du lb lc ld le b">Book</code>的班级</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="161d" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">现在我要去上<code class="du lb lc ld le b">Main</code>课了:</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="fe06" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">首先，我从<code class="du lb lc ld le b">Book</code>类实例化了三个图书对象。并且我创建了名为<code class="du lb lc ld le b">books</code>的魔法收藏<em class="la">地图</em>。这里需要注意的是<em class="la">映射</em>是从类<a class="ae jz" href="https://www.java67.com/2013/02/10-examples-of-hashmap-in-java-programming-tutorial.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> HashMap </strong> </a>实例化的，因为它是一个<a class="ae jz" href="https://www.java67.com/2014/02/what-is-actual-use-of-interface-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj">接口</strong> </a>，而不是一个<a class="ae jz" href="https://www.java67.com/2017/08/difference-between-abstract-class-and-interface-in-java8.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj">类</strong> </a>。</p><pre class="lf lg lh li fd ll le lm ln aw lo bi"><span id="f139" class="ka kb hi le b fi lp lq l lr ls">Map&lt;String, Book&gt; books = new HashMap&lt;&gt;();</span></pre><p id="459a" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">上面的短语意味着我们想要创建一个<em class="la">地图集合</em>来存储<em class="la">图书</em>对象，并为它们标记一些<strong class="iz hj">字符串</strong>关键字。</p><p id="fdf3" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">然后，我用方法<code class="du lb lc ld le b">.put()</code>将这些书添加到收藏<code class="du lb lc ld le b">books</code>中，我用书名标记它们。</p><p id="e0f0" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">使用<a class="ae jz" href="https://www.java67.com/2013/08/how-to-iterate-over-array-in-java-15.html" rel="noopener ugc nofollow" target="_blank"> for循环</a>，我只想显示用于调用对象的关键字:</p><pre class="lf lg lh li fd ll le lm ln aw lo bi"><span id="09d1" class="ka kb hi le b fi lp lq l lr ls">War and Peace<br/>White Fang<br/>Crime and Punishment</span></pre><p id="694a" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">最后，在第26行，我们看到<a class="ae jz" href="https://javarevisited.blogspot.com/2011/02/how-hashmap-works-in-java.html" rel="noopener ugc nofollow" target="_blank">如何工作<em class="la">映射</em> </a>。通过使用方法<code class="du lb lc ld le b">.get()</code>并向其传递关键字(<em class="la">这里是关键字图书名称</em>)，我们可以检索整个对象。无环路，时间更少。</p><pre class="lf lg lh li fd ll le lm ln aw lo bi"><span id="0183" class="ka kb hi le b fi lp lq l lr ls">author: ‘Fyodor Dostoevsky’ title: ‘Crime and Punishment’ number of pages: ‘576’</span></pre><h2 id="dda5" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ji kl km kn jm ko kp kq jq kr ks kt ku bi translated">设置</h2><p id="784f" class="pw-post-body-paragraph ix iy hi iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt iw hb bi translated">一个<a class="ae jz" href="https://www.java67.com/2013/01/difference-between-set-list-and-map-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj">集合</strong> </a>是集合类型。它让我们避免集合中的重复项。因此，它没有<em class="la">重复值</em>。</p><p id="c2e3" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">由于是类似<strong class="iz hj"> Maps </strong>的接口，所以不能从自身实例化。它扩展了<strong class="iz hj">集合</strong>接口。因此，它提供了与其他集合数据结构相同的方法。</p><p id="8b80" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated"><em class="la">集合</em>接口有三种实现:<a class="ae jz" href="https://javarevisited.blogspot.com/2012/06/hashset-in-java-10-examples-programs.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> HashSet </strong> </a>，<a class="ae jz" href="https://javarevisited.blogspot.com/2017/04/difference-between-priorityqueue-and-treeset-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> TreeSet </strong> </a>，<a class="ae jz" href="https://javarevisited.blogspot.com/2012/11/difference-between-treeset-hashset-vs-linkedhashset-java.html#axzz6hX6XfwBD" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj">LinkedHashSet</strong></a>。(您可以点击此<a class="ae jz" href="https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html" rel="noopener ugc nofollow" target="_blank">链接</a>了解更多相关信息)</p><p id="a26c" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">让我们看看这个例子:</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="9abc" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">我从<em class="la"> HashSet，</em>实例化了一个名为<code class="du lb lc ld le b">mySet</code>的<em class="la"> Set </em>集合，并添加了四个字符串项。我循环进入<code class="du lb lc ld le b">mySet</code>来显示物品。</p><p id="f30a" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">输出:</p><pre class="lf lg lh li fd ll le lm ln aw lo bi"><span id="9b43" class="ka kb hi le b fi lp lq l lr ls">Aziz<br/>Aziz Kale</span></pre><p id="8bd4" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">是的，我加了四项。但是由于有些项目是<a class="ae jz" href="https://javarevisited.blogspot.com/2017/04/difference-between-priorityqueue-and-treeset-in-java.html" rel="noopener ugc nofollow" target="_blank">重复的</a> <code class="du lb lc ld le b">mySet</code>没有接受相同的值。所以它只有两个项目。</p><p id="ce4f" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">在第22行，为了确定，我检查了它的大小:</p><p id="f8ba" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">输出:</p><pre class="lf lg lh li fd ll le lm ln aw lo bi"><span id="b5c0" class="ka kb hi le b fi lp lq l lr ls">I have 2 items.</span></pre><h2 id="ec0d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ji kl km kn jm ko kp kq jq kr ks kt ku bi translated">行列</h2><p id="ee63" class="pw-post-body-paragraph ix iy hi iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt iw hb bi translated">有时我们需要根据规则<strong class="iz hj"> FIFO </strong>(先进先出)处理集合中的项目。就像电影院排队一样。如果你是第一个到达检查站的人，你首先进入电影院。最后来的人，最后进入。</p><p id="0bc9" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated"><a class="ae jz" href="https://javarevisited.blogspot.com/2012/12/blocking-queue-in-java-example-ArrayBlockingQueue-LinkedBlockingQueue.html" rel="noopener ugc nofollow" target="_blank">队列</a>系列也是如此。当您将一个项目添加到<strong class="iz hj">队列时，</strong>它将被添加到集合的末尾。</p><p id="45a3" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">队列也是一个接口。它们不能直接用于实例化一个类。</p><p id="5000" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">例子来了:</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="12af" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">我创建了名为<code class="du lb lc ld le b">myQueue</code>的队列，就像<a class="ae jz" href="https://javarevisited.blogspot.com/2011/09/difference-hashmap-vs-hashset-java.html#axzz6hX6XfwBD" rel="noopener ugc nofollow" target="_blank">映射和设置</a>一样，因为它也是一个接口。</p><p id="99b0" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">我通过使用方法<code class="du lb lc ld le b">.add()</code>添加项目。不同的是，我使用<code class="du lb lc ld le b">.poll()</code>方法调用这些项。在控制台上显示该项后，它将从集合中移除。我通过在控制台上打印出<code class="du lb lc ld le b">myQueue</code>的尺寸来检查这一点。</p><p id="c63d" class="pw-post-body-paragraph ix iy hi iz b ja ju jc jd je jv jg jh ji jw jk jl jm jx jo jp jq jy js jt iw hb bi translated">输出:</p><pre class="lf lg lh li fd ll le lm ln aw lo bi"><span id="dc5d" class="ka kb hi le b fi lp lq l lr ls">I am<br/>number of the rest items: 2<br/>a<br/>number of the rest items: 1<br/>interface<br/>number of the rest items: 0</span></pre><h2 id="8efc" class="ka kb hi bd kc kd ke kf kg kh ki kj kk ji kl km kn jm ko kp kq jq kr ks kt ku bi translated">结论</h2><p id="5664" class="pw-post-body-paragraph ix iy hi iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt iw hb bi translated">我们讨论了Java中三个非常有用的集合。我们现在知道它们是接口，而不是类。因为它们扩展了Collection类，所以它们具有与Collection相同的方法。但他们也有自己特殊的方法。</p></div></div>    
</body>
</html>