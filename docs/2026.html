<html>
<head>
<title>Invalid HTTP Method: PATCH</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无效的HTTP方法:补丁</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/invalid-http-method-patch-e12ba62ddd9f?source=collection_archive---------0-----------------------#2022-03-26">https://medium.com/javarevisited/invalid-http-method-patch-e12ba62ddd9f?source=collection_archive---------0-----------------------#2022-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/how-to-fix-exception-in-thread-main.html"><div class="er es if"><img src="../Images/3f88e0d44ca58a220471db7c98acbcbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*D6ZpoQM1cKsQrtjWvyRahA.png"/></div></a></figure><p id="f76c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">令人沮丧对吗？当Java告诉你一个有效的HTTP方法<strong class="io hj">补丁不是有效的</strong>时，作为一个REST API开发者，你的眉毛肌肉开始伸缩了。如果你正在读这篇文章，脸上带着笑容(我真的祈祷你会这样)，这意味着你已经对上面的Java异常动了手脚，至少一次。</p><p id="d251" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您正在构建一个<strong class="io hj"> Java客户端</strong>应用程序，而<strong class="io hj">使用了一个</strong> <a class="ae jk" rel="noopener" href="/javarevisited/top-5-books-and-courses-to-learn-restful-web-services-in-java-using-spring-mvc-and-spring-boot-79ec4b351d12"> <strong class="io hj"> REST </strong> ful API </a>，那么您可能会经常遇到这种异常。这是因为Java客户端将使用<a class="ae jk" href="https://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"><em class="jl">HttpURLConnection</em></strong></a>类来表示到后端API的连接，问题就在这里。</p><figure class="jn jo jp jq fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-restful-web-services-with-spring-courses-for-experienced-java-programmers.html"><div class="er es jm"><img src="../Images/3624c9fb3d8ed174ec7e1ff8cac283b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*ny8JocpnsKfW49EY9oixEw.png"/></div></a><p class="jr js et er es jt ju bd b be z dx translated">连接到HTTP URL的简单方法</p></figure><p id="9530" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你仍然对补丁http方法和PUT http方法到底有什么不同感到困惑，我想我们只需要回忆一下Jason Byrne在他的一篇文章中所说的区别。在REST的世界中，补丁请求的目标是<strong class="io hj">更新现有资源的一个或多个属性</strong>，而<a class="ae jk" href="https://javarevisited.blogspot.com/2016/10/difference-between-put-and-post-in-restful-web-service.html" rel="noopener ugc nofollow" target="_blank"> PUT请求</a>的目标是做同样的事情，但只是做了一点小小的改动，如果没有找到，它可以<strong class="io hj">创建一个新资源</strong>。</p><h2 id="b97c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki kj kk jb kl km kn jf ko kp kq kr bi translated">不开玩笑！</h2><p id="71d2" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">是的，我不是在开玩笑。虽然PATCH是一个完全有效的HTTP请求方法，但是<a class="ae jk" rel="noopener" href="/javarevisited/10-best-places-to-learn-java-online-for-free-ce5e713ab5b2"> Java </a>拒绝识别它。</p><p id="b8ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在写上一篇文章时就经历过这种情况，我构建了一个RESTful服务来演示向Google OAuth 2.0的迁移。</p><div class="kx ky ez fb kz la"><a rel="noopener follow" target="_blank" href="/@hrishabhpurohit/oauth-2-0-with-google-client-libraries-java-sdk-e5439accdf7a"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hj fi z dy lf ea eb lg ed ef hh bi translated">带有Google客户端库的OAuth 2.0:Java SDK</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">免责声明:本实施指南旨在增强用户对概念的理解，而不是构建一个完整的…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">medium.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo ik la"/></div></div></a></div><p id="1526" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我碰巧有一个用例的补丁方法，并且正在使用我的一个Java HTTP客户端测试它。</p><p id="685e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在执行该行时引发了异常:</p><figure class="jn jo jp jq fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/f823b59ebe69ad56ec2866fab69a7f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*yOjmTb33iLtoK3G7ghMGtQ.png"/></div></figure><p id="d47d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" href="https://www.java67.com/2019/03/7-examples-of-httpurlconnection-in-java.html" rel="noopener ugc nofollow" target="_blank"> HttpURLConnection </a>类不识别这个http方法。</p><h2 id="ac27" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki kj kk jb kl km kn jf ko kp kq kr bi translated">好，所以我不能通过JAVA发送补丁请求？</h2><p id="e8fc" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">在您下结论之前，让我向您保证，确实有一种方法可以通过Java发送补丁http请求。但是，不是直截了当的。</p><blockquote class="lq lr ls"><p id="2120" class="im in jl io b ip iq ir is it iu iv iw lt iy iz ja lu jc jd je lv jg jh ji jj hb bi translated">因此，我们在这里遇到的是<strong class="io hj">无法让我们的http客户端</strong>(构建在Java上)向<strong class="io hj">发送请求元数据中的特定HTTP方法类型</strong>，以便服务器能够将请求导航到其对应的处理程序方法。</p></blockquote><h2 id="ec3d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki kj kk jb kl km kn jf ko kp kq kr bi translated">我们来试试糊弄Java吧！</h2><p id="f801" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">这会很有趣的，对吧？</p><p id="f201" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虽然不允许我们在HttpURLConnection类中将“PATCH”设置为http请求方法，但是我们可以设置任何我们想要的请求头。</p><p id="2ca9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我的意思是我们可以使用http协议提供的<strong class="io hj">请求头</strong>，它在内部<strong class="io hj">覆盖了在<a class="ae jk" rel="noopener" href="/javarevisited/how-to-send-http-get-request-and-parse-json-data-into-string-using-java-3c0cf7eeebbc"> HttpURLConnection </a>对象中设置的HTTP方法类型</strong>。</p><figure class="jn jo jp jq fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/e4bfd96cd67438e846e3638b20693624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*M5QY-6T6YFsui6JEib3q_Q.png"/></div></figure><p id="2075" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">知道我们是怎么骗过Java的了吧？</p><p id="a592" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们最初将http方法类型设置为“POST”，由HttpURLConnection类识别，并将请求头“<strong class="io hj"><em class="jl">X-HTTP-Method-Override</em></strong>”设置为值“PATCH”。这很管用。</p><h1 id="3169" class="lx jy hi bd jz ly lz ma kd mb mc md kh me mf mg kk mh mi mj kn mk ml mm kq mn bi translated">结论</h1><p id="82d9" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">在本文中，我们观察到了一种通过Java http客户端使用PATCH REST API方法的方式。</p><p id="42fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">继续深挖！</p></div></div>    
</body>
</html>