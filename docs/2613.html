<html>
<head>
<title>Do You Know the Tight and Loose Coupling in the Oop?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你知道Oop中的紧耦合和松耦合吗？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/do-you-know-the-tight-and-loose-coupling-in-the-oop-latest-b03f8e600115?source=collection_archive---------4-----------------------#2022-12-16">https://medium.com/javarevisited/do-you-know-the-tight-and-loose-coupling-in-the-oop-latest-b03f8e600115?source=collection_archive---------4-----------------------#2022-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="d30e" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">面向对象编程</h2><div class=""/><div class=""><h2 id="8a33" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">你的下一个面试问题可能是关于面向对象的范例。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/05/object-oriented-programming-questions-answers.html"><div class="er es jg"><img src="../Images/c066e390f8cbb81dd77a10fe673fb89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1vh_dVipi9zLsY6dU7YDg.png"/></div></a><p class="jo jp et er es jq jr bd b be z dx translated">紧耦合和松耦合</p></figure><p id="50c8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在学习java编程时，您可能会遇到松耦合和紧耦合的概念。当我在网上搜索java面试问题时，我发现这个问题很常见。他们中的许多人试图用自己的方式用不同的例子来解释。但是网上写的答案之间的差异程度表明了为什么这是一个很难理解的概念，但是我将会讨论它，并且尝试用最简单的语言来解释它。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="d2db" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">什么是紧耦合和松耦合？</h1><p id="5fba" class="pw-post-body-paragraph js jt hi ju b jv ln is jx jy lo iv ka kb lp kd ke kf lq kh ki kj lr kl km kn hb bi translated"><strong class="ju hs">紧耦合</strong>意味着一组类高度依赖于彼此。当一个类承担了太多的责任，或者一个问题分散在许多类中而没有自己的类时，就会出现这种情况。</p><p id="16c1" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">松散耦合</strong>是通过促进单一责任和关注点分离的设计来实现的。松散耦合的类可以独立于其他类被使用和测试。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="0653" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">如何实现松耦合？</h1><p id="6be5" class="pw-post-body-paragraph js jt hi ju b jv ln is jx jy lo iv ka kb lp kd ke kf lq kh ki kj lr kl km kn hb bi translated">接口是用于松耦合或解耦的强大工具。类可以通过接口而不是其他具体的类进行通信。</p><p id="282f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">让我们看一个java编程中的例子，看看我们如何实现松耦合。</p><h2 id="9453" class="lt kw hi bd kx lu lv lw lb lx ly lz lf kb ma mb lh kf mc md lj kj me mf ll ho bi translated">1.紧密耦合:</h2><p id="4442" class="pw-post-body-paragraph js jt hi ju b jv ln is jx jy lo iv ka kb lp kd ke kf lq kh ki kj lr kl km kn hb bi translated">紧密耦合的代码依赖于具体的实现。如果我们需要一个字符串列表，我们可以这样做:</p><pre class="jh ji jj jk fd mg mh mi bn mj mk bi"><span id="88fb" class="ml kw hi mh b be mm mn l mo mp">ArrayList&lt;String&gt; myList = new ArrayList&lt;String&gt;();</span></pre><p id="e513" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">那么这个实现依赖于<strong class="ju hs"> ArrayList </strong>实现。</p><h2 id="f654" class="lt kw hi bd kx lu lv lw lb lx ly lz lf kb ma mb lh kf mc md lj kj me mf ll ho bi translated">2.松散耦合:</h2><p id="f2ba" class="pw-post-body-paragraph js jt hi ju b jv ln is jx jy lo iv ka kb lp kd ke kf lq kh ki kj lr kl km kn hb bi translated">如果我们希望将实现更改为松散耦合的代码，那么我们将引用设置为接口(或其他抽象)类型。</p><pre class="jh ji jj jk fd mg mh mi bn mj mk bi"><span id="bf52" class="ml kw hi mh b be mm mn l mo mp">List&lt;String&gt; myList = new ArrayList&lt;String&gt;();</span></pre></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="1348" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">为什么松耦合的代码比紧耦合的好？</h1><pre class="jh ji jj jk fd mg mh mi bn mj mk bi"><span id="d972" class="ml kw hi mh b be mm mn l mo mp">List&lt;String&gt; myList = new ArrayList&lt;String&gt;();</span></pre><p id="b682" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">上面松散耦合的实现阻止我们使用特定于<strong class="ju hs"> ArrayList </strong>实现的<code class="du mq mr ms mh b"><strong class="ju hs">myList</strong></code>调用任何方法。我们仅限于那些在<strong class="ju hs">列表</strong>接口中定义的方法。这意味着<code class="du mq mr ms mh b"><strong class="ju hs">myList</strong></code> <strong class="ju hs"> </strong>只能访问<strong class="ju hs"> List </strong>接口的变量和方法，而不能访问<a class="ae mt" href="https://javarevisited.blogspot.com/2015/09/how-to-reset-arraylist-in-java-clear-vs-removeAll-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> ArrayList </strong>类中定义的任何附加方法。</a></p><p id="be84" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们后来决定我们真的需要一个<a class="ae mt" href="https://www.java67.com/2016/02/how-to-sort-linkedlist-in-java-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> LinkedList </strong> </a>而不是<strong class="ju hs"> ArrayList </strong>，那么我们只需要在一个地方修改代码，在那里我们已经创建了<strong class="ju hs"> new </strong> <strong class="ju hs"> List </strong>，而不是在我们已经调用了<strong class="ju hs"> ArrayList </strong>方法的100个地方。</p><p id="e64f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">当然，我们可以使用第一个声明实例化一个<strong class="ju hs"> ArrayList </strong>并限制自己不使用任何不属于<strong class="ju hs"> List </strong>接口的方法，但是使用第二个声明使编译器保持诚实。</p><h1 id="eeb6" class="kv kw hi bd kx ky mu la lb lc mv le lf ix mw iy lh ja mx jb lj jd my je ll lm bi translated">现在让我们看一个实际的例子来更好地理解它:</h1><h2 id="5347" class="lt kw hi bd kx lu lv lw lb lx ly lz lf kb ma mb lh kf mc md lj kj me mf ll ho bi translated">IMachine接口:</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mz na l"/></div><p class="jo jp et er es jq jr bd b be z dx translated">作为接口的机器</p></figure><h2 id="00d7" class="lt kw hi bd kx lu lv lw lb lx ly lz lf kb ma mb lh kf mc md lj kj me mf ll ho bi translated">实现IMachine的Machine类:</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mz na l"/></div><p class="jo jp et er es jq jr bd b be z dx translated">Machine类实现IMachine接口</p></figure><h2 id="822c" class="lt kw hi bd kx lu lv lw lb lx ly lz lf kb ma mb lh kf mc md lj kj me mf ll ho bi translated">驱动程序类别:</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mz na l"/></div><p class="jo jp et er es jq jr bd b be z dx translated">解释松耦合和紧耦合的驱动程序类</p></figure><p id="07c6" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上面的例子中，创建了两个引用，一个使用<strong class="ju hs"> Machine </strong>类，另一个使用<strong class="ju hs"> IMachine </strong>接口。</p><pre class="jh ji jj jk fd mg mh mi bn mj mk bi"><span id="3d54" class="ml kw hi mh b be mm mn l mo mp">//Tight coupling<br/>Machine machine = new Machine();</span></pre><p id="4932" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">上面的<strong class="ju hs">机器</strong>引用具有<strong class="ju hs">机器</strong>类的所有方法的可见性，并且可以访问它们。</p><pre class="jh ji jj jk fd mg mh mi bn mj mk bi"><span id="6918" class="ml kw hi mh b be mm mn l mo mp">//Loose coupling<br/>IMachine iMachine = new Machine();</span></pre><p id="043b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">鉴于<strong class="ju hs"> IMachine </strong> reference对<strong class="ju hs"> IMachine </strong>接口的所有方法可见，并且可以访问它们，但不能访问<strong class="ju hs"> Machine </strong>类中编写的附加方法。</p><p id="de06" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">使用<strong class="ju hs"> IMachine </strong>创建引用变量的好处是，如果在开发过程的后期，<strong class="ju hs"> IMachine </strong>引用可以指向其他一些实现<strong class="ju hs"> IMachine </strong>接口的具体类。</p><p id="b250" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">另外，请注意，我们只需要在引用变量被分配给对象的一个地方进行更改，而不是在引用变量调用应用程序中数百个方法的每个地方进行更改。因此，松散耦合有助于维护代码库，并允许在开发过程中将来需要时进行更改。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="5f25" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><em class="ls">本文到此为止。希望你喜欢这篇文章。</em></p><h1 id="faf2" class="kv kw hi bd kx ky mu la lb lc mv le lf ix mw iy lh ja mx jb lj jd my je ll lm bi translated">类似内容可以关注<a class="nb nc ge" href="https://medium.com/u/2c3b611409dc?source=post_page-----b03f8e600115--------------------------------" rel="noopener" target="_blank">维克拉姆古普塔</a>。</h1></div></div>    
</body>
</html>