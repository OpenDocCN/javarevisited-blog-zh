<html>
<head>
<title>Thread Interference in Java Multi-Threading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java多线程中的线程干扰</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/thread-interference-in-java-multi-threading-latest-534746003441?source=collection_archive---------4-----------------------#2022-12-29">https://medium.com/javarevisited/thread-interference-in-java-multi-threading-latest-534746003441?source=collection_archive---------4-----------------------#2022-12-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="ccae" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">JAVA多线程——JAVA中的线程干扰</h2><div class=""/><div class=""><h2 id="e1cc" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">通过示例了解竞争条件、线程堆栈和堆内存。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/445328e1d3d41356e1a382199e958fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AktzTtx2ZOH1kb8yv7Piw.jpeg"/></div></div><p class="js jt et er es ju jv bd b be z dx translated">在<a class="ae jw" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jw" href="https://unsplash.com/@max_duz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>拍照</p></figure><p id="55aa" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">线程干扰或竞态条件是多线程面试中被问得最多的问题之一。当您开始学习多线程时，您的重点应该是基础知识，而不是难懂的概念。在了解任何东西之前，你必须知道如何使用<strong class="jz hs">线程</strong>类、<strong class="jz hs">可运行</strong>接口和<strong class="jz hs">匿名类线程</strong>来创建线程。</p><p id="8939" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">一旦你清楚了如何创建和运行自己的线程，你就可以继续学习一些更复杂的概念，比如<strong class="jz hs"> <em class="kt">线程干扰、死锁、线程同步、锁定机制、ArrayBlockingQueue、线程饥饿等</em> </strong> <em class="kt">。</em></p><p id="3236" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">通过这篇文章，我将解释一些重要的概念，如<em class="kt">线程堆栈、堆内存</em>，然后借助例子解释<em class="kt">线程干扰</em>。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h2 id="bd9e" class="lb lc hi bd ld le lf lg lh li lj lk ll kg lm ln lo kk lp lq lr ko ls lt lu ho bi translated">什么是线程栈和堆内存？</h2><p id="d050" class="pw-post-body-paragraph jx jy hi jz b ka lv is kc kd lw iv kf kg lx ki kj kk ly km kn ko lz kq kr ks hb bi translated">当我们运行一个java应用程序时，操作系统会给这个应用程序分配一些堆内存来存储和执行程序。这个应用程序在执行时被称为<strong class="jz hs">进程</strong>。现在，在同一个应用程序中，我们可以有多个线程，每个线程可以执行不同的任务，如IO、数据库操作等。</p><p id="c44a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">同一个进程(应用程序)的所有线程共享这个进程的堆内存。另一方面，该应用程序的每个线程都有自己的名为<strong class="jz hs"> <em class="kt">线程堆栈</em> </strong>的内存，并在其中存储<strong class="jz hs"> <em class="kt">局部变量</em> </strong>。</p><blockquote class="ma mb mc"><p id="ca9e" class="jx jy kt jz b ka kb is kc kd ke iv kf md kh ki kj me kl km kn mf kp kq kr ks hb bi translated">请注意，当我们创建一个类的对象时，该对象存储在堆中，而不是在线程堆栈中。线程堆栈是分配给每个线程的私有内存，只存储局部变量。</p></blockquote><p id="ada1" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我已经写了一篇关于过程和线程的详细文章。如果你还没有看完这篇文章，我建议你看一遍。</p><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/javarevisited/process-and-thread-context-switching-do-you-know-the-difference-updated-8fd93877dff6"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hs fi z dy mo ea eb mp ed ef hr bi translated">进程和线程上下文切换，你知道区别吗？</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">一篇关于进程和线程、它们的区别以及上下文切换的文章。</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx jq mj"/></div></div></a></div></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h2 id="3373" class="lb lc hi bd ld le lf lg lh li lj lk ll kg lm ln lo kk lp lq lr ko ls lt lu ho bi translated">进程及其多线程:</h2><p id="c0d3" class="pw-post-body-paragraph jx jy hi jz b ka lv is kc kd lw iv kf kg lx ki kj kk ly km kn ko lz kq kr ks hb bi translated">现在让我们利用到目前为止所学的知识。下面我写了一个java程序(应用程序),因此当它正在执行时，我们可以称它为<strong class="jz hs">进程</strong>。这个进程将被分配一些堆内存。在同一个应用程序中，我创建了两个最终调用<strong class="jz hs"> run </strong>方法的线程。此外，每个线程通过run方法调用另一个类的<code class="du my mz na nb b"><strong class="jz hs">doCountDown()</strong></code> <strong class="jz hs"> </strong>方法，因为每个线程有一个字段<code class="du my mz na nb b"><strong class="jz hs">countDown</strong></code>。</p><p id="7b32" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">注意，每个线程都有自己的线程堆栈来存储<code class="du my mz na nb b"><strong class="jz hs">doCountDown()</strong></code> <strong class="jz hs"> </strong>方法的任何局部变量。</p><p id="b7c9" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在浏览一遍程序。你能试着预测或猜测可能的产量吗？</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nc nd l"/></div><p class="js jt et er es ju jv bd b be z dx translated">当变量“I”不是共享的(它在线程堆栈上)时的线程干扰/竞争情况</p></figure><p id="2cf8" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">你得到输出了吗？如果没有，也没关系。</p><p id="ac9c" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">您可以查看下面的输出。</p><h2 id="a358" class="lb lc hi bd ld le lf lg lh li lj lk ll kg lm ln lo kk lp lq lr ko ls lt lu ho bi translated">输出:</h2><pre class="jh ji jj jk fd ne nb nf bn ng nh bi"><span id="9ae8" class="ni lc hi nb b be nj nk l nl nm">Thread-1 i = 5<br/>Thread-2 i = 5<br/>Thread-2 i = 4<br/>Thread-2 i = 3<br/>Thread-2 i = 2<br/>Thread-2 i = 1<br/>Thread-1 i = 4<br/>Thread-1 i = 3<br/>Thread-1 i = 2<br/>Thread-1 i = 1</span></pre><p id="eaad" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在我来解释一下为什么每个数字要打印两次，为什么不维持顺序。</p><ol class=""><li id="383e" class="nn no hi jz b ka kb kd ke kg np kk nq ko nr ks ns nt nu nv bi translated">好了，现在你已经知道有两个线程，这两个线程都调用了<code class="du my mz na nb b"><strong class="jz hs"><em class="kt">run()</em></strong></code> <strong class="jz hs"> <em class="kt"> </em> </strong>方法，然后调用了<code class="du my mz na nb b"><strong class="jz hs"><em class="kt">doCountDown()</em></strong></code> <em class="kt"> </em>方法。在<code class="du my mz na nb b"><strong class="jz hs"><em class="kt">doCountDown()</em></strong></code> <strong class="jz hs"> <em class="kt"> </em> </strong>中有一个局部变量<strong class="jz hs"><em class="kt">'</em></strong><code class="du my mz na nb b"><strong class="jz hs"><em class="kt">i</em></strong></code><strong class="jz hs"><em class="kt">'</em></strong>'，它是由每个线程存储在线程栈中，而不是堆中。现在两个线程都有自己的<em class="kt"/><em class="kt"/>变量<strong class="jz hs"><em class="kt">'</em></strong><code class="du my mz na nb b"><strong class="jz hs"><em class="kt">i</em></strong></code><strong class="jz hs"><em class="kt">'</em></strong>的副本，因此每个数字都打印两次，因为循环执行了两次。</li><li id="b4f6" class="nn no hi jz b ka nw kd nx kg ny kk nz ko oa ks ns nt nu nv bi translated">因为这两个线程不停地一个接一个地切换，所以没有保持顺序。现在让我们假设最初，两个线程都有一个值<strong class="jz hs"><em class="kt">'</em></strong><code class="du my mz na nb b"><strong class="jz hs"><em class="kt">i</em></strong></code><strong class="jz hs"><em class="kt">'</em></strong><em class="kt"/>作为<strong class="jz hs"> <em class="kt"> 5 </em> </strong>。现在，第一个线程将该值打印为<code class="du my mz na nb b"><strong class="jz hs">[5]</strong></code>，并且发生了上下文切换，然后第二个线程也打印其<strong class="jz hs"> <em class="kt"> </em> </strong>自身<strong class="jz hs"><em class="kt">'</em></strong><code class="du my mz na nb b"><strong class="jz hs"><em class="kt">i</em></strong></code><strong class="jz hs"><em class="kt">'</em></strong>的值作为<code class="du my mz na nb b"><strong class="jz hs">[5]</strong></code>，并且通过递减<strong class="jz hs"><em class="kt">'<strong class="jz hs"><em class="kt">'</em></strong><code class="du my mz na nb b"><strong class="jz hs"><em class="kt">i</em></strong></code><strong class="jz hs"><em class="kt">'</em></strong>的值来保持打印一旦第二个线程完成了它的执行，第一个线程就开始打印它自己的<strong class="jz hs"><em class="kt">’</em></strong><code class="du my mz na nb b"><strong class="jz hs"><em class="kt">i</em></strong></code><strong class="jz hs"><em class="kt">’</em></strong>的值，方法是将它递减→ <code class="du my mz na nb b"><strong class="jz hs">[4,3,2,1]</strong></code>。</em></strong></li></ol><blockquote class="ob"><p id="2f53" class="oc od hi bd oe of og oh oi oj ok ks dx translated">一个非常重要的注意事项:每次运行程序时，我都会得到不同的输出，因为上下文切换可以发生在doCountDown方法中的任何地方。</p></blockquote><h1 id="ec40" class="ol lc hi bd ld om on oo lh op oq or ll ix os iy lo ja ot jb lr jd ou je lu ov bi translated">可能发生上下文切换的点有:</h1><ol class=""><li id="d774" class="nn no hi jz b ka lv kd lw kg ow kk ox ko oy ks ns nt nu nv bi translated"><strong class="jz hs">for循环中的初始化</strong></li><li id="6ae7" class="nn no hi jz b ka nw kd nx kg ny kk nz ko oa ks ns nt nu nv bi translated"><strong class="jz hs">循环中的条件检查</strong></li><li id="245c" class="nn no hi jz b ka nw kd nx kg ny kk nz ko oa ks ns nt nu nv bi translated"><strong class="jz hs">减量操作</strong></li><li id="584b" class="nn no hi jz b ka nw kd nx kg ny kk nz ko oa ks ns nt nu nv bi translated">最后，打印行语句，因为这一行包含一个<strong class="jz hs">字符串连接</strong></li></ol><p id="0934" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这是这两个线程之间可能发生上下文切换的4个点，并且不保证每次执行时的顺序相同。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="dd76" class="ol lc hi bd ld om oz oo lh op pa or ll ix pb iy lo ja pc jb lr jd pd je lu ov bi translated">如果我们把局部变量‘I’改成倒计时对象的一个字段变量会怎么样？</h1><p id="9ef3" class="pw-post-body-paragraph jx jy hi jz b ka lv is kc kd lw iv kf kg lx ki kj kk ly km kn ko lz kq kr ks hb bi translated">检查下面的程序，我刚刚把局部变量' I '改成了一个字段变量，现在这一次试着预测/猜测输出。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nc nd l"/></div><p class="js jt et er es ju jv bd b be z dx translated">共享变量“I”时的线程干扰/竞争情况(它在堆上)</p></figure><p id="d7fa" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">得到输出了吗？不，没关系。只需查看下面可能的输出之一。</p><h2 id="9e95" class="lb lc hi bd ld le lf lg lh li lj lk ll kg lm ln lo kk lp lq lr ko ls lt lu ho bi translated">输出:</h2><pre class="jh ji jj jk fd ne nb nf bn ng nh bi"><span id="bb9f" class="ni lc hi nb b be nj nk l nl nm">Thread-1 i = 5<br/>Thread-2 i = 5<br/>Thread-1 i = 4<br/>Thread-2 i = 3<br/>Thread-2 i = 1<br/>Thread-1 i = 2</span></pre><p id="380a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在上面的输出中，<code class="du my mz na nb b"><strong class="jz hs">thread1</strong></code>和<code class="du my mz na nb b"><strong class="jz hs">thread2</strong></code>都从堆中读取整数<strong class="jz hs"><em class="kt">‘I’</em></strong>的值作为<strong class="jz hs"> 5 </strong>。<code class="du my mz na nb b"><strong class="jz hs">thread1</strong></code>执行打印语句并打印5，然后上下文切换到<code class="du my mz na nb b"><strong class="jz hs">thread2</strong></code>。然后<code class="du my mz na nb b"><strong class="jz hs">thread2</strong></code>执行print语句，打印5，并从5减为4。现在，上下文再次切换回<code class="du my mz na nb b"><strong class="jz hs">thread1</strong></code>，它打印4并将其递减到3，然后上下文切换到<code class="du my mz na nb b"><strong class="jz hs">thread2</strong></code>。然后<code class="du my mz na nb b"><strong class="jz hs">thread2 </strong></code>打印3并将其递减为2，再次上下文切换到<code class="du my mz na nb b"><strong class="jz hs">thread1</strong></code>，然后<code class="du my mz na nb b"><strong class="jz hs">thread1</strong></code>准备打印2的打印语句，但是在上下文切换到<code class="du my mz na nb b"><strong class="jz hs">thread2</strong></code>之前，它将【T19’‘I’递减为1并打印1，最后上下文切换到已经准备好打印语句的<code class="du my mz na nb b"><strong class="jz hs">thread1</strong></code>，以将<strong class="jz hs">‘I’</strong>的值打印为2。因此输出<code class="du my mz na nb b"><strong class="jz hs"> [5,5,4,3,1,2]</strong></code></p><h2 id="36d8" class="lb lc hi bd ld le lf lg lh li lj lk ll kg lm ln lo kk lp lq lr ko ls lt lu ho bi translated">另一个可能的输出:</h2><pre class="jh ji jj jk fd ne nb nf bn ng nh bi"><span id="b84a" class="ni lc hi nb b be nj nk l nl nm">Thread-2 i = 5<br/>Thread-2 i = 4<br/>Thread-2 i = 3<br/>Thread-2 i = 2<br/>Thread-2 i = 1<br/>Thread-1 i = 0</span></pre><p id="b386" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">对于上面的输出，我建议您像我在第一个输出中那样跟踪它。另外，请注意，该程序的每次执行都会导致不同的输出，并且不保证任何固定的输出。这是因为这两个线程之间发生了线程上下文切换。</p><blockquote class="ob"><p id="ff83" class="oc od hi bd oe of pe pf pg ph pi ks dx translated">这个概念也被称为竞争条件。</p></blockquote></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="750a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs"> <em class="kt">目前就这些。我希望这篇文章能澄清你对线程干扰和竞争条件的概念。</em> </strong></p><p id="9f3c" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs"> <em class="kt">你可以在这里</em> </strong>  <strong class="jz hs"> <em class="kt">跟我联系</em> </strong> <a class="ae jw" rel="noopener" href="/@basecs101"> <strong class="jz hs"> <em class="kt">。</em> </strong></a></p></div></div>    
</body>
</html>