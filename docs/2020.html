<html>
<head>
<title>Debugging Java Equals and Hashcode Performance in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在生产中调试Java Equals和Hashcode性能</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/debugging-java-equals-and-hashcode-performance-in-production-2901df4fcd3?source=collection_archive---------1-----------------------#2022-03-23">https://medium.com/javarevisited/debugging-java-equals-and-hashcode-performance-in-production-2901df4fcd3?source=collection_archive---------1-----------------------#2022-03-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3c99cb785d02267b5a7eeee63cd19b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ddqECfVaWX0ufvixqBkXjg.jpeg"/></div></div></figure><p id="72dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在本文的<a class="ae jo" href="https://talktotheduck.dev/hashcode-and-equals-debugging-performance" rel="noopener ugc nofollow" target="_blank">中写了很多关于equals方法和哈希代码的性能指标。这些方法中有许多细微差别会导致性能问题。问题是，其中一些东西可以隐藏得很好。</a></p><p id="38b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总结一下核心问题:hashcode方法是java集合API的核心。具体来说，就是哈希表的性能(具体来说就是映射接口<a class="ae jo" href="https://www.java67.com/2012/08/5-difference-between-hashtable-hashmap-Java-collection.html" rel="noopener ugc nofollow" target="_blank">哈希表</a>)。equals方法也是如此。如果我们有比字符串对象或原语更复杂的东西，开销会迅速增加。</p><p id="3c0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但主要问题是细微的行为。本文给出的例子是Java SE URL类的例子。该类的API指定这些不同对象的以下比较将评估为真:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b0a0" class="jy jz hi ju b fi ka kb l kc kd">new URL("http://127.0.0.1/").equals(new URL("http://localhost/")); </span><span id="396d" class="jy jz hi ju b fi ke kb l kc kd">new URL("http://127.0.0.1/").hashcode() == new URL("http://localhost/").hashcode();</span></pre><p id="5f74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是规范中的一个bug。请注意，这适用于所有域，因此查找是执行散列或等于所必需的。那可能非常昂贵。</p><p id="fcdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提示:</strong>equals/hashcode的性能对于键值容器的使用必须非常高效，比如<a class="ae jo" href="https://javarevisited.blogspot.com/2015/08/difference-between-HashMap-vs-TreeMap-vs-LinkedHashMap-Java.html" rel="noopener ugc nofollow" target="_blank"> maps </a>和其他基于散列的集合</p><p id="5050" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些方法有很多陷阱。其中一些只有在一定比例下才看得见。例如，一位朋友向我展示了一种比较对象的方法，它对一系列潜在值具有外部依赖性。这在本地表现很好，但是在生产中却很慢，因为列表中有更多的元素。</p><p id="68f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何判断一个哈希函数在生产中是否很慢？</p><p id="a4b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你怎么知道这是哈希函数的错呢？</p><h1 id="97c7" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">衡量绩效</h1><p id="ba28" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">对于大多数意图和目的，我们不知道问题出在equals方法或哈希代码中。我们需要缩小问题的范围。很可能一个服务器进程比我们预期的要长，并可能在APM上显示出来。</p><p id="eae0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在APM上看到的是web服务的缓慢性能。我们可以通过使用Lightrun提供的<a class="ae jo" href="https://docs.lightrun.com/actions/#metrics" rel="noopener ugc nofollow" target="_blank">度量工具</a>来缩小范围。</p><p id="7025" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:在我们继续之前，我假设您已经熟悉了Lightrun的基础知识并安装了它。如果没有，请查看<a class="ae jo" href="https://docs.lightrun.com/" rel="noopener ugc nofollow" target="_blank">这篇介绍</a>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/05/top-5-java-courses-for-beginners-to-learn-online.html"><div class="er es lh"><img src="../Images/de4d0f0930e182f803a1faa9252ea0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qkrnV_jCcFRLPvHW"/></div></a></figure><p id="0cd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Lightrun能够设置多种度量类型:</p><ul class=""><li id="d50b" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">一种计数器，对到达特定代码行的次数进行计数</li><li id="1401" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">时间测量(tictoc ),用于测量特定代码块的性能</li><li id="9ef7" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">方法持续时间—与完整方法的tictoc相同</li><li id="a60a" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">自定义度量-基于自定义表达式的测量</li></ul><p id="591b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，您可以在所有指标上使用条件。如果性能开销影响了特定用户，您可以将测量限制为仅针对该特定用户。</p><p id="0b34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以使用这些工具来缩小性能问题的范围并找到根本原因，例如，在这里我可以检查方法中的这两行是否有问题:</p><figure class="jp jq jr js fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/09/top-5-courses-to-learn-intellij-idea-java-and-android-development.html"><div class="er es lh"><img src="../Images/e5ea1262d8bcce80ef78a5af1fdd138a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ekDBa10bSnpY6T75"/></div></a></figure><p id="dd71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加tictoc为我们提供了如下定期打印输出:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="0140" class="jy jz hi ju b fi ka kb l kc kd">INFO: 13 Feb 2022, 14:50:06 TicToc Stats::<br/>{<br/>  "VetListBlock" : {"breakpointId" : "fc27d745-b394-400e-83ee-70d7644272f3","count" : 33,"max" : 32,"mean" : 4.971277332041485,"min" : 1,"name" : "VetListBlock","stddev" : 5.908043099655046,"timestamp" : 1644756606939  }<br/>}</span></pre><p id="e60e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以查看这些打印输出，了解这些行产生的开销。您还可以使用计数器来查看我们调用方法的频率。</p><p id="4055" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>您可以将这些结果通过管道传输到<a class="ae jo" href="https://docs.lightrun.com/integrations/prometheus/" rel="noopener ugc nofollow" target="_blank">普罗米修斯/格拉夫纳</a>以获得更好的可视化效果，但这需要一些配置，这超出了本教程的范围。</p><p id="2681" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您将集合或映射视为应用程序中的主要性能损失，那么很可能是一个任意的哈希代码或equals方法出了问题。此时，您可以在方法本身中使用度量来衡量其开销。</p><p id="d7de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这与我们经常在本地调试这些东西的方式非常相似。通过测量包围可疑区域，然后重新进行测试。不幸的是，这种方法很慢，因为它需要重新编译/部署应用程序。在生产中也不切实际。使用这种方法，我们可以快速检查所有“可疑”区域，并快速缩小范围。</p><p id="53ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，我们可以在一组服务器上使用标记功能来实现这一点。这样，我们可以像扩展服务器一样扩展我们的测量。</p><h1 id="2dcf" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">检查线程安全</h1><p id="c615" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">当我们试着调试可变对象时，它们可以从多线程中被改变。这可能会引发看似性能问题的问题。通过验证我们拥有单线程访问，我们还可以减少关键部分的同步。</p><p id="4b04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，在键值存储中，如果单独的线程改变了键，则存储可能会被破坏。</p><p id="cded" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最简单的方法是使用条件当前线程是:<code class="du lw lx ly ju b">{Thread.currentThread().getName()}</code>记录当前线程:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/7a9ae5d297490f84aee03779e31ccada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qp-tgHPsLPZ2j7m-"/></div></div></figure><p id="e6c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问题是，像这样的情况可能会触发难以理解的输出，您可能会看到数百个打印输出。所以一旦我们找出了线程的名称，我们就可以添加一个条件:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="77d4" class="jy jz hi ju b fi ka kb l kc kd">!Thread.currentThread().getName().equals("threadName")</span></pre><p id="0340" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将只记录来自不同线程的访问。这是我在之前的文章<a class="ae jo" href="https://lightrun.com/tutorials/debug-race-condition-production/" rel="noopener ugc nofollow" target="_blank">这里</a>中讨论过的事情。</p><h1 id="b90c" class="kf jz hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="8d00" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">Java SE中equals和hashcode方法的性能指标至关重要。它们对<a class="ae jo" href="https://javarevisited.blogspot.com/2020/04/top-5-courses-to-learn-java-collections-and-streams.html" rel="noopener ugc nofollow" target="_blank"> Java集合API </a>有着广泛的深远影响，尤其是在与键值相关的调用中。对象必须有效地实现这一点，但是通常很难确定出错的Java类。</p><p id="7d2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用Lightrun指标来为生产中的任意方法计时。在“真实世界”环境中测量类的性能是很重要的，这可能与我们的本地测试用例不同。对于生产规模的数据，对象的行为可能完全不同，对一个类的微小更改可能会产生很大的不同..</p><p id="7edb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以缩小哈希的开销，使用日志来确定线程问题，并使用计数器来确定API的使用。</p><div class="ma mb ez fb mc md"><a rel="noopener follow" target="_blank" href="/javarevisited/top-21-string-programming-interview-questions-for-beginners-and-experienced-developers-56037048de45"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">面向初学者和有经验的开发人员的21个字符串编程面试问题</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">除了数组、二叉树和链表数据结构，字符串是编程工作中的另一个热门话题…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">medium.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr io md"/></div></div></a></div><div class="ma mb ez fb mc md"><a rel="noopener follow" target="_blank" href="/javarevisited/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">50大数据结构和算法程序员面试问题</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">准备编程工作面试？这里有50多个数据结构和算法问题，你可以练习…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">medium.com</p></div></div></div></a></div></div></div>    
</body>
</html>