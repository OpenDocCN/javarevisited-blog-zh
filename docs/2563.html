<html>
<head>
<title>Method Overriding in java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">java中的方法覆盖</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/method-overriding-in-java-6b1c9025f769?source=collection_archive---------8-----------------------#2022-12-05">https://medium.com/javarevisited/method-overriding-in-java-6b1c9025f769?source=collection_archive---------8-----------------------#2022-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/01/why-override-equals-hashcode-or-tostring-java.html"><div class="er es if"><img src="../Images/fb40b6ce642898bd562f4d7a202362dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*94k3q5-7KrziJJiExh8hhQ.gif"/></div></a><p class="im in et er es io ip bd b be z dx translated">方法覆盖</p></figure><p id="1d57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，这是java的一个重要话题，大多数新手都陷入了困境。即使他们知道什么是压倒一切的，他们也看不到这背后的概念或想法。所以在这里，我试图尽可能简单地解释它。</p><p id="0f6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在面向对象编程中，有一种东西叫做坚实原则，它帮助程序员创建可理解、可读和可测试的代码。固体代表五个原则:</p><ol class=""><li id="1ad4" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" href="https://javarevisited.blogspot.com/2017/04/single-responsibility-principle-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">年代</strong>单一责任原则</a></li><li id="3d84" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">O<strong class="is hj">笔闭合原理</strong></li><li id="22d1" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><strong class="is hj"> L </strong>伊斯科夫替代原理</li><li id="8780" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><strong class="is hj"> I </strong>界面偏析原理</li><li id="cb72" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><strong class="is hj"> D </strong>依赖反转原理</li></ol><p id="94e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将解释开闭原则，该原则规定“<strong class="is hj">类应该对扩展开放，对修改</strong>关闭”。这意味着什么？这意味着我们可以将超类的属性继承给子类，但是我们不能修改现有的类。就像我们修改或改变类的属性一样，影响范围可能是巨大的，这需要大量的调试和消磨时间。简而言之，我们可以说，我们可以添加新的功能，而不会触及或破坏现有的功能。编写一个子类并为其提供实现总是更好。</p><p id="43d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在在你的脑海中出现了另一个问题，为什么我们需要子类？写它的目的是什么？可以为以下目的编写子类:</p><ol class=""><li id="58a3" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">添加新功能。</li><li id="508b" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">修改现有的功能。</li><li id="c954" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">继承现有的功能。</li></ol><p id="b8ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在方法重写中，我们将看到所有这些是如何工作的。当涉及到重写方法时，有一些规则。</p><ol class=""><li id="8baa" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">子类方法名应该与超类方法名相同。</li><li id="f2de" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">方法的参数(即类型、顺序和参数数量)必须与超类方法参数相同。</li><li id="1382" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">子类方法的返回类型必须与超类相同。</li><li id="94b4" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">当涉及到方法中的访问修饰符时，子类必须是相同的或更高的访问修饰符。</li><li id="926f" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">如果超类方法是静态的，那么我们只能在子类中用static重写。</li></ol><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kd"><img src="../Images/3b8b5b33b87c47ae16c2e0fee8ec2822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m33uYcKYpy_xVkGPEUpL5Q.png"/></div></div><p class="im in et er es io ip bd b be z dx translated">例外的雇佣关系</p></figure><p id="e6fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当涉及到异常时，您应该知道在重写方法时特定异常的层次结构。当超类方法抛出某个<strong class="is hj">检查异常</strong>时，子类方法将做如下所述的事情:</p><ol class=""><li id="b6dc" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">忽略方法级异常</li><li id="bae5" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">子类可以抛出与超类相同的异常</li><li id="d584" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">子类方法可以抛出任何未检查的异常。</li><li id="f611" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">从超类向子类抛出异常的层次结构只是从高到低。</li></ol><p id="832a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当超类方法抛出未检查的异常时，</p><ol class=""><li id="559b" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">忽略方法级异常</li><li id="b76f" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">子类可以抛出与超类相同的异常</li><li id="0e3e" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">它可以抛出任何其他未检查的异常。</li><li id="516c" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">它可以抛出任何检查过的异常。</li></ol><p id="3780" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们试着执行一些代码，以便理解如何在java中实现方法覆盖。</p><pre class="ke kf kg kh fd km kn ko bn kp kq bi"><span id="cacf" class="kr ks hi kn b be kt ku l kv kw">class Overriding {<br/>    public static void main(String[] args) {<br/>        System.out.println("Hello, this is going to override!");<br/>        new React().show();<br/>        System.out.println(new React().show());<br/>        <br/>    }<br/>}<br/><br/>class JS{<br/>    int show(){<br/>        return 2;<br/>    }<br/>}<br/><br/>class React extends JS{<br/>    int show(){<br/>        return 4;<br/>    }<br/>}</span></pre><pre class="kx km kn ko bn kp kq bi"><span id="0a7a" class="kr ks hi kn b be kt ku l kv kw">java -cp /tmp/M2Ak9TdNc5 Overriding<br/>Hello, this is going to override!<br/>4</span></pre><p id="0e2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么这里发生了什么？实际上，我们有三节课:</p><ol class=""><li id="e1dd" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">重写代码执行的地方，这是主类。</li><li id="33f6" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">JS——它包含一些我们将在类内覆盖的行为React。</li><li id="9195" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">React —这里我们继承了JS类的行为，并对其进行了修改。</li></ol><p id="e27e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是重写类，JVM从main方法启动并执行代码，并打印第一行，如上面的终端“<strong class="is hj"> <em class="ky">你好，这将重写</em> </strong>”所示。在下一行中，它创建了一个子类的对象，并为该对象调用了方法。这就是为什么它在控制台中打印<strong class="is hj"> 4 </strong>而不是2。</p><p id="50c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你明白这个主题，如果你有任何困惑，请告诉我，以便我可以用一些更具互动性的例子来更深入地解释它。更多类似的话题，请关注，如果你喜欢这些内容，请鼓掌。敬请期待！</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es if"><img src="../Images/4004c2a6b1551a66f1abd676901da384.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*9jCsG81nxrMTn9cx_cCngw.gif"/></div></figure><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/a7d8c1ca5201216f8856b10e902b2fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/1*L2RLgwJSAbkkDfTKTb5G8A.gif"/></div></figure></div></div>    
</body>
</html>