<html>
<head>
<title>Java Virtual Machine and its Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java虚拟机及其体系结构</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-virtual-machine-and-its-architecture-2d8de5599500?source=collection_archive---------3-----------------------#2021-07-05">https://medium.com/javarevisited/java-virtual-machine-and-its-architecture-2d8de5599500?source=collection_archive---------3-----------------------#2021-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6a32" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Java虚拟机</h2></div><p id="33bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JVM可以简单地称为为Java及其应用程序提供运行时环境的引擎。JVM被认为是JRE (Java运行时环境)的一部分。它以将java代码转换成字节码，然后将字节码解释成机器语言的过程而闻名。</p><p id="7cfb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，java编译器遵循将在虚拟机中使用的代码，该虚拟机也称为<a class="ae jt" href="https://www.java67.com/2013/02/difference-between-jit-and-jvm-in-java.html" rel="noopener ugc nofollow" target="_blank"> Java虚拟机</a>，不像其他编程语言，编译器为特定系统产生机器代码。</p><p id="2a02" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java应用程序也称为“一次编写，随处运行”，因为Java代码可以在一个系统中编写，并且能够在许多支持Java的系统中运行，而无需借助JVM进行任何更改。</p><p id="10fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java JVM是平台相关的(Mac JVM、Linux JVM、Windows JVM)，而Java代码是平台无关的。</p><h2 id="2440" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">JVM架构</h2><figure class="kq kr ks kt fd ku er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/12/jre-jvm-jdk-jit-in-java-programming.html"><div class="er es kp"><img src="../Images/12720725cce7ab364a77b4cd0b6a67d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*Q09YW_fcabpnlzGJXO1s7A.png"/></div></a></figure><p id="c69e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JVM的内部架构可以分为3个主要部分，</p><p id="aecb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://javarevisited.blogspot.com/2021/05/java-classloader-interview.html" rel="noopener ugc nofollow" target="_blank">类装载器</a></p><p id="0d51" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">存储区</p><p id="1eff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行引擎</p><h2 id="4520" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">类加载器</h2><p id="215a" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">这被认为是<a class="ae jt" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686"> JVM </a>的一个子系统，它负责在程序运行时加载类文件。</p><p id="ac2a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java中有三个内置的类加载器，</p><p id="f080" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">引导类装入器</p><p id="d412" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">扩展类加载器</p><p id="457e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">系统/应用程序类加载器</p><p id="ccba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些执行三个主要功能。</p><p id="2d35" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">装载</strong></p><p id="49ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类加载器读取<em class="lc">。类</em>文件，并生成所需的二进制数据，这些数据存储在方法区中。它还存储详细信息，</p><p id="d2e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">加载的类及其直接父类的完全限定名。</p><p id="111e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果生成了<a class="ae jt" href="https://javarevisited.blogspot.com/2012/05/10-points-about-class-file-in-java.html" rel="noopener ugc nofollow" target="_blank">。类文件</a>是一个类、接口或枚举</p><p id="f9ce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">变量、修饰符和方法信息。</p><p id="e4dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">加载<em class="lc">后。class</em>file JVM创建一个Class类型的对象来表示堆<a class="ae jt" href="https://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html" rel="noopener ugc nofollow" target="_blank">中的这个文件</a>。</p><p id="8e86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">链接</strong></p><p id="05a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有的验证、准备和决议都在这里完成。验证过程确保了文件的正确性。</p><p id="cf4a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">准备是JVM为类变量分配内存并在内存中分配默认值的过程。</p><p id="0faf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解析是将符号引用转换为直接引用的过程。这是通过遍历方法区域来定位被引用的实体来完成的。但是，该功能是可选的</p><p id="7f36" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">初始化</strong></p><p id="1682" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里所有的静态变量和块都被赋予代码中提到的值。该代码从上到下分层执行。</p><h2 id="0c84" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">JVM内存</h2><p id="76af" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">JVM内存主要由以下扇区组成，</p><p id="7471" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法区域</p><p id="75e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://javarevisited.blogspot.com/2011/05/java-heap-space-memory-size-jvm.html#axzz5SDsAfcC8" rel="noopener ugc nofollow" target="_blank">堆</a></p><p id="b8f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://www.java67.com/2016/10/difference-between-heap-and-stack-memory-in-java-JVM.html" rel="noopener ugc nofollow" target="_blank">书库</a></p><p id="fb36" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">PC寄存器</p><p id="18a4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本机方法堆栈</p><p id="3e33" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">方法区</strong></p><p id="e74f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里可以找到所有的类级别信息(类名、<a class="ae jt" href="https://www.java67.com/2016/05/difference-between-static-and-nonstatic-member-variable-in-java.html" rel="noopener ugc nofollow" target="_blank">类变量</a>、直接父类名等)。).值得注意的是，每个JVM只有一个方法区域，因此它被认为是内存中的共享资源。</p><p id="bf56" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">堆</strong></p><p id="fb2f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有与对象相关的信息都存储在这里。这种内存也是公用的，因此在多个线程之间共享。</p><p id="2ec2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">堆栈</strong></p><p id="92f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个商店的<a class="ae jt" href="https://javarevisited.blogspot.com/2012/02/difference-between-instance-class-and.html" rel="noopener ugc nofollow" target="_blank">局部变量</a>和部分结果。每个线程在创建时都有自己的运行时堆栈。每当调用一个方法时，就会创建一个新的框架，并且该方法的所有局部变量都存储在相应的框架中。当方法调用完成时，这将被删除。这不是共享资源。</p><p id="8af2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> PC寄存器</strong></p><p id="33e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也称为程序计数寄存器，保存当前正在执行的JVM指令的当前地址。</p><p id="f5d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">本机方法堆栈</strong></p><p id="c780" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这包含了应用程序中使用的所有本机方法，正如名称所暗示的那样。</p><h2 id="eefa" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">执行引擎</h2><p id="d298" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">这将执行<em class="lc">。类</em>文件通过逐行读取字节码，利用其数据和信息存在于各个内存区域，并执行指令。它可以进一步分解为3个部分，</p><p id="fcea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">解释器</strong></p><p id="29dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法逐行解释代码并执行，但是，如果一个方法被调用多次，它需要再次解释，这被认为是它的一个缺点。</p><p id="c6e9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">实时编译器</strong></p><p id="62f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这被用作对上述问题的补救，其中这通过编译整个字节码并将其改变为本机码来提高解释器的效率，因此当存在重复方法调用时，JIT编译器将提供该部分的本机码，从而不需要重新解释。</p><p id="7539" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">垃圾收集器</strong></p><p id="849d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这用于销毁或清除未引用的对象。</p><h2 id="2b28" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">Java本地接口</h2><p id="8d14" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">JNI是一个框架，它提供了与用其他语言编写的其他应用程序进行通信的接口。它允许运行在JVM中的<a class="ae jt" href="https://www.java67.com/2020/03/how-to-write-clean-code-using-java-8.html" rel="noopener ugc nofollow" target="_blank"> Java代码</a>被库和本地应用程序调用。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/11/top-5-free-java-courses-for-beginners.html"><div class="er es ld"><img src="../Images/ef235ebf957b9da2123b404a158f72d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*lSCMqK_h-kzJYRYcnmWTqA.png"/></div></a></figure></div></div>    
</body>
</html>