<html>
<head>
<title>Intermediate Java 8 : Functional Interface and Nested classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中级Java 8:函数接口和嵌套类</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/intermediate-java-eaeb920d0d8b?source=collection_archive---------4-----------------------#2021-08-10">https://medium.com/javarevisited/intermediate-java-eaeb920d0d8b?source=collection_archive---------4-----------------------#2021-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="19e3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">抽象方法</strong></h1><ul class=""><li id="356a" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">抽象方法是声明时没有实现的方法(没有大括号，后跟分号)。</li><li id="46b1" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">“abstract”关键字必须在此方法声明中使用。(但是在接口中声明时是多余的，如下所述)</li></ul></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="277e" class="if ig hi bd ih ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc bi translated"><strong class="ak">界面</strong></h1><ul class=""><li id="b496" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">要实现接口，类必须提供接口所需的完整方法集。</li><li id="dc73" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">接口旨在支持运行时的动态方法解析。</li><li id="fb65" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj">田地</strong>:</li><li id="601e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">界面中的所有字段默认为<a class="ae km" href="https://javarevisited.blogspot.com/2012/10/difference-between-private-protected-public-package-access-java.html#axzz6j8KhisSX" rel="noopener ugc nofollow" target="_blank">公共</a>、<a class="ae km" href="https://javarevisited.blogspot.com/2011/11/static-keyword-method-variable-java.html" rel="noopener ugc nofollow" target="_blank">静态</a>和<a class="ae km" href="https://javarevisited.blogspot.com/2016/09/21-java-final-modifier-keyword-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank">最终</a>。</li><li id="5642" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">所以在变量声明的时候提到这些关键字是多余的。</li><li id="97b0" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">编译器抛出一个错误，使字段成为非公共的或<a class="ae km" href="https://javarevisited.blogspot.com/2013/11/difference-between-static-vs-non-static-method-java.html#axzz5Y4KkQFHS" rel="noopener ugc nofollow" target="_blank">非静态的</a>或非最终的。</li><li id="bcfd" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj">方法</strong>:</li><li id="879c" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">默认情况下，接口中的所有方法都是公共的。</li><li id="2e37" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">使方法<a class="ae km" href="https://javarevisited.blogspot.com/2012/03/private-in-java-why-should-you-always.html" rel="noopener ugc nofollow" target="_blank">私有</a>或<a class="ae km" href="http://www.java67.com/2012/12/what-is-public-private-protected-package-default-private-access-modifier-java.html" rel="noopener ugc nofollow" target="_blank">受保护</a>会产生编译错误。</li><li id="173d" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">为没有主体的方法提及抽象关键字是多余的。</li><li id="daf9" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj">定义接口:</strong></li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kn"><img src="../Images/103bf5f7446a61dbe7acc2e22e6e7b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xRtEYwnPza2uHNskttko4Q.png"/></div></div></figure><ul class=""><li id="2574" class="jd je hi jf b jg kz ji la jk lb jm lc jo ld jq jr js jt ju bi translated"><strong class="jf hj">默认方法</strong>:</li><li id="b76b" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">Java 8中引入。默认方法必须有一个主体。</li><li id="6d55" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">此方法定义必须使用关键字“default”。</li><li id="07b3" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">接口中没有必要有默认方法。实现接口的类可以选择重写它们。</li><li id="b3af" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj">静态法</strong>:</li><li id="5f8c" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">在<a class="ae km" rel="noopener" href="/hackernoon/top-5-java-8-courses-to-learn-online-2db57d9dfb8d"> Java 8 </a>中引入。类似于默认方法，除了我们不能在实现类中覆盖它们。</li><li id="04cc" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">它们用于提供一个通用的或编写良好的实现，我们不希望我们的实现类改变它。</li></ul><h1 id="7b88" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">功能界面</strong>:</h1><ul class=""><li id="91d7" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">在<a class="ae km" rel="noopener" href="/javarevisited/top-5-courses-to-learn-new-features-of-java-8-to-java-13-107eb51d2a13"> Java 8 </a>中引入。这是一个只有一个<a class="ae km" href="http://javarevisited.blogspot.sg/2017/07/is-it-possible-to-have-abstract-method-in-final-class-java.html#axzz4xXS86IVo" rel="noopener ugc nofollow" target="_blank">抽象方法</a>的接口。</li><li id="4653" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">它可以包含来自Object类的默认方法、静态方法或重写方法，但仅限于使用一个抽象方法。</li><li id="affe" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">这样做的一个主要原因是通过λ表达式来支持功能接口的实例化。</li><li id="67d6" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj"> @FunctionalInterface </strong>注释用来表示一个函数接口，如果它的抽象方法少于1个，或者多于1个，就会抛出编译时错误。</li><li id="7b4d" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">下面是一个正确的<a class="ae km" href="https://javarevisited.blogspot.com/2018/01/what-is-functional-interface-in-java-8.html" rel="noopener ugc nofollow" target="_blank">功能接口</a>的例子。</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/05/java-8-stream-lambda-expression-d.html"><div class="er es le"><img src="../Images/bfc2417de1eeb32ec41fed3a3195c745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANLZZ3Cg2FjUk9gVkIAUJQ.png"/></div></a></figure><ul class=""><li id="a768" class="jd je hi jf b jg kz ji la jk lb jm lc jo ld jq jr js jt ju bi translated">Java 8在java.util.function包中提供了以下功能接口:</li><li id="00a7" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">Function <t r="">:表示lambda epression，它接受一个T类型的参数并返回r类型的单个值，例如:Function <integer float=""> fun = (a，b，c，d)-&gt; { a+= 2；返回a/2.0 }；</integer></t></li><li id="75b3" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">消费者<t c="">con = x-&gt; system . out . println(x)；</t></li><li id="d2be" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">其他接口有谓词、双函数、双消费、双预测等</li></ul><h1 id="0590" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">抽象类</strong></h1><ul class=""><li id="979c" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">一个<a class="ae km" href="https://javarevisited.blogspot.com/2013/05/difference-between-abstract-class-vs-interface-java-when-prefer-over-design-oops.html#axzz6uGbTSBhL" rel="noopener ugc nofollow" target="_blank"> <em class="lf">抽象类</em> </a>是一个被声明为“抽象”的类——它可能包含也可能不包含抽象方法。</li><li id="b513" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">抽象类不能实例化，但可以子类化。</li><li id="e28e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">如果这个类包含抽象方法，那么这个类必须被声明为抽象的。</li><li id="ca41" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">当抽象类被子类化时，子类通常为其父类中的所有抽象方法提供实现。但是，如果没有，那么子类也必须声明为<code class="du lg lh li lj b">abstract</code>。</li><li id="7466" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj">字段</strong>:抽象类可以有非<a class="ae km" href="https://www.java67.com/2014/10/difference-between-static-and-non-static-method-java-programming.html" rel="noopener ugc nofollow" target="_blank">静态</a>和<a class="ae km" href="https://www.java67.com/2017/06/10-points-about-final-modifier-in-java.html" rel="noopener ugc nofollow" target="_blank">最终</a>的字段。</li><li id="23c5" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj">方法</strong>:抽象类可以有公共的、受保护的和私有的具体方法。</li><li id="3bde" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">一个抽象类可能有<code class="du lg lh li lj b">static</code>字段和<code class="du lg lh li lj b">static</code>方法。</li></ul></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="10e6" class="if ig hi bd ih ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc bi translated"><strong class="ak">抽象类还是接口？</strong></h1><p id="8fd2" class="pw-post-body-paragraph lk ll hi jf b jg jh lm ln ji jj lo lp jk lq lr ls jm lt lu lv jo lw lx ly jq hb bi translated">你应该使用哪个，抽象类还是接口？</p><p id="196a" class="pw-post-body-paragraph lk ll hi jf b jg kz lm ln ji la lo lp jk lz lr ls jm ma lu lv jo mb lx ly jq hb bi translated"><strong class="jf hj">如果这些陈述中的任何一个适用于您的情况，请考虑使用抽象类</strong>:</p><ul class=""><li id="2a54" class="jd je hi jf b jg kz ji la jk lb jm lc jo ld jq jr js jt ju bi translated">您希望在几个密切相关的类之间共享代码。</li><li id="2230" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">您期望扩展您的抽象类的类具有许多公共方法或字段，或者需要除public之外的访问修饰符(例如protected和private)。</li><li id="ad85" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">您想要声明<a class="ae km" href="http://www.java67.com/2012/10/nested-class-java-static-vs-non-static-inner.html" rel="noopener ugc nofollow" target="_blank">非静态</a>或非最终字段。这使您能够定义能够访问和修改其所属对象状态的方法。</li></ul><p id="979d" class="pw-post-body-paragraph lk ll hi jf b jg kz lm ln ji la lo lp jk lz lr ls jm ma lu lv jo mb lx ly jq hb bi translated"><strong class="jf hj">如果这些陈述中的任何一项适用于您的情况，请考虑使用界面:</strong></p><ul class=""><li id="133e" class="jd je hi jf b jg kz ji la jk lb jm lc jo ld jq jr js jt ju bi translated">您希望不相关的类会实现您的接口。例如，接口<a class="ae km" href="https://www.java67.com/2019/06/top-5-sorting-examples-of-comparator-and-comparable-in-java.html" rel="noopener ugc nofollow" target="_blank">可比</a>和<a class="ae km" href="https://javarevisited.blogspot.com/2013/09/how-clone-method-works-in-java.html#axzz5Y4Ks1BbR" rel="noopener ugc nofollow" target="_blank">可克隆</a>由许多不相关的类实现。</li><li id="8883" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">您希望指定特定数据类型的行为，但不关心谁实现了它的行为。</li><li id="41f2" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">您希望利用类型的多个继承。</li></ul><h1 id="f67a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">实现接口的抽象类</strong></h1><p id="bddc" class="pw-post-body-paragraph lk ll hi jf b jg jh lm ln ji jj lo lp jk lq lr ls jm lt lu lv jo lw lx ly jq hb bi translated">抽象类<a class="ae km" href="https://www.java67.com/2017/08/difference-between-abstract-class-and-interface-in-java8.html" rel="noopener ugc nofollow" target="_blank">没有必要实现所有接口的方法。</a></p><figure class="ko kp kq kr fd ks er es paragraph-image"><a href="http://www.java67.com/2018/01/is-it-possible-to-instantiate-abstract-class-in-java.html"><div class="er es mc"><img src="../Images/d2f2c0abf1351cf09f9975c243801f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96VAa8JliUpx6o3VmlKRsw.png"/></div></a></figure></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="c947" class="if ig hi bd ih ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc bi translated"><strong class="ak">嵌套类</strong></h1><ul class=""><li id="35f2" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">在另一个类中定义的类称为<a class="ae km" href="https://javarevisited.blogspot.com/2012/12/inner-class-and-nested-static-class-in-java-difference.html#axzz5caMgsIIs" rel="noopener ugc nofollow" target="_blank">嵌套类</a>。</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><a href="http://www.java67.com/2012/10/nested-class-java-static-vs-non-static-inner.html"><div class="er es md"><img src="../Images/30e9d758acf2f2fb68c6ab5fd64bf3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*hJxGkUzmuZBVJiuXprzvxA.png"/></div></a></figure><ul class=""><li id="19cf" class="jd je hi jf b jg kz ji la jk lb jm lc jo ld jq jr js jt ju bi translated">嵌套类分为两类:非静态类和静态类。非静态嵌套类称为<a class="ae km" href="https://www.java67.com/2013/08/can-we-override-private-method-in-java-inner-class.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> <em class="lf">内部类</em></strong></a><strong class="jf hj"><em class="lf">s</em></strong>。声明为<code class="du lg lh li lj b">static</code>的嵌套类称为<em class="lf">静态嵌套类</em>。</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es me"><img src="../Images/ae1c42daf46ee5ed18a953d64482a3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdERKDo0B9OjelW6APz-qg.png"/></div></div></figure><ul class=""><li id="09ff" class="jd je hi jf b jg kz ji la jk lb jm lc jo ld jq jr js jt ju bi translated">嵌套类是其封闭类的成员。</li><li id="165a" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">非静态嵌套类(内部类)可以访问封闭类的其他成员，即使它们被声明为私有。<a class="ae km" href="https://javarevisited.blogspot.com/2017/04/can-we-declare-class-static-in-java.html" rel="noopener ugc nofollow" target="_blank">静态嵌套类</a>不能访问封闭类的其他成员。</li><li id="00a9" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">作为<code class="du lg lh li lj b">OuterClass</code>的成员，嵌套类可以声明为<code class="du lg lh li lj b">private</code>、<code class="du lg lh li lj b">public</code>、<code class="du lg lh li lj b">protected</code>或<em class="lf">包私有</em>。(回想一下，外部类只能声明为<code class="du lg lh li lj b">public</code>或<em class="lf">包私有</em>。)</li><li id="5531" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">这是一种对只在一个地方使用的类进行逻辑分组的方法:如果一个类只对另一个类有用，那么将它嵌入到那个类中并把两个类放在一起是合乎逻辑的。嵌套这样的“助手类”使得它们的<a class="ae km" href="https://www.java67.com/2018/06/a-beginners-guide-to-package-in-java.html" rel="noopener ugc nofollow" target="_blank">包</a>更加精简。</li><li id="13f3" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><strong class="jf hj">它增加了封装</strong>:考虑两个顶级类A和B，其中B需要访问A的成员，否则这些成员将被声明<code class="du lg lh li lj b">private</code>。通过将类B隐藏在类A中，A的成员可以被声明为私有的，B可以访问它们。另外，B本身也可以对外界隐藏。</li></ul><h2 id="938b" class="mf ig hi bd ih mg mh mi il mj mk ml ip jk mm mn it jm mo mp ix jo mq mr jb ms bi translated"><strong class="ak">内部类</strong>:</h2><ul class=""><li id="4c8e" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">因为内部类与一个实例相关联，所以它本身不能定义任何静态成员<a class="ae km" href="http://www.java67.com/2016/05/difference-between-static-and-nonstatic-member-variable-in-java.html" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="3b72" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated"><code class="du lg lh li lj b">InnerClass</code>的实例只能存在于<code class="du lg lh li lj b">OuterClass</code>的实例中，并且可以直接访问其封闭实例的方法和字段。</li><li id="2922" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">要实例化内部类，必须首先实例化外部类。然后，使用以下语法在外部对象中创建内部对象</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mt"><img src="../Images/3945b72a25a1fac583cb623d17e3930a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wu-nWbN5FHji5d4SF2xJQA.png"/></div></div></figure><h2 id="01b0" class="mf ig hi bd ih mg mh mi il mj mk ml ip jk mm mn it jm mo mp ix jo mq mr jb ms bi translated">本地类</h2><ul class=""><li id="8fcc" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">在块中定义的内部类称为局部类。块是平衡参数之间的一组0个或多个语句。</li><li id="4b74" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">局部内部类的范围被限制在定义它们的块中。</li><li id="15c9" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">局部内部类不能从创建它的块外部进行实例化。</li><li id="b7c7" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">当编译包含局部内部类的程序时，编译器生成2。类文件——一个用于内部类，它引用外部类，另一个用于外部类。</li><li id="8548" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">局部类确实可以访问其封闭类的成员</li></ul><h2 id="68d2" class="mf ig hi bd ih mg mh mi il mj mk ml ip jk mm mn it jm mo mp ix jo mq mr jb ms bi translated">匿名类</h2><ul class=""><li id="1da7" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">它就像一个没有名字的局部内部类。</li><li id="7d94" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">如果只打算使用一次，应该用它来代替局部内部类。</li><li id="07b5" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">有助于使代码简洁。它们使您能够同时声明和实例化类。</li><li id="b801" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">局部类是类声明，而匿名类是表达式，这意味着在另一个表达式中定义类</li><li id="ce1e" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">匿名类表达式/语法包括以下内容</li></ul><ol class=""><li id="9edc" class="jd je hi jf b jg kz ji la jk lb jm lc jo ld jq mu js jt ju bi translated">新操作员</li><li id="2fb0" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq mu js jt ju bi translated">要实现的接口或要扩展的类的名称</li><li id="36a4" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq mu js jt ju bi translated">包含构造函数参数的圆括号，就像普通的类实例创建表达式一样</li></ol><ul class=""><li id="b159" class="jd je hi jf b jg kz ji la jk lb jm lc jo ld jq jr js jt ju bi translated">在下面的例子中，comp是匿名类的对象，它扩展了Comparator类</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mv"><img src="../Images/017157727fb9df215c8a5acb8e8c2d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGWs3WOyeIpUHxzj3whuOQ.png"/></div></div></figure></div></div>    
</body>
</html>