<html>
<head>
<title>Map Sum Pairs LeetCode Solution using Trie and DFS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Trie和DFS映射和对LeetCode解</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/trie-and-dfs-d4c1924d72f6?source=collection_archive---------2-----------------------#2021-07-30">https://medium.com/javarevisited/trie-and-dfs-d4c1924d72f6?source=collection_archive---------2-----------------------#2021-07-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a680" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个很好的问题可以通过使用Trie、DFS和哈希表来解决。</p><h2 id="7dd6" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">677。映射求和对</h2><p id="f0ef" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">您需要设计一个允许您执行以下操作的地图:</p><ul class=""><li id="6c82" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">将字符串键映射到给定值。</li><li id="e198" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">返回前缀等于给定字符串的关键字为的值的总和。</li></ul><p id="8c81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现<code class="du ks kt ku kv b">MapSum</code>类:</p><ul class=""><li id="59d2" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated"><code class="du ks kt ku kv b">MapSum()</code>初始化<code class="du ks kt ku kv b">MapSum</code>对象。</li><li id="9b31" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><code class="du ks kt ku kv b">void insert(String key, int val)</code>将<code class="du ks kt ku kv b">key-val</code>对插入<a class="ae jy" href="https://www.java67.com/2013/02/10-examples-of-hashmap-in-java-programming-tutorial.html" rel="noopener ugc nofollow" target="_blank">地图</a>。如果<code class="du ks kt ku kv b">key</code>已经存在，原来的<code class="du ks kt ku kv b">key-value</code>对将被新的覆盖。</li><li id="1288" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><code class="du ks kt ku kv b">int sum(string prefix)</code>返回所有<code class="du ks kt ku kv b">key</code>以<code class="du ks kt ku kv b">prefix</code>开头的对的值之和。</li></ul><p id="fef3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例1: </strong></p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="2a15" class="jd je hi kv b fi le lf l lg lh"><strong class="kv hj">Input</strong><br/>["MapSum", "insert", "sum", "insert", "sum"]<br/>[[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]<br/><strong class="kv hj">Output</strong><br/>[null, null, 3, null, 5]</span><span id="f1c3" class="jd je hi kv b fi li lf l lg lh"><strong class="kv hj">Explanation</strong><br/>MapSum mapSum = new MapSum();<br/>mapSum.insert("apple", 3);  <br/>mapSum.sum("ap");           // return 3 (apple = 3)<br/>mapSum.insert("app", 2);    <br/>mapSum.sum("ap");           // return 5 (apple + app = 3 + 2 = 5)</span></pre><p id="9555" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">约束:</strong></p><ul class=""><li id="ec48" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated"><code class="du ks kt ku kv b">1 &lt;= key.length, prefix.length &lt;= 50</code></li><li id="23ce" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><code class="du ks kt ku kv b">key</code>和<code class="du ks kt ku kv b">prefix</code>仅由小写英文字母组成。</li><li id="71b3" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><code class="du ks kt ku kv b">1 &lt;= val &lt;= 1000</code></li><li id="3900" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">最多<code class="du ks kt ku kv b">50</code>个电话会打给<code class="du ks kt ku kv b">insert</code>和<code class="du ks kt ku kv b">sum</code>。</li></ul><h2 id="346d" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">参考码</h2><pre class="kw kx ky kz fd la kv lj bn lk ll bi"><span id="0e6a" class="lm je hi kv b be ln lo l lp lh">struct TrieNode{<br/>    public:<br/>    bool is_word = false;<br/>    vector&lt;TrieNode*&gt; children;<br/>    TrieNode(){<br/>        children.assign(26, nullptr);<br/>    }<br/>};<br/>class MapSum {<br/>public:<br/>    unordered_map&lt;string, int&gt; m;<br/>    TrieNode* root;<br/>    /** Initialize your data structure here. */<br/>    MapSum() {<br/>        root = new TrieNode();<br/>    }<br/>    <br/>    void insert(string key, int val) {<br/>        if (m.find(key) != m.end()) {<br/>            m[key] = val;<br/>            return;<br/>        }<br/>        m[key] = val;<br/>        // insert this word to TrieNode<br/>        auto node = root;<br/>        const int n = key.size();<br/>            for (int i = 0; i &lt; n; ++i){<br/>                int ch_idx = key[i] - 'a';<br/>                if (node -&gt; children[ch_idx] == nullptr){<br/>                    node -&gt; children[ch_idx] = new TrieNode();<br/>                }<br/>                node = node -&gt; children[ch_idx];<br/>                if (i == n - 1) node -&gt; is_word = true;<br/>            }<br/>        return;<br/>    }<br/>    <br/>    int dfs(TrieNode* node, string prefix){<br/>        int ret = 0;<br/>        if (node -&gt; is_word) ret += m[prefix];<br/>        for (char ch = 'a'; ch &lt;= 'z'; ch++){<br/>            if (node -&gt; children[ch - 'a'] != nullptr){<br/>                ret += dfs(node -&gt; children[ch - 'a'], prefix + ch);<br/>            }<br/>        }<br/>        return ret; <br/>    }<br/>    <br/>    int sum(string prefix) {<br/>        auto node = root;<br/>        for (int i = 0; i &lt; prefix.size(); ++i){<br/>            int ch_idx = prefix[i] - 'a';<br/>            if (node -&gt; children[ch_idx] == nullptr) return 0;<br/>            node = node -&gt; children[ch_idx];<br/>        }<br/>        return dfs(node, prefix);<br/>    }<br/>};<br/>/**<br/> * Your MapSum object will be instantiated and called as such:<br/> * MapSum* obj = new MapSum();<br/> * obj-&gt;insert(key,val);<br/> * int param_2 = obj-&gt;sum(prefix);<br/> */</span></pre><h1 id="e2a1" class="lq je hi bd jf lr ls lt jj lu lv lw jn lx ly lz jq ma mb mc jt md me mf jw mg bi translated">问题</h1><p id="08a9" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">472。串联词</p><h1 id="60a6" class="lq je hi bd jf lr ls lt jj lu lv lw jn lx ly lz jq ma mb mc jt md me mf jw mg bi translated">解决办法</h1><pre class="kw kx ky kz fd la kv lj bn lk ll bi"><span id="22c7" class="lm je hi kv b be ln lo l lp lh">struct TrieNode{<br/>    public:<br/>    bool is_word = false;<br/>    vector&lt;TrieNode*&gt; children;<br/>    TrieNode(){<br/>        children.assign(26, nullptr);<br/>    }<br/>};<br/>class Trie{<br/>    public:<br/>    TrieNode* root;<br/>    Trie(){<br/>        root = new TrieNode();<br/>    }<br/>    void insert(string &amp;word){<br/>        if (word.empty())return;<br/>        auto curr = root;<br/>        for (auto c: word){<br/>            int idx = c - 'a';<br/>            if (curr-&gt;children[idx] == nullptr){<br/>                curr-&gt;children[idx] = new TrieNode();<br/>            }<br/>            curr = curr-&gt;children[idx];<br/>        }<br/>        curr -&gt; is_word = true;<br/>    }<br/>};<br/><br/>class Solution {<br/>public:<br/><br/>    unordered_map&lt;string, int&gt; memo;<br/>    int dfs(int i, string&amp; word, TrieNode* node){<br/>        string sub_str = word.substr(i);<br/>        if (memo.find(sub_str) !=memo.end())return memo[sub_str];<br/>        if (i == word.size()){<br/>            return memo[sub_str] = 0;<br/>        }<br/>        auto curr = node;<br/>        int max_words = -1;<br/>        for (int j = i; j &lt; (int) word.size(); ++j){<br/>            curr = curr-&gt;children[word[j] - 'a'];<br/>            if (curr == nullptr)break;<br/>            if (curr -&gt; is_word){<br/>                int this_ret = dfs(j + 1, word, node);<br/>                if (this_ret == -1) continue;<br/>                else {<br/>                    max_words = max(max_words, 1 + this_ret); <br/>                }<br/>            }<br/>        }<br/>        return memo[sub_str] = max_words;<br/>    }<br/>    vector&lt;string&gt; findAllConcatenatedWordsInADict(vector&lt;string&gt;&amp; words) {<br/>        Trie trie;<br/>        for (auto &amp;word: words){<br/>            trie.insert(word);<br/>        }<br/>        vector&lt;string&gt; ret;<br/>        for (auto &amp;word: words){<br/>            int num_of_concat_words = dfs(0, word, trie.root);<br/>            if (num_of_concat_words &gt;= 2){<br/>                ret.push_back(word);<br/>            }<br/>        }<br/>        return ret;<br/>    }<br/>};</span></pre><h2 id="b9c0" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">其他数据结构问题和资源</h2><div class="mh mi ez fb mj mk"><a rel="noopener follow" target="_blank" href="/javarevisited/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hj fi z dy mp ea eb mq ed ef hh bi translated">50大数据结构和算法程序员面试问题</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">有很多计算机科学毕业生和程序员申请编程、编码和软件…</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">medium.com</p></div></div></div></a></div><div class="mh mi ez fb mj mk"><a rel="noopener follow" target="_blank" href="/javarevisited/top-10-free-data-structure-and-algorithms-courses-for-beginners-best-of-lot-ad807cc55f7a"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hj fi z dy mp ea eb mq ed ef hh bi translated">面向初学者的10大免费数据结构和算法课程——最好的</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">算法和数据结构是计算机科学的两个最基本和最重要的课题，是计算机科学的基础</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my mz mk"/></div></div></a></div></div></div>    
</body>
</html>