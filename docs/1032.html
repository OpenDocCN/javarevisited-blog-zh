<html>
<head>
<title>Java Lambda Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java Lambda表达式</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-lambda-expressions-6696793a6c38?source=collection_archive---------1-----------------------#2021-02-28">https://medium.com/javarevisited/java-lambda-expressions-6696793a6c38?source=collection_archive---------1-----------------------#2021-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="ab fe cl hk"><img src="../Images/3e4a7a24a2f9993edf8a2377f9e4aaa7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*yZBeQ92cU_KHnvSgYwE77g.png"/></div></figure><div class=""/><p id="3535" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在面向对象编程中，每个代码块都与类和对象相关。一个方法不能独立存在。例如，当我们想要打印<code class="du jk jl jm jn b">Hello world!</code>时，我们必须创建一个类，并在这个类中定义一个执行打印的方法。相反，函数式编程允许我们创建和使用独立的方法。λ表达式是在面向对象的Java世界中实现函数式编程的方法。它是在Java 8版本中添加的。</p><h2 id="6cd8" class="jo jp hp bd jq jr js jt ju jv jw jx jy ix jz ka kb jb kc kd ke jf kf kg kh ki bi translated">λ表达式的优点</h2><ul class=""><li id="1f38" class="kj kk hp io b ip kl it km ix kn jb ko jf kp jj kq kr ks kt bi translated">启用函数式编程。</li><li id="a6f0" class="kj kk hp io b ip ku it kv ix kw jb kx jf ky jj kq kr ks kt bi translated">使代码更具可读性。</li><li id="ebad" class="kj kk hp io b ip ku it kv ix kw jb kx jf ky jj kq kr ks kt bi translated">允许摆脱样板代码。</li><li id="c70e" class="kj kk hp io b ip ku it kv ix kw jb kx jf ky jj kq kr ks kt bi translated">促进API和库的使用。</li><li id="60c3" class="kj kk hp io b ip ku it kv ix kw jb kx jf ky jj kq kr ks kt bi translated">支持并行编程。</li></ul><p id="8a6b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们像Java 8版本之前一样实现第一段提到的<code class="du jk jl jm jn b">Hello world!</code>打印过程。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="c162" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与其直接打印<code class="du jk jl jm jn b">Hello world!</code>，不如通过行为传递来实现。首先，创建一个接口和一个实现该接口的类。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="3f07" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，将<code class="du jk jl jm jn b">Greeting</code>接口作为参数添加到<code class="du jk jl jm jn b">greet()</code>方法中。然后，创建一个<code class="du jk jl jm jn b">HelloGreeting</code>的实例，并将这个实例发送给<code class="du jk jl jm jn b">greet()</code>方法。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="8295" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们也可以通过创建一个匿名内部类来提供这个功能，而不是创建<code class="du jk jl jm jn b">HelloGreeting</code>类。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="a0b2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">无论以上哪种方式，我们都在一个实现了<code class="du jk jl jm jn b">Greeting</code>的类中指定行为，然后传递这个行为。不这样传递行为，可以直接传递类似下面结构的行为吗？</p><pre class="kz la lb lc fd lf jn lg lh aw li bi"><span id="15c3" class="jo jp hp jn b fi lj lk l ll lm">public void greet(perform()) {<br/>    perform();<br/>}</span></pre><p id="0d98" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">是的。Lambda表达式使我们能够创建与类无关的方法，并且我们可以传递这些方法(行为)。</p><figure class="kz la lb lc fd hj er es paragraph-image"><div class="er es ln"><img src="../Images/7b774010017941d5b99a7579871845ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*XUzttcPqkmVE2Ercl8VrIA.png"/></div></figure><p id="0bab" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">λ表达式的结构</strong></p><p id="8394" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Lambda表达式可以赋给一个变量。换句话说，可以认为是把一个方法赋给一个变量。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="0c11" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面显示了一个代表性的结构。从这个结构到lambda表达式结构的转换如下:</p><ul class=""><li id="d10e" class="kj kk hp io b ip iq it iu ix lo jb lp jf lq jj kq kr ks kt bi translated">当创建一个属于类的方法时，使用访问修饰符是有意义的，但是因为lambda表达式与类无关，所以不需要访问修饰符。</li><li id="ccfe" class="kj kk hp io b ip ku it kv ix kw jb kx jf ky jj kq kr ks kt bi translated">不需要指定方法名，因为lambda表达式提供的函数将通过变量使用。</li><li id="21f2" class="kj kk hp io b ip ku it kv ix kw jb kx jf ky jj kq kr ks kt bi translated">由于编译器知道所写的lambda表达式的返回类型——它是由我们指定的，我会提到——所以没有必要指定返回类型。</li><li id="71ec" class="kj kk hp io b ip ku it kv ix kw jb kx jf ky jj kq kr ks kt bi translated">和上面的子句一样，不需要指定参数的类型，因为编译器知道参数的类型。</li><li id="83a5" class="kj kk hp io b ip ku it kv ix kw jb kx jf ky jj kq kr ks kt bi translated">如果lambda表达式只有一行，花括号是可选的。</li></ul><p id="75bc" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">lambda表达式的结构如下例所示。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="55b6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">注意-1: </strong>和第3行一样，return关键字对于不使用花括号的单行语法是无效的。</p><p id="1cf8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">注意-2: </strong> While <code class="du jk jl jm jn b">this</code>引用可以在静态上下文中创建的匿名内部类中使用；它不能用于在静态上下文中创建的lambda表达式。</p><p id="0da7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">注-3: </strong>在<a class="ae lr" href="https://youtu.be/1OpAgZvYXLQ" rel="noopener ugc nofollow" target="_blank">这篇</a>演讲中，Venkat强调，由于其结构和创建目的，使用单行lambda表达式是一个很好的实践。我强烈建议你看那个演讲！</p><p id="f39f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么我们给lambda表达式赋值的变量是什么类型呢？功能界面。</p><figure class="kz la lb lc fd hj er es paragraph-image"><div class="er es ln"><img src="../Images/7b774010017941d5b99a7579871845ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*XUzttcPqkmVE2Ercl8VrIA.png"/></div></figure><h2 id="3954" class="jo jp hp bd jq jr js jt ju jv jw jx jy ix jz ka kb jb kc kd ke jf kf kg kh ki bi translated">功能界面</h2><p id="26ef" class="pw-post-body-paragraph im in hp io b ip kl ir is it km iv iw ix ls iz ja jb lt jd je jf lu jh ji jj hb bi translated">只包含一个抽象方法的接口称为函数接口。在函数接口中，可以根据需要多次找到默认方法和静态方法。重要的是只有一个抽象方法。</p><p id="4d12" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">用<code class="du jk jl jm jn b">@FunctionalInterface</code>标注，可以说明该接口是一个功能接口。这个注释的目的是为了意识到程序员正在使用一个函数接口，并防止添加一个新的抽象方法。如果不使用这个注释，并且接口中有一个抽象方法，那么这个接口仍然是一个函数接口。所以使用这个注释可以被看作是最佳实践。</p><p id="634b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为什么Java设计者没有创造一个全新的变量类型？这样做的主要原因是向后兼容。例如，<code class="du jk jl jm jn b">Thread</code>类可以使用lambda表达式，因为它有一个将<code class="du jk jl jm jn b">Runnable</code>函数接口作为参数的构造函数。然而，如果设计者已经创建了一个新的变量类型，那么必须对<code class="du jk jl jm jn b">Thread</code>类进行修改，以使用这个新的变量类型。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="8359" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们必须为每个lambda表达式创建一个函数接口吗？其实是的，但是考虑到这种情况，Java设计师用Java 8在<code class="du jk jl jm jn b"><a class="ae lr" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">java.util.function</a></code> <em class="lv"> </em>包下创建了很多功能接口，适合常见用例场景。</p><p id="d84a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过使用这个包中的<code class="du jk jl jm jn b"><a class="ae lr" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BiConsumer.html" rel="noopener ugc nofollow" target="_blank">BiConsumer</a></code>功能接口，我们可以执行除法过程。这个接口有两种类型，这些类型定义了<code class="du jk jl jm jn b">accept()</code>方法的参数类型。同样，这个方法的返回类型是<code class="du jk jl jm jn b">void</code>。在这里，通过查看<code class="du jk jl jm jn b">accept()</code>方法，我们可以看到，我们将给出两个参数，不会返回任何内容。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="118a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在第16行，执行从<code class="du jk jl jm jn b">main</code>传来的打印操作。正如所见，传递的行为是由<code class="du jk jl jm jn b">accept()</code>方法执行的。</p><p id="2e51" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，由于异常处理，lambda表达式提供的更可读代码的优势被削弱了。使用lambda表达式时，处理异常的最佳方式是使用包装器。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="0f1b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如所看到的，调用<code class="du jk jl jm jn b">process()</code>方法的行已经减少到一行，可读性得到了提高。</p><figure class="kz la lb lc fd hj er es paragraph-image"><div class="er es ln"><img src="../Images/7b774010017941d5b99a7579871845ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*XUzttcPqkmVE2Ercl8VrIA.png"/></div></figure><h2 id="71b2" class="jo jp hp bd jq jr js jt ju jv jw jx jy ix jz ka kb jb kc kd ke jf kf kg kh ki bi translated">一个例子</h2><p id="9f91" class="pw-post-body-paragraph im in hp io b ip kl ir is it km iv iw ix ls iz ja jb lt jd je jf lu jh ji jj hb bi translated">在本节中，首先，将使用Java 8之前的方法，然后使用Java 8方法对示例进行改进。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="c186" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如您在上面看到的，包含<code class="du jk jl jm jn b">Person</code>对象的列表是在main方法中创建的。然后，通过创建一个匿名的内部类，这些<code class="du jk jl jm jn b">Person</code>对象按照它们的姓氏进行排序。之后，所有的<code class="du jk jl jm jn b">Person</code>对象用<code class="du jk jl jm jn b">printAll()</code>方法打印，姓氏以<code class="du jk jl jm jn b">O</code>开头的<code class="du jk jl jm jn b">Person</code>对象用<code class="du jk jl jm jn b">printLastNameBegginningWithO()</code>方法打印。</p><p id="34f1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虽然<code class="du jk jl jm jn b">printLastNameBegginningWithO()</code>方法实现了期望的功能，但它并不灵活。例如，当我们想要打印名字以<code class="du jk jl jm jn b">Y</code>开头的<code class="du jk jl jm jn b">Person</code>对象时，应该编写一个全新的方法。为了提供灵活性，让我们创建一个包含<code class="du jk jl jm jn b">check()</code>方法的名为<code class="du jk jl jm jn b">Condition</code>的接口，并创建一个将<code class="du jk jl jm jn b">Condition</code>接口作为参数的名为<code class="du jk jl jm jn b">printConditionally()</code>的方法。该方法将打印满足作为参数传递的条件的<code class="du jk jl jm jn b">Person</code>对象。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="4c0c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面，<code class="du jk jl jm jn b">Person</code>通过创建匿名内部类，根据三种不同的条件，使用单一方法打印对象。分别打印所有的<code class="du jk jl jm jn b">Person</code>对象、姓氏以<code class="du jk jl jm jn b">O</code>开头的<code class="du jk jl jm jn b">Person</code>对象、名字以<code class="du jk jl jm jn b">Y</code>开头的<code class="du jk jl jm jn b">Person</code>对象。</p><p id="c06b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们看看如何使用lambda表达式摆脱样板代码。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="c44b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们提到过Java 8中的<code class="du jk jl jm jn b">java.util.function</code> <em class="lv"> </em>包。我们可以使用内置的<code class="du jk jl jm jn b"><a class="ae lr" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html" rel="noopener ugc nofollow" target="_blank">Predicate</a></code> <em class="lv"> </em>接口来代替我们自己创建的<code class="du jk jl jm jn b">Condition</code>接口。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="6c84" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可能还需要一个行为传递，因为它不总是仅仅是一个打印过程，所以让我们扩展一下这个例子。为此，我们可以使用<code class="du jk jl jm jn b"><a class="ae lr" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" rel="noopener ugc nofollow" target="_blank">Consumer</a> </code>接口。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="2520" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如第13行所示，<code class="du jk jl jm jn b">consumer.accept()</code>执行通过的打印过程。因此<code class="du jk jl jm jn b">performConditionally()</code>变得更加灵活，可以执行许多不同的功能。</p><p id="6629" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">重要的是，lambda表达式(或方法引用)的参数和返回值对应于函数接口中呈现的抽象方法的输入参数和返回值。</p><figure class="kz la lb lc fd hj er es paragraph-image"><div class="er es ln"><img src="../Images/7b774010017941d5b99a7579871845ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*XUzttcPqkmVE2Ercl8VrIA.png"/></div></figure><h2 id="73c8" class="jo jp hp bd jq jr js jt ju jv jw jx jy ix jz ka kb jb kc kd ke jf kf kg kh ki bi translated">方法引用</h2><p id="9095" class="pw-post-body-paragraph im in hp io b ip kl ir is it km iv iw ix ls iz ja jb lt jd je jf lu jh ji jj hb bi translated">方法引用是lambda表达式的一种特殊用法。它们用于使用现有方法以更短、更易读的形式创建lambda表达式。有三种类型的方法引用:</p><p id="391f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 1-静态方法的引用</strong></p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="30bd" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面创建的两个线程提供相同的功能，但是使用静态方法引用实例化了<code class="du jk jl jm jn b">thread2</code>对象。如图所示，其结构类似于<code class="du jk jl jm jn b">ClassName::MethodName</code>。</p><p id="9a99" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 2-引用一个实例方法</strong></p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="a4c2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> 3-对构造函数的引用</strong></p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="2c20" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lv">文件结束</em></p></div></div>    
</body>
</html>