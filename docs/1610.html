<html>
<head>
<title>How to Write Testable Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写可测试的代码</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/how-to-write-testable-code-d23a5f1dac2e?source=collection_archive---------1-----------------------#2021-10-02">https://medium.com/javarevisited/how-to-write-testable-code-d23a5f1dac2e?source=collection_archive---------1-----------------------#2021-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8262956e98042815a764b438d6698a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FGv3mXLE4DzHT1Q0.jpg"/></div></div><p class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://softgrade.org/writing-testable-code/" rel="noopener ugc nofollow" target="_blank">https://softgrade.org/writing-testable-code/</a></p></figure><p id="7dfb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章不是关于测试驱动开发，或者测试最佳实践，或者任何高级的测试概念。相反，我们的目标是推荐一个简单的心态变化，允许<a class="ae iu" href="https://softgrade.org/writing-testable-code/" rel="noopener ugc nofollow" target="_blank">编写可测试的代码</a>，而不需要首先编写任何测试。</p><p id="9316" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一点是<strong class="ix hj">最终</strong>编写测试，因为不是每个团队都有测试驱动开发的奢侈。这种思维模式的改变将允许编写可以在以后的时间点上容易测试的代码，并且带有<a class="ae iu" href="https://javarevisited.blogspot.com/2019/04/top-5-junit-and-unit-testing-courses-java-programmers.html#axzz6qnblZnVj" rel="noopener ugc nofollow" target="_blank"> TDD </a>的一些好处，而不必事先编写测试。</p><h1 id="fac8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">但首先，一个故事…</h1><p id="7c1f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">威尔刚刚加入一家在线教育公司，担任软件工程师。他的第一项任务是将班级平均指标添加到考试结束后运行的作业中。</p><p id="cda1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">产品经理清楚地解释了任务，并将钻研代码。在询问一位同事后，他找出了这项工作的代码所在，并发现了以下内容:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="12be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看起来这是一项非常简单的工作，Will修改了代码，添加了一个平均统计数据:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="3cf8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很高兴很快就完成了任务，剩下的唯一事情就是确保他的实现工作正常，不会破坏任何东西。经过这样的检查，他可以放心地提交代码。</p><p id="53f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再次与他的同事交谈有助于他理解如何测试平台，所以他继续创建一个新的类，创建一个考试，创建两个学生，分别登录并提交考试。考试后的工作运行，幸运的是，结果似乎很好。</p><p id="2b72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，Will花了半天时间来设置端到端测试并创建所有虚拟数据。如果有人要求对这段代码再做一次修改，他也要花大约一个小时的时间。他不得不尝试使用多个输入示例进行端到端测试，以覆盖边缘情况。</p><h1 id="2de8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">生产力流失</h1><p id="042f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在上面的故事中，Will遇到了多种潜在的生产力流失，这些流失影响了他作为<a class="ae iu" rel="noopener" href="/javarevisited/10-books-java-developers-should-read-in-2020-e6222f25cc72">开发人员</a>的独立性、他同事的生产力以及他提交代码变更的速度和信心。进行测试可能会解决所有这些问题:</p><ul class=""><li id="9ca2" class="lc ld hi ix b iy iz jc jd jg le jk lf jo lg js lh li lj lk bi translated">测试套件充当文档(不严重依赖同事)</li><li id="bcbb" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated">运行测试将确保更改不会破坏任何以前的功能，并确保新功能按预期工作</li><li id="5d7a" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated">编写测试会让开发人员考虑边缘情况</li></ul><p id="732c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是你可能不需要任何关于测试有用性的证明。如果Will是公司的一名<a class="ae iu" href="https://javarevisited.blogspot.com/2018/02/top-5-java-design-pattern-courses-for-developers.html" rel="noopener ugc nofollow" target="_blank"> <em class="lq">经验丰富的开发人员</em> </a>，也会遇到上述情况。</p><h1 id="d2da" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">让我们谈谈可测试性</h1><p id="2dee" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们对可测试性的定义就是测试某段代码的简单程度。考虑这个函数:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="5e12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于将要引入的更改，唯一需要测试的部分是新引入的平均分数(为了简单起见，我们忽略这个db的模式更改的意义)。如果威尔为<code class="du lr ls lt lu b">max_score</code>、<code class="du lr ls lt lu b">min_score</code>和<code class="du lr ls lt lu b">avg_score</code>写了一个测试来确认他的代码能够工作，这就足够了。</p><p id="f853" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问题在于代码的组织方式。很难测试数据库上存在的依赖关系(以及生产代码中潜在的许多其他东西)。更“可测试”的代码如下:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="7a12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们想为这段代码写一个测试，我们可以简单地用一些虚拟数据测试<code class="du lr ls lt lu b">calculate_stats</code>。</p><p id="9515" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个例子中，从不可测试到可测试的变化很容易实现，但在现实世界中并非如此。这个玩具例子用来说明，仅仅采用可测试代码的思维方式就会产生可测试的功能，我们可以很容易地为将来的某个时候编写测试。</p><p id="b201" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果Will遇到的代码是可测试的，他会修改代码，然后编写一个测试来确认它是否按预期工作。没有必要设置端到端测试，也没有必要浪费时间填充前端虚拟数据，然后运行整个作业来检查它是否适用于不同的输入。</p><p id="fbf0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果Will在代码中看到复杂的依赖关系，情况可能会有所不同。向这样的代码添加测试需要重构很大一部分，作为一个新手，这很难做到，因为它需要代码知识。随着时间的推移，Will可能会习惯不可测试的代码风格和低水平的生产力。</p><p id="c257" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加了测试的可测试代码示例:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="3c18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这向我们展示了可测试代码(即使我们忽略了测试)是如何实现以下目标的:</p><ul class=""><li id="ce6d" class="lc ld hi ix b iy iz jc jd jg le jk lf jo lg js lh li lj lk bi translated">代码文档(统计信息提取在它自己的函数中被称为<code class="du lr ls lt lu b">calculate_stats</code>)</li><li id="63b9" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated">编写测试的简易性(因为代码被适当地分离)迫使开发人员添加测试</li><li id="5f46" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated">让开发人员有信心通过创建和运行测试来快速做出更改</li></ul><p id="fc5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码也将是应用关注点分离模式的结果，但是通过简单地考虑代码的可测试性得到了不同的结果。这种思维模式的好处超过了<a class="ae iu" rel="noopener" href="/javarevisited/7-best-online-courses-to-learn-object-oriented-design-pattern-in-java-749b6399af59?source=---------10------------------">广泛的设计模式知识</a>。更简单的基础会产生更优雅、对开发人员友好的代码。</p><p id="f943" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">总之，采用编写可测试代码的思维方式有很多好处；免费文档、将来添加测试的便利性，以及由于代码更简单而增加的提交变更的信心只是其中的一部分。这是<a class="ae iu" rel="noopener" href="/javarevisited/5-best-junit-and-test-driven-development-books-for-java-developers-2d3fecb5c9ac">测试驱动开发</a>的精髓，没有强制测试优先的方法。</span></p><p id="bbde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章最初发表于<a class="ae iu" href="https://softgrade.org" rel="noopener ugc nofollow" target="_blank">https://softgrade.org</a>。为了让印刷热了新闻，考虑订阅作为一个免费会员那里！几个月后将会发布中等帖子。</p><div class="me mf ez fb mg mh"><a href="https://softgrade.org" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hj fi z dy mm ea eb mn ed ef hh bi translated">软坡度</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">软件博客</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">softgrade.org</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv io mh"/></div></div></a></div></div></div>    
</body>
</html>