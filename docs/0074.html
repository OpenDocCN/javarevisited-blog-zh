<html>
<head>
<title>Java generics Cheat sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java泛型备忘单</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-generics-cheat-sheet-2b178948233?source=collection_archive---------0-----------------------#2019-06-03">https://medium.com/javarevisited/java-generics-cheat-sheet-2b178948233?source=collection_archive---------0-----------------------#2019-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/144d3184900aac14d0c693a17d893c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sBV659K4cTrZinDXHXdU4Q.jpeg"/></div></div></figure><p id="9180" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在周围看到了仿制药，它无处不在，但仍然如此神秘。让我们试着理解泛型的基础。</p><h1 id="0a09" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">为什么是仿制药？</strong></h1><ol class=""><li id="f4fc" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated">编译时更强的类型检查。</li><li id="4a18" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">使程序员能够实现通用算法，这些算法可以应用于各种各样的对象，而不必为每种类型编写多次。</li></ol><h1 id="18d5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">通用类</strong></h1><p id="62f6" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">让我们看一个简单的例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="047c" class="lo jp hi lk b fi lp lq l lr ls"><strong class="lk hj">public class </strong>Node&lt;T&gt; {<br/>    <strong class="lk hj">private </strong>T <strong class="lk hj">data</strong>;<br/><br/>    <strong class="lk hj">public </strong>Node(T data) {<br/>        <strong class="lk hj">this</strong>.<strong class="lk hj">data </strong>= data;<br/>    }<br/><br/>    <strong class="lk hj">public void </strong>setData(T data) {<br/>        <strong class="lk hj">this</strong>.<strong class="lk hj">data </strong>= data;<br/>    }<br/>}</span></pre><p id="64f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">菱形运算符中的泛型T是类型。我们可以使用不同的类型，如基本类型或自定义类，如下所示:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="8d47" class="lo jp hi lk b fi lp lq l lr ls">Node&lt;String&gt; myStringNode = <strong class="lk hj">new </strong>Node&lt;&gt;(<strong class="lk hj">"Hello world!!"</strong>);<br/>Node&lt;Integer&gt; myIntegerNode = <strong class="lk hj">new </strong>Node&lt;&gt;(100);<br/>Node&lt;Number&gt; myNumberNode = <strong class="lk hj">new </strong>Node&lt;&gt;(11.23);</span></pre><h1 id="0f6b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">通用方法</strong></h1><p id="4084" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">让我们看看泛型方法的一些简单例子。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="583f" class="lo jp hi lk b fi lp lq l lr ls"><strong class="lk hj">public static </strong>&lt;T&gt; <strong class="lk hj">void </strong>print(T type) {<br/>    System.<strong class="lk hj"><em class="lt">out</em></strong>.println(type.toString());<br/>}<br/><br/><strong class="lk hj">public static void </strong>main(String[] args) {<br/>    <em class="lt">print</em>(<strong class="lk hj">new </strong>Integer(100));<br/>    <em class="lt">print</em>(<strong class="lk hj">new </strong>Float(1.11));<br/>    <em class="lt">print</em>(<strong class="lk hj">new </strong>Person(<strong class="lk hj">"Danerys"</strong>, <strong class="lk hj">"Targaryen"</strong>));<br/>}<br/><br/><strong class="lk hj">public static class </strong>Person {<br/>    String <strong class="lk hj">firstName</strong>;<br/>    String <strong class="lk hj">lastName</strong>;<br/><br/>    MyClass(String firstName, String lastName) {<br/>        <strong class="lk hj">this</strong>.<strong class="lk hj">firstName </strong>= firstName;<br/>        <strong class="lk hj">this</strong>.<strong class="lk hj">lastName </strong>= lastName;<br/>    }<br/><br/>    @Override<br/>    <strong class="lk hj">public </strong>String toString() {<br/>        <strong class="lk hj">return firstName </strong>+ <strong class="lk hj">" " </strong>+ <strong class="lk hj">lastName</strong>;<br/>    }<br/>}</span></pre><h1 id="cb1f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">边界类型参数</h1><p id="7003" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">当您想要限制类型参数时，可以使用这些参数。例如，我们可以定义一个函数，不管参数的类型如何，它都至少返回两个参数。因此，该函数将接受任何实现类似接口的类。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="1e15" class="lo jp hi lk b fi lp lq l lr ls"><strong class="lk hj">public static </strong>&lt;T <strong class="lk hj">extends </strong>Comparable&lt;T&gt;&gt; T getMinimum(T t1, T t2) {<br/>    <strong class="lk hj">if </strong>(t1.compareTo(t2) &lt; 0) {<br/>        <strong class="lk hj">return </strong>t1;<br/>    }<br/>    <strong class="lk hj">return </strong>t2;<br/>}<br/><br/><strong class="lk hj">public static void </strong>main(String[] args) {<br/>    System.<strong class="lk hj"><em class="lt">out</em></strong>.println(<em class="lt">getMinimum</em>(100,20));<br/>    System.<strong class="lk hj"><em class="lt">out</em></strong>.println(<em class="lt">getMinimum</em>(<strong class="lk hj">"aman"</strong>,<strong class="lk hj">"rohan"</strong>));<br/>}</span><span id="3645" class="lo jp hi lk b fi lu lq l lr ls">output:<br/>20<br/>aman</span></pre><h1 id="ad11" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">无限通配符</h1><p id="b7f0" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">假设我们有一个类<em class="lt">形状</em>和另一个类<em class="lt">矩形</em>。<em class="lt">矩形</em>延伸<em class="lt">形状</em>。现在假设我们有一个列表&lt; <em class="lt">形状</em> &gt;和列表&lt; <em class="lt">矩形</em> &gt;</p><p id="82c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lt">矩形</em>列表不是<em class="lt">形状</em>列表，尽管<em class="lt">矩形</em>延伸了<em class="lt">形状</em>。<em class="lt">形状</em>的集合不是<em class="lt">矩形</em>集合的超类型。</p><p id="44c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的代码将抛出一个编译时异常，因为列表&lt;<em class="lt">形状</em> &gt;与列表&lt; <em class="lt">矩形</em> &gt;不同</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="f714" class="lo jp hi lk b fi lp lq l lr ls"><strong class="lk hj">private static void </strong>printArea(List&lt;Shape&gt; list){<br/>    <strong class="lk hj">for </strong>(Shape shape:list){<br/>        System.<strong class="lk hj"><em class="lt">out</em></strong>.println(shape.getArea());<br/>    }<br/>}<br/><br/><strong class="lk hj">public static void </strong>main(String[] args) {<br/>    List&lt;Rectangle&gt; rectangles = <strong class="lk hj">new </strong>ArrayList&lt;&gt;();<br/>    <em class="lt">printArea</em>(rectangles);//will throw compile time error here<br/>}<br/><br/><strong class="lk hj">public interface </strong>Shape{<br/>    <strong class="lk hj">int </strong>getArea();<br/>}<br/><br/><strong class="lk hj">public static class </strong>Rectangle <strong class="lk hj">implements </strong>Shape{<br/>    <strong class="lk hj">public int </strong>getArea(){<br/>        <strong class="lk hj">return </strong>1*2;<br/>    }<br/>}<br/><br/><strong class="lk hj">public static class </strong>Circle <strong class="lk hj">implements </strong>Shape{<br/>    <strong class="lk hj">public int </strong>getArea(){<br/>        <strong class="lk hj">return </strong>314;<br/>    }<br/>}</span></pre><p id="b776" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用通配符来解决这个问题</p><p id="34e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问号(？)被称为泛型编程中的通配符。它表示未知类型。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="fb90" class="lo jp hi lk b fi lp lq l lr ls"><strong class="lk hj">private static void </strong>printArea(List&lt;? <strong class="lk hj">extends  </strong>Shape&gt; list){<br/>    <strong class="lk hj">for </strong>(Shape shape:list){<br/>        System.<strong class="lk hj"><em class="lt">out</em></strong>.println(shape.getArea());<br/>    }<br/>}</span></pre><p id="4155" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将适用于所有实现形状接口的类</p><h1 id="1bf2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">类型橡皮擦</strong></h1><p id="e92b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">为了让泛型无缝工作，java编译器使用了类型擦除器。</p><p id="8ce8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么是橡皮擦？</p><p id="4321" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类型擦除器是java编译器使用的一种技术，它使我们的生活变得更加简单。它基本上删除了所有的泛型类型，用普通的类和接口来代替，以便JVM理解。它执行以下所有操作:</p><p id="cc01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a.如果所有泛型类型是无界的，则用对象替换它们</p><p id="62ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">b.用其绑定替换所有泛型类型</p><p id="fbad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">c.如有必要，插入类型转换</p><p id="1385" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">d.生成桥接方法以保持扩展泛型类型中的多态性</p><p id="1c9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是在类型擦除过程中添加的一个额外的方法，以避免不明确的情况</p><p id="b9cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="2dd2" class="lo jp hi lk b fi lp lq l lr ls"><strong class="lk hj">public class </strong>Node&lt;T&gt; {<br/>    <strong class="lk hj">private </strong>T <strong class="lk hj">data</strong>;<br/><br/>    <strong class="lk hj">public </strong>Node(T data) {<br/>        <strong class="lk hj">this</strong>.<strong class="lk hj">data </strong>= data;<br/>    }<br/><br/>    <strong class="lk hj">public void </strong>setData(T data) {<br/>        <strong class="lk hj">this</strong>.<strong class="lk hj">data </strong>= data;<br/>    }<br/>}</span><span id="2d72" class="lo jp hi lk b fi lu lq l lr ls"><strong class="lk hj">public class </strong>MyNode <strong class="lk hj">extends </strong>Node&lt;Integer&gt; {<br/><br/>    <strong class="lk hj">public </strong>MyNode(Integer data){<br/>        <strong class="lk hj">super</strong>(data);<br/>    }<br/><br/>    @Override<br/>    <strong class="lk hj">public void </strong>setData(Integer data) {<br/>        <strong class="lk hj">super</strong>.setData(data);<br/>    }<br/>}</span></pre><p id="8ac3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">键入eraser后，生成的代码如下:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="6675" class="lo jp hi lk b fi lp lq l lr ls"><strong class="lk hj">public class </strong>Node {<br/>    <strong class="lk hj">private </strong>Object <strong class="lk hj">data</strong>;<br/><br/>    <strong class="lk hj">public </strong>Node(Object data) {<br/>        <strong class="lk hj">this</strong>.<strong class="lk hj">data </strong>= data;<br/>    }<br/><br/>    <strong class="lk hj">public void </strong>setData(Object data) {<br/>        <strong class="lk hj">this</strong>.<strong class="lk hj">data </strong>= data;<br/>    }<br/>}</span><span id="f825" class="lo jp hi lk b fi lu lq l lr ls"><strong class="lk hj">public class </strong>MyNode <strong class="lk hj">extends </strong>Node {<br/><br/>    <strong class="lk hj">public </strong>MyNode(Integer data){<br/>        <strong class="lk hj">super</strong>(data);<br/>    }<br/><br/>    <strong class="lk hj">public void </strong>setData(Integer data) {<br/>        <strong class="lk hj">super</strong>.setData(data);<br/>    }<br/><br/>    @Override<br/>    <strong class="lk hj">public void </strong>setData(Object data) {<br/>        setData((Integer)data);<br/>    }<br/>}</span></pre><p id="0302" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编译器增加了一个额外的方法来保持多态性</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="fcb3" class="lo jp hi lk b fi lp lq l lr ls">@Override<br/><strong class="lk hj">public void </strong>setData(Object data) {<br/>   setData((Integer)data);<br/>}</span></pre><p id="f6eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，每当我们使用泛型类型时，编译器都会为我们做一些繁重的工作。它使用橡皮擦生成所有的代码，否则就必须由我们来编写。</p><p id="8fbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">泛型是一个很棒的工具，它让我们可以编写抽象出逻辑的地方，然后这个逻辑可以应用于给定类型的所有对象。集合框架是一个很好的例子，说明了泛型是如何使我们的生活变得更简单的，使用它我们可以使我们的代码更干净，避免重复。</p><p id="e4c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为泛型是每个Java开发人员都应该掌握的工具。</p></div></div>    
</body>
</html>