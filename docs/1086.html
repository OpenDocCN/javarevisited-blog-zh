<html>
<head>
<title>Build a Tiny Compiler in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java构建一个微型编译器</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/build-a-tiny-compiler-in-java-662f67a1ce85?source=collection_archive---------1-----------------------#2021-03-20">https://medium.com/javarevisited/build-a-tiny-compiler-in-java-662f67a1ce85?source=collection_archive---------1-----------------------#2021-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5fea37e4f82035f48c1c476d39827baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WeS2DQXwNgTwNoKfi_bUBw.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">Codekrypt编译器</p></figure><p id="d5da" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi js translated">你在谷歌搜索“如何用Java创建一个编译器？”，“Java中的微型编译器？”，“AST到Java字节码”。那你来对地方了。<strong class="iw hj">微小</strong>这个词是主观的。但是，代码很简单，足以理解编译器开发的端到端流程。</p><h2 id="a6b3" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jf km kn ko jj kp kq kr jn ks kt ku kv bi translated">空谈不值钱。给我看看代码！</h2><p id="0cfa" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">这就对了:<a class="ae lb" href="https://github.com/arjunsk/codekrypt-compiler/tree/master/compiler-examples/ck-compiler" rel="noopener ugc nofollow" target="_blank"> Codekrypt编译器Github </a></p><h2 id="6778" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jf km kn ko jj kp kq kr jn ks kt ku kv bi translated">先决条件:</h2><ol class=""><li id="ee51" class="lc ld hi iw b ix kw jb kx jf le jj lf jn lg jr lh li lj lk bi translated"><a class="ae lb" href="https://github.com/arjunsk/java-bytecode/tree/master/java-asm/visitor-pattern-example" rel="noopener ugc nofollow" target="_blank">访客模式</a></li><li id="a707" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated"><a class="ae lb" href="https://github.com/arjunsk/java-bytecode/tree/master/java-asm/ow2-asm-example" rel="noopener ugc nofollow" target="_blank"> Java ASM </a></li></ol><h2 id="7a11" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jf km kn ko jj kp kq kr jn ks kt ku kv bi translated">编译器阶段:</h2><ol class=""><li id="0eb4" class="lc ld hi iw b ix kw jb kx jf le jj lf jn lg jr lh li lj lk bi translated"><strong class="iw hj">词法</strong>分析【字符串→令牌】</li><li id="db57" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated"><strong class="iw hj">句法</strong>分析(即解析)[ Token → AST ]</li><li id="0f33" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated"><strong class="iw hj">语义</strong>分析【验证AST】</li><li id="06ec" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">优化(可选)</li><li id="f6a6" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">代码生成[AST → Java字节码]</li></ol><h2 id="28a6" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jf km kn ko jj kp kq kr jn ks kt ku kv bi translated">语法:</h2><p id="668a" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">为了简单起见，我们将使用下面的语法。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><ul class=""><li id="8a50" class="lc ld hi iw b ix iy jb jc jf lw jj lx jn ly jr lz li lj lk bi translated">我们的<code class="du ma mb mc md b">Program </code>会有多个<code class="du ma mb mc md b">Statement</code>。</li><li id="c835" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lz li lj lk bi translated">一个<code class="du ma mb mc md b">Statement</code>不是<code class="du ma mb mc md b">Let</code>就是<code class="du ma mb mc md b">Show</code>。</li><li id="726c" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lz li lj lk bi translated">设的形式为<code class="du ma mb mc md b">VAR = INT</code>。</li><li id="56f0" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lz li lj lk bi translated">显示形式为<code class="du ma mb mc md b">SHOW INT</code>或<code class="du ma mb mc md b">SHOW VAR</code>。</li><li id="ed4c" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lz li lj lk bi translated">VAR →变量(小写或大写字母的字符串)</li><li id="a158" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lz li lj lk bi translated">INT →(整数，即<code class="du ma mb mc md b">Positive Number</code>不带小数)</li></ul><p id="db13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个语法来自ANTRL4的另一篇文章。</p><p id="07ea" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们从实现编译器开始。</p><h1 id="4f2d" class="me kc hi bd kd mf mg mh kh mi mj mk kl ml mm mn ko mo mp mq kr mr ms mt ku mu bi translated">1.词法分析(标记器)</h1><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="b78e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ma mb mc md b">nextToken()</code> →我们对每个字符进行迭代，看看能否转换成令牌。</p><p id="018d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ma mb mc md b">getCurrentToken()</code> →调用<code class="du ma mb mc md b">nextToken()</code>后，我们获取当前设置的令牌。</p><p id="bff3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的<strong class="iw hj">令牌</strong>会持有<code class="du ma mb mc md b">type</code> &amp; <code class="du ma mb mc md b">value</code>。</p><h1 id="cf71" class="me kc hi bd kd mf mg mh kh mi mj mk kl ml mm mn ko mo mp mq kr mr ms mt ku mu bi translated">2.解析器+ AST</h1><p id="45ea" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">简单地说，解析器就是使用<code class="du ma mb mc md b">Lexer</code>来填充下面的框架类。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="941f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">需要注意的重点是<code class="du ma mb mc md b">ProgramContext</code>、<code class="du ma mb mc md b">StatementContext</code>、<code class="du ma mb mc md b">LetContext</code>、<code class="du ma mb mc md b">ShowContext</code>、<code class="du ma mb mc md b">TerminalNode </code>是<strong class="iw hj">可见</strong>和<strong class="iw hj">解析树</strong>的子树。</p><h2 id="32e8" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jf km kn ko jj kp kq kr jn ks kt ku kv bi translated">为什么？</h2><p id="a672" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated"><strong class="iw hj">可访问</strong> →接受自定义访问者在各节点添加业务逻辑。</p><p id="4cb7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">解析树</strong> →用于遍历子节点和传播访问者。</p><h1 id="09c4" class="me kc hi bd kd mf mg mh kh mi mj mk kl ml mm mn ko mo mp mq kr mr ms mt ku mu bi translated">大西洋时间</h1><p id="b595" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">我们创建了一个基类(<code class="du ma mb mc md b">ParserRuleContext</code>)，它具体化了常见的方法，可以被它们的子类扩展。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="8873" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">语法元素(即AST节点)从这个基类扩展而来。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/f4b550920d989c8a966c7fd4cc085550.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*UcfvEmY3k90G415Z8jObbQ.png"/></div><p class="iq ir et er es is it bd b be z dx translated">语法元素</p></figure><p id="9e28" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在AST的子节点(ie实现)将<strong class="iw hj">只有</strong>有相关的变量和函数。我们来看一个<code class="du ma mb mc md b">LetContext</code>的例子。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="4f95" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ma mb mc md b">LetContext </code>节点只负责处理<code class="du ma mb mc md b">variableName </code> &amp; <code class="du ma mb mc md b">variableValue</code>。</p><p id="0996" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du ma mb mc md b"><a class="ae lb" href="https://github.com/arjunsk/codekrypt-compiler/blob/master/compiler-examples/ck-compiler/src/main/java/com/arjunsk/compiler/ck/domain/tree/nodes/common/TerminalNode.java" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">TerminalNode</strong></a></code>因为他们没有孩子，所以逻辑略有不同。</p><h1 id="c9a6" class="me kc hi bd kd mf mg mh kh mi mj mk kl ml mm mn ko mo mp mq kr mr ms mt ku mu bi translated">3.访问者和语义</h1><p id="43d9" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">是啊！访客，是的。我们将在接下来的3个阶段使用访问者。</p><p id="f3d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">语法</strong>验证“Arjun 1234良好”。(是有效的sentance吗？)</p><p id="e3a3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">语义</strong>验证“阿琼善是”。(有意义吗？)</p><p id="e2f1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们的例子中，从语义上来说，我们需要验证变量在被<code class="du ma mb mc md b">SHOW VAR1</code>引用之前是否声明了(<code class="du ma mb mc md b">VAR1 = 10</code>)。</p><p id="0568" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该验证逻辑可以使用<strong class="iw hj">语义分析器</strong>来实现。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h1 id="b160" class="me kc hi bd kd mf mg mh kh mi mj mk kl ml mm mn ko mo mp mq kr mr ms mt ku mu bi translated">4.访客和翻译。</h1><p id="9935" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">解释器逐行运行你的代码。</p><p id="6a73" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将实现一个处理<code class="du ma mb mc md b">LetContext</code> &amp; <code class="du ma mb mc md b">ShowContext</code>的访问者来打印我们代码的输出。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h1 id="fcea" class="me kc hi bd kd mf mg mh kh mi mj mk kl ml mm mn ko mo mp mq kr mr ms mt ku mu bi translated">5.访问者和代码生成(Java ASM)</h1><p id="1570" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">这部分会有点难，但是如果你有使用<a class="ae lb" rel="noopener" href="/javarevisited/20-essential-java-libraries-and-apis-every-programmer-should-learn-5ccd41812fc7"> Java ASM </a>的想法，那么真的会很简单。在这个阶段，我们将把AST转换成Java字节码。</p><blockquote class="mw mx my"><p id="a30b" class="iu iv mz iw b ix iy iz ja jb jc jd je na jg jh ji nb jk jl jm nc jo jp jq jr hb bi translated">为您的类生成ASM代码最简单的方法是使用<a class="ae lb" href="https://github.com/arjunsk/java-bytecode/tree/master/java-asm/ow2-asm-example/src/main/java/com/arjunsk/asm/asmifier" rel="noopener ugc nofollow" target="_blank"> ASMifier </a>。</p></blockquote><p id="e10d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du ma mb mc md b"><strong class="iw hj">visitProgram</strong>()</code>中，我们打开<code class="du ma mb mc md b">ClassWriter </code>和<code class="du ma mb mc md b">main MethodVistor</code>。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="7c39" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦<code class="du ma mb mc md b">ClassWriter </code>和<code class="du ma mb mc md b">main Method Visitor</code>打开，我们调用<code class="du ma mb mc md b">super()</code>将调用传播到子节点，即<code class="du ma mb mc md b">VisitLet()</code>和<code class="du ma mb mc md b">VisitShow()</code>，然后关闭这些编写器。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="3158" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du ma mb mc md b"><strong class="iw hj">visitLet</strong>()</code>中，我们使用Java Ops代码:</p><ul class=""><li id="bf2e" class="lc ld hi iw b ix iy jb jc jf lw jj lx jn ly jr lz li lj lk bi translated"><code class="du ma mb mc md b">BIPUSH </code>(字节推送)</li><li id="9599" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lz li lj lk bi translated"><code class="du ma mb mc md b">ASTORE </code> + <code class="du ma mb mc md b">VariableIndex </code>将引用存储到一个<a class="ae lb" href="https://javarevisited.blogspot.com/2018/03/finally-java-10-has-var-to-declare-local-variables.html#axzz5Xl86cS70" rel="noopener ugc nofollow" target="_blank">局部变量</a>中。</li></ul><p id="a182" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">注1 </strong> : VariableIndex从1开始，因为索引0是为<code class="du ma mb mc md b">main(String[] var0)</code>中的args[]保留的。</p><p id="d6e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">注2 </strong>:我们保存<code class="du ma mb mc md b">VariableIndex </code>以便在<code class="du ma mb mc md b">visitShow()</code>中进一步参考。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="063d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du ma mb mc md b"><strong class="iw hj">visitShow</strong>()</code>中，我们使用Java Ops代码:</p><ul class=""><li id="14bb" class="lc ld hi iw b ix iy jb jc jf lw jj lx jn ly jr lz li lj lk bi translated"><code class="du ma mb mc md b">ALOAD </code> + <code class="du ma mb mc md b">VariableIndex</code>:从局部变量(VAR)加载引用</li><li id="6007" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lz li lj lk bi translated"><code class="du ma mb mc md b">BIPUSH </code>(字节推送):如果是整数常量。(整数)</li><li id="c6b3" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lz li lj lk bi translated"><code class="du ma mb mc md b">INVOKEVIRTUAL</code>:调用<code class="du ma mb mc md b">System.out.println()</code></li></ul><h1 id="9665" class="me kc hi bd kd mf mg mh kh mi mj mk kl ml mm mn ko mo mp mq kr mr ms mt ku mu bi translated">6.链接和编译。</h1><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="3ba2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要从生成的<code class="du ma mb mc md b">.class</code>文件中读取<code class="du ma mb mc md b">Java</code>代码，使用<a class="ae lb" rel="noopener" href="/javarevisited/7-best-courses-to-learn-intellij-idea-for-beginners-and-experienced-java-programmers-2e9aa9bb0c05"> IntelliJ的</a>反编译器。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/2948365492fc25a7a764b587e34fd33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdcYcn7LKWpxsL7PmzbohQ.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">反编译的类文件</p></figure><h2 id="3233" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jf km kn ko jj kp kq kr jn ks kt ku kv bi translated">结论</h2><p id="048f" class="pw-post-body-paragraph iu iv hi iw b ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn la jp jq jr hb bi translated">你坚持到了最后。干杯🍻！</p><p id="2040" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Java很冗长，很难一行一行地解释代码。但是我已经尽力给出了编译器开发过程的高层次概述。</p><p id="b2c8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请务必在<a class="ae lb" href="https://github.com/arjunsk/codekrypt-compiler/tree/master/compiler-examples/ck-compiler" rel="noopener ugc nofollow" target="_blank"> Github </a>查看完整代码。开始<strong class="iw hj">这个项目，因为我可能会用更成熟的语法更新这个项目。<a class="ae lb" href="https://github.com/arjunsk/codekrypt-compiler" rel="noopener ugc nofollow" target="_blank">父项目</a>包含了我已经尝试过的<code class="du ma mb mc md b">parser-libraries</code>的例子。希望这篇文章对某人有所帮助！</strong></p><p id="100e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">觉得有意思？<br/> </strong>请通过以下方式表示您的支持👏。</p></div></div>    
</body>
</html>