<html>
<head>
<title>Scaffolding Spring Boot, Freemarker and JDI — Building DDTJ, Day 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搭建Spring Boot、Freemarker和JDI的脚手架——构建DDTJ，第2天</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/scaffolding-spring-boot-freemarker-and-jdi-building-ddtj-day-2-1b991ad3c40c?source=collection_archive---------3-----------------------#2021-12-21">https://medium.com/javarevisited/scaffolding-spring-boot-freemarker-and-jdi-building-ddtj-day-2-1b991ad3c40c?source=collection_archive---------3-----------------------#2021-12-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0d5812a8312ff4e73195512c4456060b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhhJySGSDiFZhY-b59FnjA.png"/></div></div></figure><p id="f05d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">昨天我讨论了从头开始构建一个新的开源项目的第一步(这也非常适用于商业项目)。今天，我们继续第一阶段，即搭建实际项目和挑选工具。剧透一下，我选了Spring Boot应用框架…</p><h1 id="8a27" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">为什么我选择了Spring Boot？</h1><p id="29f6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这是一个简单的选择:</p><ul class=""><li id="d582" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">Spring Boot非常成熟</li><li id="b2b8" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">我很了解Spring Boot</li><li id="0685" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">Spring framework的配置方法将允许项目增长以支持额外的用例</li><li id="a7b5" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">Spring Boot的本地支持将让我把最终的应用打包成一个可执行文件</li></ul><p id="184f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显而易见的问题是，我为什么要考虑别的东西？</p><p id="42e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我很矛盾，因为Spring Native仍然缺少一些我需要的东西，比如Freemarker支持(或者任何模板引擎)。我认为从长远来看，为这个工具提供本地编译是非常重要的。但是对于第一个MVP，我认为这是一个“过早的优化”。此外，我觉得我所熟悉的春天的替代品并不成熟。</p><p id="beca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这很重要:尽量避免MVP的新技术。我说的“新”是指你不熟悉的工具。</p><p id="390a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我关心的另一件事是<a class="ae jo" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e"> Spring Boot </a>的大小。其他应用程序开发框架通常以内存占用更小、启动时间更快而自豪。从长远来看，这些事情很重要。但是我认为，以后移植Spring Boot应用程序比研究基于供应商利基基准的东西更容易。</p><p id="c6cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我使用<a class="ae jo" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr工具</a>创建了一个基础项目，它生成了一些样板配置和源代码。我避免了许多您通常添加到spring应用程序中的标准Spring集成选项，例如:</p><ul class=""><li id="23a9" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">Spring Data  —我们不需要数据库访问或数据库连接。为了提高性能，一切都直接存储在内存中。甚至不是内存数据库，没有必要</li><li id="dd8a" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><strong class="is hj"> Spring Security </strong> —应用在虚拟机本地运行。是的，安全是至关重要的，但Spring Security过度关注web安全。我们甚至不会用HTTPS来评选MVP</li><li id="faa7" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><strong class="is hj">春云</strong> —这个工具我们不需要任何云服务。它需要在本地快速工作</li></ul><p id="c927" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我为RESTful web服务添加了Spring Boot web支持。我考虑过使用WebFlux，但我不确定它是否能为这种类型的应用程序提供更好的性能。此外，对于新的架构，我认为这并不重要。</p><p id="8e83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前我不需要Spring框架的大部分特性，比如自动配置、依赖管理等等。但随着我们的前进，它们会派上用场。例如，使用外部配置文件定制为特定公司生成的模板的能力在企业设置中非常有用。</p><p id="1636" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我所做的唯一配置更改是设置:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="fab6" class="lp jq hi ll b fi lq lr l ls lt">server.port=2012</span></pre><p id="319d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在配置属性文件中(我使用12月20日作为数字，这不是一个众所周知的端口)。spring的好处在于，即使你在那个端口上有一些东西，使用<code class="du lu lv lw ll b">-Dserver.port</code>在不同的端口上启动它也是微不足道的。</p><h1 id="dd3d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">模板引擎</h1><p id="1ba7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Spring Boot广泛支持Freemarker、Velocity和百里香。这三个我都用过，但据我所知，大多数是用Freemarker，而百里香主要是用于HTML。该项目需要Java代码生成，Freemarker可以做到这一点(Velocity也可以)。这不是我自己做过的事(用Freemarker ),但是有很多样本代码。我仍然不确定它是否能很好地满足我的需求，但是当我们生成源代码时，我们会知道的。</p><p id="707e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，我只是添加了依赖项，还没有编写一行Freemarker资源模板…我不确定它是否合适，或者对于成品来说是否足够。我们得看看那件事。</p><p id="b12a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论哪种方式，我们都可以在稍后将它与Spring MVC一起用于一个简单的web应用程序UI。</p><h1 id="9d1d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Java 11全面普及</h1><p id="aaf4" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我想用Java 17。当我用Java 17作为JDK开始甚至生成第一个项目时，我真的想这么做。我的思考过程围绕着使用Java 17和GraalVM来编译它，但是它还不支持17，Spring Boot也不能用Freemarker编译到native。</p><p id="8ce9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以现在我标准化了Java 11，随着这些项目的成熟，我会重新评估，把我从JDK更新周期中解放出来。</p><h1 id="fa10" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">龙目岛和皮科岛CLI</h1><p id="666b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">因为我要用JDK 11号，不能用唱片，所以我用了龙目岛。我知道这是有争议的，但是到目前为止它对我来说是有效的，并且支持Spring Boot本地编译。我认为许多人讨厌Lombok，因为他们在Spring Data/JPA代码中误用了equals/hashcode支持。这将导致问题，正如我在这里提到的<a class="ae jo" href="https://talktotheduck.dev/hashcode-and-equals-debugging-performance" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1d91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于命令行界面，我使用了<a class="ae jo" href="https://picocli.info/" rel="noopener ugc nofollow" target="_blank"> PicoCLI </a>。很久以前我就想写它了，但被其他事情耽搁了。当我们开始运行Lightrun时，我研究了许多用于Java的CLI工具。他们都很糟糕。我和其他人一样喜欢固执己见的方法，但是他们真的不让我定义CLI代码的语法。</p><p id="c390" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我已经放弃的时候，我尝试了Pico CLI。我的期望很低，但完全被吹走了。它易于使用，同时功能强大。我再也不想看到一个<code class="du lu lv lw ll b">argv</code>！</p><h1 id="4df2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一个启示和战略转变</h1><p id="d4e4" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我花了几个月的时间到处思考滴滴涕。许多架构在我脑海中循环，最终我选定了一个。我可以很好地看到大场景…</p><p id="a0e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，当我开始搭建Spring Boot代码时，我开始意识到这种方法是完全错误和浪费的。这通常是设计的问题。一旦我们将一些事情提交到一个文档中，并跟随“团队”前进，我们经常会觉得我们已经和我们选择的方向结婚了。我们无法“感受”一个设计。当我开始在Spring Boot编写代码时，这种方法变得更加清晰。</p><p id="836a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最初的方法由三部分组成:</p><ol class=""><li id="02c8" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn lx ky kz la bi translated">在目标虚拟机中运行的代理，与Spring Boot后端通信</li><li id="7f99" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lx ky kz la bi translated">存储代理状态的Spring Boot后端</li><li id="77e6" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lx ky kz la bi translated">与Spring Boot后端通信的CLI工具</li></ol><p id="f911" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我开始想:我们到底为什么需要一个经纪人？</p><p id="671c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我最初的方法，因为大多数工具都是这样构建的，但这个特定的工具只能利用JDI API，而不是代理API。如果我们这样做了，我们甚至不需要离开舒适的Spring Boot。这可能意味着我们可以升级到Java 17，而目标虚拟机仍然可以运行Java 8，如果我们愿意的话。</p><p id="60b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在最初的架构中，我考虑了类文件操作来适应字节码。</p><p id="1652" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种架构更加简单快捷。它将减少一些通信，应该工作良好。希望规模合适。</p><h1 id="575f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">数据模型</h1><p id="a32b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我今天主要关注的是数据模型。将正确的字段放置到位，并定义调试过程将存储调用的结构。我在后端spring框架代码和CLI代码之间共享了数据模型。</p><p id="c5d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我还是一个年轻的程序员时，有一条公理:正确的数据结构是项目所需工作的50%。我不知道是不是50%，但是当你考虑数据模型的时候，项目的拼图就到位了。</p><h1 id="a1d3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">单一回购</h1><p id="0aeb" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我选择了单一回购方式，而不是多个项目。这背后有几个原因:</p><ul class=""><li id="a811" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">这更容易，我们有一个版本，我们在一个地方更新所有的部分</li><li id="995d" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">开始/跟随/分叉的一个位置</li><li id="1108" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">CI和集成测试要容易得多</li><li id="b72d" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">一点是拥有所有的文件，而不是把人们送上一条采摘樱桃的道路</li></ul><p id="8615" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我开始使用git时，人们说服我拆分我的回购，因为“git就是这么用的”。我愚蠢地听信了那个…巨大的错误。</p><h1 id="723a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">CI、声纳和Snyk</h1><p id="bb34" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我不喜欢代码评审，对声纳云也不太感冒。在PR上得到一个错误消息从来都不是一件有趣的事情…但是它捕捉到了错误并且做得相当好。不像人类评论家，它是迅速的，一致的和彻底的。这有点“极端”，它的一些吹毛求疵让我抓狂，但我觉得它让我成为一名更好的程序员。它真的在我的初始代码中发现了错误，这很神奇，因为代码很少。我喜欢错误消息是主动的，并且有很好的建议。再说一次，比大多数人都要好。</p><p id="c556" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我疯狂的一件事是，我收到一些“代码气味”警告，这些警告完全没问题，但我不能“删除它们”。例如，我需要使用<a class="ae jo" href="https://github.com/ddtj/ddtj/blob/main/Backend/src/main/java/dev/ddtj/backend/javadebugger/MonitoredSession.java#L20-L23" rel="noopener ugc nofollow" target="_blank">com . sun API</a>,因为没有Java API可供选择。这是一个有文档记录的API，但仍然…或者有一个警告，建议我在<a class="ae jo" href="https://github.com/ddtj/ddtj/blob/main/Backend/src/main/java/dev/ddtj/backend/javadebugger/MonitoredSession.java#L86-L106" rel="noopener ugc nofollow" target="_blank">这个块</a>中使用Maps computeIfAbsent而不是<code class="du lu lv lw ll b">get()</code>。一般来说，我会接受的。但是我在这个过程中使用了同步，并且缩小了锁的范围。所以我想在完成“计算”后从那个块返回。这使得锁的效率更高(可以说，因为走出锁而进入另一个锁是有细微差别的...</p><p id="dec8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不管怎样，总是看着警告让我觉得我在做错事。</p><p id="233d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将它集成到GitHub actions中，这很容易做到，并为CLI和Spring Boot后端代码添加了工件。因此，当一些东西开始工作，我们将有历史性的建设等。开始工作。相当整洁。</p><p id="9a3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我添加了<a class="ae jo" href="https://snyk.io/" rel="noopener ugc nofollow" target="_blank"> Snyk </a>，这对于当前的漏洞状态似乎是必不可少的。既然它对开源项目是免费的，我们应该试着让它出现在我们所有的回购上。集成很简单，这很好。不幸的是目前徽章似乎正遭受<a class="ae jo" href="https://github.com/snyk/snyk/issues/347" rel="noopener ugc nofollow" target="_blank">这个问题</a>。</p><p id="c844" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码就在那里；(目前)看起来没什么，但构建项目的基本框架正在形成。</p><h1 id="57ab" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">明天</h1><p id="028e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这是忙碌的一天，如果你跟踪这个项目，代码正在充实。我目前的主要工作是调试API和将我们需要的核心数据导入Spring Boot后端。</p><p id="c7e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以明天我打算更多地讨论这个问题。使用JDI和网络界面。我还将讨论代码覆盖、测试等。我甚至可能开始研究我写的代码，讨论我为什么做各种事情。现在它仍然有点太抽象，有代码，但我不知道它是否有任何好处。</p><p id="2136" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你觉得这很有趣/有用，你可以在twitter上关注我，我在那里发布我做的一切。爸爸开玩笑说…</p></div></div>    
</body>
</html>