# 好消息和坏消息，支点和转向—构建 DDTJ 第 6 天

> 原文：<https://medium.com/javarevisited/good-news-and-bad-news-pivot-and-turn-building-ddtj-day-6-3795d30882b9?source=collection_archive---------2----------------------->

![](img/0d5812a8312ff4e73195512c4456060b.png)

上周我[花了 5 天时间建造和设计](https://dev.to/codenameone/series/15971)的 [DDTJ 项目](https://github.com/ddtj/ddtj)。希望我能在这个周末完成 MVP。当我们上周离开这个系列时，我被卡住了。本周有一点进步…

关于好消息/坏消息的笑话有很多变体。我相信你们都知道它的一些形式…这里有一个面向编程的:

本着这种精神，我已经取得了一些进展，我们现在正在收集一些数据…坏消息是:我不得不放弃许多概念，性能比没有我们的仪器大约差 700 倍。呃。

# 我是怎么到这里的？

上周，在调试远程虚拟机时，我还在对本地存储的对象进行建模。您可能还记得，debug API 需要在本地复制对象，以便我们稍后可以分析它们。我们不能将它留在目标虚拟机中，因为随着虚拟机的继续运行，数据将会丢失。

我创建了一个数据模型并实现了一个调试器，它可以有效地自动调试应用程序并存储所有数据。不幸的是，这并不像人们希望的那么简单。

最初，我想我应该使用 step over API 来检查单独的行。这包括一些问题:

*   不看源代码/字节码，我不知道一行包含什么，我也不想陷入这种复杂性
*   我不能同时有两个跨越监视器的实例。这是嵌套方法调用、线程等需要的东西。

所以使用单步执行代码的方法对于这个工具来说是不实际的…

# 方法进入/退出

幸运的是，几乎所有调试 API 都支持设置方法进入/退出事件。这让我们可以监控所有重要的点，并记录所有相关的信息。完美…几乎…

问题是，假设我们有这样的代码:

```
public void myMethod(int x) {
    otherObject.otherMethod(x, y);
}
```

对于这个序列，我将得到 4 个事件:

```
Method enter to myMethod
Method enter to otherMethod
Method exit on otherMethod
Method exit on myMethod
```

到目前为止，一切顺利。但问题是。我需要记录在`myMethod`中对`otherMethod`的调用，这样我可以在以后模拟它。

我该怎么做？

我们需要分析数据，并查看与`myMethod`的呼叫层级相关的数据。

解决方案是以某种方式知道进入事件和退出事件是相关的。最初，我试图动态创建退出事件，并将其限制到特定的对象实例。但是递归失败了。

我尝试了几种方法。我现在有一个能用的，但是不理想…

# 当前的方法

当方法进入时，我创建一个唯一可重复的字符串。它大致由以下公式构成:

```
threadId + object instance id (if not static) + frame count + callstack
```

这是一个相对较长的字符串，但它是唯一的。当输入一个方法时，我们在地图中放置一个对象，并以此作为键。然后，当退出该方法时，我们使用相同的键找到对象。

现在，我们可以连接方法入口/出口，从而记录我们需要的所有数据。

# 表演

不幸的是，这还不够。`700x`远高于调试环境中合理的`10x`或可承受的`20x`性能下降。通常我们需要远离过早的优化，但是如果架构中有概念上的缺陷，我们需要理解它。`700x`这不是我们可以实际操作的。

因此，我的下一个重点是为拉请求准备好当前的代码，然后继续了解性能影响以及到底是什么导致了这种开销。

关于这个问题，我有很多理论，但是经验告诉我不要去理会它们。很多时候，我们认为“昂贵”的东西实际上只是一个小小的凸起。我们贴现的东西最终成为了巨大的损失。侧写员会告诉我们时间浪费在哪里，我可以根据事实进行评估。现在我不想看。如果我这样做了，我将不能停下来，重要的是停下来，与主干同步并迭代地移动。

# 明天

这是一个简短的帖子，因为我还在忙于发布 PR 和加快测试速度。一旦完成，我希望能进入侧写阶段。
按照目前的速度，我认为我最初的目标是拥有一个可以为 spring boot 生成测试的工具，这个目标可能在本周会很高。我将降低对调试 hello world 应用程序和生成简单测试用例的期望。在我经历了这个 API 的所有事情之后，这看起来也是一个相当雄心勃勃的目标。

如果你想了解这个系列的最新进展以及我从事的许多其他工作，那么[在 twitter 上关注我](https://twitter.com/debugagent)。