<html>
<head>
<title>Spring Data Projections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">春季数据预测</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-data-projections-6f4e56023795?source=collection_archive---------1-----------------------#2021-06-22">https://medium.com/javarevisited/spring-data-projections-6f4e56023795?source=collection_archive---------1-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="401a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring数据预测快速介绍！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2839a96d0c18d19692d6851ad7f7bfc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3t6WOu5JxwRMuEWprQ3Zg.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">伊恩·杜利在Unsplash<a class="ae jt" href="https://unsplash.com/s/photos/neat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><p id="c81d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring Data支持存储库中的定制查询，开发人员只需要按照一套方式为他们正在寻找的功能编写存储库方法。至少对于大多数类型的搜索来说，只需在接口中定义方法就可以了。开发人员选择要搜索的功能和字段，创建方法并传入所需的参数，方法就会做它应该做的事情。</p><p id="563f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这非常简单明了。但是假设您不希望(无论出于什么原因)将整个实体或对象作为查询的一部分返回。假设您只需要原始实体的字段子集:Spring data projections to the rescue！</p><p id="d65d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring支持不同类型的投影:基于接口、基于类和动态投影。出于本文的考虑，我将坚持使用基于接口的投影。Spring数据文档中有关于<a class="ae jt" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#projections.dtos" rel="noopener ugc nofollow" target="_blank">其他类型</a>的精彩信息！</p><p id="4f5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们开始之前，我使用了以下版本的工具和语言:</p><ul class=""><li id="5b61" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">科特林 : 1.4.21</li><li id="5057" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">等级 : 6.7.1</li><li id="0953" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated"><a class="ae jt" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e?source=---------39------------------"> Spring Boot </a> : 2.4.1</li><li id="9c52" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">JDK: 15人</li></ul><p id="6a5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于这一点，让我们一步一步地讨论如何使用spring数据预测，使用书籍作为我们想要管理的资源:</p><h2 id="3854" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">步骤1:定义实体</h2><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="10dd" class="ki kj hi le b fi li lj l lk ll">import javax.persistence.Entity<br/>import javax.persistence.GeneratedValue<br/>import javax.persistence.Id<br/><br/>@Entity<br/>class BookEntity(<br/>    val name: String,<br/>    val author: String,<br/>    val isSeries: Boolean,<br/>    val yearPublished: Int,<br/>    val publisherName: String,<br/>    val genre: String<br/>) {<br/><br/>    @Id<br/>    @GeneratedValue<br/>    var id: Long = 0<br/><br/>    override fun equals(other: Any?): Boolean {<br/>        if (this === other) return true<br/>        if (<em class="lm">javaClass </em>!= other?.<em class="lm">javaClass</em>) return false<br/><br/>        other as BookEntity<br/><br/>        if (name != other.name) return false<br/>        if (author != other.author) return false<br/>        if (isSeries != other.isSeries) return false<br/>        if (yearPublished != other.yearPublished) return false<br/>        if (publisherName != other.publisherName) return false<br/>        if (genre != other.genre) return false<br/><br/>        return true<br/>    }<br/><br/>    override fun hashCode(): Int {<br/>        var result = name?.hashCode() ?: 0<br/>        result = 31 * result + (author?.hashCode() ?: 0)<br/>        result = 31 * result + isSeries.hashCode()<br/>        result = 31 * result + (yearPublished ?: 0)<br/>        result = 31 * result + (publisherName?.hashCode() ?: 0)<br/>        result = 31 * result + (genre?.hashCode() ?: 0)<br/>        return result<br/>    }<br/><br/>    override fun toString(): String {<br/>        return "BookEntity(" +<br/>                "name='$name', " +<br/>                "author='$author', " +<br/>                "isSeries=$isSeries, " +<br/>                "yearPublished=$yearPublished, " +<br/>                "publisherName='$publisherName', " +<br/>                "genre='$genre', " +<br/>                "id=$id" +<br/>                ")"<br/>    }<br/>}</span></pre><p id="6e01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们定义了一个非常简单的类来管理书籍。我们让ID字段自动生成(这样用户就不必为它设置一个值),所有其他字段都是必需的！</p><h2 id="3401" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">步骤2:定义存储库</h2><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="bcfb" class="ki kj hi le b fi li lj l lk ll">import org.springframework.data.repository.CrudRepository<br/><br/>interface BookRepository : CrudRepository&lt;BookEntity, Long&gt; {<br/><br/>    fun findByAuthor(author: String): List&lt;BookEntity&gt;<br/>}</span></pre><p id="a8ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们定义一个简单的存储库来管理书籍。为了简单起见，我们假设不需要任何分页或排序功能。所以我们只是从<a class="ae jt" href="https://www.java67.com/2021/01/spring-data-jpa-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"> Spring Data的</a> <code class="du ln lo lp le b">CrudRepository</code>延伸。</p><h2 id="b10c" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">步骤3:使用存储库保存和检索数据</h2><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="955a" class="ki kj hi le b fi li lj l lk ll">import org.springframework.beans.factory.annotation.Autowired<br/>import org.springframework.boot.CommandLineRunner<br/>import org.springframework.boot.autoconfigure.SpringBootApplication<br/>import org.springframework.boot.runApplication<br/><br/>@SpringBootApplication<br/>class Application : CommandLineRunner {<br/><br/>   @Autowired<br/>   private lateinit var bookRepository: BookRepository<br/><br/>   override fun run(vararg args: String?) {<br/>      bookRepository.saveAll(<br/>         <em class="lm">listOf</em>(<br/>            BookEntity(<br/>               name = "Harry Potter and the Chamber of Secrets",<br/>               author = "J K Rowling",<br/>               isSeries = true,<br/>               yearPublished = 1998,<br/>               publisherName = "Bloomsbury Publishing",<br/>               genre = "Fantasy"<br/>            ),<br/>            BookEntity(<br/>               name = "Harry Potter and the Goblet of Fire",<br/>               author = "J K Rowling",<br/>               isSeries = true,<br/>               yearPublished = 2000,<br/>               publisherName = "Bloomsbury Publishing",<br/>               genre = "Fantasy"<br/>            ),<br/>            BookEntity(<br/>               name = "Harry Potter and the Deathly Hallows",<br/>               author = "J K Rowling",<br/>               isSeries = true,<br/>               yearPublished = 2007,<br/>               publisherName = "Bloomsbury Publishing",<br/>               genre = "Fantasy"<br/>            ),<br/>            BookEntity(<br/>               name = "Lord of the Rings: The Fellowship of the Ring",<br/>               author = "J.R.R. Tolkien",<br/>               isSeries = true,<br/>               yearPublished = 1954,<br/>               publisherName = "Allen &amp; Unwin",<br/>               genre = "Adventure"<br/>            ),<br/>            BookEntity(<br/>               name = "The Lion, the Witch, and the Wardrobe",<br/>               author = "C. S. Lewis",<br/>               isSeries = true,<br/>               yearPublished = 1950,<br/>               publisherName = "Geoffrey Bles",<br/>               genre = "Children's Fantasy"<br/>            ),<br/>            BookEntity(<br/>               name = "Gone Girl",<br/>               author = "Gillian Flynnp",<br/>               isSeries = false,<br/>               yearPublished = 2012,<br/>               publisherName = "Crown Publishing Group",<br/>               genre = "Thriller"<br/>            )<br/>         )<br/>      )<br/><br/>      bookRepository.findByAuthor("J K Rowling")<br/>         .<em class="lm">forEach </em><strong class="le hj">{ </strong>book <strong class="le hj">-&gt; </strong><em class="lm">println</em>(book) <strong class="le hj">}<br/>   </strong>}<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   <em class="lm">runApplication</em>&lt;Application&gt;(*args)<br/>}</span></pre><p id="d896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的数据库目前没有数据。所以我们首先加载一些数据。我们添加了一些<a class="ae jt" rel="noopener" href="/hackernoon/top-5-spring-boot-and-spring-cloud-books-for-java-developers-75df155dcedc?source=---------23------------------">书籍</a>，然后作者使用我们在存储库中创建的自定义查询获取它们。</p><p id="ccdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们此时运行此应用程序，我们将在日志中看到以下内容:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="6993" class="ki kj hi le b fi li lj l lk ll">BookEntity(name='Harry Potter and the Chamber of Secrets', author='J K Rowling', isSeries=true, yearPublished=1998, publisherName='Bloomsbury Publishing', genre='Fantasy', id=1)</span><span id="4128" class="ki kj hi le b fi lq lj l lk ll">BookEntity(name='Harry Potter and the Goblet of Fire', author='J K Rowling', isSeries=true, yearPublished=2000, publisherName='Bloomsbury Publishing', genre='Fantasy', id=2)</span><span id="8a38" class="ki kj hi le b fi lq lj l lk ll">BookEntity(name='Harry Potter and the Deathly Hallows', author='J K Rowling', isSeries=true, yearPublished=2007, publisherName='Bloomsbury Publishing', genre='Fantasy', id=3)<br/></span></pre><h2 id="0d5c" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">步骤4:引入投影！</h2><p id="46a9" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">假设我们只想获得某个作者写的书名，而不是获得关于书籍的所有信息。因此，我们用一个方法创建了一个接口，该方法以<code class="du ln lo lp le b">get</code>开头，后跟我们要检索的字段的名称(在我们的例子中是<code class="du ln lo lp le b">name</code>)。</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="b0b4" class="ki kj hi le b fi li lj l lk ll">import org.springframework.beans.factory.annotation.Value<br/><br/>interface BookName {<br/><br/>    fun getName(): String<br/>}</span></pre><h2 id="c158" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">步骤5:更新存储库</h2><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="e425" class="ki kj hi le b fi li lj l lk ll">import org.springframework.data.repository.CrudRepository<br/><br/>interface BookRepository : CrudRepository&lt;BookEntity, Long&gt; {<br/><br/>    fun findByAuthor(author: String): List&lt;BookName&gt;<br/>}</span></pre><p id="f419" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们更新了<code class="du ln lo lp le b">findByAuthor</code>方法的返回类型，以返回一个<code class="du ln lo lp le b">BookName</code>对<code class="du ln lo lp le b">BookEntity</code>的列表。作为最后一步，我们还更新了打印语句以打印投影方法</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="fd68" class="ki kj hi le b fi li lj l lk ll">bookRepository.findByAuthor("J K Rowling")<br/>   .<em class="lm">forEach </em><strong class="le hj">{ </strong>bookName <strong class="le hj">-&gt; </strong><em class="lm">println</em>(bookName.getName()) <strong class="le hj">}</strong></span></pre><h2 id="e871" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">步骤6:行动中的预测</h2><p id="2383" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">现在，当我们运行我们的应用程序时，我们应该会在控制台中看到以下内容:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="451f" class="ki kj hi le b fi li lj l lk ll">Harry Potter and the Chamber of Secrets<br/>Harry Potter and the Goblet of Fire<br/>Harry Potter and the Deathly Hallows</span></pre><h2 id="fa87" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">第七步:另一种投影方法</h2><p id="6f65" class="pw-post-body-paragraph if ig hi ih b ii lr ik il im ls io ip iq lt is it iu lu iw ix iy lv ja jb jc hb bi translated">如果我们想将<code class="du ln lo lp le b">BookEntity</code>中的多个字段合并成投影界面中的一个字段，我们可以将<code class="du ln lo lp le b">getName()</code>方法更新为:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="ca7e" class="ki kj hi le b fi li lj l lk ll">import org.springframework.beans.factory.annotation.Value<br/><br/>interface BookName {<br/><br/>    @Value("#{target.name + ', ' + target.yearPublished}")<br/>    fun getName(): String<br/>}</span></pre><p id="6583" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们运行应用程序时，我们应该会在日志中看到以下内容:</p><pre class="je jf jg jh fd ld le lf lg aw lh bi"><span id="54a9" class="ki kj hi le b fi li lj l lk ll">Harry Potter and the Chamber of Secrets, 1998<br/>Harry Potter and the Goblet of Fire, 2000<br/>Harry Potter and the Deathly Hallows, 2007</span></pre></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="ac12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">春季数据预测就是这么简单方便！如需进一步阅读，请参考Spring Data JPA关于<a class="ae jt" href="https://docs.spring.io/spring-data/jpa/docs/1.10.1.RELEASE/reference/html/#projections" rel="noopener ugc nofollow" target="_blank">预测</a>的文档！</p></div></div>    
</body>
</html>