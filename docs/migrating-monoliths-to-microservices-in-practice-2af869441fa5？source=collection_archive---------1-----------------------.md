# 在实践中将单片迁移到微服务

> 原文：<https://medium.com/javarevisited/migrating-monoliths-to-microservices-in-practice-2af869441fa5?source=collection_archive---------1----------------------->

[![](img/795cfa3914c740787645e5a96537b685.png)](https://javarevisited.blogspot.com/2021/09/microservices-design-patterns-principles.html)

已经有很多关于从整体架构迁移到微服务架构的文章，例如[这可能是一个更好的例子](https://martinfowler.com/articles/break-monolith-into-microservices.html)。这些架构的优点和缺点应该非常清楚。不过，我想谈谈别的东西:战略。我们建造巨石柱，因为它们更容易开始。当我们的系统已经投入生产时，微服务通常出于需要而出现。

然而，在决定何时进行迁移或不进行迁移时，会出现许多问题——如何决定服务的边界？你如何验证你的[微服务架构](/javarevisited/8-best-online-courses-to-learn-service-oriented-soa-and-microservices-architecture-94c01d6b94e6)的自愈性能？

对于服务网格的分布式方面，这尤其具有挑战性。我们需要一个完整的应用程序视图，因为它的一些部分已经分离了。我们的目标是保持我们在传统整体建筑中的便利性，同时避免伴随地域而来的紧密耦合。在本文中，我将概述一些在进行这种迁移时可以使用的实用方法。

# 决定

我强烈支持“从一个整体开始”的阵营，它应该是一个模块化的整体，这样我们就可以很容易地分解它。有这样一个神话:一整块石头是“相互关联的代码块”。事实远非如此，大多数单片使用现代编程语言的能力(例如包、模块等)。)来分离各个片段。

模块化整体的各个部分之间的调用通过明确定义的接口或事件总线进行。我支持单片应用的立场可能源于我的 Java 背景，因为 [Java](/javarevisited/10-best-places-to-learn-java-online-for-free-ce5e713ab5b2) 特别适合大型单片应用。根据您的架构、语言、问题领域等不同，您分割代码库的点会完全不同。

在这方面你如何做出客观的选择？何时是开始向[微服务](/javarevisited/7-free-microservices-courses-for-java-programmers-c9b2f3a2ea7d)迁移的最佳时机？

微服务架构迁移最重要的先决条件是授权分离。如果不将其作为外部服务分离出来，可能就没有前进的空间了。这是微服务迁移中最困难的部分。

这件事的好处是，你可以采取这一步，同时保持整体架构。如果您不能执行迁移，那么前进就毫无意义。一旦做到这一点，还有其他几个因素涉及:

*   团队规模 —随着团队的成长，保持凝聚力是一项挑战。通过回顾团队的成长，我们可以很容易地确定这一点。关注入职速度和其他指标，如问题解决时间。这些可能是项目复杂性的最佳度量。
*   **相互依赖** —如果项目高度相互依赖，并且没有清晰的分割线，微服务的好处可能会成为阻碍。一些项目本质上是混合在一起的，没有清晰的部分分离。注意不同模块之间的事务完整性。事务管理等功能无法在微服务之间携带。如果您有一个必须可靠一致的系统，比如一个需要始终一致的银行系统，那么事务的边界必须位于单个服务中。这些类型的事情会使迁移过程变得特别困难。
*   **测试**——如果没有大量的特定模块测试和一大套集成测试，你不可能完成这样的工作。审查测试代码将比其他任何方法更能告诉你你的准备情况。你能在逻辑上孤立地测试一个模块吗？

一旦你有了这些概念，你就可以开始估算从整体迁移到微服务的好处。

# 我们从哪里开始？

假设整体代码已经相对模块化并支持 SSO(单点登录)，我们可以选择任何我们想要的模块。我们如何知道哪一个会对我们投入的时间和精力有最好的回报呢？

理想情况下，我们希望瞄准能给我们带来最大好处并且最容易迁移的部分:

*   **看问题跟踪器/版本控制** —哪个模块最容易出故障？
*   **检查模块性** —哪个模块最小且最不相互依赖？数据能干净地分开吗？—最好从悬挂较低的水果开始
*   **分析您的应用** —哪个模块最昂贵，并且可以从扩展中受益？

当在本地运行时，这些事情非常简单，但是应用程序在生产环境中的行为通常与其本地或暂存环境有很大的不同。在这些情况下，我们可以使用开发人员可观察性工具，如运行时行计数器来评估使用情况。当我们选择要突破的模块时，我们需要在利益和效用之间取得平衡。

# 避免微小的整体架构

人们经常背诵微服务的租户，但继续构建一些不遵循一般规则的东西。“自愈”是最明显的例子。

将一个整体的各个部分解耦到一个微服务应用程序中是非常困难的。我们需要分离出各个部分，并确保每一部分在大规模下都能正常工作。或者更糟，在停工期间。

当一个可部署的服务关闭时，系统如何生存？我们如何测试这样的东西？

这种架构中最大的问题之一是部署的规模。我们将单个服务包装在发现系统、API 网关和断路器中，以实现修复特性。通常 API 网关(和类似的服务)是基于 SaaS 的解决方案，但是即使我们自己部署了它们，准确地复制我们的产品也是很困难的。

典型的复杂性包括将 URL 编码到网关和实际代码中。偶然绕过网关，直接到达服务器或底层基础设施。这些都是在遗留代码和大型系统中难以发现的微妙之处。

由于这种复杂的拓扑结构，在本地工作时，正确测试修复行为几乎是不可能的。你得到的任何结果都是不准确的，因为部署的后勤工作千差万别。

但是我们不能仅仅为了证明一个观点就让一个生产微服务瘫痪。对吗？

这是[微服务架构](/javarevisited/10-best-java-microservices-courses-with-spring-boot-and-spring-cloud-6d04556bdfed)的巨大优势之一。在发现代码中，我们可以添加一个特例，为特定用户提供“虚拟”或失败的微服务。问题是，症状可能很难验证，因为“自我修复”服务看起来好像在运行。在这种情况下，我们可以使用[日志](https://docs.lightrun.com/logs/)或[快照](https://docs.lightrun.com/snapshots-plugin/)来验证是否到达了正确的代码，模块是否确实断开。

例如，我们可以使用大多数 API 网关来模拟 API 的不可用性。然后，我们可以通过调用一个调用并验证断路器是否被触发以及结果是否仍在到达来检查其他服务是否按预期工作。我们的系统似乎痊愈了。但也许某些用户代码直接调用了 webservice 并有效地绕过了 API 网关？如何验证缓存中的一切都正常工作，并使用您期望的回退？

这就是日志和快照的用武之地。我们可以在后端 API 和中断服务中添加它们，以验证我们得到的结果确实是来自网关缓存的结果。

# 冲洗—重复

当我们将第一个微服务从单一应用中分离出来时，这个过程是最具挑战性的。当我们打破更多的碎片时，通常会变得更容易，直到整个整体消失。但是在前进的道路上也有挑战。最初，我们选择一个更容易实现的目标。随着我们向前发展，我们会遇到更大的挑战，并且需要确定可能不太理想的服务的界限。

问题是我们经常需要根据直觉采取这些步骤。但是当我们创建模块时，我们可能使用了逻辑分离而不是相互依赖。

因此，两个模块可能有很深的依赖性，作为微服务可能没有意义。将它们拆分到不同的位置，甚至将它们捆绑在一起可能更有意义。例如，我们可能有一个管理多个账户的会计系统。

逻辑分离可能会将在帐户之间转移资金的代码移到单独的模块中。但这将使事情变得非常困难。在会计系统中，钱必须从一个账户到另一个账户，它永远不会“消失”。当我们把钱存入一个账户时，我们必须把钱从另一个账户中减去，两者都需要在一次交易中完成。

一个简单的解决方法可能是在一个请求中完成资金的扣除和转移。然而，这并不能解决一般的问题，因为钱可以从一个账户中取出来，然后分散到多个账户中。在多个小手术中这样做，会产生副作用。这是可行的，但就我个人而言，在这种情况下，我会将核心会计逻辑与账户系统放在一起。

其中一些相互依赖关系可以从代码中推断出来并被重构掉。转换成消息传递和异步调用。使用消息服务是解耦最有效的方法之一。许多语言和平台支持不同部分之间的模块屏障。这让我们可以将整个模块与应用程序的其余部分隔离开来，并将交互限制在一个狭窄的界面上。通过设置这样的障碍，我们可以使用编译器和 IDE 来加强模块限制。

# 最后

分解单一的应用程序总是具有挑战性。将业务逻辑隔离到正确的领域需要时间和精力。特定服务的通信开销和功能划分是在这种过程中产生差异的组件。没有交付保证，测试更加困难。由于 API 网关、代理设置、发现等原因，生产环境完全不同于开发环境。

遗留代码的成功迁移对客户来说是无缝的。对我们来说，它完全改变了动态。交付是不同的，验证部署是否成功远比使用单一应用程序更具挑战性。当一切正常时，用户体验是相似的，但是我们如何验证这一点呢？

这就是工具派上用场的地方，我们可以使用开发人员可观察性工具(日志、计数器、日志)来验证即使在生产失败的情况下，跨服务边界的修复仍然在工作。这不是一个微不足道的壮举，因为松耦合只是第一步。不同形式的故障期间的行为只能在生产中测试，我们不想仅仅为了证明一点而失败。