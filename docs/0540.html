<html>
<head>
<title>Upload and Retrieve files from AWS S3 using the pre-signed URL pattern in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java中预先签名的URL模式从AWS S3上传和检索文件</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/upload-and-retrieve-files-form-aws-s3-using-the-presigned-url-pattern-in-java-ecde26e9441f?source=collection_archive---------2-----------------------#2020-06-22">https://medium.com/javarevisited/upload-and-retrieve-files-form-aws-s3-using-the-presigned-url-pattern-in-java-ecde26e9441f?source=collection_archive---------2-----------------------#2020-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="18dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我学习AWS的过程中，我偶然发现了S3的预先设计的URL模式。在处理从云中上传和下载对象时，这种模式对于节省服务器带宽非常重要。</p><p id="a48b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本质上，它的工作方式是完全绕过服务器，将服务器从处理和等待上传/下载时间的负担中解放出来，并节省重要的资源(见图1)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/02/spring-security-interview-questions-answers-java.html"><div class="er es jd"><img src="../Images/0a0f227231a8c24af83eaec23da7cad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sBKdMJvZEklHmFPOlEfCHQ.png"/></div></a><p class="jl jm et er es jn jo bd b be z dx translated">图1:博客架构</p></figure><p id="bd42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于本教程的目的，我将使用这个简单的博客项目来说明这在<a class="ae jp" rel="noopener" href="/javarevisited/review-of-courseras-java-programming-software-engineering-fundamentals-specialization-4dcfa0ed2de4"> Java </a>中是如何工作的。该项目是一个博客网站的模拟，有一个Angular 8客户端和<a class="ae jp" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e?source=---------39------------------"> Spring Boot后端</a>和<a class="ae jp" rel="noopener" href="/javarevisited/7-best-free-postgresql-courses-for-beginners-to-learn-in-2021-3bf369d73794"> Postgres数据库</a>，当然，S3作为一个文件系统，用于保存“大”文件，关于该项目的更多细节和完整代码可以在我的<a class="ae jp" href="https://github.com/elmodeer/simple-blog-project" rel="noopener ugc nofollow" target="_blank"> gitHub </a>上找到。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="290c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将考虑的用例是当用户试图上传/更新他们的个人资料图片或文章缩略图时。采取以下步骤:<br/> 1-客户端请求上传/更新特定文件。<br/> 2-服务器从S3为该特定资源请求一个预先指定的URL。<br/> 3-服务器将URL发送回客户端。<br/> 4-客户端使用资源本身直接向S3发出上传/获取请求。</p><p id="e0c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看这是如何工作的，</p><h1 id="1e53" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">1-设置S3桶</h1><p id="bfb3" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">您需要设置一个<a class="ae jp" rel="noopener" href="/javarevisited/7-best-aws-s3-and-dynamodb-courses-for-beginners-in-2021-a8a44b6066da">S3 bucket</a>t并允许公众访问它，这可以通过在创建一个新bucket并编辑CORS配置后导航到permission选项卡来实现。将下面的代码片段粘贴到编辑器中，然后点击save。</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="9063" class="lf jy hi lb b fi lg lh l li lj">&lt;?xml version=”1.0" encoding=”UTF-8"?&gt;<br/>&lt;CORSConfiguration xmlns=”<a class="ae jp" href="http://s3.amazonaws.com/doc/2006-03-01/" rel="noopener ugc nofollow" target="_blank">http://s3.amazonaws.com/doc/2006-03-01/</a>"&gt;<br/>&lt;CORSRule&gt;<br/> &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt;<br/> &lt;AllowedMethod&gt;POST&lt;/AllowedMethod&gt;<br/> &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt;<br/> &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt;<br/> &lt;AllowedMethod&gt;DELETE&lt;/AllowedMethod&gt;<br/> &lt;AllowedMethod&gt;HEAD&lt;/AllowedMethod&gt;<br/> &lt;AllowedHeader&gt;*&lt;/AllowedHeader&gt;<br/>&lt;/CORSRule&gt;<br/>&lt;/CORSConfiguration&gt;</span></pre><p id="d515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，这绝不违反您的存储桶的安全性，因为除了您的服务器之外，没有人能够访问这个存储桶。通过它，你可以完全控制如何与它交互，以及谁有权访问其中的哪些文件。</p><h1 id="2787" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">2-客户端请求生成预先指定的URL</h1><p id="6f89" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">客户端可以请求两种预先指定的URL，一种是“放置”一个新资源，另一种是“获取”一个已经持久化的资源。</p><p id="8644" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两者都是对spring控制器的简单调用，负责生成带有文件名的URL。</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="4603" class="lf jy hi lb b fi lg lh l li lj">// for "PUT"<br/>generatePresignedPutUrl(file: File): Observable&lt;any&gt; {</span><span id="37d9" class="lf jy hi lb b fi lk lh l li lj">return this.http.get('http://localhost:8080/api/articles/putImage/'<br/>                     + file.name, { responseType: 'text' });</span><span id="b036" class="lf jy hi lb b fi lk lh l li lj">}</span><span id="966f" class="lf jy hi lb b fi lk lh l li lj">// for "GET"<br/>generatePresignedGetUrl(articleId: number): Observable&lt;any&gt;{</span><span id="5359" class="lf jy hi lb b fi lk lh l li lj">return this.http.get('http://localhost:8080/api/articles/getImage/'<br/>                     + articleId, { responseType: 'text' });</span><span id="fc51" class="lf jy hi lb b fi lk lh l li lj">}</span></pre><h1 id="4645" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">3- URL生成</h1><p id="23be" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">作为第一步，我们需要将AWS sdk导入到项目中，以便能够与任何AWS产品通信。导入可以通过maven依赖或Gradle来实现。之后，我们将有一个生成<a class="ae jp" href="https://javarevisited.blogspot.com/2016/10/difference-between-put-and-post-in-restful-web-service.html#axzz6poJhuerN" rel="noopener ugc nofollow" target="_blank">、【上传】、【获取】URL的方法。</a></p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="87e3" class="lf jy hi lb b fi lg lh l li lj">public static String generatePresignedUrl<br/>                           (String fileName, HttpMethod mehtod) {<br/>    try {<br/>        // Set the pre-signed URL to expire after 10 mins.<br/>        java.util.Date expiration = new java.util.Date();<br/>        long expTimeMillis = expiration.getTime();<br/>        expTimeMillis += 1000 * 60 * 10;<br/>        expiration.setTime(expTimeMillis);<br/><br/>        // Generate the pre-signed URL<br/>        GeneratePresignedUrlRequest generatePresignedUrlRequest =<br/>        new GeneratePresignedUrlRequest(<em class="ll">bucketName</em>, fileName)<br/>                .withMethod(mehtod)<br/>                .withExpiration(expiration);<br/>        URL url = <em class="ll">s3Client</em>.generatePresignedUrl(<br/>                                       generatePresignedUrlRequest);<br/>        <em class="ll">logger</em>.info("pre-signed URL for " + mehtod.toString() <br/>        + " operation has been generated.");<br/>        return url.toString();<br/>      } catch (Exception e) {<br/>        e.printStackTrace();<br/>      }<br/>     <em class="ll">logger</em>.error("URL could not be generated");<br/>     return null;</span></pre><p id="fb85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在生成URL之后，它们被发送回客户机，在客户机上附加所需的文件后，它们可以被执行。</p><h1 id="276a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">4.1 -执行PUT请求</h1><p id="13a1" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">在获得PUT url之后，文件可以直接附加到它上面并直接执行。我为此创建了这个助手函数。</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="bb94" class="lf jy hi lb b fi lg lh l li lj">uploadfileToAWSS3(fileuploadurl: string, file: File):  <br/>                                                 Observable&lt;any&gt;{</span><span id="1056" class="lf jy hi lb b fi lk lh l li lj">    const req = new HttpRequest(<br/>    'PUT',<br/>    fileuploadurl,<br/>    file, <br/>    {<br/>        reportProgress: true, // to track upload process<br/>    });<br/>    return this.http.request(req);<br/>}</span></pre><p id="6c29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，您可以在代码中的任何地方调用它并订阅它，还可以检查响应代码以确保它是一个成功的请求。</p><h1 id="0599" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">4.2 —执行GET请求</h1><p id="10b8" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">get请求更容易处理，我所做的只是将返回的预先签名的url绑定到HTML文件中<code class="du lm ln lo lb b">img</code>标记的“src”属性。</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="2ae8" class="lf jy hi lb b fi lg lh l li lj">// HTML<br/>&lt;img class="rounded" [src]=imageUrl *ngIf=imageUrl&gt;</span><span id="8b63" class="lf jy hi lb b fi lk lh l li lj">// Typescript<br/>  imageUrl: string;<br/>       .....<br/>  getImage(): void {<br/>     this.userService.generatePresignedGetUrl(this.user.id)<br/>         .subscribe(imageUrl =&gt; { <br/>                    this.imageUrl = imageUrl; <br/>         }),<br/>         (err: any) =&gt; {<br/>             console.log(err.error);<br/>         };<br/>  }</span></pre><p id="b6ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已。现在，预先设计的URL已经完全正常工作了。一个非常重要的问题是观察你从应用程序内部发出的请求，以及它们是否包含除了来自<a class="ae jp" rel="noopener" href="/javarevisited/5-best-aws-courses-for-beginners-and-experienced-developers-to-learn-in-2021-563212409fbd?source=rss-bb36d8439904------2&amp;utm_source=dlvr.it&amp;utm_medium=linkedin"> AWS </a>的<code class="du lm ln lo lb b">X-Amz-Algorithm</code>之外的任何其他认证机制。</p><p id="9f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您使用附加到请求的JWT身份验证头，就会发生这种情况。在这种情况下，您需要过滤来自该头的任何S3请求。</p><p id="4130" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这将有助于任何人绊倒在这些事情上。如果您有任何改进、更正或任何与代码相关的内容，欢迎发表评论。</p><p id="f553" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">相关资源</strong></p><p id="aa94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1- <a class="ae jp" href="https://github.com/elmodeer/simple-blog-project" rel="noopener ugc nofollow" target="_blank"> GitHub代码</a> <br/> 2- <a class="ae jp" href="https://docs.aws.amazon.com/AmazonS3/latest/dev/PresignedUrlUploadObjectJavaSDK.html" rel="noopener ugc nofollow" target="_blank"> AWS预签名URL </a></p></div></div>    
</body>
</html>