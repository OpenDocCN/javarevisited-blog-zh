<html>
<head>
<title>Current State of Spring Boot 2.7 Native with Kotlin (GraalVM)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 2.7的当前状态与Kotlin (GraalVM)原生</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/current-state-of-spring-boot-native-with-kotlin-graalvm-699b1812cc65?source=collection_archive---------0-----------------------#2022-10-08">https://medium.com/javarevisited/current-state-of-spring-boot-native-with-kotlin-graalvm-699b1812cc65?source=collection_archive---------0-----------------------#2022-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="11d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文介绍了使用<strong class="ih hj"> Kotlin 1.7 </strong>建立一个示例<strong class="ih hj"> Spring Boot </strong> <strong class="ih hj"> 2.7 </strong>项目，然后在GraalVM<strong class="ih hj"><em class="jd">native-image</em></strong>和Spring AOT(提前)插件的帮助下，将其编译成本地平台可执行文件的经验。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://www.java67.com/2020/05/5-free-courses-to-learn-kotlin-for-java-and-Android-developers.html"><div class="er es je"><img src="../Images/886ea49b6eb58a69c4d81889937fc5cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZC4g-0-xeGC1Kwv7lKMFw.png"/></div></a></figure><h1 id="8d69" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated"><strong class="ak">为什么</strong></h1><p id="ce56" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">用于运行大多数服务器端<a class="ae kp" rel="noopener" href="/javarevisited/top-5-courses-to-learn-kotlin-in-2020-dfc3fa7706d8"> Kotlin </a>程序的<a class="ae kp" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686"> JVM </a> (Java虚拟机)以启动和预热时间缓慢而闻名，之后才能提供最佳性能。</p><p id="02eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尤其是在快速扩展的云环境中，这可能是一个主要的缺点。此外，服务器程序的部署规模可能会非常大。GraalVM是由Oracle提供的，它的本机映像工具允许我们从任何JVM字节码中生成本机可执行文件(大小要小得多)。</p><p id="ef99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使得应用启动速度极快，无需任何预热。</p><p id="3cf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，总有一个陷阱:与运行在Hotspot JVM上的服务器程序相比，峰值性能较低，因为没有使用<a class="ae kp" href="https://javarevisited.blogspot.com/2011/12/jre-jvm-jdk-jit-in-java-programming.html" rel="noopener ugc nofollow" target="_blank"> JIT </a>(实时)编译器，因此不可能进行运行时优化。</p><p id="6a26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">(使用GraalVM企业版可以获得接近JIT的性能，这不是免费提供的)</em></p><h1 id="687f" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated"><strong class="ak">设置</strong></h1><p id="9018" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们希望创建一个典型的服务器应用程序，它将数据保存在H2内存数据库中，并公开一个简单的REST API进行交互。</p><p id="f0d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，我们使用<a class="ae kp" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e"> Spring Boot </a> (2.7)和<a class="ae kp" rel="noopener" href="/javarevisited/7-free-courses-to-learn-kotlin-in-2020-327c3872c1e1">科特林</a> (1.7)利用<a class="ae kp" rel="noopener" href="/javarevisited/7-best-webflux-and-reactive-spring-boot-courses-for-java-programmers-33b7c6fa8995">弹簧网通量</a>。对于数据库访问，我们将使用R2DBC，它支持异步数据库操作。总的来说，我尽可能多地使用Kotlin特有的特性来测试它们的原生支持。</p><h1 id="c248" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated"><strong class="ak">代码</strong></h1><p id="7a91" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我就不解释设立<a class="ae kp" href="https://javarevisited.blogspot.com/2022/08/how-to-test-spring-boot-application.html" rel="noopener ugc nofollow" target="_blank">基地Spring Boot申请</a>的来龙去脉了。完整的示例项目可以在<a class="ae kp" href="https://github.com/jonas-tm/spring-boot-kotlin-reactive-example" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="jd"> GitHub </em> </strong> </a>上找到。</p><div class="kq kr ez fb ks kt"><a href="https://github.com/jonas-tm/spring-boot-kotlin-reactive-example" rel="noopener  ugc nofollow" target="_blank"><div class="ku ab dw"><div class="kv ab kw cl cj kx"><h2 class="bd hj fi z dy ky ea eb kz ed ef hh bi translated">GitHub-Jonas-TM/spring-boot-kot Lin-reactive-example</h2><div class="la l"><h3 class="bd b fi z dy ky ea eb kz ed ef dx translated">在GitHub上创建一个帐户，为Jonas-TM/spring-boot-kot Lin-reactive-example开发做贡献。</h3></div><div class="lb l"><p class="bd b fp z dy ky ea eb kz ed ef dx translated">github.com</p></div></div><div class="lc l"><div class="ld l le lf lg lc lh jk kt"/></div></div></a></div><p id="d625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Gradle 设置使用了Spring Boot插件和实验性的Spring AOT插件，该插件内部包含了Spring Native所需的所有东西。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="6fd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面显示了简化的服务器设置。它包括一个协程CRUD存储库和初始数据创建器。该服务在根路径上公开了一个简单的<em class="jd">GET</em>REST端点。为此，我们使用Spring WebFlux协程路由器DSL(特定领域语言)。</p><p id="992c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了保持示例简短，News数据类用于持久化Spring数据，并作为REST API的返回类型，利用Kotlin序列化(<em class="jd"> @Serializable </em>)。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="e3b6" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated"><strong class="ak">本土形象</strong></h1><p id="a6f2" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">一旦我们设置好服务，我们就可以通过<code class="du lk ll lm ln b">./gradlew nativeRun</code>将它作为本地映像运行。为此，您必须设置以下内容:</p><ul class=""><li id="ab5d" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated"><strong class="ih hj"> GraalVM </strong>已安装，环境变量<code class="du lk ll lm ln b"><a class="ae kp" href="https://www.java67.com/2016/06/how-to-set-javahome-and-path-in-linux.html" rel="noopener ugc nofollow" target="_blank">JAVA_HOME</a></code>已设置(我推荐使用<a class="ae kp" href="https://sdkman.io/" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> sdkman </em> </a>)</li><li id="8f04" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj"> <em class="jd">原生-镜像</em> </strong> <a class="ae kp" href="https://www.graalvm.org/22.2/reference-manual/native-image/#install-native-image" rel="noopener ugc nofollow" target="_blank">已安装</a>并可达</li></ul><p id="a8d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring AOT插件将自动在构建管道中运行，以创建一个特殊的Spring Boot JAR，在编译成本机映像时需要运行这个JAR。它将尝试为您的程序创建所有需要的<a class="ae kp" href="https://www.graalvm.org/22.2/reference-manual/native-image/metadata/" rel="noopener ugc nofollow" target="_blank">可达性配置</a>，以便作为本机映像正常工作。</p><h1 id="adb6" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">问题1</h1><p id="b50e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">当我们启动应用程序时，它会在启动过程中崩溃，并显示以下消息:</p><blockquote class="mc md me"><p id="f413" class="if ig jd ih b ii ij ik il im in io ip mf ir is it mg iv iw ix mh iz ja jb jc hb bi translated">缺少kot Lin . internal . JDK 8 . JDK 8 platform implementations .<init>()的本机反射配置。</init></p></blockquote><p id="e7ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为代码中定义了<code class="du lk ll lm ln b">DataCreator</code>。如果仔细观察，您会发现它正在启动一个协程，用一些样本数据填充H2数据库。如果我们放弃使用协程，应用程序会正常启动。</p><p id="1e91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为<a class="ae kp" href="https://javarevisited.blogspot.com/2018/02/5-courses-to-learn-kotlin-programming-java-android.html" rel="noopener ugc nofollow" target="_blank">科特林</a>协程在内部使用反射，这是Spring AOT不支持的。我们也不能通过一个Spring AOT配置注释来定义它，因为错误消息中命名的类是一个内部类。这是一个众所周知的问题，不是Spring独有的，而是所有Kotlin程序的问题。这里有一张公开的bug票<a class="ae kp" href="https://youtrack.jetbrains.com/issue/KT-51579/PlatformImplementations-loading-is-not-compatible-with-graalvm-native-image-no-fallback" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd"/></strong></a>。</p><p id="67ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们必须手工定义一个<code class="du lk ll lm ln b">reflection-config.json</code>文件。下面的代码必须放在这里<code class="du lk ll lm ln b">/src/main/resources/META-INF/native-image/reflect-config.json</code>，由原生图像工具自动获取。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="6a89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们现在尝试将程序作为本机映像运行，它应该会正确启动。</p><h1 id="22af" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">问题2</h1><p id="3b26" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">当应用程序启动时，它似乎工作正常，但是，当我们调用端点时，我们得到以下错误:</p><blockquote class="mc md me"><p id="aa8b" class="if ig jd ih b ii ij ik il im in io ip mf ir is it mg iv iw ix mh iz ja jb jc hb bi translated">kotlin . reflect . JVM . internal . kotlinreflectioninternal错误:无法计算函数的调用方:公共构造函数新闻(…</p></blockquote><p id="909d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这表明新闻数据类没有被Spring AOT正确配置，也没有创建反射配置。</p><p id="618c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它没有被自动拾取的主要原因是我们使用WebFlux协同路由器DSL来定义REST端点。如果我们使用传统的方式(` @ <a class="ae kp" href="https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html" rel="noopener ugc nofollow" target="_blank"> RestController </a>和`<a class="ae kp" href="https://javarevisited.blogspot.com/2021/10/difference-between-requestmapping-and..html" rel="noopener ugc nofollow" target="_blank">@ get mapping</a>`)Spring AOT就会找到它。</p><p id="5821" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们可以利用Spring Native项目的特殊注释，它允许我们在代码中定义反射配置:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="d7e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">手动添加类型提示后，我们现在可以调用端点了。</p><p id="ca37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">边注</em> </strong> <em class="jd">:如果我们在一个单独的服务类中定义ServerResponse创建，而不是直接在路由器下定义，DSL Spring将无法正确注册返回类型并在本机映像中使用Jackson序列化而不是KotlinX序列化。唯一可能的解决方法是切换到端点的传统@RestController定义。</em></p><h1 id="a442" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated"><strong class="ak">启动时间</strong></h1><p id="4fe8" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">由于GraalVM本机映像最有趣的部分是启动时间，下面是我的Mac M1上的一些简单测试数据，来自Spring Boot日志:</p><ul class=""><li id="7817" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated"><strong class="ih hj"><em class="jd">JAR</em></strong><em class="jd">:</em>1.695秒(JVM运行为2.042)</li><li id="e38e" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj"> <em class="jd">本机镜像</em> </strong> : 0.076秒(JVM运行0.078)</li></ul></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><h1 id="0566" class="jm jn hi bd jo jp mp jr js jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj bi translated"><strong class="ak">结论</strong></h1><p id="ab63" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">正如人们可能会发现的那样，Kotlin与Spring Native和GraalVM原生映像的结合还没有准备好投入生产使用。然而，已经有可能创建一个简单的运行服务器，它可以按预期工作(在应用了一些修复之后)。</p><p id="524d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用本文中展示的方法，需要100%的测试覆盖率(利用本地测试)来确保一切按预期运行(确保没有反射配置丢失)。</p><p id="604f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我期待着Spring Native在未来改进对它的支持，特别是因为它将成为<strong class="ih hj"> Spring Boot 3 </strong>的一部分。Kotlin团队也在不断努力让Kotlin生态系统准备好与原生映像一起使用。激动人心的时刻就在前面，我们只需要再等一会儿。</p></div></div>    
</body>
</html>