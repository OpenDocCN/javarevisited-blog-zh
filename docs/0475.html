<html>
<head>
<title>Beyond Traditional Acceptance Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越传统的验收测试</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/beyond-traditional-acceptance-tests-79cbcee63eda?source=collection_archive---------1-----------------------#2020-06-04">https://medium.com/javarevisited/beyond-traditional-acceptance-tests-79cbcee63eda?source=collection_archive---------1-----------------------#2020-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1cc5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">杀虫剂:编写领域驱动测试的库</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2eed722a2e1aab1abd44a8db8fbd9262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*usZoi02Jfp2NuII6.jpg"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">瓢虫——一种天然杀虫剂。<a class="ae jn" href="https://pixabay.com/users/cocoparisienne-127419/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/users/cocoparisienne-127419/</a></p></figure><p id="01a7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对此我很抱歉，但我最近忽略了这个博客，原因是我目前正试图写一本书，解释如何用<a class="ae jn" rel="noopener" href="/javarevisited/top-5-courses-to-learn-kotlin-in-2020-dfc3fa7706d8">科特林</a>以函数方式编写完整的应用程序。这花费了我大量的时间，因为我需要解释函数式编程原理，同时还要编写一个真实的web应用程序(包括数据库、渐进式增强、身份验证)。等等。).嗯，我希望这是值得的努力。如果你感兴趣，你可以在这里注册更新<a class="ae jn" href="https://tinyurl.com/funkotlinbook" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="6072" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">顺便说一下，在写书的时候，我还创建了一个开源库来编写名为<a class="ae jn" href="https://github.com/uberto/pesticide" rel="noopener ugc nofollow" target="_blank">杀虫剂</a>的领域驱动测试。</p><p id="b4cf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我为伦敦Java社区做了一个介绍，解释了什么是DDT以及如何使用杀虫剂。</p><p id="0e35" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我也将在我自己的博客上谈论这件事，这似乎是公平的。先来个介绍。</p><h2 id="4745" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">领域驱动测试</h2><p id="bf03" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">最常见的自动化测试是所谓的单元测试。它们非常有用，但是它们在单个小单元上工作——因此得名——如果我们想以自动的方式验证我们的应用程序作为一个整体工作，我们需要编写一个不同粒度级别的测试。</p><p id="4e3e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://wiki.c2.com/?AcceptanceTest" rel="noopener ugc nofollow" target="_blank"> AcceptanceTests </a>是一种端到端测试我们的完整应用程序的方法，目的是确保它在正确的轨道上。传统的方法是记录用户与系统的交互，并在每次我们想要验证系统是否正确时回放。</p><p id="b532" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不幸的是，用这种方式编写测试会使它们很难理解，因为目标隐藏在关于用户交互的非本质细节之外。</p><p id="5afd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">纳特·普莱斯(因谷歌而出名的<a class="ae jn" href="http://www.growing-object-oriented-software.com/" rel="noopener ugc nofollow" target="_blank">)发明了</a><a class="ae jn" href="https://www.youtube.com/watch?v=Fk4rCn4YLLU" rel="noopener ugc nofollow" target="_blank">领域驱动的测试风格</a>，当他厌倦了以一种“点击这里，然后点击那里”的方式编写的测试。<em class="lr"> <br/> </em>他们还受到了<a class="ae jn" href="http://www.thucydides.info/#/" rel="noopener ugc nofollow" target="_blank">宁静</a>和安东尼·马卡诺的剧本模式的影响。</p><p id="57df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个名字来源于对测试应该使用业务领域术语来编写的关注。DDT也是一个恰当的名字，因为它们在杀死虫子方面非常有效(就像杀虫剂一样)。</p><p id="2cee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那么创新在哪里呢？这个想法是为我们的应用程序的两个或多个表示(<strong class="jq hj">协议</strong>)提供一个单一的接口(<strong class="jq hj">解释器</strong>)——例如<code class="du ls lt lu lv b">DomainOnly</code>和<code class="du ls lt lu lv b">Http</code>。这迫使我们定义一种独立于每个协议细节的通用语言。</p><p id="808d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们还打算在测试中和与业务人员的对话中使用相同的术语。这样，我们可以促进软件开发人员和业务领域专家之间的交流。这就是所谓的<code class="du ls lt lu lv b"><a class="ae jn" href="https://martinfowler.com/bliki/UbiquitousLanguage.html" rel="noopener ugc nofollow" target="_blank">ubiquitous language.</a></code></p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="68a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">过了一段时间，在编写DDT时，我们发现了帮助我们保持代码整洁的模式和其他不太好用的东西。最终，我决定提炼这些知识，用一种更通用、更优雅的方式编写一个库，并以开源方式发布。</p><blockquote class="lw lx ly"><p id="d83f" class="jo jp lr jq b jr js ij jt ju jv im jw lz jy jz ka ma kc kd ke mb kg kh ki kj hb bi translated">杀虫剂是一个库，它将我们的需求描述为由我们系统的<strong class="jq hj">参与者</strong>(域<a class="ae jn" href="https://www.infoq.com/presentations/pragmatic-personas/" rel="noopener ugc nofollow" target="_blank">角色</a>)和一个或多个<strong class="jq hj">解释者</strong>之间的交互列表组成的故事。</p></blockquote><p id="b409" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用解释器的不同实现运行相同的测试，我们得到以下好处:</p><ul class=""><li id="1376" class="mc md hi jq b jr js ju jv jx me kb mf kf mg kj mh mi mj mk bi translated">确信该功能在端到端和内存域中都有效。</li><li id="c462" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">使用贴近业务的语言记录我们的特色。</li><li id="6187" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">从测试中移除UI或技术细节。</li><li id="ad3a" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">确保基础设施层中没有业务逻辑<strong class="jq hj">和</strong>业务逻辑中没有基础设施细节。</li></ul></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="113e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们看看如何用杀虫剂写一个测试。</p><p id="9658" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<a class="ae jn" rel="noopener" href="/@javinpaul/top-10-free-courses-to-learn-git-and-github-best-of-lot-967aa314ea"> GitHub </a>杀虫剂示例项目中有几个例子。我们将看一下<code class="du ls lt lu lv b">PetShopDDT</code>的例子。假设我们需要为一家宠物店编写RESTful API。</p><p id="bd8a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我的建议是在开始编写应用程序之前，直接从用户故事开始编写DDT。</p><p id="a6ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的故事会说这样的话:<em class="lr">“作为一个潜在客户，我想查看一只宠物的价格，以便购买它。”</em></p><h2 id="dd7e" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">阶段1 —编写DDT</h2><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="cc50" class="kr ks hi lv b fi mu mv l mw mx">class PetShopDDT : DomainDrivenTest&lt;PetShopInterpreter&gt;<em class="lr">(allPetShopInterpreters) {</em></span><span id="63c2" class="kr ks hi lv b fi my mv l mw mx"><em class="lr">//something will go here</em></span><span id="c7a5" class="kr ks hi lv b fi my mv l mw mx"><strong class="lv hj">}</strong></span></pre><p id="3378" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了进行编译，我们已经为我们的领域定义了解释器接口。大概是这样的:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="23b3" class="kr ks hi lv b fi mu mv l mw mx">interface PetShopInterpreter: DomainInterpreter&lt;DdtProtocol&gt; {<em class="lr"><br/><br/>    </em>fun populateShop<em class="lr">(</em>vararg pets: Pet<em class="lr">)</em><br/><br/>    fun askPetPrice(petName: String): Int</span><span id="c7cc" class="kr ks hi lv b fi my mv l mw mx">    fun buyPet(petName: String): String<em class="lr"><br/></em>}</span></pre><p id="9bc9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以在这里定义您需要的所有方法，但有一些简单的规则:</p><ul class=""><li id="6551" class="mc md hi jq b jr js ju jv jx me kb mf kf mg kj mh mi mj mk bi translated">它必须是一个接口，所以你可以有多个实现，每个你想使用的协议一个。</li><li id="e304" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">它只需要使用领域概念，比如Json、Http状态、按钮等等。不应该出现在这里。</li><li id="4b48" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">这些方法应该反映一些原子用户交互，或者是一个问题(“询问宠物价格”)或者是一个动作(“购买宠物”)。</li></ul><p id="629d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">确切的名称现在并不重要，因为我们将在以后的工作中更改它们。</p><p id="2c8f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们现在必须定义运行测试的协议列表。杀虫剂中已经定义了四种，但是你可以自己定义。</p><p id="6bb6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，这里我们想使用<code class="du ls lt lu lv b">DomainOnly</code>和<code class="du ls lt lu lv b">HttpRest</code>协议。这意味着我们需要创建两个<code class="du ls lt lu lv b">PetShopInterpreter</code>的实现，并将它们放在一个集合中供我们的测试使用。</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="aca2" class="kr ks hi lv b fi mu mv l mw mx">val <em class="lr">allPetShopInterpreters </em>= <em class="lr">setOf(<br/>    </em>DomainOnlyPetShop(),<br/>    HttpRestPetshop<em class="lr">(</em>"localhost", 8082<em class="lr">)<br/>)</em></span></pre><p id="b1a4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这一点上，我们只能为每个定义协议和<code class="du ls lt lu lv b">prepare</code>方法，将所有的方法实现作为一个<code class="du ls lt lu lv b">TODO()</code>:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="8e9f" class="kr ks hi lv b fi mu mv l mw mx">class HttpRestPetshop<em class="lr">(</em>val host: String, val port: Int<em class="lr">) </em>: PetShopInterpreter <em class="lr">{<br/><br/>    </em>override val protocol = Http<em class="lr">(</em>"$host:$port"<em class="lr">)<br/><br/>    </em>override fun prepare(): DomainSetUp = try <em class="lr">{<br/>        //try to start the local http server <br/>        //or to connect with the deployed one<br/>        </em>Ready<br/>    <em class="lr">} </em>catch <em class="lr">(</em>t: Throwable<em class="lr">) {<br/>        </em>NotReady<em class="lr">(</em>t.toString()<em class="lr">)<br/>    }</em></span><span id="a912" class="kr ks hi lv b fi my mv l mw mx">    override fun askPetPrice(petName: String): Int<em class="lr"> = TODO()</em></span><span id="9923" class="kr ks hi lv b fi my mv l mw mx">...<br/></span><span id="6847" class="kr ks hi lv b fi my mv l mw mx">class DomainOnlyPetShop() : PetShopInterpreter <em class="lr">{<br/><br/></em>    override val protocol = DomainOnly<br/><br/>    override fun prepare(): DomainSetUp = Ready</span><span id="dcb4" class="kr ks hi lv b fi my mv l mw mx">    override fun askPetPrice(petName: String): Int<em class="lr"> = TODO()</em></span><span id="4124" class="kr ks hi lv b fi my mv l mw mx">...</span></pre><p id="ad15" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要继续，我们需要定义至少一个<strong class="jq hj">参与者</strong>。参与者代表滴滴涕内部系统的用户。</p><p id="0975" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们开始定义我们商店的客户。</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="5354" class="kr ks hi lv b fi mu mv l mw mx">data class PetBuyer(override val name: String): <br/>   DdtActor&lt;PetShopInterpreter&gt;() {</span><span id="e4ca" class="kr ks hi lv b fi my mv l mw mx"><br/>fun `check that the price of $ is $`(pet: String, price: Int) =<br/>     step(petName, expectedPrice) {<br/>        val price  = askPetPrice(pet)<br/>        expectThat(price).isEqualTo(expectedPrice)<br/>     }</span></pre><p id="17f2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里有几件事值得注意:</p><ul class=""><li id="34fd" class="mc md hi jq b jr js ju jv jx me kb mf kf mg kj mh mi mj mk bi translated">actor类必须有一个名为name的字段。这个名字将作为演员的参考，所以我们不能在同一个测试中有两个同名的演员。</li><li id="ffd5" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">演员必须从<code class="du ls lt lu lv b">DdtActor</code>或<code class="du ls lt lu lv b">DdtActorWithContext</code>继承正确的<code class="du ls lt lu lv b">DomainInterpreter.</code></li><li id="4bd9" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">应该使用<code class="du ls lt lu lv b">step</code>函数在actor中创建一个方法。这很重要，因为该方法将成为一个动态测试。</li><li id="8922" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">方法名称中的所有` $ '符号将被替换为步骤参数，以创建测试名称。通过这种方式，测试可以指出他们正在测试的确切的上下文。</li><li id="5dcd" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">actor步骤的主要职责是将所有的期望(或断言)保持在一起，但是隐藏起来，这样它们就不会扰乱实际的测试。</li></ul></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="3710" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们可以将第一个测试放在一起:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="3553" class="kr ks hi lv b fi mu mv l mw mx">class PetShopDDT : DomainDrivenTest&lt;PetShopInterpreter&gt;<em class="lr">(allPetShopInterpreters) {<br/><br/>  </em>val mary by NamedActor<em class="lr">(</em>::PetBuyer<em class="lr">)</em></span><span id="6cea" class="kr ks hi lv b fi my mv l mw mx">  @DDT<br/>  fun `mary buys a lamb`() = ddtScenario <strong class="lv hj">{<br/>    </strong>setting <strong class="lv hj">{<br/>      //set up here<br/></strong><em class="lr">    </em><strong class="lv hj">} </strong><em class="lr">atRise </em>play<em class="lr">(<br/>      </em>mary.`check that the price of $ is $`<em class="lr">(</em>"lamb", 64<em class="lr">)<br/>    </em>)<em class="lr">.</em><strong class="lv hj"><em class="lr">wip</em></strong><em class="lr">(</em>LocalDate.of<em class="lr">(</em>2020, 6, 7<em class="lr">)</em>, "Working on it"<em class="lr">)<br/>  </em><strong class="lv hj">}<br/>}</strong></span></pre><p id="f3f6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">关于这段代码的几点说明:</p><ul class=""><li id="7ccf" class="mc md hi jq b jr js ju jv jx me kb mf kf mg kj mh mi mj mk bi translated">测试类需要从<code class="du ls lt lu lv b">DomainDrivenTest</code>继承并指定哪些解释器应该运行(<code class="du ls lt lu lv b">allPetShopInterpreters</code>)。</li><li id="ba98" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">可以使用<code class="du ls lt lu lv b">NamedActor</code>委托人创建执行元。</li><li id="bcad" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">单个测试需要用<code class="du ls lt lu lv b">DDT</code>注释或者<code class="du ls lt lu lv b">TestFactory</code>标记，因为它们会生成多个测试。</li><li id="a243" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">每个测试都由一个<code class="du ls lt lu lv b">ddtScenario</code>生成，它负责为Junit5生成所有测试。</li><li id="a274" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">测试DSL是<code class="du ls lt lu lv b">setting … atRise play(steps)</code>，其中步骤是参与者的交互，设置部分是可选的，用于将系统置于给定状态。</li><li id="41da" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">可以用<code class="du ls lt lu lv b">wip</code>扩展指定一个在制品修饰符，它将忽略失败的测试，直到到期日。</li></ul><p id="5a3c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们像往常一样从我们的ide或者从命令行使用<a class="ae jn" href="https://javarevisited.blogspot.com/2020/05/top-5-courses-and-books-to-learn-gradle.html#axzz6O7LgbL92" rel="noopener ugc nofollow" target="_blank"> Gradle </a>来运行测试。这是它在IntelliJ中的样子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://itnext.io/top-5-intellijidea-and-android-studio-courses-for-java-and-android-programmers-afcc27309b60"><div class="er es mz"><img src="../Images/d200341411253eb848b6db140f7c870e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYSd33ej2PIgBtwoWM9AfA.png"/></div></a><p class="jj jk et er es jl jm bd b be z dx translated">第一次运行我们的测试</p></figure><p id="5ced" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">测试是灰色的，因为它们被标记为工作进行中，并且日期还没有到期。</p><p id="b77b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意每个步骤是如何变成一个测试的，它使用Http和DomainOnly协议运行相同的测试两次。此外，方法名中的美元符号被替换为实际值。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="1acf" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">阶段2——编写行走骨架</h2><p id="c0d8" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">现在我们已经有了测试，我们应该用它来指导应用程序的开发。</p><p id="29dc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一个好的实践是从Http解释器开始，然后建模我们的域接口。通过这种方式，我们避免了在与我们的web服务器不匹配的域接口上浪费时间的风险。</p><p id="3e99" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了测试Http服务器，我们需要一个Http客户端。所以我们可以在<code class="du ls lt lu lv b">HttpInterpreter</code>里面放一个。</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="145b" class="kr ks hi lv b fi mu mv l mw mx">val client = JettyClient()</span></pre><p id="ddab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们还需要在测试开始时启动我们的本地服务器</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="f6a4" class="kr ks hi lv b fi mu mv l mw mx">class HttpRestPetshop<em class="lr">(</em>val host: String, val port: Int<em class="lr">)</em> {<br/>...<br/>override fun prepare(): DomainSetUp = try <em class="lr">{<br/>    </em>if <em class="lr">(</em>host == "localhost" &amp;&amp; !started<em class="lr">) {<br/>        </em>started = true<br/>        <em class="lr">println(</em>"Pets example started listening on port $port"<em class="lr">)<br/>        </em>val server = PetShopHandler<em class="lr">(</em>PetShopHub()<em class="lr">)<br/>                       </em>.<em class="lr">asServer(</em>Jetty<em class="lr">(</em>port<em class="lr">))</em>.start()<br/>        registerShutdownHook <strong class="lv hj">{<br/>            </strong>server.stop()<br/>        <strong class="lv hj">}<br/>    </strong><em class="lr">}<br/>    </em>Ready<br/><em class="lr">} </em>catch <em class="lr">(</em>t: Throwable<em class="lr">) {<br/>    </em>NotReady<em class="lr">(</em>t.toString()<em class="lr">)<br/>}</em></span></pre><p id="701f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们通过覆盖<code class="du ls lt lu lv b">prepare</code>方法来做到这一点。在某种程度上，也许这段代码足够通用，可以成为<code class="du ls lt lu lv b"><strong class="jq hj">Pesticide</strong></code>本身的一部分……但是目前你需要自己写类似的东西。</p><p id="4f22" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">还要注意，只有当测试的指定主机是“localhost”时，我们才启动本地服务器。如果我们愿意，我们也可以在我们的云环境中使用相同的测试。</p><p id="20a8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此时，我们需要实现我们的<code class="du ls lt lu lv b">askPetPrice</code>方法，使用Http客户端发送请求，然后解析响应以返回价格。类似于:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="961d" class="kr ks hi lv b fi mu mv l mw mx">override fun askPetPrice<em class="lr">(</em>petName: String<em class="lr">)</em>: Int? <em class="lr">{<br/>    </em>val req = Request<em class="lr">(</em>GET, uri<em class="lr">(</em>"pets/<em class="lr">${</em>petName<em class="lr">}</em>"<em class="lr">))<br/>    </em>val resp = <strong class="lv hj">client<em class="lr">(</em>req<em class="lr">)</em></strong><em class="lr"><br/>    expectThat(</em>resp.status<em class="lr">)</em>.<em class="lr">isEqualTo(OK)<br/><br/>    </em>val pet = klaxon.<strong class="lv hj">parse</strong>&lt;Pet&gt;<em class="lr">(</em>resp.bodyString()<em class="lr">)<br/>    </em>return pet?.price<br/><em class="lr">}</em></span></pre><p id="8241" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du ls lt lu lv b">HttpInterpreter</code>中唯一的断言是技术上的，比如在这种情况下检查响应代码。所有的域断言都应该留在参与者的步骤中。</p><p id="0f85" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好了，现在我们的测试要求rest调用，但是它将得到一个错误，因为还没有服务器代码。</p><p id="de94" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，我们转到服务器，我们将实施我们的路线:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="7859" class="kr ks hi lv b fi mu mv l mw mx">class PetShopHandler<em class="lr">(</em>val <strong class="lv hj">hub</strong>: PetShopHub<em class="lr">)</em>: HttpHandler <em class="lr">{<br/>   <br/>   </em>val klaxon = Klaxon() //json parser/serializer<br/><br/>   override fun invoke<em class="lr">(</em>request: Request<em class="lr">) </em>= petShopRoutes<em class="lr">(</em>request<em class="lr">)</em></span><span id="6f31" class="kr ks hi lv b fi my mv l mw mx">   val petShopRoutes: HttpHandler = <em class="lr">routes(<br/>     </em>  <strong class="lv hj">"/pets/{name}"</strong> <em class="lr">bind </em><strong class="lv hj">GET</strong> to <strong class="lv hj">::petDetails</strong><br/>   <em class="lr">)<br/><br/>  </em>fun petDetails<em class="lr">(</em>request: Request<em class="lr">)</em>: Response =<br/>    request.<em class="lr">path(</em>"name"<em class="lr">)<br/>        </em>?.<em class="lr">let(</em>hub::getByName<em class="lr">)<br/>        </em>?.<em class="lr">let(</em>::toJson<em class="lr">)<br/>        </em>?.<em class="lr">let(</em>Response<em class="lr">(</em>Status.OK<em class="lr">)</em>::body<em class="lr">)<br/>        </em>?: Response<em class="lr">(</em>Status.BAD_REQUEST<em class="lr">)<br/><br/>  </em>private fun toJson<em class="lr">(</em>it: Pet<em class="lr">) </em>= klaxon.toJsonString<em class="lr">(</em>it<em class="lr">)<br/>}</em></span></pre><p id="0698" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Http4k中，一切都是函数。我们将我们的路线附加到简单的<code class="du ls lt lu lv b">(Request) -&gt; Response</code>类型的函数上。为了保持良好的函数风格，函数本身——在本例中为<code class="du ls lt lu lv b">petDetails</code>—由一系列更简单的函数组成。</p><p id="5ac7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">实际的域在这里由<code class="du ls lt lu lv b">hub</code>字段表示。在写<code class="du ls lt lu lv b">PetShopHandler</code>的时候，我们“发现”了<code class="du ls lt lu lv b">PetShopHub</code>必须公开的方法——在这个例子中是<code class="du ls lt lu lv b">getByName</code>。</p><p id="2ee0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了保持这个例子中的简单，我们使用<code class="du ls lt lu lv b">null</code>来捕获所有的错误。所以我们完全避免了异常，相反，如果任何一步给我们一个空值，我们就返回一个错误页面。</p><p id="d7c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">顺便说一句，如果你感兴趣，我的书将详细分析和解释这种风格。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="b9c6" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">阶段3—编写域</h2><p id="62f3" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">所以现在我们的Http DDT在PetShopHub方法上失败了，这个方法还没有实现。</p><p id="ee4f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这一点上，我们把Http DDT放在一边，我们只关注域DDT，因为我们现在需要写域。</p><p id="713b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们将Http客户端放在<code class="du ls lt lu lv b">HttpInterpreter</code>中时，我们将hub的一个实例放在<code class="du ls lt lu lv b">DomainOnlyInterpreter</code>中，我们以这种方式使用它:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="267f" class="kr ks hi lv b fi mu mv l mw mx">class DomainOnlyPetShop() : PetShopInterpreter <em class="lr">{</em></span><span id="81c7" class="kr ks hi lv b fi my mv l mw mx">private val hub = PetShopHub()</span><span id="95c1" class="kr ks hi lv b fi my mv l mw mx">...<br/>override fun askPetPrice<em class="lr">(</em>petName: String<em class="lr">)</em>: Int? =   <br/>  hub.getByName<em class="lr">(</em>petName<em class="lr">)</em>?.price</span></pre><p id="0cb7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们可以创建我们的域了:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="3396" class="kr ks hi lv b fi mu mv l mw mx">class PetShopHub() {<em class="lr"><br/><br/>    </em>private val pets: AtomicReference&lt;List&lt;Pet&gt;&gt; = AtomicReference<em class="lr">(emptyList</em>()<em class="lr">)<br/>   </em><strong class="lv hj"><br/>    </strong>fun getByName<em class="lr">(</em>petName: String<em class="lr">)</em>: Pet? = pets.get().<em class="lr">firstOrNull </em><strong class="lv hj">{ it</strong>.name == petName <strong class="lv hj">}</strong></span><span id="0126" class="kr ks hi lv b fi my mv l mw mx"><strong class="lv hj">}</strong></span></pre><p id="85e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们开始在内存中使用一个链表来存储宠物。如果这是一个真实的项目，在以后的某个时候，我们将注入一个函数来读写数据库或一些其他形式的持久性。</p><p id="a8eb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们现在运行DDT，我们可以看到他们仍然失败，因为商店是空的。我们需要在测试中添加一个设置，并填充商店:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="ff9f" class="kr ks hi lv b fi mu mv l mw mx">class PetShopDDT ...</span><span id="ac09" class="kr ks hi lv b fi my mv l mw mx">  val <strong class="lv hj">lamb</strong> = Pet<em class="lr">(</em>"lamb", 64<em class="lr">)<br/>  v</em>al <strong class="lv hj">hamster</strong> = Pet<em class="lr">(</em>"hamster", 128<em class="lr">)</em></span><span id="13b7" class="kr ks hi lv b fi my mv l mw mx">  @DDT<br/>  fun `mary buys a lamb`() = ddtScenario <strong class="lv hj">{<br/>    </strong>setting <strong class="lv hj">{<br/>      populateShop<em class="lr">(</em>lamb, hamster<em class="lr">)</em></strong><em class="lr"><br/>    </em><strong class="lv hj">} </strong><em class="lr">atRise </em>play<em class="lr">(<br/>      </em>mary.`check that the price of $ is $`<em class="lr">(</em>"lamb", 64<em class="lr">)</em>,<br/>    <em class="lr">)<br/>  </em><strong class="lv hj">}</strong></span></pre><p id="e555" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们还需要在解释器接口上实现该方法:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="425c" class="kr ks hi lv b fi mu mv l mw mx">interface PetShopInterpreter : DomainInterpreter&lt;DdtProtocol&gt; <em class="lr">{</em></span><span id="7fa6" class="kr ks hi lv b fi my mv l mw mx">  fun populateShop<em class="lr">(</em>vararg pets: Pet<em class="lr">)</em></span></pre><p id="e857" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以及<code class="du ls lt lu lv b">HttpRestPetshop</code>:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="49f0" class="kr ks hi lv b fi mu mv l mw mx">class HttpRestPetshop ...</span><span id="7e9c" class="kr ks hi lv b fi my mv l mw mx">override fun populateShop<em class="lr">(</em>vararg pets: Pet<em class="lr">) </em>=<br/>    pets.<em class="lr">forEach </em><strong class="lv hj">{<br/>        </strong>val resp = client<em class="lr">(</em>addPetRequest<em class="lr">(</em><strong class="lv hj">it</strong><em class="lr">))<br/>        expectThat(</em>resp.status<em class="lr">)</em>.<em class="lr">isEqualTo(ACCEPTED)<br/>    </em><strong class="lv hj">}</strong></span></pre><p id="84ed" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以及<code class="du ls lt lu lv b">DomainOnlyPetShop</code>:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="e3e2" class="kr ks hi lv b fi mu mv l mw mx">class DomainOnlyPetShop() : PetShopInterpreter <em class="lr">{</em></span><span id="5452" class="kr ks hi lv b fi my mv l mw mx">  override fun populateShop<em class="lr">(</em>vararg pets: Pet<em class="lr">) </em>=<br/>    pets.<em class="lr">forEach </em><strong class="lv hj">{<br/>      </strong>hub.addPet<em class="lr">(</em><strong class="lv hj">it</strong><em class="lr">)<br/>    </em><strong class="lv hj">}<br/></strong>...</span></pre><p id="1e81" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，DDT将通过这两个协议！</p><p id="9b67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以移除<code class="du ls lt lu lv b">wip</code>标志，然后再次运行测试:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/d417a40231a18412914338b5375dfee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YhDGbnV-TZLwjnHDab1guA.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">所有测试现在都是绿色的！</p></figure><h2 id="cbb7" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">阶段4 —向测试中添加新步骤</h2><p id="8a45" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">现在，我们可以继续向测试添加新的步骤，向应用程序添加新的特性，直到我们认为场景已经完成:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="f836" class="kr ks hi lv b fi mu mv l mw mx">class PetShopDDT : DomainDrivenTest&lt;PetShopInterpreter&gt;<em class="lr">(allPetShopInterpreters) {<br/><br/>    </em>val mary by NamedActor<em class="lr">(</em>::PetBuyer<em class="lr">)</em></span><span id="348c" class="kr ks hi lv b fi my mv l mw mx">    val lamb = Pet<em class="lr">(</em>"lamb", 64<em class="lr">)<br/>    </em>val hamster = Pet<em class="lr">(</em>"hamster", 128<em class="lr">)</em></span><span id="114d" class="kr ks hi lv b fi my mv l mw mx">  @DDT<br/>  fun `mary buys a lamb`() = ddtScenario <strong class="lv hj">{<br/>    </strong>setting <strong class="lv hj">{<br/>      </strong>populateShop<em class="lr">(</em>lamb, hamster<em class="lr">)<br/>    </em><strong class="lv hj">} </strong><em class="lr">atRise </em>play<em class="lr">(<br/>      </em>mary.`check that the price of $ is $`<em class="lr">(</em>"lamb", 64<em class="lr">)</em>,<br/>      mary.`check that the price of $ is $`<em class="lr">(</em>"hamster", 128<em class="lr">)</em>,               <br/>      mary.`put $ into the cart`<em class="lr">(</em>"lamb"<em class="lr">)</em>,<br/>      mary.`checkout with pets $`<em class="lr">(</em>"lamb"<em class="lr">)<br/>      )<br/>   </em><strong class="lv hj">}<br/>}</strong></span></pre><p id="a5ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在运行测试，我们可以看到一切都是绿色的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/a5b0880d7c0a6b022e1317632e47cccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*gEZArOhbD2cco43p9S0j-g.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">成功完成测试运行</p></figure><p id="52b3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们也可以从命令行用<code class="du ls lt lu lv b">./gradlew test</code>运行测试:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="b1df" class="kr ks hi lv b fi mu mv l mw mx">PetShopDDT &gt; DomainOnly - Setting up the scenario PASSED</span><span id="ea61" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; DomainOnly - Mary check that the price of lamb is 64 PASSED</span><span id="251c" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; DomainOnly - Mary check that the price of hamster is 128 PASSED</span><span id="6049" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; DomainOnly - Mary put lamb into the cart PASSED</span><span id="5655" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; DomainOnly - Mary check that there are no more lamb for sale PASSED</span><span id="61ee" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; DomainOnly - Mary checkout with pets lamb PASSED</span><span id="5e2a" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; Http localhost:8082 - Setting up the scenario PASSED</span><span id="d0ac" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; Http localhost:8082 - Mary check that the price of lamb is 64 PASSED</span><span id="3182" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; Http localhost:8082 - Mary check that the price of hamster is 128 PASSED</span><span id="5cff" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; Http localhost:8082 - Mary put lamb into the cart PASSED</span><span id="63f5" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; Http localhost:8082 - Mary check that there are no more lamb for sale PASSED</span><span id="3df6" class="kr ks hi lv b fi my mv l mw mx">PetShopDDT &gt; Http localhost:8082 - Mary checkout with pets lamb PASSED</span></pre><p id="6ce6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从这里开始应该是下坡路了。您可以在此找到所有PetShop测试的完整代码:</p><div class="nc nd ez fb ne nf"><a href="https://github.com/uberto/pesticide/tree/master/pesticide-examples/src/test/kotlin/com/ubertob/pesticide/examples/petshop" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">Uber to/杀虫剂</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt jh nf"/></div></div></a></div></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="cb76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里只有另一个有趣的特性值得一提——在测试期间存储和检索新数据。</p><p id="ac19" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，电子商务网站的一个常见模式是创建一个虚拟购物车或篮子来放置您的文章。如果站点不需要注册，它将为购物车生成一个唯一的id，用户必须记住这个id直到结账。</p><p id="3f32" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">到目前为止一切顺利。现在的问题是，我们无法预测购物车id将会是什么，那么我们如何编写关于它的断言呢？</p><p id="07b8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们来看看玛丽把她的小羊放进手推车时的步骤:</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="7527" class="kr ks hi lv b fi mu mv l mw mx">fun `put $ into the cart`<em class="lr">(</em>petName: String<em class="lr">) </em>=<br/>    step<em class="lr">(</em>petName<em class="lr">) </em><strong class="lv hj">{ </strong>cxt <strong class="lv hj">-&gt;<br/>        </strong><em class="lr">expectThat(</em>cxt.getOrNull()<em class="lr">)</em>.<em class="lr">isNull</em>()<br/>        val cartId = createNewCart() ?: fail<em class="lr">(</em>"No CartId"<em class="lr">)<br/>        </em>addToCart<em class="lr">(</em>cartId, petName<em class="lr">)<br/>        </em><strong class="lv hj">cxt.store</strong><em class="lr">(</em>cartId<em class="lr">)<br/>    </em><strong class="lv hj">}</strong></span></pre><p id="9c83" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这里，我们从我们的响应中获得<code class="du ls lt lu lv b">cartId</code>,并将它存储在测试上下文中——见粗体行。</p><pre class="iy iz ja jb fd mq lv mr ms aw mt bi"><span id="ac0a" class="kr ks hi lv b fi mu mv l mw mx">fun `checkout with pets $`<em class="lr">(</em>vararg pets: String<em class="lr">) </em>=<br/>    step<em class="lr">(</em>pets.<em class="lr">asList</em>().<em class="lr">joinToString(</em>","<em class="lr">)) </em><strong class="lv hj">{ </strong>ctx <strong class="lv hj">-&gt;<br/>        </strong>val cartId = <strong class="lv hj">ctx.get()</strong><br/>        val cart = askCartStatus<em class="lr">(</em>cartId<em class="lr">)<br/>        </em>val petList = cart?.pets?.<em class="lr">map(</em>Pet::name<em class="lr">)</em>.<em class="lr">orEmpty</em>()<br/>        <em class="lr">expectThat(</em>petList<em class="lr">)</em>.<em class="lr">containsExactly(</em>pets.<em class="lr">toList</em>()<em class="lr">)<br/>        </em>checkOut<em class="lr">(</em>cartId<em class="lr">)<br/>    </em><strong class="lv hj">}</strong></span></pre><p id="5c42" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下一步，我们可以检索<code class="du ls lt lu lv b">cartId</code>的当前值，并使用它来调用checkout。</p><p id="9b93" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我认为这足以让我们先看看如何使用杀虫剂，还有其他的可能性，比如<a class="ae jn" href="https://www.freecodecamp.org/news/these-are-the-top-testing-tools-libraries-and-frameworks-for-java-developers-8c0e3f9bc11d/?source=user_profile---------1---------------------" rel="noopener ugc nofollow" target="_blank">测试java应用</a>，测试javascript页面，<a class="ae jn" rel="noopener" href="/javarevisited/5-best-courses-to-learn-spring-cloud-and-microservices-1ddea1af7012">测试微服务</a>，测试遗留应用，等等。其中一些已经在示例中涉及到了，一些将在不久的将来涉及到。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="8292" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们以一个大问题来结束:</p><p id="cf72" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我的项目中使用农药安全吗？ </p><p id="2434" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好吧，这是你的电话，但请考虑到:</p><ul class=""><li id="f011" class="mc md hi jq b jr js ju jv jx me kb mf kf mg kj mh mi mj mk bi translated">我们正在一个大项目中使用它，它是几年经验的结果。</li><li id="7189" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">这是测试代码，不会给你的应用带来风险。</li><li id="62f1" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">它是开源的，相对较小，并且包含测试——即使我放弃了这个项目，你仍然可以使用它并扩展它。</li><li id="67d2" class="mc md hi jq b jr ml ju mm jx mn kb mo kf mp kj mh mi mj mk bi translated">它不是一个成熟的产品，所以可能会有粗糙的边缘，可能会有API的变化，虽然在1.x版本中没有。</li></ul></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="3086" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那都是乡亲们！我真的希望杀虫剂库也能对其他人的项目有用。</p><p id="6a5e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我非常乐意在这个博客、Twitter或Github上帮助和讨论任何关于杀虫剂的问题。</p><p id="b9fa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi">—</p><p id="41f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你对更多类似的帖子感兴趣，请点击这里或我的twitter账户@ <a class="ae jn" href="https://twitter.com/ramtop" rel="noopener ugc nofollow" target="_blank"> ramtop </a>关注我</p></div></div>    
</body>
</html>