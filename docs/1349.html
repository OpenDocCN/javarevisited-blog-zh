<html>
<head>
<title>I need an index with this List iteration method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我需要这个列表迭代方法的索引</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/i-need-an-index-with-this-list-iteration-method-1e339fd55ed7?source=collection_archive---------1-----------------------#2021-06-28">https://medium.com/javarevisited/i-need-an-index-with-this-list-iteration-method-1e339fd55ed7?source=collection_archive---------1-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="32c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用外部和内部迭代器通过索引在Java中对列表进行迭代</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7314de330ea2352f91d53088ee34e1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C8mryqLGnTnIJ3ra"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">Maksym Kaharlytskyi 在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="089b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何用索引遍历Java中的列表</h1><p id="75d6" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在Java中，有几种方法可以迭代带有索引的<code class="du kx ky kz la b">List</code>。我将介绍一些最常见的外部迭代方法，以及如何将它们与提供索引结合起来。我将解释如何使用<code class="du kx ky kz la b">RandomAccess</code>接口安全地迭代<code class="du kx ky kz la b">List</code>接口。</p><h2 id="fa17" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">使用迭代器迭代</h2><p id="ce1e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是集合迭代的最基本形式，适用于任何<code class="du kx ky kz la b">Collection</code>(Java 5之前)，以及Java中的任何<code class="du kx ky kz la b">Iterable</code>类型(从Java 5开始)。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="7769" class="lb jv hi la b fi lt lu l lv lw">List&lt;Integer&gt; list = Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.with(1, 2, 3);<br/>int <strong class="la hj">index </strong>= 0;<br/>for (Iterator&lt;Integer&gt; it = list.iterator(); it.hasNext(); <strong class="la hj">index</strong>++)<br/>{<br/>    Integer integer = it.next();<br/>    System.<strong class="la hj"><em class="lx">out</em></strong>.println(integer + <strong class="la hj">":" </strong>+ <strong class="la hj">index</strong>);<br/>}</span><span id="a168" class="lb jv hi la b fi ly lu l lv lw">// Outputs:<br/>// 1:0<br/>// 2:1<br/>// 3:2</span></pre><p id="5587" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要直接操作<code class="du kx ky kz la b">Iterator</code>，请使用这种形式的迭代。例如，如果您有一个扁平的配对列表，您需要调用两次<code class="du kx ky kz la b">next</code>()来重新构建它们的配对。</p><h2 id="52b9" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">使用Java 5 for-each循环的迭代器</h2><p id="3f41" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">for-each循环只是带有<code class="du kx ky kz la b">Iterator</code>的for循环的语法糖。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="d51b" class="lb jv hi la b fi lt lu l lv lw">List&lt;Integer&gt; list = List.<em class="lx">of</em>(1, 2, 3);<br/>int <strong class="la hj">index </strong>= 0;<br/>for (Integer integer : list)<br/>{<br/>    System.<strong class="la hj"><em class="lx">out</em></strong>.println(integer + <strong class="la hj">":" </strong>+ <strong class="la hj">index</strong>++);<br/>}</span><span id="63d1" class="lb jv hi la b fi ly lu l lv lw">// Outputs:<br/>// 1:0<br/>// 2:1<br/>// 3:2</span></pre><p id="f058" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数情况下使用这种形式的迭代，<strong class="ih hj">除了</strong>当关注原始迭代性能和创建<code class="du kx ky kz la b">Iterator</code>实例的时候。</p><h2 id="68c3" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">使用索引for循环进行迭代</h2><p id="c704" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是随机访问<code class="du kx ky kz la b">List</code>的最快外部循环迭代。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="481c" class="lb jv hi la b fi lt lu l lv lw">List&lt;Integer&gt; list = Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.with(1, 2, 3);<br/>for (int <strong class="la hj">i </strong>= 0; <strong class="la hj">i </strong>&lt; list.size(); <strong class="la hj">i</strong>++)<br/>{<br/>    Integer integer = list.get(<strong class="la hj">i</strong>);<br/>    System.<strong class="la hj"><em class="lx">out</em></strong>.println(integer + <strong class="la hj">":" </strong>+ <strong class="la hj">i</strong>);<br/>}</span><span id="f7fc" class="lb jv hi la b fi ly lu l lv lw">// Outputs:<br/>// 1:0<br/>// 2:1<br/>// 3:2</span></pre><p id="88b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您优化迭代代码以提高性能时，请使用这种形式的迭代。这主要适用于库或框架代码，但也可能适用于应用程序代码中的一些性能关键或垃圾敏感区域。只有在你能保证一个<code class="du kx ky kz la b">List</code>是<code class="du kx ky kz la b">RandomAccess</code>的地方才使用这个代码。</p><p id="9e2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是你怎么知道一个列表是否支持随机访问呢？</p><h2 id="5a64" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">随机访问接口</h2><p id="e6d3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在Java 1.4中，引入了一个名为<code class="du kx ky kz la b">RandomAccess</code>的标记接口。我不知道为什么它只作为一个标记接口被添加，并且没有在它上面定义<code class="du kx ky kz la b">size</code>和<code class="du kx ky kz la b">get</code>的方法。这个接口被许多库算法用来优化<code class="du kx ky kz la b">RandomAccess</code>列表，并为非<code class="du kx ky kz la b">RandomAccess</code> <code class="du kx ky kz la b">List</code>实例提供性能安全的迭代。您将在标准Java库中的<code class="du kx ky kz la b">instanceof</code>检查中找到对该接口的引用(查看<code class="du kx ky kz la b">Collections</code>类中的一些示例)。下面是一个使用<code class="du kx ky kz la b">RandomAccess</code>接口迭代一个可能是也可能不是<code class="du kx ky kz la b">RandomAccess</code>的<code class="du kx ky kz la b">List</code>的例子。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="66ea" class="lb jv hi la b fi lt lu l lv lw">List&lt;Integer&gt; list = Stream.<em class="lx">of</em>(1, 2, 3)<br/>        .collect(Collectors.<em class="lx">toCollection</em>(LinkedList::new));</span><span id="32bd" class="lb jv hi la b fi ly lu l lv lw">if (list instanceof RandomAccess)<br/>{<br/>    for (int <strong class="la hj">i </strong>= 0; <strong class="la hj">i </strong>&lt; list.size(); <strong class="la hj">i</strong>++)<br/>    {<br/>        Integer integer = list.get(<strong class="la hj">i</strong>);<br/>        System.<strong class="la hj"><em class="lx">out</em></strong>.println(integer + ":" + i);<br/>    }<br/>}<br/>else<br/>{<br/>    int index = 0;<br/>    for (Integer integer : list)<br/>    {<br/>        System.<strong class="la hj"><em class="lx">out</em></strong>.println(integer + ":" + index++);<br/>    }<br/>}</span><span id="e376" class="lb jv hi la b fi ly lu l lv lw">// Outputs:<br/>// 1:0<br/>// 2:1<br/>// 3:2</span></pre><p id="06ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本例中，将执行<code class="du kx ky kz la b">if</code>语句的<code class="du kx ky kz la b">else</code>部分，因为<code class="du kx ky kz la b">LinkedList</code>不是<code class="du kx ky kz la b">RandomAccess</code> <code class="du kx ky kz la b">List</code>。</p><h2 id="2793" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">IntStream.range()和子列表()</h2><p id="d28a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">从Java 8开始，可以使用<code class="du kx ky kz la b">IntStream.range()</code>迭代一组索引，并使用<code class="du kx ky kz la b">List</code>通过<code class="du kx ky kz la b">get()</code>进行查找。<code class="du kx ky kz la b">IntStream.range()</code>可用于索引for循环的面向对象版本。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="f262" class="lb jv hi la b fi lt lu l lv lw">List&lt;Integer&gt; list = List.<em class="lx">of</em>(1, 2, 3, 4, 5);<br/>IntStream.<em class="lx">range</em>(1, 4)<br/>        .forEach(index -&gt;<br/>                System.<strong class="la hj"><em class="lx">out</em></strong>.println(<em class="lx">list</em>.get(index) + <strong class="la hj">":" </strong>+ index));</span><span id="540b" class="lb jv hi la b fi ly lu l lv lw">// Outputs:<br/>// 2:1<br/>// 3:2<br/>// 4:3</span></pre><p id="1fa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种方法，开发人员可以迭代<code class="du kx ky kz la b">List</code>中特定范围的索引。使用<code class="du kx ky kz la b">subList</code>也可以达到同样的效果。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="e565" class="lb jv hi la b fi lt lu l lv lw">List&lt;Integer&gt; list = List.<em class="lx">of</em>(1, 2, 3, 4, 5);<br/>list.subList(1, 4).forEach(System.<strong class="la hj"><em class="lx">out</em></strong>::println);</span><span id="1b0a" class="lb jv hi la b fi ly lu l lv lw">// Outputs:<br/>// 2<br/>// 3<br/>// 4</span></pre><p id="2dc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码将输出除第一个和最后一个元素之外的所有元素。<code class="du kx ky kz la b">InStream.range()</code>和<code class="du kx ky kz la b">subList()</code>都包含在from索引中，不包含在to索引中。</p><p id="2ae2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是请注意，使用<code class="du kx ky kz la b">subList()</code>，我们在对<code class="du kx ky kz la b">forEach</code>的调用中失去了对索引的访问。没有办法使用<code class="du kx ky kz la b">subList</code>重新访问这个索引。</p><h1 id="bae8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">带索引的内部Eclipse集合迭代器</h1><p id="137f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Eclipse Collections 有几个内部迭代器，它们被传递给所提供的函数接口的元素和索引。</p><h2 id="1619" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">forEachWithIndex(ordereditable)</h2><p id="bd92" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">该方法将从第一个元素迭代到最后一个元素，并将每个元素及其索引传递给提供的<code class="du kx ky kz la b">ObjectIntProcedure</code>。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="d71c" class="lb jv hi la b fi lt lu l lv lw">MutableList&lt;Integer&gt; list = Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.with(1, 2, 3);<br/>list.forEachWithIndex((each, index) -&gt; <br/>        System.<strong class="la hj"><em class="lx">out</em></strong>.println(each + <strong class="la hj">": " </strong>+ index));</span><span id="fb44" class="lb jv hi la b fi ly lu l lv lw">// Outputs:<br/>// 1: 0<br/>// 2: 1<br/>// 3: 2</span></pre><h2 id="f873" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">reversefeachwithindex(reversible iterable)</h2><p id="04c3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">该方法将从最后一个元素迭代到第一个元素，并将每个元素及其索引传递给提供的<code class="du kx ky kz la b">ObjectIntProcedure</code>。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="1ed1" class="lb jv hi la b fi lt lu l lv lw">MutableList&lt;Integer&gt; list = Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.with(1, 2, 3);<br/>list.reverseForEachWithIndex((each, index) -&gt;<br/>        System.<strong class="la hj"><em class="lx">out</em></strong>.println(each + <strong class="la hj">": " </strong>+ index));</span><span id="6b1a" class="lb jv hi la b fi ly lu l lv lw">// Outputs:<br/>// 3: 2<br/>// 2: 1<br/>// 1: 0</span></pre><h2 id="179b" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">带范围的forEachWithIndex(ordereditable)</h2><p id="9c72" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">除了<code class="du kx ky kz la b">ObjectIntProcedure</code>之外，还有一个<code class="du kx ky kz la b">forEachWithIndex</code>过载，它包含<code class="du kx ky kz la b">from</code>和<code class="du kx ky kz la b">to</code>指数范围。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="97b7" class="lb jv hi la b fi lt lu l lv lw">MutableList&lt;ObjectIntPair&lt;String&gt;&gt; result =<br/>        Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.empty();<br/>MutableList&lt;String&gt; list =<br/>        Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>, <strong class="la hj">"4"</strong>, <strong class="la hj">"5"</strong>);<br/>list.forEachWithIndex(1, 3,<br/>        (each, index) -&gt; <em class="lx">result</em>.add(<br/>                PrimitiveTuples.<em class="lx">pair</em>(each, index)));<br/><br/>var expected = List.<em class="lx">of</em>(<br/>        PrimitiveTuples.<em class="lx">pair</em>(<strong class="la hj">"2"</strong>, 1),<br/>        PrimitiveTuples.<em class="lx">pair</em>(<strong class="la hj">"3"</strong>, 2),<br/>        PrimitiveTuples.<em class="lx">pair</em>(<strong class="la hj">"4"</strong>, 3));<br/>Assertions.<em class="lx">assertEquals</em>(expected, result);</span></pre><p id="94af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据指定的范围，此方法可用于向前和向后迭代。以下代码将反向执行，因为<code class="du kx ky kz la b">from</code>索引大于<code class="du kx ky kz la b">to</code>索引。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="5605" class="lb jv hi la b fi lt lu l lv lw">MutableList&lt;ObjectIntPair&lt;String&gt;&gt; result =<br/>        Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.empty();<br/>MutableList&lt;String&gt; list =<br/>        Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>, <strong class="la hj">"4"</strong>, <strong class="la hj">"5"</strong>);<br/>list.forEachWithIndex(3, 1,<br/>        (each, index) -&gt; <em class="lx">result</em>.add(<br/>                PrimitiveTuples.<em class="lx">pair</em>(each, index)));<br/><br/>var expected = List.<em class="lx">of</em>(<br/>        PrimitiveTuples.<em class="lx">pair</em>(<strong class="la hj">"4"</strong>, 3),<br/>        PrimitiveTuples.<em class="lx">pair</em>(<strong class="la hj">"3"</strong>, 2),<br/>        PrimitiveTuples.<em class="lx">pair</em>(<strong class="la hj">"2"</strong>, 1));<br/>Assertions.<em class="lx">assertEquals</em>(expected, result);</span></pre><h2 id="870a" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">ziptwithindex</h2><p id="a3f4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这个方法获取集合的所有元素，并将它们和它们的索引一起“压缩”到<code class="du kx ky kz la b">Pair</code>实例中。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="717c" class="lb jv hi la b fi lt lu l lv lw">MutableList&lt;String&gt; list = Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>);<br/>MutableList&lt;Pair&lt;String, Integer&gt;&gt; zipped = list.zipWithIndex();<br/><br/>var expected = List.<em class="lx">of</em>(<br/>        Tuples.<em class="lx">pair</em>(<strong class="la hj">"1"</strong>, 0),<br/>        Tuples.<em class="lx">pair</em>(<strong class="la hj">"2"</strong>, 1),<br/>        Tuples.<em class="lx">pair</em>(<strong class="la hj">"3"</strong>, 2));<br/>Assertions.<em class="lx">assertEquals</em>(expected, zipped);</span></pre><h2 id="a2cb" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">collectWithIndex(ordereditable)</h2><p id="8a45" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这种方法允许开发人员收集集合中的所有元素以及它们在新集合中的索引。这是一种更通用的、潜在有用的<code class="du kx ky kz la b">zipWithIndex</code>形式，结果可以是开发人员想要的任何类型，而不仅仅是一个<code class="du kx ky kz la b">Pair&lt;Integer, Integer&gt;</code>。在下面的例子中，集合被收集到一个新的<code class="du kx ky kz la b">StringIntPair</code>记录实例集合中。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="d969" class="lb jv hi la b fi lt lu l lv lw">record StringIntPair(String value, int index){};<br/>MutableList&lt;String&gt; list = Lists.<strong class="la hj"><em class="lx">mutable</em></strong>.with(<strong class="la hj">"1"</strong>, <strong class="la hj">"2"</strong>, <strong class="la hj">"3"</strong>);<br/>MutableList&lt;StringIntPair&gt; collected =<br/>        list.collectWithIndex(StringIntPair::new);<br/><br/>var expected = List.<em class="lx">of</em>(<br/>        new StringIntPair(<strong class="la hj">"1"</strong>, 0),<br/>        new StringIntPair(<strong class="la hj">"2"</strong>, 1),<br/>        new StringIntPair(<strong class="la hj">"3"</strong>, 2));<br/>Assertions.<em class="lx">assertEquals</em>(expected, collected);</span></pre><p id="118b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">collectWithIndex方法将ObjectIntToObjectFunction作为参数。</p><h1 id="48a9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Eclipse集合11.0的到来</h1><p id="9814" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">写完这篇博客后，我决定是时候给<code class="du kx ky kz la b">OrderedIterable</code>和<code class="du kx ky kz la b">ListIterable</code>接口添加<code class="du kx ky kz la b">selectWithIndex</code>和<code class="du kx ky kz la b">rejectWithIndex</code>方法了。当Eclipse Collections 11.0发布时，开发人员将能够使用将元素和索引都作为参数的谓词进行包含性和排他性过滤。</p><p id="ec4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的示例演示了如何根据偶数和奇数索引将一个列表划分为单独的列表。</p><pre class="je jf jg jh fd lp la lq lr aw ls bi"><span id="b449" class="lb jv hi la b fi lt lu l lv lw">ImmutableList&lt;Integer&gt; list = Lists.<strong class="la hj"><em class="lx">immutable</em></strong>.with(1, 2, 3, 4, 5);<br/>ImmutableList&lt;Integer&gt; evenIndexes = <br/>        list.selectWithIndex((each, index) -&gt; index % 2 == 0);<br/>ImmutableList&lt;Integer&gt; oddIndexes = <br/>        list.rejectWithIndex((each, index) -&gt; index % 2 == 0);<br/><br/>Assert.<em class="lx">assertEquals</em>(Lists.<strong class="la hj"><em class="lx">immutable</em></strong>.with(1, 3, 5), evenIndexes);<br/>Assert.<em class="lx">assertEquals</em>(Lists.<strong class="la hj"><em class="lx">immutable</em></strong>.with(2, 4), oddIndexes);</span></pre><p id="919a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">selectWithIndex</code>和<code class="du kx ky kz la b">rejectWithIndex</code>方法在Eclipse集合11.0.0.M3里程碑版本中可用。</p><h1 id="df93" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">摘要</h1><p id="0be5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在这篇博客中，我展示了用元素和索引迭代<code class="du kx ky kz la b">List</code>实例的不同方法。在普通Java中，您目前唯一的选择是使用外部迭代器。使用<a class="ae jt" href="https://github.com/donraab/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合，</a>开发人员可以选择使用一些专门的内部迭代器，将元素和索引作为参数传递给提供给他们的函数接口。</p><p id="864b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽情享受吧！</p><p id="d6b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lx">我是</em><a class="ae jt" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="lx">Eclipse Collections</em></a><em class="lx">OSS项目在</em><a class="ae jt" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="lx">Eclipse Foundation</em></a><em class="lx">的项目负责人。</em> <a class="ae jt" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="lx">月食收藏</em> </a> <em class="lx">是开投</em> <a class="ae jt" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="lx">投稿</em> </a> <em class="lx">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="4de2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">您可能想探索的其他文章:</strong></p><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/javarevisited/the-java-programmer-roadmap-f9db163ef2c2"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">2021年Java程序员路线图</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">2021年成为Java开发人员的图解指南，包含相关课程的链接</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx jn mj"/></div></div></a></div><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/javarevisited/7-best-webflux-and-reactive-spring-boot-courses-for-java-programmers-33b7c6fa8995"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">面向Java程序员的7门最佳WebFlux和反应式Spring Boot课程</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">我最喜欢的课程2021年学习Java中的反应式编程使用WebFlux、RxJava和反应式Spring Boot来自…</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="my l mu mv mw ms mx jn mj"/></div></div></a></div><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/javarevisited/my-favorite-spring-mvc-courses-for-java-developers-5ede7f85dd88"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">我最喜欢的2021年Java开发者学习的春季MVC课程</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">这些是初学者和有经验的Java开发人员学习Spring MVC框架的最佳在线课程…</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mz l mu mv mw ms mx jn mj"/></div></div></a></div></div></div>    
</body>
</html>