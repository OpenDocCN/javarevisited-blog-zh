<html>
<head>
<title>Spring Boot Testing — Data and Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot测试—数据和服务</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-boot-testing-data-and-services-bc8b4c62ee8f?source=collection_archive---------1-----------------------#2021-06-17">https://medium.com/javarevisited/spring-boot-testing-data-and-services-bc8b4c62ee8f?source=collection_archive---------1-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5649" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">章</h1><ol class=""><li id="9210" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><a class="ae jv" rel="noopener" href="/javarevisited/spring-boot-testing-data-and-services-bc8b4c62ee8f?source=friends_link&amp;sk=86148a772616274202776f4515c078e4"> Spring Boot测试—数据和服务</a></li><li id="c6df" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated"><a class="ae jv" rel="noopener" href="/javarevisited/spring-boot-testing-testcontainers-and-flyway-df4a71376db4?source=friends_link&amp;sk=1d0ffcd36bb4265c2d0120520bc8a567"> Spring Boot测试—测试容器和飞行路线</a></li></ol><p id="1eda" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">我认为测试是软件开发中必不可少的事情。我不是唯一一个。如果你问任何开发人员测试是否重要，他们可能会告诉你同样的事情。</p><p id="bff3" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">但现实并不那么光明。我见过的几乎所有项目要么缺乏测试，要么缺乏测试质量。不只是一个案例。问题是系统性的。</p><p id="ec29" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">为什么会这样？我认为开发人员通常没有足够重视提高测试框架使用的知识。因此，当涉及到验证业务逻辑时，程序员不知道如何去做。</p><p id="abb0" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">让我们来填补空白，看看春考为我们准备了什么。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es ks"><img src="../Images/35b9c39cf3cff6b9d8623c1f95ba2f4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*sz09nDQFtqaeu5VyHqewPA.jpeg"/></div></figure><p id="c7d2" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">代码片段取自这个<a class="ae jv" href="https://github.com/SimonHarmonicMinor/spring-boot-test-example" rel="noopener ugc nofollow" target="_blank">库</a>。您可以克隆它并运行测试，看看它是如何工作的。</p><h1 id="8a84" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">服务层+模拟</h1><p id="cd8e" class="pw-post-body-paragraph kb kc hi jf b jg jh ke kf ji jj kh ki jk la kk kl jm lb kn ko jo lc kq kr jq hb bi translated">模仿在测试环境中变得如此普遍，以至于<a class="ae jv" href="https://javarevisited.blogspot.com/2014/04/difference-between-stub-and-mock-object-java-junit.html" rel="noopener ugc nofollow" target="_blank"> <em class="ld">模仿</em> </a>和<a class="ae jv" rel="noopener" href="/javarevisited/6-best-appium-and-mobile-testing-courses-for-android-and-ios-developers-80f6cd51e375"> <em class="ld">测试</em> </a>几乎被认为是同义词。</p><p id="64f3" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">假设我们有<code class="du le lf lg lh b">PersonCreateService</code>。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">PersonCreateService:创建人员</p></figure><p id="cf47" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated"><code class="du le lf lg lh b">PersonValidateService</code>是我们的自定义界面。<code class="du le lf lg lh b">PersonRepository</code>是一个简单的<a class="ae jv" href="https://www.baeldung.com/the-persistence-layer-with-spring-data-jpa" rel="noopener ugc nofollow" target="_blank">春季数据JpaRepository </a>。</p><p id="ea58" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">让我们用模拟写一个单元测试。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">PersonCreateServiceTest:shouldFailUserCreation</p></figure><p id="b22c" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">好吧，这个很简单。让我们考虑一些更复杂的事情。一个用户的创作通过了怎么办？这需要更多的决心。</p><p id="624c" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">首先，我们需要模仿<code class="du le lf lg lh b">PersonRepository</code>，因此<code class="du le lf lg lh b">saveAndFlush</code>返回新的<code class="du le lf lg lh b">Person</code>实例，其中填充了<code class="du le lf lg lh b">id</code>字段。其次，我们需要测试结果<code class="du le lf lg lh b">PersonDTO</code>是否包含预期的信息。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">PersonCreateServiceTest:shodCreateNewUser</p></figure><p id="5043" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">事情变得棘手了。但是还没到休息的时候。假设已经用<code class="du le lf lg lh b">createFamily</code>方法增强了<code class="du le lf lg lh b">PersonCreateServiceImpl</code>。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">person create service:create family</p></figure><p id="b9a0" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">它也需要测试。我们试着写一个。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">PersonCreateServiceTest:shouldCreateFamily</p></figure><p id="038b" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">当我看这段代码时，我看到的只是一派胡言。数据流如此复杂，以至于几乎不可能得到测试真正在做什么。更重要的是，没有<em class="ld">测试</em>，而是<em class="ld">验证</em>一些特定的方法被称为定义的时间。“有什么区别？”你可能会问。假设<code class="du le lf lg lh b">saveAndFlush</code>方法的执行被定制的方法所取代，定制的方法更新实体并在存档表中保存以前的状态(例如<code class="du le lf lg lh b">saveWithArchiving</code>)。尽管业务逻辑是相同的，但是测试会失败，因为新方法没有被模仿。</p><p id="0bd9" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">也许最后一句话还不够有说服力。让我们看看<code class="du le lf lg lh b">Person</code>实体的声明。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">个人实体</p></figure><p id="97fc" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">它有一个<code class="du le lf lg lh b">PrePersist</code>回调函数，在数据库中插入新记录之前设置创建日期。问题是它不能用模拟来测试。该逻辑正在被JPA提供者调用。模仿不能模仿这种行为。</p><p id="6e52" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">所以，我们来下结论。模拟非常适合测试那些你可以控制的功能。这些通常是用户定义的服务(例如<code class="du le lf lg lh b">PersonValidateService</code>)。<a class="ae jv" href="https://www.java67.com/2021/01/spring-data-jpa-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"> Spring Data和JPA </a>在运行时会生成很多东西。模拟不会帮助你测试它。</p><h1 id="ad4a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">服务层+ H2数据库</h1><p id="33f3" class="pw-post-body-paragraph kb kc hi jf b jg jh ke kf ji jj kh ki jk la kk kl jm lb kn ko jo lc kq kr jq hb bi translated">如果您有一个应该与数据库交互的服务，那么真正测试它的唯一方法是在真实的数据库实例上运行它。<a class="ae jv" href="https://www.h2database.com/html/main.html" rel="noopener ugc nofollow" target="_blank">首先想到的是H2 DB </a>。</p><p id="41e8" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">谢天谢地，我们不需要任何复杂的配置和复杂的beans声明来在测试环境中运行数据库。Spring Boot会处理这件事。</p><h2 id="b1c3" class="lo ig hi bd ih lp lq lr il ls lt lu ip jk lv lw it jm lx ly ix jo lz ma jb mb bi translated">DataJpaTest</h2><p id="b933" class="pw-post-body-paragraph kb kc hi jf b jg jh ke kf ji jj kh ki jk la kk kl jm lb kn ko jo lc kq kr jq hb bi translated">我们从哪里开始？首先，我们需要声明测试套件。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">测试套件声明</p></figure><p id="07e9" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated"><code class="du le lf lg lh b">@DataJpaTest</code>这里的注释确实神奇。具体来说，有4点。</p><ol class=""><li id="cc53" class="jd je hi jf b jg kd ji kg jk mc jm md jo me jq jr js jt ju bi translated">启动H2数据库的嵌入式实例。</li><li id="e5d3" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">根据声明的实体类创建数据库模式。</li><li id="3df1" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">将所有存储库beans添加到应用程序上下文中。</li><li id="cbc5" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">用<code class="du le lf lg lh b">@Transactional</code>注释包装整个测试套件。因此，每个测试执行变得独立。</li></ol><p id="9a99" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">你可能已经注意到了<code class="du le lf lg lh b">@MockBean</code>注释。这就是<a class="ae jv" href="https://javarevisited.blogspot.com/2018/11/top-5-spring-boot-features-java.html#axzz6CwWzuI40" rel="noopener ugc nofollow" target="_blank"> Spring特性</a>，它不仅模仿接口，还将它添加到应用程序上下文中。因此，在测试运行期间，它可以被其他beans自动连接。</p><p id="6fab" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">现在我们需要实例化将要测试的服务。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">PersonCreatesService声明</p></figure><p id="5be8" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">在我看来，最灵活的解决方案提供了<code class="du le lf lg lh b">@TestConfiguration</code>注解。它允许我们修改现有的应用程序上下文。当<code class="du le lf lg lh b">PersonCreateService</code>加入后，可以很容易的注射<code class="du le lf lg lh b">@Autowire</code>。</p><p id="e727" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">好了，先来一个简单的<code class="du le lf lg lh b">createFamily</code>方法的快乐路径测试。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">PersonCreatesServiceTest:“创建家庭”快乐之路</p></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es mf"><img src="../Images/39e621b8bf6dc384dcc277bce746eed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*1PWlMMMiSFC15s4MeJn5xQ.png"/></div><p class="lk ll et er es lm ln bd b be z dx translated">试验结果</p></figure><p id="335d" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">正如您所看到的，这个测试比使用模拟的测试更干净、更简短、更容易理解。不仅如此，我们现在能够测试<a class="ae jv" rel="noopener" href="/javarevisited/top-5-books-to-learn-hibernate-for-java-developers-b2cb4b16ccd6?source=---------14------------------"> Hibernate </a>回调(例如<code class="du le lf lg lh b">@PrePersist</code>)。</p><p id="8808" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">嗯，这个是蛋糕。但是如果<code class="du le lf lg lh b">ValidationFailedException</code>发生了呢？这意味着事务应该回滚。让我们找出答案。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">PersonCreateServiceTest:" shouldRollbackIfAnyUserIsNotValidated "</p></figure><p id="9594" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">创建<code class="du le lf lg lh b">"John"</code>时执行应该会失败。这意味着总人数必须等于0，因为抛出异常会回滚事务。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es mg"><img src="../Images/a1b7ba42fc87e5360e556c11533c2009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*7KYr-kF_GBwqLmBrDcbttQ.png"/></div><p class="lk ll et er es lm ln bd b be z dx translated">试验结果</p></figure><pre class="kt ku kv kw fd mh lh mi mj aw mk bi"><span id="70fb" class="lo ig hi lh b fi ml mm l mn mo">expected: &lt;0&gt; but was: &lt;2&gt;<br/>Expected :0<br/>Actual   :2</span></pre><p id="6c43" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">出事了。似乎由于某种原因，事务没有回滚。这是真的。</p><p id="1312" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">我提到过<code class="du le lf lg lh b">@DataJpaTest</code>用<code class="du le lf lg lh b">@Transactional</code>包装套件。因此，测试套件和服务都是事务性的。注释的默认传播级别是<code class="du le lf lg lh b">REQUIRED</code>。这意味着调用另一个事务方法<strong class="jf hj">不会启动新的事务。相反，它继续执行当前语句中的SQL语句。<code class="du le lf lg lh b">ValidationFailedException</code>发生不会回滚事务，因为异常没有离开它的作用域。因此，计数返回2而不是0。</strong></p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es mp"><img src="../Images/1cdb3af466a7655fa0c158b56b862fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZxgd_4dBq_5kk5znbHhIw.png"/></div></div></figure><p id="4dca" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">我在我的文章<a class="ae jv" href="https://levelup.gitconnected.com/spring-data-transactional-caveats-f6edd41d6785?source=friends_link&amp;sk=684542cba1a8de7233c974f25e500ede" rel="noopener ugc nofollow" target="_blank">“春季数据—交易警告”</a>中描述了这种现象。</p><p id="024c" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">我们能做些什么呢？实际上，习惯不允许我们做任何事情。我们可以将<code class="du le lf lg lh b">PersonCreateService.createFamily</code>事务传播标记为<code class="du le lf lg lh b">REQUIRES_NEW</code>。这解决了当前测试的问题，但增加了新的问题。您可以在我在文章开头标记的库中找到更多的例子。</p><p id="fe9e" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">如果<code class="du le lf lg lh b">@DataJpaTest</code>导致如此怪异的问题，那么它的目的是什么？嗯，它的名字描述了目标。它应该与<em class="ld">存储库测试</em>一起使用。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">人员信息库</p></figure><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">PersonRepositoryDataJpaTest</p></figure><p id="25ef" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">看到了吗？非常合适。该测试执行一条SQL语句。在这种情况下，<code class="du le lf lg lh b">@DataJpaTest</code>的交易行为就变得方便了。但是服务层要复杂得多。我们需要一个不同的工具。</p><h2 id="0074" class="lo ig hi bd ih lp lq lr il ls lt lu ip jk lv lw it jm lx ly ix jo lz ma jb mb bi translated">跳趾试验</h2><p id="09de" class="pw-post-body-paragraph kb kc hi jf b jg jh ke kf ji jj kh ki jk la kk kl jm lb kn ko jo lc kq kr jq hb bi translated">让我们稍微重写一下测试声明。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">personcreateserviceimplspringboottest声明</p></figure><p id="5c5c" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">与<code class="du le lf lg lh b">@DataJpaTest</code>备选方案有一些不同。</p><p id="bc40" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated"><code class="du le lf lg lh b">@SpringBootTest</code>注释启动整个Spring上下文，而不仅仅是JPA存储库。另一件重要的事情是，它<strong class="jf hj">没有</strong>用<code class="du le lf lg lh b">@Transactional</code>包装测试套件。<code class="du le lf lg lh b">webEnvironment = WebEnvironment.NONE</code>是一个轻微的优化。在测试用例中，我们不需要web层。因此，没有必要在这方面花费资源。</p><p id="c7b9" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated"><code class="du le lf lg lh b">@AutoConfigureTestDatabase</code>注释配置嵌入式H2数据库，并根据定义的实体创建模式。<code class="du le lf lg lh b">@DataJpaTest</code>已经包含了它，所以声明它们是多余的(除非我们想参数化<code class="du le lf lg lh b">@AutoConfigureTestDatabase</code>，但这超出了范围)。</p><p id="3354" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">你可能也注意到了，我们只是自动连线了<code class="du le lf lg lh b">PersonCreateService</code>，没有任何额外的配置。由于默认情况下<code class="du le lf lg lh b">@SpringBootTest</code>实例化每个bean，服务已经存在于应用程序上下文中。</p><p id="b94a" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">需要在<code class="du le lf lg lh b">@BeforeEach</code>回调<strong class="jf hj"> </strong>中重置数据库，因为<code class="du le lf lg lh b">@SpringBootTest</code>不提供事务行为。但是我们需要在测试运行之间保持桌子干净。</p><p id="0a3e" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">所以，让我们把来自<code class="du le lf lg lh b">@DataJpaTest</code>例子的测试放进去，看看它是如何工作的。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">personcreateserviceimplspringboottest</p></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es mu"><img src="../Images/9700bdee7cc3d8af62e9a116e0b1fad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*EfSvr76LKLFVPXDnrn-k-g.png"/></div><p class="lk ll et er es lm ln bd b be z dx translated">试验结果</p></figure><p id="6425" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">一切都像魔咒一样管用。</p><p id="9eb2" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">我们所有的测试用例都假设<code class="du le lf lg lh b">PersonValidateService.checkUserCreation</code>有一个检查输入参数的简单逻辑。但在现实中，这可能不是真的。该服务也可以与数据库交互，以便检查先决条件。所以，我们来模仿一下行为。</p><p id="4103" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">假设验证器不允许创建一个新的人，如果有一个人同名的话。为了测试这个场景，我们需要适当模拟<code class="du le lf lg lh b">PersonValidateService</code>，并在调用<code class="du le lf lg lh b">PersonCreateService.createFamily</code>方法之前提前插入一个家庭成员。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="li lj l"/></div><p class="lk ll et er es lm ln bd b be z dx translated">PersonCreateServiceImplSpringBootTest</p></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es mv"><img src="../Images/c682dcb67e12ac9f8e19041e2b5e4ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*S-X7r95HS3ax4Ud5dCHAfA.png"/></div><p class="lk ll et er es lm ln bd b be z dx translated">试验结果</p></figure><p id="5b3b" class="pw-post-body-paragraph kb kc hi jf b jg kd ke kf ji kg kh ki jk kj kk kl jm km kn ko jo kp kq kr jq hb bi translated">有用！另外，这里剧透一下。无论您应用什么配置，它都无法与<code class="du le lf lg lh b">@DataJpaTest</code>一起工作。你可以在<a class="ae jv" href="https://github.com/SimonHarmonicMinor/spring-boot-test-example" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到这个例子。</p><blockquote class="mw mx my"><p id="b779" class="kb kc ld jf b jg kd ke kf ji kg kh ki mz kj kk kl na km kn ko nb kp kq kr jq hb bi translated"><em class="hi">2021年7月14日编辑</em></p><p id="b59e" class="kb kc ld jf b jg kd ke kf ji kg kh ki mz kj kk kl na km kn ko nb kp kq kr jq hb bi translated">实际上，<code class="du le lf lg lh b">@DataJpaTest</code> <strong class="jf hj">可以</strong>非事务运行。你只需要将<code class="du le lf lg lh b">@Transactional(propagation = NOT_SUPPORTED)</code>添加到测试类中。雷南·弗兰卡谢谢你的提示！</p></blockquote><pre class="kt ku kv kw fd mh lh mi mj aw mk bi"><span id="e1f2" class="lo ig hi lh b fi ml mm l mn mo">@DataJpaTest<br/>@Transactional(propagation = Propagation.<em class="ld">NOT_SUPPORTED</em>)<br/>class PersonCreateServiceImplTestH2 {<br/><br/>  @Autowired<br/>  private PersonRepository personRepository;<br/>  @MockBean<br/>  private PersonValidateService personValidateService;<br/>  @Autowired<br/>  private PersonCreateService personCreateService;<br/><br/>  @BeforeEach<br/>  void beforeEach() {<br/>    personRepository.deleteAll();<br/>  }<br/><br/>  @TestConfiguration<br/>  static class Config {<br/><br/>    @Bean<br/>    public PersonCreateService personCreateService(<br/>        PersonRepository personRepository,<br/>        PersonValidateService personValidateService<br/>    ) {<br/>      return new PersonCreateServiceImpl(personValidateService, personRepository);<br/>    }<br/>  }</span><span id="7640" class="lo ig hi lh b fi ne mm l mn mo">  // test cases...<br/>}</span></pre><h1 id="7b90" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="6687" class="pw-post-body-paragraph kb kc hi jf b jg jh ke kf ji jj kh ki jk la kk kl jm lb kn ko jo lc kq kr jq hb bi translated">感谢您的阅读！那是一篇相当长的文章，我很高兴你能看完。下次我们将讨论<a class="ae jv" href="https://www.testcontainers.org/" rel="noopener ugc nofollow" target="_blank"> Testcontainers </a>与<a class="ae jv" href="https://javarevisited.blogspot.com/2021/02/-spring-boot-testing-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"> Spring Test </a>的集成。如果您有任何问题或建议，请在下面留下您的评论。下次见！</p></div></div>    
</body>
</html>