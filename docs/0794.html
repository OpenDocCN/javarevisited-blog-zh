<html>
<head>
<title>Java 8 Important Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 8的重要特性</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/important-java-8-features-e52c8d8e8662?source=collection_archive---------2-----------------------#2020-11-20">https://medium.com/javarevisited/important-java-8-features-e52c8d8e8662?source=collection_archive---------2-----------------------#2020-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/121862a4108424adc385e42876e07d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/0*BbNzc9erdOsSolt1.png"/></div></figure><p id="6754" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Java 8于2014年3月18日发布。对于软件开发平台来说，这是一个革命性的版本，对Java编程、JVM、工具和库进行了各种增强。以下是Java 8的一些重要且有用的特性:</p><h2 id="1c99" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated"><strong class="ak">功能接口:</strong></h2><p id="5385" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">函数接口是Java 8中引入的新概念。只有一个抽象方法的接口成为函数接口，但是，它可以有任意数量的默认或静态方法，它也可以声明一个对象类的方法(例如:toString())。</p><p id="d684" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们不需要使用<a class="ae kk" href="https://javarevisited.blogspot.com/2018/01/what-is-functional-interface-in-java-8.html" rel="noopener ugc nofollow" target="_blank"> @functionalInterface注释</a>来将一个接口标记为函数接口，但是这个注释是一个避免在函数接口中意外添加<a class="ae kk" href="https://www.java67.com/2017/07/can-you-make-abstract-class-method-final-in-java.html" rel="noopener ugc nofollow" target="_blank">抽象方法</a>的工具。<code class="du kl km kn ko b"><strong class="io hj">java.lang.Runnable</strong></code>用单一抽象方法run()是函数接口的一个很好的例子。λ表达式可以用来表示函数接口的实例</p><h2 id="f8eb" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated"><strong class="ak"> 1。λ表达式:</strong></h2><p id="d44e" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">Lambda表达式提供了一种精确的方法，通过使用表达式来实现单一抽象方法(函数接口)。由于函数接口只有一个方法，<a class="ae kk" href="https://www.java67.com/2020/03/how-to-write-clean-code-using-java-8.html" rel="noopener ugc nofollow" target="_blank"> lambda表达式</a>可以很容易地提供方法实现，我们只需要提供方法参数和业务逻辑。它在集合库中也非常有用，可以帮助迭代，<a class="ae kk" href="https://www.java67.com/2016/08/java-8-stream-filter-method-example.html" rel="noopener ugc nofollow" target="_blank">过滤</a>和提取数据。</p><p id="cb14" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，以下面实现runnable接口的代码为例</p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="0b92" class="jk jl hi ko b fi kx ky l kz la"><strong class="ko hj">Runnable r = new Runnable(){<br/>@Override <br/>public void run() { <br/>System.out.println(“My Runnable”); <br/>}};</strong></span></pre><p id="7372" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lb">用</em><a class="ae kk" href="https://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#axzz6ieZZarMY" rel="noopener ugc nofollow" target="_blank"><em class="lb">λ表达式</em> </a> <em class="lb">，上面的代码可以缩短为仅仅单行:</em></p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="c204" class="jk jl hi ko b fi kx ky l kz la"><strong class="ko hj">Runnable r1 = () -&gt; { System.out.println(“My Runnable”); };<em class="lb"><br/></em></strong></span></pre><p id="2d49" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lb"> Lambda表达式被视为一个函数，因此编译器不会单独创建一个. class文件。</em></p><h2 id="f9be" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated"><strong class="ak"> 2。方法参考</strong></h2><p id="0128" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated"><a class="ae kk" href="https://javarevisited.blogspot.com/2017/03/what-is-method-references-in-java-8-example.html" rel="noopener ugc nofollow" target="_blank">方法引用</a>帮助我们通过方法的名字来指向它们。使用<strong class="io hj"> :: </strong>符号描述，可以用于静态或实例方法，也可以用于使用new运算符的构造函数，如<strong class="io hj"> TreeSet::new </strong>。方法引用是调用方法的lambda表达式的简写符号。</p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="3ca1" class="jk jl hi ko b fi kx ky l kz la"><strong class="ko hj">str -&gt; System.out.println(str)</strong></span></pre><p id="009d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以<a class="ae kk" href="https://javarevisited.blogspot.com/2017/08/how-to-convert-lambda-expression-to-method-reference-in-java8-example.html#axzz5gKl3DykI" rel="noopener ugc nofollow" target="_blank">用类似<em class="lb"> System.out::println </em>的方法引用</a>替换上面的lambda表达式。</p><p id="aeca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">示例:</p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="2438" class="jk jl hi ko b fi kx ky l kz la"><strong class="ko hj">public class Abc {<br/>public static void thrd(){<br/>System.out.println(“Thread is running !”);<br/>}<br/>public static void main(String[] args) {<br/>Thread t2=new Thread(Abc::thrd);<br/>t2.start(); }}</strong></span></pre><h2 id="a380" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated"><strong class="ak"> 3。forEach: </strong></h2><p id="3609" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">Java 8提供了一个新方法<a class="ae kk" href="https://www.java67.com/2016/01/how-to-use-foreach-method-in-java-8-examples.html" rel="noopener ugc nofollow" target="_blank"> forEach() </a>来迭代集合和流。它在Iterable和Stream接口中定义。<br/>每当我们需要遍历一个集合时，我们需要创建一个<a class="ae kk" href="https://www.java67.com/2013/02/java-iterator-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">迭代器</strong> </a>，在这个过程中，如果迭代器使用不当，我们可能会得到<a class="ae kk" href="https://www.java67.com/2015/10/how-to-solve-concurrentmodificationexception-in-java-arraylist.html" rel="noopener ugc nofollow" target="_blank">ConcurrentModificationException</a>。</p><p id="81b8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">扩展Iterable接口的集合类可以使用forEach()方法来迭代元素。该方法采用单个参数，该参数是一个函数接口。所以，我们可以通过一个<a class="ae kk" rel="noopener" href="/javarevisited/7-best-java-tutorials-and-books-to-learn-lambda-expression-and-stream-api-and-other-features-3083e6038e14?source=---------14------------------">λ表达式</a>作为自变量。<br/>例如:</p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="cb36" class="jk jl hi ko b fi kx ky l kz la"><strong class="ko hj">public static void main(String[] args) {<br/> List&lt;String&gt; list= new ArrayList&lt;String&gt;();<br/> list.add(“Apple”);<br/> list.add(“Orange”);<br/> list.add(“Banana”);<br/>//lambda expression in forEach Method <br/> list.forEach(str-&gt;System.out.println(str));<br/>//above line can also be written using method reference as<br/> list.forEach(System.out::println));<br/>}</strong></span></pre><h2 id="70b2" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated"><strong class="ak"> 4。流API </strong></h2><p id="6588" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">Stream是Java 8中引入的抽象层。有了流，我们可以像Sql语句一样以声明的方式处理数据。它表示来自支持集合函数的源的对象序列。流API将允许顺序和并行执行。</p><p id="0eca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">集合接口已经用<strong class="io hj"> <em class="lb"> stream() </em> </strong>和<strong class="io hj"> <em class="lb"> parallelStream() </em> </strong>默认方法进行了扩展，以获得用于顺序和并行执行的流。我们可以使用流来<a class="ae kk" rel="noopener" href="/javarevisited/how-to-use-streams-map-filter-and-collect-methods-in-java-1e13609a318b">过滤、收集、打印、</a>以及从一个<a class="ae kk" rel="noopener" href="/javarevisited/top-10-free-data-structure-and-algorithms-courses-for-beginners-best-of-lot-ad807cc55f7a">数据结构</a>转换到另一个数据结构，等等。</p><p id="81be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">流在本质上是功能性的。对流执行的操作不会修改它的源。例如，<a class="ae kk" href="https://javarevisited.blogspot.com/2018/05/java-8-filter-map-collect-stream-example.html#axzz5gKl4TfLR" rel="noopener ugc nofollow" target="_blank">过滤从集合中获得的流</a>会产生一个没有过滤元素的新流，而不是从源集合中删除元素。</p><p id="6dea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与需要显式迭代的集合相比，流操作在内部对源元素进行迭代。<br/>流过滤器示例:</p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="5046" class="jk jl hi ko b fi kx ky l kz la"><em class="lb"> </em><strong class="ko hj">public static void main(String[] args) { <br/> List&lt;Product&gt; products = new ArrayList&lt;Product&gt;(); <br/> //Adding Products <br/> products.add(new Product(1,”Fruits”,20000f)); <br/> products.add(new Product(2,”Vehicle”,33000f)); <br/> products.add(new Product(3,”Household”,25000f)); <br/> <br/> List&lt;Float&gt; priceList =products.stream() <br/>  .filter(p -&gt; p.price &gt; 30000) // filtering data <br/>  .map(p-&gt;p.price)              // fetching price <br/>  .collect(Collectors.toList()); // collecting as list <br/>  System.out.println(priceList); // will print [33000.0]<br/> }</strong></span></pre><p id="b15d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">更多例子和Java 8 Stream API支持的所有方法可以查看<a class="ae kk" href="https://www.java2novice.com/java-8/streams/map-method-example/" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="1567" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 5。接口<br/> </strong>中的默认和静态方法Java 8允许接口拥有<a class="ae kk" href="https://www.java67.com/2017/08/java-8-default-methods-faq-frequently-questions-answers.html" rel="noopener ugc nofollow" target="_blank">默认</a>和<a class="ae kk" href="https://www.java67.com/2019/02/can-you-add-non-abstract-method-on-interface-in-java.html" rel="noopener ugc nofollow" target="_blank">静态方法</a>。在接口中使用默认方法的原因是允许开发人员在不影响实现这些接口的类的情况下向接口添加新方法，这使得接口向后兼容。</p><p id="4560" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">向后兼容性是在不破坏旧代码的情况下添加新功能。</p><p id="34ab" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接口中的静态方法类似于默认方法，除了我们不能在实现这些接口的类中覆盖这些方法。</p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="1d74" class="jk jl hi ko b fi kx ky l kz la"><strong class="ko hj">interface ParentInt{  <br/>    default void defaultMet(){  <br/>        System.out.println("default method");  <br/>    }  <br/>    static void staticMet(){<br/>     System.out.println("static method");<br/>    }<br/>    void existingMet(String str);  <br/>}  <br/>public class child implements ParentInt{ <br/> <br/>    public void existingMet(String str){           <br/>        System.out.println("String is: "+str);  <br/>    }  <br/>    public static void main(String[] args) {  <br/>     Example obj = new Example();<br/>     <br/>     //calling the default method of interface<br/>        obj.defaultMet();     <br/>        //calling the static method of interface<br/>        ParentInt.staticMet();<br/>        //calling the abstract method of interface<br/>        obj.existingMet("Java 8 Features "); <br/>    }  <br/>}</strong></span></pre><p id="dec5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出:</p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="9f6c" class="jk jl hi ko b fi kx ky l kz la"><strong class="ko hj">default method<br/>static method<br/>String is: Java 8 Features</strong></span></pre><h2 id="1132" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">6。Base64编解码:</h2><p id="ffa0" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">Java 8中引入的另一个特性是<a class="ae kk" href="https://javarevisited.blogspot.com/2016/10/base64-encoding-example-in-java-8.html#axzz5HKrGFmPU" rel="noopener ugc nofollow" target="_blank"> Base64编码</a>和<a class="ae kk" href="https://javarevisited.blogspot.com/2012/02/how-to-encode-decode-string-in-java.html#axzz54LFhfNxy" rel="noopener ugc nofollow" target="_blank">解码</a>。它提供了一个Base64类来处理加密和解密。我们需要在源文件中导入java.util.Base64类来使用它的方法。<br/>在Java 8之前，我们需要添加外部jar，如Apache Commons <code class="du kl km kn ko b">Codec’s Base64.encodeBase64(byte[]) </code>和Base64.decodeBase64(byte[])，如这里的<a class="ae kk" href="http://javarevisited.blogspot.sg/2012/02/how-to-encode-decode-string-in-java.html" rel="noopener ugc nofollow" target="_blank">所示</a>，或者Sun的内部Base64编码器和解码器sun.misc.BASE64Encoder()。encode()和sun.misc.BASE64Decoder()。解码()</p><p id="a247" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以上是Java 8中引入的一些重要特性。希望你觉得有用。</p><p id="7ed8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谢谢！！:)</p></div></div>    
</body>
</html>