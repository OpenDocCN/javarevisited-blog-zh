# 我们对机会主义重构的看法

> 原文：<https://medium.com/javarevisited/our-take-on-opportunistic-refactoring-e606bb76e8c8?source=collection_archive---------0----------------------->

![](img/f69154759d3733c6b9a42b3c9bb86d59.png)

[修复中的救世主教堂](http://www.new-cat.nichost.ru/ru/restoration/spas)

代码库在某种程度上是一种不断变化的物质。软件产品本身不同于任何其他产品。不像建筑也有架构，一个软件一旦建成就不会保持不变。不像小工具，一个软件没有新的版本，在新的版本之后你应该扔掉你的旧版本。

不，软件在进化。在这一演变过程中，一些建筑、结构或其他决策不像以前那样合适，这是完全正常的。

在某些时候，当新的特性需求到来时，您最初的决定开始对您不利。这就是你需要做出选择的地方:是做对还是做快，然后再处理[的技术债务](https://martinfowler.com/bliki/TechnicalDebt.html)。很多时候开发商选择错了。遗留代码就是这样诞生的。

随着项目开发的进行，越来越多的决策支持 fast。直到最后**开发者被迫选择正确的**，仅仅因为快不再快了。

当技术部门的数量多得令人应接不暇时——团队开始考虑重构，以根据新的需求调整应用程序架构。在这一点上，全面的重构是一件非常冒险的事情。重构的必要性只对开发团队来说是显而易见的。客户或采购订单希望新功能以与以前相同的速度交付，但向他解释为什么功能开发要冻结几周并不容易，这不仅不会带来任何新的商业价值，还可能引入新的产品包。

听起来很熟悉？

幸运的是，有一种方法介于快速特性交付和全面重构之间。这被称为[机会主义重构](https://martinfowler.com/bliki/OpportunisticRefactoring.html)，并且基于[童子军规则](https://deviq.com/boy-scout-rule/):

> 让你的代码比你发现的更好。

这意味着如果有机会的话，在受新特性实现影响的地方一段一段地清理代码。

![](img/aa4579e6e69b9a53a387b5fd79689593.png)

[志愿者清理芬兰湾](https://nevnov.ru/679464-volontery-ubirali-musor-na-skorost-na-beregu-finskogo-zaliva)

> **您可能会得到一些工作，但是要意识到如果与现有类的交互被改变的话会更好。在你认为自己已经完成之前，抓住机会去做。** —马丁·福勒，机会主义重构

所有这些听起来足够简单和明智。但是将它合并到一个遗留项目中需要一个非常专注的团队。每个团队成员都应该清楚地理解为什么他要做更多的工作来实现一些简单的特性。每个团队成员都应该了解如何改进项目的当前状态，以及在实施过程中他可以做些什么来改进它。

这就是我们想出的方法，在我们的团队中成功地用于一些非常糟糕的遗留项目。

![](img/edbc72ba2b9c6d07bf3e7fc0f18a7959.png)

[先锋(苏联童子军)捡废金属](https://turboteka.ru/2017/03/19/sovetskie-plakaty-pro-pionerov-19-foto/)

为了建立这种童子军的态度，我们稍微扩展了一下我们的代码审查过程。

基本上是这样的:**如果在特性实现过程中，你对类进行了一些修改，那么这个完整的类现在有资格进行代码评审**。

可以先以建议的形式逐步开始。但是过一会儿，你会注意到团队成员已经做得更多了，在评审过程中预见到那些建议。

此外，在这个过程中，评审者不应该总是被动的。他还可以为反向审核推动一些更改。

只要在你的团队里行得通。

## 这种机会性重构有助于以下几个方面:

*   团队成员之间几乎**不需要同步**:一旦某个特性被认为是一个独立的工作——所有围绕的重构也或多或少是独立的；
*   工作对客户来说变得更加透明，并且比专门的全面重构过程带来更少的风险；
*   **特性与一些代码改进一起交付**；
*   通过使用像代码审查这样的已知过程，成年礼变得更加自然；**没有人是被迫突然变成童子军**。

令人惊讶的是，我发现[这种方法在一些团队中会遇到很大的摩擦](https://softwareengineering.stackexchange.com/questions/244807/reconciling-the-boy-scout-rule-and-opportunistic-refactoring-with-code-reviews)。一个积极的团队成员做的比要求的多，而不是拥抱一个实践，它被团队成员和管理层拒绝。这是非常缺乏远见的。

这里有一些如何处理它的建议:

*   万一团队成员对这种方法有某种形式的拒绝——开始只与感兴趣的人建立这种方法；它可以在团队成员之间传播；
*   万一管理层有任何担心，不要告诉你的经理你到底在做什么；功能已经交付，但规划从来都不精确；毕竟——代码审查是你内部团队的事情。

同样在对这个 [StackExchange](https://softwareengineering.stackexchange.com/) 线程的回答中，许多人建议以某种方式分割特性实现和重构*(不同的 PR，不同的提交)*以使修改对评审者来说是清楚的。但是我反对。因为重构是由特性实现引起的——两者都应该被视为一个变化的一部分。

总的来说，为每一个变化做更多的事情，保持代码库的整洁和设计决策的清晰是一个好的实践。

用这种方法，很容易注意到没有常规任务。每个任务不仅可以增加业务价值，还可以增加代码质量方面的价值。