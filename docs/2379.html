<html>
<head>
<title>Troubleshooting and Fixing OutOfMemoryError in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot内存不足错误的故障排除和修复</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/troubleshooting-and-fixing-outofmemoryerror-in-spring-boot-5cc559f556ea?source=collection_archive---------1-----------------------#2022-09-10">https://medium.com/javarevisited/troubleshooting-and-fixing-outofmemoryerror-in-spring-boot-5cc559f556ea?source=collection_archive---------1-----------------------#2022-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/281c19be32f4e2acc918d0534f401f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D9Mqy3BZA9C9sRBU"/></div></div><p class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae iu" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>拍摄</p></figure><p id="e6b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在一家领先的跨国公司工作，在一个工程团队中，帮助为员工打造优秀的内部产品。我主要从事<a class="ae iu" rel="noopener" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"> Java </a>、<a class="ae iu" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e"> Spring Boot </a>和RDBMS(<a class="ae iu" rel="noopener" href="/javarevisited/7-best-free-postgresql-courses-for-beginners-to-learn-in-2021-3bf369d73794">Postgres</a>/<a class="ae iu" rel="noopener" href="/javarevisited/top-5-courses-to-learn-mysql-in-2020-4ffada706">MySQL</a>)栈的工作。几年前，我们的团队开始了从Monolith到<a class="ae iu" rel="noopener" href="/javarevisited/10-best-java-microservices-courses-with-spring-boot-and-spring-cloud-6d04556bdfed">微服务</a>的转型之旅，下面是我们的应用通常遵循的架构。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://www.java67.com/2021/02/microservices-interview-questions-answers-java-spring.html"><div class="er es jt"><img src="../Images/38a60360fe53ead709b1daa2a1d70ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCAA9_22QZgtGNSBycWLaA.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">整体到微服务</p></figure><h1 id="a259" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">性能问题</h1><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://www.java67.com/2019/02/7-common-socket-errors-and-exception-in-java.html"><div class="er es kw"><img src="../Images/cb0b08c63cb1618a75b5aa1dc16b4858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zw7yxJ_l18F_P-TmqVLCQ.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">Grafana仪表板显示巨大的CPU利用率</p></figure><p id="6482" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们公司最近的一次公告之后，我们开始看到我们的应用程序的流量出现了意想不到的激增。最终用户开始抱怨应用程序变得缓慢，我们也开始从我们团队使用的日志监控工具<a class="ae iu" href="https://www.vmware.com/in/products/vrealize-log-insight.html" rel="noopener ugc nofollow" target="_blank"> LogInsight </a>收到许多错误警报。从Grafana <a class="ae iu" href="https://grafana.com/solutions/kubernetes/?pg=dashboards&amp;plcmt=featured-dashboard-1" rel="noopener ugc nofollow" target="_blank">仪表板</a>(查看两个CPU利用率峰值)中，我们发现微服务单元承受着巨大的压力，这导致Spring Cloud Gateway单元抛出C <a class="ae iu" href="https://javarevisited.blogspot.com/2013/02/java-net-ConnectException-Connection-refused.html" rel="noopener ugc nofollow" target="_blank">连接超时异常</a>，从而发出警报。</p><h2 id="0420" class="kx jz hi bd ka ky kz la ke lb lc ld ki jg le lf km jk lg lh kq jo li lj ku lk bi translated">应用技术规范:</h2><p id="eceb" class="pw-post-body-paragraph iv iw hi ix b iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">应用程序运行在遵循网关设计模式的微服务架构上。后端pod是基于JAVA 8的Spring Boot docker映像。部署规格为2CPU和4GB RAM，每个微服务总共有3个pod。Java正在使用<a class="ae iu" href="https://javarevisited.blogspot.com/2016/10/how-to-increase-heap-size-of-eclipse-OutOfMemoryError.html" rel="noopener ugc nofollow" target="_blank">默认堆参数运行。</a>我们使用<a class="ae iu" href="https://www.sqlrevisited.com/2022/03/mysql-vs-postgresql-pros-and-cons.html" rel="noopener ugc nofollow" target="_blank"> Postgresql </a>作为我们的RDBMS。</p><p id="4f75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最初，我认为由于异常巨大的流量，pod无法承受负载，所以我增加了我们的<a class="ae iu" href="https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/index.html" rel="noopener ugc nofollow" target="_blank"> TKG </a>命名空间上的资源，以便我可以增加后端pod的数量。它创造了奇迹。厉害了，长舒了一口气。几周后，我们开始看到同样的警报。是时候系好安全带，找到问题的根源了。</p><h1 id="33f9" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">影响:</strong></h1><p id="5da5" class="pw-post-body-paragraph iv iw hi ix b iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">由于应用程序运行缓慢，最终用户对用户体验不满意。应用程序管理员在完成审批流程时面临问题，这增加了他们的积压工作。</p><h1 id="a5a9" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">这个问题是如何解决的？</h1><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/5c8bca1fee438a4f532144a336d44c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4DoEU4RTiIy-cIxA0ksKA.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">来自LogInsight的屏幕截图:内存不足错误</p></figure><p id="bbb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.vmware.com/in/products/vrealize-log-insight.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">登录查看</strong> </a> <strong class="ix hj">救援</strong>。我开始搜索我们的微服务pods的日志来找出缓慢的原因，发现这是可怕的<a class="ae iu" href="https://javarevisited.blogspot.com/2011/09/javalangoutofmemoryerror-permgen-space.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> OOM错误:Java堆空间</strong> </a>。我从<a class="ae iu" href="https://www.vmware.com/in/products/vrealize-log-insight.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> LogInsight </strong> </a>导出了日志，检查了OOM错误的堆栈跟踪，发现有一个API导致了这个问题。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2012/01/tomcat-javalangoutofmemoryerror-permgen.html"><div class="er es lr"><img src="../Images/d9de82427e555b3c65ddabfdae704465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRJyCpkSwxBW2GoDdjvX7g.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">LogInsight的屏幕截图:OOM错误的堆栈跟踪</p></figure><h1 id="3ac0" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我是如何修复它的？</h1><p id="f501" class="pw-post-body-paragraph iv iw hi ix b iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">好了，现在我已经缩小了导致瓶颈的API的范围。看起来像是API依次发出一个数据库查询，返回超过100k+行，阻塞了整个堆内存。一般来说，这不是一个很大的计数，但是如果我们的实体映射类包含很多属性并且有多个关联，这就会成为一个问题</p><p id="ed11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">。我没有一次获取所有行并<a class="ae iu" href="https://www.java67.com/2016/10/3-ways-to-convert-string-to-json-object-in-java.html" rel="noopener ugc nofollow" target="_blank">将它们映射到Java对象</a>来获得计算值，而是用一个高级的高效查询来代替它，以获得相同的结果。这一变化极大地提高了应用程序的性能，并极大地减少了堆的大小。</p><p id="708e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了解决这个问题，我还调整了某些东西，这样我们就可以维持不断增长的流量。</p><p id="6900" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.使用弹簧Kubernetes致动器<a class="ae iu" href="https://www.baeldung.com/spring-liveness-readiness-probes" rel="noopener ugc nofollow" target="_blank">端点</a>引入<a class="ae iu" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">活性和就绪探针</strong></a>；因此，万一应用程序停止响应，Kubernetes可以停止并重启容器。</p><p id="59ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.JAVA 8没有<a class="ae iu" rel="noopener" href="/marionete/managing-java-heap-size-in-kubernetes-3807159e2438#:~:text=As%20we%20may%20have%20been,are%20not%20imposing%20any%20quotas."> docker感知</a>，因此不会根据部署YAML中提供的请求和限制来分配适当的JVM堆空间。如果不指定<code class="du ls lt lu lv b">-Xmx</code>，默认的“最大堆”是主机RAM的1/4 (25%)。所以我在Dockerfile的启动命令中添加了初始和最大堆大小参数。</p><p id="5f8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ls lt lu lv b">java -Xms1024m -Xmx2048m -jar /opt/java/microservices/$APP_NAME/jar/$APP_NAME*.jar</code></p><p id="dcb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.使用<a class="ae iu" href="https://www.ehcache.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> Ehcache </strong> </a>为最热门的GET APIs引入<a class="ae iu" rel="noopener" href="/javarevisited/distributed-caching-with-ehcache-using-mysql-16b71d62ec23">分布式缓存</a>。</p><p id="710e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其他可以调查的事项:</p><p id="f60b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Hibernate的查询计划缓存加快了查询的准备。这减少了它们的总执行时间，并提高了应用程序的性能。<strong class="ix hj">默认情况下，计划缓存中的最大条目数为</strong><a class="ae iu" href="https://docs.jboss.org/hibernate/orm/4.1/javadocs/org/hibernate/cfg/AvailableSettings.html#QUERY_PLAN_CACHE_MAX_SIZE" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">2048</strong></a><strong class="ix hj">。</strong>如果<code class="du ls lt lu lv b">HQLQueryPlan</code>对象占用2–3mb，它可以占用4–6GB的堆内存。</p><p id="fe91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">通过设置以下属性减小查询计划缓存大小</strong>:</p><ul class=""><li id="f8cb" class="lw lx hi ix b iy iz jc jd jg ly jk lz jo ma js mb mc md me bi translated"><code class="du ls lt lu lv b">spring.jpa.properties.hibernate.query.plan_cache_max_size</code>:控制计划缓存的最大条目数(默认为<strong class="ix hj"> 2048 </strong>)</li><li id="166b" class="lw lx hi ix b iy mf jc mg jg mh jk mi jo mj js mb mc md me bi translated"><code class="du ls lt lu lv b">spring.jpa.properties.hibernate.query.plan_parameter_metadata_max_size</code>:管理缓存中<code class="du ls lt lu lv b">ParameterMetadata</code>实例的数量(默认为<strong class="ix hj"> 128 </strong></li></ul><p id="387c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更多详情在<a class="ae iu" href="https://thorben-janssen.com/hibernate-query-plan-cache/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">索雷本的博客</strong> </a> <strong class="ix hj">。</strong></p><p id="e1b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">结果:</strong></p><p id="e2fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有来自LogInsight的警报，最终用户很高兴。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><h1 id="cf61" class="jy jz hi bd ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv bi translated">结论</h1><p id="98ce" class="pw-post-body-paragraph iv iw hi ix b iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">这段经历教会了我如何调试和修复Spring Boot应用程序中的性能问题。通过修复SQL查询、使用索引和实现缓存层来微调应用程序应该是提高应用程序性能的主要步骤；如果这不能解决问题，那么我们应该考虑增加资源。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="fadb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你喜欢这篇文章，请花一分钟给我鼓掌👏或者请我喝杯咖啡<a class="ae iu" href="https://www.buymeacoffee.com/abhiandy" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/abhiandy</a></p></div></div>    
</body>
</html>