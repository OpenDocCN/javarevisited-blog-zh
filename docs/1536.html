<html>
<head>
<title>High Performance Logging — Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高性能日志记录— Java</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/high-performance-logging-java-59ba374b2166?source=collection_archive---------0-----------------------#2021-09-07">https://medium.com/javarevisited/high-performance-logging-java-59ba374b2166?source=collection_archive---------0-----------------------#2021-09-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/55668a340609f8abf51bc0d74aa7e5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ifr_P2aTHyNcc4xuoR7gA.jpeg"/></div></div></figure><p id="3699" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当架构和设计开发时，日志记录是软件中的一个基本原则。因为日志记录会直接影响应用程序的性能。如果我们不在应用程序中进行有意义和可理解的日志记录，生产应用程序中的故障排除将是一场噩梦。我们需要知道什么需要记录，什么不应该记录。否则，我们将面临许多问题，如安全问题、容量问题等。</p><h2 id="7706" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">SLF4J(Java的简单日志门面)</h2><p id="f58f" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">SLF4J为Log4j、Log4j2、Logback等日志框架提供了日志API。这有助于减少各种日志框架和应用程序之间的紧密耦合。这也将提高代码的可维护性。最好的方法是<a class="ae ko" href="https://javarevisited.blogspot.com/2013/08/why-use-sl4j-over-log4j-for-logging-in.html#axzz6JyHI5fGb" rel="noopener ugc nofollow" target="_blank">在代码</a>中使用SLF4J，并在运行时使用日志框架。</p><p id="e631" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">软件行业中最流行的日志框架是Log4j和Log4j2。</p><h2 id="8681" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">为什么Log4j2比Log4j好？</h2><ul class=""><li id="21e4" class="kp kq hi is b it kj ix kk jb kr jf ks jj kt jn ku kv kw kx bi translated">主要是Log4j2支持异步记录器。</li><li id="b41c" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">对Log4j2配置文件进行配置修改时，无需重启服务器。</li><li id="d4bd" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">无垃圾运行时。</li><li id="6028" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">开发人员可以定义自定义日志级别。</li><li id="42b7" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">并发性提高，没有任何死锁。</li><li id="f9f3" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">从java 8开始，lambda函数支持日志记录。</li></ul><h2 id="c758" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">带有Log4j2的历史记录记录器</h2><p id="879b" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">Chronicle logger是一个为Java语言开发的速度极快的记录器，使用Chronicle Queue作为持久性引擎。它支持Log4j2日志框架的使用。使用这个历史日志记录器的实现，我们可以最小化应用程序的日志开销，并提高应用程序的性能。在这种方法中，日志记录部分从操作系统层开始在<a class="ae ko" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686?source=---------8------------------"> JVM应用程序</a>中负责。</p><p id="deac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ld">使用这种依赖关系— </em></p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="9282" class="jo jp hi lj b fi ln lo l lp lq">&lt;<strong class="lj hj">dependency</strong>&gt;<br/>    &lt;<strong class="lj hj">groupId</strong>&gt;net.openhft&lt;/<strong class="lj hj">groupId</strong>&gt;<br/>    &lt;<strong class="lj hj">artifactId</strong>&gt;chronicle-logger-log4j-2&lt;/<strong class="lj hj">artifactId</strong>&gt;<br/>    &lt;<strong class="lj hj">version</strong>&gt;4.21ea40&lt;/<strong class="lj hj">version</strong>&gt;<br/>&lt;/<strong class="lj hj">dependency</strong>&gt;</span></pre><p id="1f9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ld">日志记录配置文件示例— </em></p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="5a03" class="jo jp hi lj b fi ln lo l lp lq">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;configuration packages="net.openhft.chronicle.logger,net.openhft.chronicle.logger.log4j2"&gt;<br/>    &lt;appenders&gt;<br/>        &lt;Chronicle name="CHRONICLE"&gt;<br/>            &lt;path&gt;/var/log/&lt;/path&gt;<br/>            &lt;chronicleCfg&gt;<br/>                &lt;blockSize&gt;128&lt;/blockSize&gt;<br/>                &lt;bufferCapacity&gt;256&lt;/bufferCapacity&gt;<br/>     &lt;rollCycle&gt;HOURLY&lt;/rollCycle&gt;<br/>            &lt;/chronicleCfg&gt;<br/>        &lt;/Chronicle&gt;<br/>    &lt;/appenders&gt;<br/>    &lt;loggers&gt;<br/>        &lt;logger name="chronicle" level="info" additivity="false"&gt;<br/>            &lt;appender-ref ref="CHRONICLE"/&gt;<br/>        &lt;/logger&gt;<br/>    &lt;/loggers&gt;<br/>&lt;/configuration&gt;</span></pre><h2 id="d3b7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">Log4j2内存映射文件附加器</h2><p id="6cf2" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">这是高性能日志记录的另一种方式，它将日志记录的责任交给了操作系统。使用内存映射文件的主要好处是应用程序性能。在执行日志记录时，JVM没有I/O开销。因为appender不是将日志记录到磁盘内存映射文件，而是将日志事件写入本地内存。</p><p id="8447" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ld">样本日志记录配置文件— </em></p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="3c20" class="jo jp hi lj b fi ln lo l lp lq">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;Configuration status="info" name="SampleApplication" packages="com.sidath.app"&gt;<br/>  &lt;Appenders&gt;<br/>    &lt;MemoryMappedFile name="AppLog" fileName="/var/log/application.log"&gt;<br/>      &lt;PatternLayout&gt;<br/>        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;<br/>      &lt;/PatternLayout&gt;<br/>    &lt;/MemoryMappedFile&gt;<br/>  &lt;/Appenders&gt;<br/>  &lt;Loggers&gt;<br/>    &lt;Root level="Info"&gt;<br/>      &lt;AppenderRef ref="AppLog"/&gt;<br/>    &lt;/Root&gt;<br/>  &lt;/Loggers&gt;<br/>&lt;/Configuration&gt;</span></pre><h2 id="0026" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">夏天似的</h2><p id="fc3e" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">日志是软件开发的一个重要部分。这会直接影响应用程序的性能，因为日志记录是一项高度I/O密集型的操作。如果您真的关心应用程序的性能，那么最好使用上面提到的方法。</p><p id="fd3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ld">参考文献</em> </strong></p><p id="3b1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OpenHFT/Chronicle-Logger:一个亚微秒java logger，支持标准日志API，如Slf【github.com】Log4J(T4)</p><p id="aa41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ko" href="https://logging.apache.org/log4j/log4j-2.1/manual/appenders.html" rel="noopener ugc nofollow" target="_blank"> Log4j 2附加器—阿帕奇Log4j 2 </a></p></div></div>    
</body>
</html>