<html>
<head>
<title>Command Pattern for Invoking REST API with Spring boot Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Spring boot Java 调用 REST API 的命令模式</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/command-pattern-for-invoking-rest-api-with-spring-boot-java-39ef4eb2f568?source=collection_archive---------0-----------------------#2018-06-12">https://medium.com/javarevisited/command-pattern-for-invoking-rest-api-with-spring-boot-java-39ef4eb2f568?source=collection_archive---------0-----------------------#2018-06-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e17f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="7b72" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">固体原理教给我们一个基本术语，叫做“开放扩展，封闭修改”具有面向对象编程的良好设计总是提供灵活性，以便在未来添加新功能，而无需对现有代码进行任何更改。</p><p id="e0c4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，对于这种实现，设计模式通过解决一个复杂的问题帮助很大。命令模式是设计模式之一，它封装了采取任何行动所需的一切，并允许松散耦合的行动执行。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><a href="https://medium.com/javarevisited/top-5-books-and-courses-to-learn-restful-web-services-in-java-using-spring-mvc-and-spring-boot-79ec4b351d12"><div class="er es kg"><img src="../Images/afd1433d56dde5fb146ff2a1c02af89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGWw1iyE4Pj5SICZNS22-g.jpeg"/></div></a><p class="ko kp et er es kq kr bd b be z dx translated">图:带有命令设计模式的 REST API 调用</p></figure><h1 id="8186" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">REST API 可以直接使用，为什么要使用命令模式？</h1><p id="ebc5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">命令模式适用于以下情况:</p><ol class=""><li id="f64e" class="ks kt hi jf b jg kb jk kc jo ku js kv jw kw ka kx ky kz la bi translated">它借助命令对象将服务调用方和接收方解耦。在这里，Invoker 提供了发送方和接收方之间的松散耦合。</li><li id="86d6" class="ks kt hi jf b jg lb jk lc jo ld js le jw lf ka kx ky kz la bi translated">通过<code class="du lg lh li lj b">ServiceInvoker</code>执行具体命令(<code class="du lg lh li lj b">PostServiceCommand</code>、<code class="du lg lh li lj b">GetServiceCommand</code>)。因此，一个具体类中的变化不会影响另一个具体类。</li><li id="3e40" class="ks kt hi jf b jg lb jk lc jo ld js le jw lf ka kx ky kz la bi translated">它封装了进行 REST API 调用所需的一切，并允许动作的执行完全独立于任何上下文。</li></ol><h1 id="673f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">代码讨论</h1><p id="da08" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><em class="lk"> IServiceCommand </em></p><p id="de2c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><code class="du lg lh li lj b">IServiceCommand The interface</code>声明了两个名为“Execute 和 ExecuteAsync”的方法。因此，它以两种不同的方式声明和接口执行<a class="ae ll" rel="noopener" href="/javarevisited/why-java-developer-should-use-spring-to-develop-restful-web-services-efe36d7a6727"> REST API </a>调用:同步和异步。</p><pre class="kh ki kj kk fd lm lj ln lo aw lp bi"><span id="37c9" class="lq ig hi lj b fi lr ls l lt lu">package com.my.service;</span><span id="8030" class="lq ig hi lj b fi lv ls l lt lu">import java.util.concurrent.CompletableFuture;</span><span id="c2c4" class="lq ig hi lj b fi lv ls l lt lu">public interface IServiceCommand {</span><span id="0767" class="lq ig hi lj b fi lv ls l lt lu">public Object Execute();</span><span id="a56f" class="lq ig hi lj b fi lv ls l lt lu">public CompletableFuture&lt;Object&gt; ExecuteAysnc();</span><span id="189c" class="lq ig hi lj b fi lv ls l lt lu">}</span></pre><p id="efad" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lk"> PostServiceCommand </em></p><p id="6dd9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它是 Post REST API 请求的具体命令类。它封装了与 POST 请求相关的所有逻辑。</p><pre class="kh ki kj kk fd lm lj ln lo aw lp bi"><span id="f30e" class="lq ig hi lj b fi lr ls l lt lu">package com.my.service;</span><span id="e025" class="lq ig hi lj b fi lv ls l lt lu">import java.util.concurrent.CompletableFuture;</span><span id="fea6" class="lq ig hi lj b fi lv ls l lt lu">import org.springframework.http.HttpEntity;<br/>import org.springframework.http.client.ClientHttpRequestFactory;<br/>import org.springframework.scheduling.annotation.Async;<br/>import org.springframework.stereotype.Service;<br/>import org.springframework.web.client.RestTemplate;</span><span id="ba0e" class="lq ig hi lj b fi lv ls l lt lu"><a class="ae ll" href="http://twitter.com/Service" rel="noopener ugc nofollow" target="_blank">@Service</a><br/>public class PostServiceCommand implements IServiceCommand {</span><span id="ae28" class="lq ig hi lj b fi lv ls l lt lu">private RequestMapper requestMapper;<br/> private String otherUrl = "";</span><span id="56cb" class="lq ig hi lj b fi lv ls l lt lu">public PostServiceCommand(RequestMapper requestMapper, String otherUrl) {<br/>  this.requestMapper = requestMapper;<br/>  this.otherUrl = otherUrl;<br/> }</span><span id="e03e" class="lq ig hi lj b fi lv ls l lt lu">public Object Execute() {<br/>  ClientHttpRequestFactory requestFactory = ClientConfig.getClientHttpRequestFactory();<br/>  RestTemplate restTemplate = new RestTemplate(requestFactory);<br/>  String requestUrl = String.format(ClientConfig.getBaseUrl(), this.otherUrl);<br/>  HttpEntity&lt;RequestMapper&gt; request = new HttpEntity&lt;RequestMapper&gt;(this.requestMapper);<br/>  Object response = restTemplate.postForObject(requestUrl, request, Object.class);<br/>  return response;<br/> }</span><span id="0941" class="lq ig hi lj b fi lv ls l lt lu"><a class="ae ll" href="http://twitter.com/Async" rel="noopener ugc nofollow" target="_blank">@Async</a><br/> public CompletableFuture&lt;Object&gt; ExecuteAysnc() {<br/>  Object response = Execute();<br/>  return CompletableFuture.completedFuture(response);<br/> }<br/>}</span></pre><p id="1b70" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lk">获取服务命令</em></p><p id="4ae1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它也是 GET REST API 调用的具体命令类。</p><pre class="kh ki kj kk fd lm lj ln lo aw lp bi"><span id="e362" class="lq ig hi lj b fi lr ls l lt lu">package com.my.service;</span><span id="9e4d" class="lq ig hi lj b fi lv ls l lt lu">import java.util.concurrent.CompletableFuture;</span><span id="c6aa" class="lq ig hi lj b fi lv ls l lt lu">import org.springframework.http.client.ClientHttpRequestFactory;<br/>import org.springframework.scheduling.annotation.Async;<br/>import org.springframework.stereotype.Service;<br/>import org.springframework.web.client.RestTemplate;</span><span id="75a3" class="lq ig hi lj b fi lv ls l lt lu"><a class="ae ll" href="http://twitter.com/Service" rel="noopener ugc nofollow" target="_blank">@Service</a><br/>public class GetServiceCommand implements IServiceCommand {</span><span id="0e1c" class="lq ig hi lj b fi lv ls l lt lu">private String otherUrl = "";</span><span id="babc" class="lq ig hi lj b fi lv ls l lt lu">public GetServiceCommand(String requestUrl) {<br/>  this.otherUrl = requestUrl;<br/> }</span><span id="e15e" class="lq ig hi lj b fi lv ls l lt lu">public Object Execute() {<br/>  ClientHttpRequestFactory requestFactory = ClientConfig.getClientHttpRequestFactory();<br/>  RestTemplate restTemplate = new RestTemplate(requestFactory);<br/>  String requestUrl = ClientConfig.getBaseUrl() + this.otherUrl;<br/>  Object response = restTemplate.getForEntity(requestUrl, Object.class);<br/>  return response;<br/> }</span><span id="4831" class="lq ig hi lj b fi lv ls l lt lu"><a class="ae ll" href="http://twitter.com/Async" rel="noopener ugc nofollow" target="_blank">@Async</a><br/> public CompletableFuture&lt;Object&gt; ExecuteAysnc() {<br/>  Object response = Execute();<br/>  return CompletableFuture.completedFuture(response);<br/> }<br/>}</span></pre><p id="ee56" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lk">服务调用者</em></p><p id="3c09" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它是一个服务调用程序类，要求服务命令执行请求。</p><pre class="kh ki kj kk fd lm lj ln lo aw lp bi"><span id="f45c" class="lq ig hi lj b fi lr ls l lt lu">package com.my.service;</span><span id="254f" class="lq ig hi lj b fi lv ls l lt lu">import java.util.concurrent.CompletableFuture;</span><span id="41e4" class="lq ig hi lj b fi lv ls l lt lu">public class ServiceInvoker {</span><span id="1da9" class="lq ig hi lj b fi lv ls l lt lu">private IServiceCommand serviceCommand;</span><span id="e92d" class="lq ig hi lj b fi lv ls l lt lu">public ServiceInvoker(IServiceCommand serviceCommand) {</span><span id="7b19" class="lq ig hi lj b fi lv ls l lt lu">this.serviceCommand = serviceCommand;</span><span id="8108" class="lq ig hi lj b fi lv ls l lt lu">}</span><span id="2f67" class="lq ig hi lj b fi lv ls l lt lu">public Object ExecuteRequest() {</span><span id="edef" class="lq ig hi lj b fi lv ls l lt lu">System.out.println("Start: Service Request");</span><span id="6fde" class="lq ig hi lj b fi lv ls l lt lu">return serviceCommand.Execute();</span><span id="eb3f" class="lq ig hi lj b fi lv ls l lt lu">}</span><span id="9232" class="lq ig hi lj b fi lv ls l lt lu">public CompletableFuture&lt;Object&gt; ExecuteAsyncRequest() {</span><span id="ee18" class="lq ig hi lj b fi lv ls l lt lu">System.out.println("Start: Asynchrnous Service Request");</span><span id="76d6" class="lq ig hi lj b fi lv ls l lt lu">return serviceCommand.ExecuteAysnc();</span><span id="930d" class="lq ig hi lj b fi lv ls l lt lu">}</span><span id="a86b" class="lq ig hi lj b fi lv ls l lt lu">}</span></pre><p id="2fa2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lk">请求映射器</em></p><p id="7ae9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它只是一个请求映射器类，用于在 POST REST API 调用期间映射请求对象。</p><pre class="kh ki kj kk fd lm lj ln lo aw lp bi"><span id="c707" class="lq ig hi lj b fi lr ls l lt lu">package com.my.service;</span><span id="75a9" class="lq ig hi lj b fi lv ls l lt lu">public class RequestMapper {</span><span id="7fac" class="lq ig hi lj b fi lv ls l lt lu">public String Id;</span><span id="e7d2" class="lq ig hi lj b fi lv ls l lt lu">public String Name;</span><span id="13fb" class="lq ig hi lj b fi lv ls l lt lu">public String City;</span><span id="04c3" class="lq ig hi lj b fi lv ls l lt lu">public String Designation;</span><span id="6b14" class="lq ig hi lj b fi lv ls l lt lu">}</span></pre><p id="0a67" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lk">客户端操作</em></p><p id="f698" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">客户端可以像下面这样调用:</p><p id="4b71" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">同步操作:</p><pre class="kh ki kj kk fd lm lj ln lo aw lp bi"><span id="dde7" class="lq ig hi lj b fi lr ls l lt lu">String requestUrl = "";</span><span id="a0ea" class="lq ig hi lj b fi lv ls l lt lu">Map&lt;String, Object&gt; params = workItem.getParameters();</span><span id="f4e8" class="lq ig hi lj b fi lv ls l lt lu">RequestMapper requestMapper = new RequestMapper();</span><span id="0b17" class="lq ig hi lj b fi lv ls l lt lu">requestMapper.Id = "123";</span><span id="6c67" class="lq ig hi lj b fi lv ls l lt lu">requestMapper.Name = "Gul"</span><span id="1240" class="lq ig hi lj b fi lv ls l lt lu">requestMapper.City = "Bangalore";</span><span id="0c34" class="lq ig hi lj b fi lv ls l lt lu">requestMapper.Designation = "Software Engineer";</span><span id="e805" class="lq ig hi lj b fi lv ls l lt lu">IServiceCommand serviceCommand = new GetServiceCommand(requestUrl);</span><span id="5a33" class="lq ig hi lj b fi lv ls l lt lu">ServiceInvoker serviceInvoker = new ServiceInvoker(serviceCommand);</span><span id="d68f" class="lq ig hi lj b fi lv ls l lt lu">serviceInvoker.ExecuteRequest();</span><span id="1c61" class="lq ig hi lj b fi lv ls l lt lu">}</span></pre><p id="fc46" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">异步操作:</p><pre class="kh ki kj kk fd lm lj ln lo aw lp bi"><span id="e450" class="lq ig hi lj b fi lr ls l lt lu">IServiceCommand serviceCommand = new PostServiceCommand(requestMapper, requestUrl);</span><span id="6490" class="lq ig hi lj b fi lv ls l lt lu">ServiceInvoker serviceInvoker = new ServiceInvoker(serviceCommand);</span><span id="f5f1" class="lq ig hi lj b fi lv ls l lt lu">CompletableFuture&lt;Object&gt; response = serviceInvoker.ExecuteAsyncRequest();</span><span id="ced1" class="lq ig hi lj b fi lv ls l lt lu">while (true) {</span><span id="8dae" class="lq ig hi lj b fi lv ls l lt lu">if (response.isDone()) {</span><span id="3ccb" class="lq ig hi lj b fi lv ls l lt lu">System.out.println("End: Done");</span><span id="c98e" class="lq ig hi lj b fi lv ls l lt lu">break;</span><span id="98d6" class="lq ig hi lj b fi lv ls l lt lu">}</span><span id="93cd" class="lq ig hi lj b fi lv ls l lt lu">}</span></pre><h1 id="9d0f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="3a94" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">命令模式</strong>为 REST API 调用构建了一个非常好的松耦合系统。它为 POST 和 gets 请求定义了两个独立的具体类。还可以为 PUT 或 DELETE 等其他操作定义单独的具体类。因此，它隐藏了命令的实际执行。</p></div></div>    
</body>
</html>