<html>
<head>
<title>The Dark Side of “Java Collections Framework”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“Java集合框架”的阴暗面</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/the-dark-side-of-java-collections-framework-881a9f142231?source=collection_archive---------2-----------------------#2020-05-02">https://medium.com/javarevisited/the-dark-side-of-java-collections-framework-881a9f142231?source=collection_archive---------2-----------------------#2020-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e821" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的Java开发者几乎每天都会用到<code class="du jd je jf jg b">List</code>、<code class="du jd je jf jg b">Set</code>、<code class="du jd je jf jg b">Map</code>这样的接口。这些集合为我们提供了非常有用的功能，有助于创建和维护复杂的软件。但是你有没有感觉到有些事情不对劲？Java集合是不是太灵活了？你曾经和你的队友讨论过使用列表的“正确”方式吗？嗯，我想你见过。我认为Java Collections框架的核心有一个很大的设计问题。所以，我们来讨论一下。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/9feed1cb8785cdfe07c2aac8f4c834bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYPXOVwhqXWTkn4ZhblBTQ.jpeg"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">来自<a class="ae jx" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jx" href="https://pixabay.com/users/ErikaWittlieb-427626/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1724901" rel="noopener ugc nofollow" target="_blank">erikawittleb</a>的图片</p></figure><h1 id="b007" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">没有真正的不变性</h1><p id="e2c5" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">Java Collections Framework从一开始就没有考虑过任何只读或不可变的东西，因为即使是<code class="du jd je jf jg b">Collection</code>接口也有像<code class="du jd je jf jg b">clear</code>、<code class="du jd je jf jg b">add</code>和<code class="du jd je jf jg b">remove</code>这样的方法。这种方法本来是可以接受的，但是最近，Java语言已经通过众所周知的实用程序得到了增强，比如<code class="du jd je jf jg b">Arrays.asList&lt;T&gt;(T... element)</code>、<code class="du jd je jf jg b">Collections.emptyList()</code>、<code class="du jd je jf jg b">Collections.singletonList&lt;T&gt;(T element)</code>和许多其他实用程序。那么，他们怎么了？让我们仔细看看。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="45a4" class="lf jz hi jg b fi lg lh l li lj">List&lt;Integer&gt; list = Arrays.asList(21, 22, 23); <br/>list.add(24) <em class="lk">// UnsupportedOperationException, but why?</em></span></pre><p id="d401" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么鬼东西？我们知道<code class="du jd je jf jg b">List</code>是从拥有<code class="du jd je jf jg b">add</code>方法的<code class="du jd je jf jg b">Collection</code>扩展而来的。所以，问题是<code class="du jd je jf jg b">Arrays.asList</code>返回了一个限制添加新项目的实现。现在我们面临着一个奇怪的局面。虽然<code class="du jd je jf jg b">List</code>接口为我们提供了一个方法，但是我们不能调用它。但问题是模糊会变得更糟。看看这个。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="5360" class="lf jz hi jg b fi lg lh l li lj">List&lt;Integer&gt; list = Arrays.asList(21, 22, 23); <br/>list.set(0, 121);<br/>System.out.println(list); <em class="lk">// [121, 22, 23]</em></span></pre><p id="dd46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里没有例外。因此，我们可以修改列表，但不能在其中插入新的项目。我不知道为什么会做出如此奇怪的设计决定。但说实话，这个方法的JavaDoc恰当地描述了这种情况。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="5b1b" class="lf jz hi jg b fi lg lh l li lj">The returned list implements the optional Collection methods, except those that would change the size of the returned list. Those methods leave the list unchanged and throw UnsupportedOperationException.</span></pre><p id="c195" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，它解决歧义了吗？不完全是。想象一下，你需要写一个接受<code class="du jd je jf jg b">List&lt;String&gt;</code>的方法。我认为猜测您收到了哪个实现或者在每个<code class="du jd je jf jg b">set</code>或<code class="du jd je jf jg b">add</code>调用上写下<code class="du jd je jf jg b">try {} catch(Exception e)</code>都不会令人愉快。不管怎样，我们再看一个例子。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="d092" class="lf jz hi jg b fi lg lh l li lj">List&lt;Integer&gt; list = ...<br/>List&lt;Integer&gt; filtered = filter(list);</span></pre><p id="90e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">filter</code>方法接受<code class="du jd je jf jg b">List</code>实现并返回一个过滤后的实现，但是结果返回了什么列表呢？它是一个新实例还是同一个修改过的实例？可以修改原来的列表吗，会影响结果吗？顺便问一下，我们如何知道作为参数传递的是什么实现？也许无法添加或删除条目(例如，这种实现会在<code class="du jd je jf jg b">Collections.emptyList()</code>之前返回)。如您所见，即使是简单的代码片段也会产生如此大的混乱。可以说我们可以使用<a class="ae jx" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" rel="noopener ugc nofollow" target="_blank"> Java Stream API </a>。嗯，这是真的。<code class="du jd je jf jg b">Stream</code>在每次<code class="du jd je jf jg b">map</code>、<code class="du jd je jf jg b">filter</code>或其他方法调用时创建一个新对象。问题解决了吗？不。我们有一个方便的外观来操作集合，但这并不意味着集合摆脱了模糊性和意外的行为。那么，有什么解决办法呢？其实有好几个。</p><h1 id="8ff5" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">遗传可变性</h1><p id="2744" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">这就是Kotlin作为一个新的集合架构所提供的。我们在子接口中定义所有的变异方法，而不是把它们放在一个地方。看起来是这样的。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ll"><img src="../Images/aa1e85d1d38fc316abf176b5428c3611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zl3ZTBMvNzqfyG93GuIUTA.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">简化的科特林收藏架构</p></figure><p id="ebfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那看起来很不错。让我们再看一下前面的例子。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="c8bb" class="lf jz hi jg b fi lg lh l li lj">val list: List&lt;Int&gt; = ...<br/>val filtered: List&lt;Int&gt; = filter(list);</span></pre><p id="ee12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，<code class="du jd je jf jg b">List</code>没有任何变异方法。在这种情况下，我们可以确定<code class="du jd je jf jg b">filtered</code>是一个新对象，并且<code class="du jd je jf jg b">list</code>没有被修改。就这样吗？一个让代码干净可维护的绝对公式？再说一次，不是真的。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="3738" class="lf jz hi jg b fi lg lh l li lj">val mutableList: ArrayList&lt;Int&gt; = ArrayList()<br/>mutableList.add(1)<br/>...<br/>someAsyncTask(mutableList) // accepts List&lt;Int&gt;<br/>...<br/>mutableList.clear()</span></pre><p id="a119" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然已经执行了<code class="du jd je jf jg b">someAsyncTask</code>的线程无权修改列表，但是另一个线程意外地清除了它，因为原始对象实现了<code class="du jd je jf jg b">MutableList</code>。所以，也可以解释为<code class="du jd je jf jg b">List</code>。我必须承认JavaDoc对于<code class="du jd je jf jg b">List</code>接口再次有了它的权威性。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="6025" class="lf jz hi jg b fi lg lh l li lj">Creates a new read-only list with the specified <strong class="jg hj">[size]</strong>, where each element is calculated by calling the specified <strong class="jg hj">[init]</strong> function.</span></pre><p id="6e01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lk">只读</em>不代表<em class="lk">不可变</em>。这意味着当前线程不能访问任何变异方法，但是不能保证这个列表不能被其他人修改。所以，我们有一些理论上可以被除了我们之外的任何人修改的东西。我认为这样的行为不是我们所要寻找的，但无论如何，这种方法仍然比Java实现的要好。</p><h1 id="b07e" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">分离可变性</h1><p id="97a0" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">我们可以定义一个单独的层次结构，而不是继承只读集合。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lm"><img src="../Images/cf7e98a51d9747b83be8a832b495f4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2E7tQ3j4dO_DhQao3VG5g.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">真正不可变的集合</p></figure><p id="4387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du jd je jf jg b">Collection</code>和<code class="du jd je jf jg b">ImmutableCollection</code>没有公共接口，那么就没有办法将一个集合转换为另一个集合，或者将一个可变列表传递给接受不可变列表的方法。这种方法是由一些库开发的，如<a class="ae jx" href="https://www.vavr.io/vavr-docs/#_collections" rel="noopener ugc nofollow" target="_blank"> Vavr </a>、<a class="ae jx" href="https://www.eclipse.org/collections/#start" rel="noopener ugc nofollow" target="_blank"> Eclipse Collections </a>或<a class="ae jx" href="https://github.com/SimonHarmonicMinor/Java-Useful-Utils" rel="noopener ugc nofollow" target="_blank"> Java-Useful-Utils </a>。它允许我们严格区分不可变实体和可变实体。如果你通过了<code class="du jd je jf jg b">ImmutableSet</code>，你可以确定没有人能够意外地修改这个集合。</p><blockquote class="ln lo lp"><p id="6500" class="if ig lk ih b ii ij ik il im in io ip lq ir is it lr iv iw ix ls iz ja jb jc hb bi translated">可以注意到，所有这些集合都有一个公共接口。那就是<code class="du jd je jf jg b">Iterable&lt;T&gt;</code>。不仅如此，<code class="du jd je jf jg b">Iterable.iterator()</code>返回的<code class="du jd je jf jg b">Iterator</code>还有<code class="du jd je jf jg b">remove</code>方法，默认抛出异常。然而，这意味着即使是不可变的集合也不是完全不可变的。所以，这是我们想要使用Java <code class="du jd je jf jg b">for-each</code>循环必须付出的代价，因为实现<code class="du jd je jf jg b">Iterable&lt;T&gt;</code>是唯一的办法。</p></blockquote><h1 id="e9b5" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="b049" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">我坚信不变性是一个不应该被忽视的基本要素。也许有一天<a class="ae jx" href="https://www.jcp.org/en/home/index" rel="noopener ugc nofollow" target="_blank"> JCP </a>会同意这个观点，但是现在，仅此而已。</p></div></div>    
</body>
</html>