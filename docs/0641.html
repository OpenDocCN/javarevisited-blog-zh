<html>
<head>
<title>Cracking the Minimum Candy Distribution Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解最小糖果分配问题</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/how-to-solve-the-minimum-candy-distribution-problem-4c868740f16a?source=collection_archive---------1-----------------------#2020-08-18">https://medium.com/javarevisited/how-to-solve-the-minimum-candy-distribution-problem-4c868740f16a?source=collection_archive---------1-----------------------#2020-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ih ii ij ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ig"><img src="../Images/6944be47029df8f3ef12ec8bc46be3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhP02uJn8RY_RaL2azsKqA.png"/></div></div><p class="ir is et er es it iu bd b be z dx translated">图片由<a class="ae iv" href="https://www.freepik.com/premium-vector/colourful-fruit-candies-chocolate-sweets-flat-icons-circle-design_4080058.htm#:~:text=Copy%20link" rel="noopener ugc nofollow" target="_blank"> Freepik </a></p></figure><h1 id="3268" class="iw ix hi bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">问题陈述</h1><p id="171f" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">有N个孩子站在一条线上，每个孩子都有一个评分值。你给这些孩子糖果，同时确保每个孩子必须至少有一个糖果，评分高的孩子比他们的邻居得到更多的糖果。你必须给的最少糖果是多少？</p><h2 id="0aa7" class="ks ix hi bd iy kt ku kv jc kw kx ky jg kf kz la jk kj lb lc jo kn ld le js lf bi translated">示例:</h2><ul class=""><li id="26c3" class="lg lh hi jw b jx jy kb kc kf li kj lj kn lk kr ll lm ln lo bi translated">输入:[1，0，2] |输出:5 { <strong class="jw hj">分布</strong> : [2，1，2] }</li><li id="d471" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr ll lm ln lo bi translated">输入:[1，2，2] |输出:4 { <strong class="jw hj">分布</strong> : [2，1，1] }</li><li id="42d0" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr ll lm ln lo bi translated">输入:[0，2，0，6，6] |输出:7 { <strong class="jw hj">分配</strong> :[1，2，1，2，1] }</li></ul><h1 id="0b26" class="iw ix hi bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">解决办法🍬—时间和空间复杂度O(n)</h1><p id="4b15" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">基本上每个孩子都要评估<strong class="jw hj">两个</strong> <strong class="jw hj">邻居(上一个孩子和下一个孩子)</strong>才能找到他/她应该得到的糖果数:</p><ul class=""><li id="cfe4" class="lg lh hi jw b jx lu kb lv kf lw kj lx kn ly kr ll lm ln lo bi translated">如果孩子的糖果比邻居的多，那么孩子应该比邻居得到更多的糖果。</li><li id="d5a0" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr ll lm ln lo bi translated">如果孩子的评级低于或等于邻居的评级，则邻居可以被忽略，因为这对所讨论的孩子的糖果计数没有影响。</li></ul><p id="691f" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated"><a class="ae iv" rel="noopener" href="/hackernoon/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0">算法</a>的具体步骤及其代码如下:</p><figure class="md me mf mg fd ik er es paragraph-image"><a href="https://www.java67.com/2018/06/data-structure-and-algorithm-interview-questions-programmers.html"><div class="er es mc"><img src="../Images/77a0556519ebbb1fb49349a8a295568c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7fK8DuRe7xg5QTxpui342w.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">向前遍历</p></figure><ul class=""><li id="baa7" class="lg lh hi jw b jx lu kb lv kf lw kj lx kn ly kr ll lm ln lo bi translated">向前遍历:从第一个孩子开始遍历评级，并在途中更新下一个孩子的糖果计数。如果当前孩子的评分小于下一个孩子的评分，那么下一个孩子的糖果数必须至少比当前孩子的糖果数多<em class="mh"> </em> 1。</li></ul><figure class="md me mf mg fd ik er es paragraph-image"><a href="https://medium.com/javarevisited/7-free-books-to-learn-data-structure-and-algorithms-in-java-346b2d70db10"><div class="er es mi"><img src="../Images/1d69478521edeab4038ab2343cf1b57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Cf2nIi-fTqU1ljgxJ6vRQ.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">向后遍历</p></figure><ul class=""><li id="0db9" class="lg lh hi jw b jx lu kb lv kf lw kj lx kn ly kr ll lm ln lo bi translated">向后遍历:从最后一个孩子开始遍历评级，并在途中更新前一个孩子的糖果计数。如果当前孩子的评分低于前一个孩子的评分，则前一个孩子的糖果数必须至少比当前孩子的糖果数多<em class="mh"> </em> 1。</li><li id="b10e" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr ll lm ln lo bi translated">数糖果:计算每个孩子的糖果总数。</li></ul><pre class="md me mf mg fd mj mk ml mm aw mn bi"><span id="d083" class="ks ix hi mk b fi mo mp l mq mr"><strong class="mk hj">// Language: Java<br/>// Time Complexity: O(n) 3 Linear traversals.<br/>// Space Complexity: O(n) Array of candies.</strong></span><span id="1cd0" class="ks ix hi mk b fi ms mp l mq mr">public int candy(int[] ratings) {<br/>      if (ratings.length &lt; 2) {<br/>        return ratings.length;<br/>      }<br/>        <br/>      int[] candies = new int[ratings.length];<br/>      Arrays.fill(candies, 1);<br/>        <br/>     <strong class="mk hj"> // ** Step 1: Forward **</strong><br/>      for (int i=0; i&lt;ratings.length-1; i++) {<br/>        if (ratings[i] &gt;= ratings[i+1]) {<br/>          continue;<br/>        }         <br/>        candies[i+1] = candies[i] + 1;    <br/>      }<br/>        <br/>      <strong class="mk hj">// ** Step 2: Backward **</strong><br/>      for (int i=ratings.length-1; i&gt;0; i--) {<br/>        if (ratings[i] &gt;= ratings[i-1]) {<br/>          continue;<br/>        }<br/>        candies[i-1] = Math.max(candies[i] + 1, candies[i-1]);   <br/>      }<br/>        <br/>      <strong class="mk hj">// ** Step 3: Count Candies **</strong><br/>      int count = 0;<br/>      for (int i=0; i&lt;candies.length; i++) {<br/>        count += candies[i];<br/>      }<br/>        <br/>      return count;     <br/> }</span></pre><p id="38d3" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">这是一个完全可以接受的解决方案，但是我们可以通过优化下一节中的<a class="ae iv" rel="noopener" href="/hackernoon/10-data-structure-algorithms-and-programming-courses-to-crack-any-coding-interview-e1c50b30b927?source=user_profile---------8-----------------------">算法</a>来节省一些空间。</p><h1 id="0f87" class="iw ix hi bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">🍬空间的最优化— O(n) -&gt; O(1)</h1><h2 id="3304" class="ks ix hi bd iy kt ku kv jc kw kx ky jg kf kz la jk kj lb lc jo kn ld le js lf bi translated">基础知识介绍</h2><p id="71d4" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">让我们将输入[0，4，9，25，8，6，5]的分布可视化如下:</p><figure class="md me mf mg fd ik er es paragraph-image"><a href="https://medium.com/javarevisited/20-array-coding-problems-and-questions-from-programming-interviews-869b475b9121"><div class="er es mt"><img src="../Images/0c0a144ce1fa1585545f0ce9cd4fe75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNeM9pWN495AJAfkwRK0Dw.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">评分[0，4，9，25，8，6，5]</p></figure><p id="4d6c" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">以下是一些重要的观察结果:</p><ul class=""><li id="8c53" class="lg lh hi jw b jx lu kb lv kf lw kj lx kn ly kr ll lm ln lo bi translated">📈<strong class="jw hj">【0，4，9，25】的上坡</strong>(递增数字)的<br/>长度=4。</li><li id="2297" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr ll lm ln lo bi translated">向上倾斜中的糖果数是10=1+2+3+4，这是n =长度=4 (n*n+1/2)的连续递增数的总和</li><li id="9fb6" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr ll lm ln lo bi translated">📉<strong class="jw hj">对于【25，8，6，5】的向下斜坡</strong>(递减数字)的长度=4。</li><li id="a5a9" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr ll lm ln lo bi translated">向下倾斜中的糖果数是10=4+3+2+1，这是n =长度=4 (n*n+1/2)的连续递增数的总和</li><li id="37b7" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr ll lm ln lo bi translated">两个斜坡的<strong class="jw hj">峰</strong>是中间的孩子，等级为25。</li></ul><h2 id="9e50" class="ks ix hi bd iy kt ku kv jc kw kx ky jg kf kz la jk kj lb lc jo kn ld le js lf bi translated">峰值的糖果计数</h2><p id="6585" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><strong class="jw hj">等斜率<br/> </strong>糖果计数为额定值25(峰值)为4。这是最长斜坡的长度。在本例中，其左侧和右侧的两个斜坡的长度都是4。</p><p id="f56c" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">这是有道理的，因为更长的斜率意味着更多的1，以确保孩子比邻居得到更多的糖果。最终，在坡顶的孩子将得到最大数量的糖果。</p><figure class="md me mf mg fd ik er es paragraph-image"><a href="https://hackernoon.com/10-data-structure-algorithms-books-every-programmer-should-read-d50487313127"><div class="er es mu"><img src="../Images/e6ec74d1a7587a5938e668fe1a498440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLYJ7bg1RZ0prgguRrb0tw.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">对于等级[8，6，5，4，3]，峰值为等级8的1的凸起</p></figure><p id="6408" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">让我们<strong class="jw hj">沿着[0，4，9，25，8，6，5]向下的斜坡向上走</strong>，做一些糖果作业:</p><ol class=""><li id="3a3c" class="lg lh hi jw b jx lu kb lv kf lw kj lx kn ly kr mv lm ln lo bi translated">评分5: 1糖果；这是最低金额。</li><li id="cea0" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr mv lm ln lo bi translated">评分6: 2糖果&gt;评分5。</li><li id="0514" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr mv lm ln lo bi translated">评分8: 3糖果&gt;评分6。</li><li id="4b8e" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr mv lm ln lo bi translated">评分25: 4糖果&gt;评分8。</li></ol><p id="29c9" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">然而，问题是关于糖果的总数，并不要求我们像上面的步骤那样找到糖果/孩子的分配。</p><p id="beaf" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">记住这一点，让我们<strong class="jw hj">沿着</strong>相同的下坡[0，4，9，25，8，6，5]走下去，做一些糖果分配:</p><ol class=""><li id="7076" class="lg lh hi jw b jx lu kb lv kf lw kj lx kn ly kr mv lm ln lo bi translated">评分25: 4糖果&gt;评分9。</li><li id="259b" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr mv lm ln lo bi translated">评分8: 1糖果；这是最低金额。<br/>这对peak的糖果数量没有影响，因为它应该至少有1+1=2颗糖果，而它已经有4颗了。</li><li id="2bd3" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr mv lm ln lo bi translated">评级6: 2糖果；下坡<strong class="jw hj">(无峰值)</strong>有2个子【8，6】。理想情况下，等级6应该有1颗糖果，等级8应该有2颗糖果，以保持更高等级=更多糖果的约束。因为我们不关心确切的儿童糖果对，这种交换是无害的。<br/>这对peak的糖果数量没有影响，因为它应该至少有2+1=3颗糖果，而它已经有4颗了。</li><li id="6a64" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr mv lm ln lo bi translated">评分5: 3糖果；向下的斜坡有3个子斜坡[8，6，5]。<br/>理想情况下，等级5应该有1颗糖果，等级6应该有2颗糖果，等级8应该有3颗糖果，以保持等级越高=糖果越多的限制。因为我们不关心确切的儿童糖果对，这种交换是无害的。<br/>这对peak的糖果数量没有影响，因为它应该至少有3+1=4颗糖果，而它已经有4颗了。</li></ol><p id="b762" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">上述方法的好处是向下倾斜的长度简单地决定了给孩子的糖果量。</p><p id="ee8d" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated"><strong class="jw hj">不等斜率<br/> </strong>让我们在最后加上一个评分为4的孩子。</p><figure class="md me mf mg fd ik er es paragraph-image"><a href="https://medium.com/javarevisited/top-10-free-data-structure-and-algorithms-courses-for-beginners-best-of-lot-ad807cc55f7a?source=collection_home---4------0-----------------------"><div class="er es mw"><img src="../Images/5e444a7e9c46d9b5ad37a84c561f0dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pulxpsTtZKdV-M7X5uS4-A.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">评分[0，4，9，25，8，6，5，4]</p></figure><p id="c02b" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">除了以上部分中的步骤之外，将4颗糖果分配给等级4，因为向下的斜坡现在有4个子级[8，6，5，4]。</p><p id="2043" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">这会影响评级为25时的峰值吗？它有4颗糖果。给定它前面长度为4的斜率，它应该有5个糖果来维持更高等级=更多糖果的约束。</p><p id="cf90" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">那么我们如何解决这个问题呢？</p><p id="0245" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">我们求出<strong class="jw hj">斜率差:</strong>如果这个向下斜率的大小大于等于向上斜率(4 ≥ 4)，那么糖果计数加1(斜率差)。凸起为1时，4在峰值时基本上会变成5。</p><p id="1c11" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">让我们在最后添加另一个评分为3的孩子。</p><figure class="md me mf mg fd ik er es paragraph-image"><a href="https://medium.com/javarevisited/7-best-courses-to-learn-data-structure-and-algorithms-d5379ae2588?source=---------18------------------"><div class="er es mx"><img src="../Images/db5d3c06b053b5081a319d9dc251c1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGHNNLdQRerAiGs5k-daMg.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">评分[0，4，9，25，8，6，5，4，3]</p></figure><p id="5157" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">除了上面的步骤，分配5个糖果到等级3，因为向下的斜坡现在有5个孩子[8，6，5，4，3]。</p><p id="03e6" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">因为向下斜率的大小大于向上斜率(5≥4)，所以整个糖果数加1。凸起为1时，5在峰值时基本上会变成6。</p><p id="2e31" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">该算法的代码如下:</p><pre class="md me mf mg fd mj mk ml mm aw mn bi"><span id="d1cf" class="ks ix hi mk b fi mo mp l mq mr"><strong class="mk hj">// Language: Java<br/>// Time Complexity: O(n) Linear traversal.<br/>// Space Complexity: O(1) Constant space for variables.</strong></span><span id="fc2e" class="ks ix hi mk b fi ms mp l mq mr">public int candy(int[] ratings) {<br/>      if (ratings.length &lt; 2) {<br/>          return ratings.length;<br/>      }<br/>         <br/>      int count = 1;<br/>      int upSlopeLength = 0;<br/>      int upSlope = 0;<br/>      int downSlope = 0;<br/>         <br/>      for (int i=1; i&lt;ratings.length; i++) {<br/>          int previous = ratings[i-1];<br/>          int me = ratings[i];<br/>          <br/>          // <strong class="mk hj">** Equal Ratings **</strong>   <br/>          if (me == previous) {<br/>              upSlope = 0;<br/>              downSlope = 0;<br/>              upSlopeLength = 0;<br/>              count += 1;<br/>          // <strong class="mk hj">** Upward Slope **<br/>          </strong>} else if (me &gt; previous) {<br/>              upSlope = upSlope == 0 ? 1 : upSlope;<br/>              upSlope += 1;<br/>              downSlope = 0;<br/>              count += upSlope;<br/>              upSlopeLength = upSlope;<br/>          // <strong class="mk hj">** Downward Slope **</strong><br/>          } else {<br/>              upSlope = 0;<br/>              downSlope += 1;<br/>              int slopeDiff = <br/>                (downSlope + 1 - upSlopeLength) &gt; 0 ? 1 : 0;<br/>              count += downSlope + slopeDiff;         <br/>          }     <br/>      }<br/>      return count;  <br/>}</span></pre></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><p id="df52" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">如果你觉得这篇文章有用，<strong class="jw hj">请帮助我接触更多的开发学习者！</strong></p><p id="7de4" class="pw-post-body-paragraph ju jv hi jw b jx lu jz ka kb lv kd ke kf lz kh ki kj ma kl km kn mb kp kq kr hb bi translated">通过“鼓掌”来展示一些❤👏在页面的左边距(在桌面上)或底部(在手机上)。通过连续点击，您可以这样做多达<strong class="jw hj"> 50 </strong>次！</p><h1 id="e7d9" class="iw ix hi bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">阿努姆·马利克</h1><p id="bc05" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在<a class="ae iv" href="https://twitter.com/anumsarmadmalik" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注NMTechBytes，获取我的每日技术信息:)</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><h2 id="dbcf" class="ks ix hi bd iy kt ku kv jc kw kx ky jg kf kz la jk kj lb lc jo kn ld le js lf bi translated">特别感谢:</h2><ul class=""><li id="833b" class="lg lh hi jw b jx jy kb kc kf li kj lj kn lk kr ll lm ln lo bi translated"><a class="ae iv" href="https://leetcode.com/problems/candy/discuss/135698/Simple-solution-with-one-pass-using-O(1)-space" rel="noopener ugc nofollow" target="_blank">一次通过的简单解决方案</a></li><li id="77be" class="lg lh hi jw b jx lp kb lq kf lr kj ls kn lt kr ll lm ln lo bi translated"><a class="ae iv" href="https://leetcode.com/problems/candy/submissions/" rel="noopener ugc nofollow" target="_blank"> LeetCode糖果问题</a></li></ul></div></div>    
</body>
</html>