<html>
<head>
<title>instanceof should be your last resort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">instanceof 应该是您的最后手段</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/instanceof-should-be-your-last-resort-4b8b3667cd17?source=collection_archive---------0-----------------------#2019-09-14">https://medium.com/javarevisited/instanceof-should-be-your-last-resort-4b8b3667cd17?source=collection_archive---------0-----------------------#2019-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fdc15d50e66ceb87fcc2d8badd78c102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Io4GI-iAa0dpHoHkLhg19Q.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://pixabay.com/users/ractapopulous-24766/" rel="noopener ugc nofollow" target="_blank">抽象的</a></p></figure><p id="05f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时候，在 Java 中会出现这样的情况，一个方法接收一个非常通用类型的对象，并且需要对它进行操作。通常情况下，你会用<code class="du jt ju jv jw b">if</code>链式调用<code class="du jt ju jv jw b"><a class="ae iu" href="https://javarevisited.blogspot.com/2015/12/10-points-about-instanceof-operator-in-java-example.html" rel="noopener ugc nofollow" target="_blank">instanceof</a></code>来获取接收到的对象的具体类型，将这个对象转换为具体类型，并对具体类型进行操作。</p><p id="e460" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">听起来很熟悉？嗯，如果你的代码中有很多这样的项目，你可能会对 Java 模式匹配项目感到兴奋。但是我要说，你有重大的设计缺陷，并且没有利用你所使用的语言的面向对象的特性。<a class="ae iu" href="https://www.tutorialspoint.com/java/java_polymorphism.htm" rel="noopener ugc nofollow" target="_blank">多态性</a>，大多。</p><p id="98c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们来看一个例子。</p><p id="bfc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">比方说，您正在开发一个系统，该系统与许多其他系统进行通信，并存储一些以内部格式获取的数据。某种带有许多适配器的聚合系统。其中一个适配器的组件视图如下所示:</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div class="er es jx"><img src="../Images/ccc2fd4532312598b70f188917949b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*KLjbbyj83pI5SSiyYhUVMw.png"/></div><p class="iq ir et er es is it bd b be z dx translated">图 1:组件视图</p></figure><p id="403d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有获取数据的系统都以该系统的特定格式提供数据。系统与系统之间是如此的不同，以至于每一个都被映射到一个特定的类。</p><p id="18cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设有五个外部数据提供者，每个都有一个响应对象:<code class="du jt ju jv jw b">ResponseFromSystem1</code>、<code class="du jt ju jv jw b">ResponseFromSystem2</code>、<code class="du jt ju jv jw b">ResponseFromSystem3</code>、<code class="du jt ju jv jw b">ResponseFromSystem4</code>、<code class="du jt ju jv jw b">ResponseFromSystem5</code>。</p><p id="03df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要某种实现来请求所有这些外部系统，收集数据并将其存储在内部。让我们假设每个系统都可以用描述系统类型的唯一整数来标识。</p><p id="5e04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现可能如下所示:</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><p class="iq ir et er es is it bd b be z dx translated">代码片段 1:初始实现</p></figure><p id="0d6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这里我们有一个 API 方法，它根据提供的类型 id 调用外部系统，并在内部存储数据。由于外部系统以及它们的响应各不相同，因此在为调用使用合适的<a class="ae iu" href="http://javarevisited.blogspot.sg/2016/08/adapter-design-pattern-in-java-example.html#axzz5B6EWE6M7" rel="noopener ugc nofollow" target="_blank">适配器</a>之后，<code class="du jt ju jv jw b">callExternal</code>只提供一个<code class="du jt ju jv jw b">Object</code>作为结果。这个<code class="du jt ju jv jw b">Object</code>用<code class="du jt ju jv jw b">convert2Internal</code> a 方法转换成内部表示，并且这个表示被存储。</p><p id="f64f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是<code class="du jt ju jv jw b">convert2Internal</code>方法，所有的乐趣都在这里！</p><p id="59ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于<code class="du jt ju jv jw b">callExternal</code>简单地返回<code class="du jt ju jv jw b">Object</code>，我们不知道调用了什么系统，必须检查每一个可能的选项。也是不可能的。看到这个<code class="du jt ju jv jw b">throw new IllegalArgumentException(“No such external system!”)</code>？它永远不会被调用，因为在这个上下文中<code class="du jt ju jv jw b">Object</code>有这么多可能的值。<em class="ke">但是编译器不知道这一点，也不会对它采取任何措施。</em></p><p id="959e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下具有讽刺意味的是，您知道对象是什么，<a class="ae iu" href="https://javarevisited.blogspot.com/2011/12/jre-jvm-jdk-jit-in-java-programming.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> Java 运行时</strong> </a> <strong class="ix hj">也知道</strong>。只是编译器没那么容易被说服。</p><p id="c6a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的问题(编译器没有被说服是正确的)是我们在一个过于宽泛的抽象上操作。这是一种糟糕的抽象。除非我们知道<em class="ke">的具体类型</em>并能对其进行<em class="ke">具体操作</em>，否则它并不能告诉我们关于该对象的太多信息。</p><p id="5a30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要的是一个好的抽象。这将抽象出所有不必要的具体内容，留下所需的抽象内容，足以让我们说服编译器。</p><p id="921d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们通过引入名为<code class="du jt ju jv jw b">Convertible</code>的接口来做到这一点:</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><p class="iq ir et er es is it bd b be z dx translated">代码片段 2:可转换接口</p></figure><p id="9b15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它告诉我们的是，任何实现这个接口的对象都可以将自己转换成<code class="du jt ju jv jw b">InternalRepresentation</code>。我们真的不需要知道更多！</p><p id="69ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用外部系统响应来实现这个接口。比如<code class="du jt ju jv jw b">ResponseFromSystem1</code>。让它只包含一个从外部系统返回的某个数字或某个东西的字段。在我们可以存储这个响应之前，它应该被转换成我们拥有的内部表示。所以我们告诉编译器<code class="du jt ju jv jw b">ResponseFromSystem1</code>实现了<code class="du jt ju jv jw b">Convertible</code>接口，并为转换提供了实现:</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><p class="iq ir et er es is it bd b be z dx translated">片段 3:来自系统 1 的响应</p></figure><p id="152a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了为<code class="du jt ju jv jw b">provideInternalResRepresentation()</code>添加实现，我们没有改变内部表示。而且很酷。<code class="du jt ju jv jw b">ResponseFromSystem1</code>知道它的内部内容，并且知道如何将它映射到我们系统中使用的表示。</p><p id="2be0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果我们用<code class="du jt ju jv jw b">Convertible</code>的实现扩展来自所有其他系统的所有其他响应，我们(你、我和编译器)将<strong class="ix hj">确定</strong>外部调用只能返回<code class="du jt ju jv jw b">Convertible</code>。</p><p id="8039" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们可以这样重写<code class="du jt ju jv jw b">callExternal</code>方法:</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><p class="iq ir et er es is it bd b be z dx translated">代码片段 4:代码调整</p></figure><p id="0123" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们现在可以放弃这个丑陋的<code class="du jt ju jv jw b">if — else</code>链方法与转换。在那之后，我们会看到这样的内容:</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><p class="iq ir et er es is it bd b be z dx translated">代码片段 5:最终的实现</p></figure><p id="0289" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，真不错！现在，在<code class="du jt ju jv jw b">callExternal</code>之后，我们有了一个好的抽象。它抽象掉了所有不必要的信息，如响应的具体类型，但给我们留下了有用的信息，即这个响应可以转换为内部表示。我们只需要在上面调用<code class="du jt ju jv jw b">provideInternalResRepresentation</code>！</p><p id="3c1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java 运行时现在将为我们计算出实际的类型，并在具体对象上调用实际的实现。<a class="ae iu" href="https://www.tutorialspoint.com/java/java_polymorphism.htm" rel="noopener ugc nofollow" target="_blank">多态性</a>，耶！</p><p id="8b3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们的系统响应对象现在更接近于<a class="ae iu" href="https://en.wikipedia.org/wiki/Domain_model" rel="noopener ugc nofollow" target="_blank">域对象</a>，而远离<a class="ae iu" href="https://en.wikipedia.org/wiki/Anemic_domain_model" rel="noopener ugc nofollow" target="_blank">贫血域对象</a>(请参见关于<a class="ae iu" href="https://martinfowler.com/bliki/AnemicDomainModel.html" rel="noopener ugc nofollow" target="_blank">贫血域模型</a>的精彩文章)。这太好了！这些对象不仅仅是数据的持有者，还封装了逻辑。这就是整个 OOP 的目的！</p><p id="8851" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总结一下:</p><blockquote class="kf kg kh"><p id="c486" class="iv iw ke ix b iy iz ja jb jc jd je jf ki jh ji jj kj jl jm jn kk jp jq jr js hb bi translated"><code class="du jt ju jv jw b">instaceof</code>用法应该认为是代码气味。</p></blockquote><p id="d528" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">过度使用它可能表示以下情况之一:</p><ul class=""><li id="c7d4" class="kl km hi ix b iy iz jc jd jg kn jk ko jo kp js kq kr ks kt bi translated">你在使用<a class="ae iu" href="https://javarevisited.blogspot.com/2017/04/difference-between-abstraction-and-encapsulation-in-java-oop.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">不好的抽象</strong> </a>。它比它应该隐藏的更多。</li><li id="4ac8" class="kl km hi ix b iy ku jc kv jg kw jk kx jo ky js kq kr ks kt bi translated">你试图统一属于不同领域的事物。您操作的实体之间没有有用的抽象点。</li></ul><h1 id="6822" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">抽象的经验法则是，它本身就足以让你在任务的上下文中操作它背后的实体。</h1><p id="d5a9" class="pw-post-body-paragraph iv iw hi ix b iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated">它不应该要求公开太多的内部实现(这样它就不太灵活)，也不应该公开太少(所以你需要转换成具体的类型)。</p><p id="bbb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ke">好吧，就这样。如果有任何反馈或问题，我将非常高兴！请随意将它们贴在这里的回复或个人笔记中。</em></p><p id="89f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">学习 Java 的其他<strong class="ix hj">有用资源</strong>你可能喜欢的<br/><a class="ae iu" href="https://javarevisited.blogspot.com/2017/12/10-things-java-programmers-should-learn.html#axzz5atl0BngO" rel="noopener ugc nofollow" target="_blank">2019 年 Java 程序员应该学习的 10 件事</a> <br/> <a class="ae iu" href="http://www.java67.com/2018/08/top-10-free-java-courses-for-beginners-experienced-developers.html" rel="noopener ugc nofollow" target="_blank">从零开始学习 Java 的 10 门免费课程</a> <br/> <a class="ae iu" href="https://medium.freecodecamp.org/must-read-books-to-learn-java-programming-327a3768ea2f" rel="noopener ugc nofollow" target="_blank">深入学习 Java 的 10 本书</a> <br/> <a class="ae iu" href="http://www.java67.com/2018/04/10-tools-java-developers-should-learn.html" rel="noopener ugc nofollow" target="_blank"> 10 个工具每个 Java 开发人员都应该知道的</a> <br/> <a class="ae iu" href="http://javarevisited.blogspot.sg/2013/04/10-reasons-to-learn-java-programming.html" rel="noopener ugc nofollow" target="_blank">学习 Java 编程语言的 10 个理由</a><br/><a class="ae iu" href="http://javarevisited.blogspot.sg/2018/01/10-frameworks-java-and-web-developers-should-learn.html" rel="noopener ugc nofollow" target="_blank">Java 和 Web 开发人员应该学习的 10 个框架 成为 2019 年更优秀的 Java 开发者</a><br/><a class="ae iu" href="http://javarevisited.blogspot.sg/2018/04/top-5-java-frameworks-to-learn-in-2018_27.html" rel="noopener ugc nofollow" target="_blank">2019 年要学习的 5 大 Java 框架</a> <br/> <a class="ae iu" href="https://javarevisited.blogspot.sg/2018/01/10-unit-testing-and-integration-tools-for-java-programmers.html" rel="noopener ugc nofollow" target="_blank">每个 Java 开发者都应该知道的 10 个测试库</a></p><div class="mc md ez fb me mf"><a rel="noopener follow" target="_blank" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">面向初学者的 10 大 Java 在线课程</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">如果你是计算机科学专业的毕业生，或者想学习 Java 并且正在寻找一些很棒的资源，比如…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt io mf"/></div></div></a></div></div></div>    
</body>
</html>