<html>
<head>
<title>The less heard type of Inversion of Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">较少听到的控制反转类型</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/the-less-heard-type-of-inversion-of-control-924e5586377a?source=collection_archive---------1-----------------------#2022-04-20">https://medium.com/javarevisited/the-less-heard-type-of-inversion-of-control-924e5586377a?source=collection_archive---------1-----------------------#2022-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a2f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">控制反转是一种帮助我们编写松散耦合代码的设计原则。每当我们听到IoC，我们就会自动想到<a class="ae jd" href="https://javarevisited.blogspot.com/2015/06/difference-between-dependency-injection.html" rel="noopener ugc nofollow" target="_blank">依赖注入</a>，这两个术语经常互换使用。然而，事实并非如此。这种普遍的误解促使我写了这篇文章。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2012/12/inversion-of-control-dependency-injection-design-pattern-spring-example-tutorial.html"><div class="er es je"><img src="../Images/19693259d20702579e9b97a198367f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VUARzdVdqFY4csLJ"/></div></a><p class="jm jn et er es jo jp bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@nadineshaabana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">纳丁·沙巴纳</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="d973" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">到底什么是控制反转？</h1><p id="66c9" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">IoC是一个反转程序控制流的原则。它可以是关于创建一个复杂的对象，编写回调，声明性编码和许多其他事情。</p><p id="9fd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">IoC是一个原则，而依赖注入是这个原则的一个实现。让我们快速看一个例子。</p><pre class="jf jg jh ji fd kt ku kv kw aw kx bi"><span id="8177" class="ky jr hi ku b fi kz la l lb lc">class OrderService{<br/>    OrderService(){<br/>        this.emailService = new EmailServiceImpl()<br/>    }<br/>}</span></pre><p id="a905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的<code class="du ld le lf ku b">OrderService</code>需要一个<code class="du ld le lf ku b">EmailService</code>来完成它的业务逻辑。不过有个问题，<em class="lg">耦合</em>太多。<code class="du ld le lf ku b">OrderService</code>不仅依赖于一个具体的<code class="du ld le lf ku b">EmailService</code>类，它还自豪地承担了创建<code class="du ld le lf ku b">EmailService</code>对象的责任(这本身可能是一个复杂、昂贵的操作)。</p><p id="65e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们可以将<strong class="ih hj"> <em class="lg">反转</em> </strong>上的控件<code class="du ld le lf ku b">EmailService</code>创建对象。</p><pre class="jf jg jh ji fd kt ku kv kw aw kx bi"><span id="1710" class="ky jr hi ku b fi kz la l lb lc">class OrderService{<br/>    OrderService(IEmailService emailService){<br/>        this.emailService = emailService;<br/>    }<br/>}</span></pre><p id="f4a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意<code class="du ld le lf ku b">OrderService</code>不再控制<code class="du ld le lf ku b">EmailService</code>的创建方式。另外，<code class="du ld le lf ku b">OrderService</code>现在只能依赖于一个<a class="ae jd" href="https://javarevisited.blogspot.com/2010/10/abstraction-in-java.html" rel="noopener ugc nofollow" target="_blank"> <em class="lg">抽象</em> </a> ( <code class="du ld le lf ku b">IEmailService</code>是一个<code class="du ld le lf ku b">interface</code>)并且我们甚至可以在运行时选择实际的实现。这样，我们可以实现更低的耦合和更好的可测试性。</p><p id="6a01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上解决方案确实是<a class="ae jd" href="https://www.java67.com/2012/09/top-10-java-design-pattern-interview-question-answer.html" rel="noopener ugc nofollow" target="_blank"> <em class="lg">依赖注入</em> </a>。这里的<em class="lg">依赖</em> ( <code class="du ld le lf ku b">EmailService</code>)是<em class="lg">注入</em>到主体(<code class="du ld le lf ku b">OrderService</code>)。</p><p id="7016" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是依赖注入并不是IoC的唯一形式。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://www.java67.com/2022/01/top-5-courses-to-learn-design-patterns.html"><div class="er es lh"><img src="../Images/18c2eb1dd6d5c6bd2868d0ac27e02279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*dmnZ17GA54nO3bSB"/></div></a><p class="jm jn et er es jo jp bd b be z dx translated">尤达说，国际奥委会还有另一种模式</p></figure><h1 id="38f7" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">服务定位器</h1><p id="2de0" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">服务定位器是另一种使用控制反转的设计模式。然而，与DI不同，依赖项不会注入到主题中。主体通过中央<em class="lg">注册表</em>按需获取依赖关系。</p><p id="d90f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:<code class="du ld le lf ku b">OrderService</code>根据用户偏好向用户发送通知。通知可以是寻呼机、短信或电子邮件(默认)。</p><pre class="jf jg jh ji fd kt ku kv kw aw kx bi"><span id="a922" class="ky jr hi ku b fi kz la l lb lc">class OrderService{<br/>    void notify(User user){<br/>        serviceLocator.getServiceBy(user.preference())<br/>            .sendNotification(user);<br/>    }<br/>}</span><span id="fcf9" class="ky jr hi ku b fi li la l lb lc">class ServiceLocator {<br/>    INotificationService getServiceBy(<br/>            NotificationType notificationType){<br/>         return switch(notificationType){<br/>             case PAGER -&gt; pagerService<br/>             case SMS -&gt; smsService<br/>             else -&gt; emailService<br/>         }<br/>    }<br/>}</span></pre><p id="b0ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像这里的DI一样，<code class="du ld le lf ku b">OrderService</code>也不负责创建<code class="du ld le lf ku b">EmailService</code>(或任何其他服务)，因此实现了低耦合。</p><p id="9838" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这里通过<code class="du ld le lf ku b">ServiceLocator</code>实现了另一件奇妙的事情。<code class="du ld le lf ku b">OrderService</code>不需要知道<code class="du ld le lf ku b">NotificationService</code>的任何子接口，它为<code class="du ld le lf ku b">notificationType</code>寻找合适的<code class="du ld le lf ku b">NotificationService</code>的工作也被委托给服务定位器，它可以被重用。</p><p id="f252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们用DI实现这个功能，那么<code class="du ld le lf ku b">OrderService</code>应该依赖于所有类型的<code class="du ld le lf ku b">NotificationService</code>，并且它不能委派寻找合适的<code class="du ld le lf ku b">NotificationService</code>的任务。</p><h1 id="74be" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">ServiceLocator的缺点</h1><ol class=""><li id="fbe9" class="lj lk hi ih b ii ko im kp iq ll iu lm iy ln jc lo lp lq lr bi translated">依赖关系不明显，而且由于运行时缺少依赖关系，更容易出错。</li><li id="7fc8" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">所有主题都必须包含对服务定位器的引用。</li><li id="f06b" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">与DI相比更难测试</li></ol><h1 id="cf0c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="40dd" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">当我们每天都在使用DI时，我们应该了解DI和IoC之间的细微差别，以及它们之间的关系。虽然DI对于大多数用例来说是更合适的选择，但是也有服务定位器大放异彩的场景。</p></div></div>    
</body>
</html>