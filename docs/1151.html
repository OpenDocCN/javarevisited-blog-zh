<html>
<head>
<title>Concurrency and locking on databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库的并发和锁定</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/concurrency-and-locking-on-databases-daa14e2aa68d?source=collection_archive---------0-----------------------#2021-04-16">https://medium.com/javarevisited/concurrency-and-locking-on-databases-daa14e2aa68d?source=collection_archive---------0-----------------------#2021-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b045" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">解决使用JPA、Hibernate和Spring数据时的并发问题。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9ee10d34aec537faf5a52cc8a4455ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyT2xZPFl98ymTOZjLQE9A.jpeg"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">托拜厄斯·菲舍尔在<a class="ae jn" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="0285" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦应用程序上的不同线程(或微服务生态系统中的不同应用程序实例)需要对同一个数据库表进行更改，最终就会出现竞争情况。</p><p id="83d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过对同一个表进行操作，这些不同的线程最终会想要更新同一行。如果没有进一步的控制，一些更新将无声无息地丢失…</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2016/02/top-20-hibernate-interview-questions.html"><div class="er es kk"><img src="../Images/071c0b3cc3d0a1fed5a94a60402af978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSsXyFJ1sX9j7ZoOthJuEg.png"/></div></a><p class="jj jk et er es jl jm bd b be z dx translated">默默的失去改变</p></figure><p id="3962" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">很明显，当我们谈论在两个流中更新同一个字段时，这种情况会发生。</p><p id="bd23" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是，在更新不同的字段时也会出现这种情况！默认情况下，<a class="ae jn" rel="noopener" href="/javarevisited/top-5-hibernate-online-training-courses-for-beginners-and-advance-java-programmers-469460596b2b"> Hibernate </a>为所有实体字段发出一个UPDATE语句，因此整行都被更新。Hibernate的<code class="du kl km kn ko b"><a class="ae jn" href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/DynamicUpdate.html" rel="noopener ugc nofollow" target="_blank">@DynamicUpdate</a></code>注释不就解决问题了吗？它只会更新已更改的字段，对吗？嗯，no. <a class="ae jn" rel="noopener" href="/javarevisited/top-5-books-to-learn-hibernate-for-java-developers-b2cb4b16ccd6?source=---------14------------------"> Hibernate </a>会将内存中实体的状态与数据库进行比较。然后，它将为所有不同的列生成一个<code class="du kl km kn ko b">UPDATE</code>语句，不管它们在哪里发生了更改。因此，保存内存中的实体仍然会覆盖数据库中所做的更改！</p><p id="d307" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个无声的问题，因为没有引发错误来标记覆盖。唯一的解决方案是重新加载记录并重试更新。但是要这样做，应用程序必须知道存在冲突。</p><p id="5d22" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个问题有两个可行的解决办法。所有这些都要求在处理受影响的实体时事务处于活动状态。</p><h1 id="7d26" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">乐观锁定</h1><p id="2172" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">可以并发处理的每个JPA实体都用一个<code class="du kl km kn ko b"><a class="ae jn" href="https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/Version.html" rel="noopener ugc nofollow" target="_blank">@Version</a></code>列增强。</p><p id="529d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当对自上次读取以来已被修改的行进行更新时，版本号不再相同，并且会引发异常。</p><p id="0474" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过重新加载受影响的实体、重新应用更改并再次保存，可以实现恢复。</p><p id="b04b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">乐观锁定的缺点:</p><ol class=""><li id="fa61" class="lm ln hi jq b jr js ju jv jx lo kb lp kf lq kj lr ls lt lu bi translated">冲突只有在提交时才知道，所以在所有处理完成后。事务将在此时回滚。当使用其他非事务性资源来处理实体时，这可能是一个问题。</li><li id="5d90" class="lm ln hi jq b jr lv ju lw jx lx kb ly kf lz kj lr ls lt lu bi translated">重试机制的复杂性:只能回放处理的结果。如果处理中涉及非事务性资源，必须注意不要重复<a class="ae jn" href="https://javarevisited.blogspot.com/2016/05/what-are-idempotent-and-safe-methods-of-HTTP-and-REST.html#axzz5j9AEsxuT" rel="noopener ugc nofollow" target="_blank">非幂等操作</a>。</li></ol><h1 id="f4c4" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">悲观锁定</h1><p id="9025" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">换句话说，在数据库级别使用带有行锁定的长时间运行的事务。每个想要处理行的事务都需要等待，直到另一个事务完成或者超时。当事务完成时，锁被释放。</p><p id="7fdc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">锁超时会导致异常，但不一定会导致事务回滚。只有在<code class="du kl km kn ko b"><a class="ae jn" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html" rel="noopener ugc nofollow" target="_blank">@Transactional</a></code>方法或<code class="du kl km kn ko b"><a class="ae jn" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionTemplate.html" rel="noopener ugc nofollow" target="_blank">TransactionTemplate</a></code>回调中使用Spring事务时，回滚才有保证，因为如果这些方法抛出异常，Spring会回滚事务。</p><p id="c4a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最常见的悲观锁定模式是锁定行，防止在事务开始时读取和修改该行。这被称为<em class="ma">悲观写</em>锁。当同一行被锁定时，任何其他事务都不能读取或修改该行。它经常导致一个<code class="du kl km kn ko b">SELECT … FOR UPDATE</code>或类似的声明被发布。</p><p id="b66a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">也可以锁定该行，只允许修改，这意味着其他<a class="ae jn" href="https://javarevisited.blogspot.com/2011/11/database-transaction-tutorial-example.html#axzz5WDqhDqX3" rel="noopener ugc nofollow" target="_blank">事务</a>可以随时读取它。这是一个<em class="ma">悲观读</em>锁。并非所有的数据库或JPA实现都支持这种模式，通常会自动升级到悲观写锁。</p><p id="6b22" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所需的JPA锁定模式可以按照本<a class="ae jn" href="https://javaee.github.io/tutorial/persistence-locking002.html" rel="noopener ugc nofollow" target="_blank"> Java EE教程中关于锁定模式</a>的描述进行配置。当使用Spring数据时，我们可以在Spring存储库方法中使用<code class="du kl km kn ko b"><a class="ae jn" href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/org/springframework/data/jpa/repository/Lock.html" rel="noopener ugc nofollow" target="_blank">@Lock</a></code>注释来指定所需的锁模式。锁定超时值可以通过设置应用于Spring存储库方法的<code class="du kl km kn ko b"><a class="ae jn" href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/org/springframework/data/jpa/repository/QueryHints.html" rel="noopener ugc nofollow" target="_blank">@QueryHints</a></code>注释中的<code class="du kl km kn ko b">javax.persistence.lock.timeout</code>提示来定义。</p><p id="f1c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">悲观锁定的缺点:</p><ol class=""><li id="1f08" class="lm ln hi jq b jr js ju jv jx lo kb lp kf lq kj lr ls lt lu bi translated">依赖数据库进行同步。</li><li id="8ac3" class="lm ln hi jq b jr lv ju lw jx lx kb ly kf lz kj lr ls lt lu bi translated">超时必须被配置为一个提示，所以它不是一个契约，因此不一定可以在数据库之间移植。</li><li id="fbde" class="lm ln hi jq b jr lv ju lw jx lx kb ly kf lz kj lr ls lt lu bi translated">当多个资源被锁定时，可能会发生死锁。</li><li id="fb1b" class="lm ln hi jq b jr lv ju lw jx lx kb ly kf lz kj lr ls lt lu bi translated">在数据库级别使用更多资源。</li></ol><h1 id="0ea9" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">应该用哪个？</h1><p id="f324" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">看情况。一如既往。</p><p id="a520" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">理想情况下，应用程序流应该以这样一种方式设计，即<a class="ae jn" rel="noopener" href="/javarevisited/8-best-multithreading-and-concurrency-courses-for-experienced-java-developers-8acfd3b25094">并发性</a>不是问题。因此，没有共享资源。这个一般原则也适用于数据库资源，比如<strong class="jq hj">行</strong>。</p><p id="2614" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，当不可能防止不同的流同时更新同一行时，有两个因素会影响对这些机制之一的选择。</p><p id="21b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，应该在权衡以下任何一种情况所带来的后果之后做出选择:</p><h2 id="6221" class="mb kq hi bd kr mc md me kv mf mg mh kz jx mi mj lb kb mk ml ld kf mm mn lf mo bi translated">交通</h2><p id="b2d4" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">悲观锁定增加了数据库服务器所需的资源，而乐观锁定将负担留给了客户端。</p><p id="1191" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于低流量，悲观锁定可能是合适的。但是，如果流量增加，数据库服务器可能会受到资源的限制，从而导致另一种类型的问题。此外，客户机中的线程将被阻塞，直到行锁被释放，从而降低了客户机处理请求的能力。</p><p id="af80" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当流量水平上升时，乐观锁定是更好的选择。</p><h2 id="78c2" class="mb kq hi bd kr mc md me kv mf mg mh kz jx mi mj lb kb mk ml ld kf mm mn lf mo bi translated">并发</h2><p id="e84a" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">乐观锁定要求客户端应用程序在发生冲突时刷新其数据。这种刷新增加了数据库往返次数，从而增加了数据库服务器的负载。</p><p id="307e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">高并发性场景是悲观锁定的理想选择。</p><h1 id="215b" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">结论</h1><p id="b240" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">有两种方法可用于在<a class="ae jn" rel="noopener" href="/hackernoon/top-5-sql-and-database-courses-to-learn-online-48424533ac61">数据库</a>级别管理并发:<strong class="jq hj">乐观锁定</strong>和<strong class="jq hj">悲观锁定。</strong></p><p id="5e8a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在两种锁定模式下，应该在仔细考虑流量和并发性对应用程序和数据库服务器的影响后，选择一种模式或两种模式的组合。</p><p id="88c0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">众所周知，负载测试应始终在预期的最大流量水平下执行，以增强对解决方案的信心并尽早发现问题。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><h1 id="b9a9" class="kp kq hi bd kr ks mw ku kv kw mx ky kz io my ip lb ir mz is ld iu na iv lf lg bi translated">资源</h1><p id="42e1" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx lj jz ka kb lk kd ke kf ll kh ki kj hb bi translated">关于<code class="du kl km kn ko b">@QueryHints</code>注释的文档:<a class="ae jn" href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/org/springframework/data/jpa/repository/QueryHints.html" rel="noopener ugc nofollow" target="_blank">query hints(Spring Data JPA 2 . 4 . 7 API)</a></p><p id="078e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">链接到一个关于锁模式的Java EE教程。</p><p id="0de6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">关于<code class="du kl km kn ko b">@Lock</code>注释的文档:<a class="ae jn" href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/org/springframework/data/jpa/repository/Lock.html" rel="noopener ugc nofollow" target="_blank">锁(Spring Data JPA 2.4.7 API) </a></p><p id="319e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">关于<code class="du kl km kn ko b">@Transactional</code>注释的文档:<a class="ae jn" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html" rel="noopener ugc nofollow" target="_blank">事务型(Spring Framework 5.3.5 API) </a></p><p id="8655" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">关于<code class="du kl km kn ko b">@Version</code>注释的文档:<a class="ae jn" href="https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/Version.html" rel="noopener ugc nofollow" target="_blank">版本(hibernate-JPA-2.1-API 1 . 0 . 0 . final API)(jboss.org)</a></p><p id="80a3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">关于<code class="du kl km kn ko b">@DynamicUpdate</code>的文档注释:<a class="ae jn" href="https://docs.jboss.org/hibernate/orm/5.4/javadocs/org/hibernate/annotations/DynamicUpdate.html" rel="noopener ugc nofollow" target="_blank">dynamic update(Hibernate JavaDocs)(jboss.org)</a></p></div></div>    
</body>
</html>