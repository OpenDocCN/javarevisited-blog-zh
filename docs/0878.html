<html>
<head>
<title>A Quick Glance On Blocking Queue In Java!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速浏览一下Java中的阻塞队列！</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/a-quick-glance-on-blocking-queue-in-java-7a95a9ae5a47?source=collection_archive---------3-----------------------#2020-12-29">https://medium.com/javarevisited/a-quick-glance-on-blocking-queue-in-java-7a95a9ae5a47?source=collection_archive---------3-----------------------#2020-12-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2012/02/producer-consumer-design-pattern-with.html#axzz5gssD6l67"><div class="er es if"><img src="../Images/185be968abd97517c67b02f0a60b7c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*npZ_hkGuK-OyGtgKhFgNOA.jpeg"/></div></a></figure><figure class="in io ip iq fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/06/java-lock-and-condition-example-producer-consumer.html#axzz6e8hmwujv"><div class="er es im"><img src="../Images/41fd6c372774cc21a318618dd3062aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*OCG116g0tXVWia4S5HKE7w.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">图1.1:说明阻塞队列工作的示意图</p></figure><p id="57ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">读者们好，</p><p id="5c16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我带着关于阻塞队列的新教程回来了，它解释了阻塞队列的所有基本概念和基本介绍，以及它们是如何工作的，以及它们是如何在Java中实现的。</p><p id="fc25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">阻塞队列:</strong>阻塞队列被定义为当队列未被完全填满时发生元素插入的队列，否则执行操作的线程将被阻塞，并且它将等待一个或多个元素从队列中被移除或者队列被完全清空以将另一个元素插入到队列中，并且当元素必须从队列中出列时， 如果队列已经是空的，那么执行操作的线程被阻塞，它等待另一个元素插入队列来执行它的操作，阻塞队列图如上所示。</p><p id="d0e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>队列不接受空值，如果空值被传递给队列它会抛出NullPointerException。</p><p id="12e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">阻塞队列的类型</strong></p><p id="4c08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两种类型的阻塞队列，描述如下:</p><ul class=""><li id="f184" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hj">有界阻塞队列:</strong>有界阻塞队列可以理解为阻塞队列，其中阻塞队列的大小是有限的或固定的，一旦通过将它传入参数来分配大小，就不能再增加。使用有界阻塞队列的阻塞队列的一些实现是阻塞队列的数组实现，也可以将<a class="ae kc" href="https://www.java67.com/2015/12/producer-consumer-solution-using-blocking-queue-java.html" rel="noopener ugc nofollow" target="_blank">阻塞队列</a>的链接表示视为有界阻塞队列，但它并不完全是有界阻塞队列。</li><li id="300e" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated"><strong class="ix hj">无界阻塞队列:</strong>无界队列可以理解为阻塞队列，其中阻塞队列的大小不受限制，并且它能够随着元素的插入而增长。使用无界阻塞队列的阻塞队列的一些实现是阻塞队列、优先级阻塞队列等的链接表示。</li></ul><p id="b1b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数组阻塞队列:</strong> <a class="ae kc" href="https://javarevisited.blogspot.com/2012/12/blocking-queue-in-java-example-ArrayBlockingQueue-LinkedBlockingQueue.html" rel="noopener ugc nofollow" target="_blank">数组阻塞队列</a>可以理解为大小固定且在运行时不能改变的有界阻塞队列。它遵循由正常队列数据结构维护的<strong class="ix hj"> FIFO规则</strong>，即(先进先出)。示例如下所示:</p><figure class="in io ip iq fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/04/top-5-courses-to-learn-java-collections-and-streams.html#axzz6nwXUSoGH"><div class="er es ki"><img src="../Images/d143e7e8dbe150943ab1d9d9b1e140f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AitDcT9iHycfj5y1gB1sYQ.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">图1.1:Java中数组阻塞队列的例子</p></figure><p id="a620" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">上述代码的输出将是:<br/> </strong>【队列已经=【Rahul Ram Sita】。<br/>现在，队列已经= [Ram Sita]</p><p id="9093" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"/>链接阻塞队列:链接阻塞队列可以理解为有界阻塞队列和无界阻塞队列，其中元素的存储如同节点在链表中的存储，也遵循<strong class="ix hj"> FIFO规则</strong>(先进先出)，它的头定义存储时间最长的元素，尾定义存储时间最短的节点。示例如下所示:</p><figure class="in io ip iq fd ij er es paragraph-image"><a href="https://www.java67.com/2018/08/top-10-free-java-courses-for-beginners-experienced-developers.html"><div class="er es kj"><img src="../Images/fb3944b11595535fbf508378889466c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22ZjOo9XhOZ8mnxsKCagvA.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">图2.2:Java中链接阻塞队列的例子</p></figure><p id="add3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">上述代码的输出将是:<br/></strong>Queue has =【Rahul Ram Sita】。<br/>现在，队列已经= [Ram Sita] <br/> Ram</p><p id="6fa6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">延迟队列:</strong>延迟队列定义为延迟方法返回的时间应为等待时间或当前元素释放的延迟时间的阻塞队列。</p><p id="1d25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">优先级阻塞队列:</strong>优先级阻塞队列定义为无界阻塞队列，其中元素按照用户给定的优先级排列。用户不能将null元素添加到队列中。</p><h2 id="1d13" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated"><a class="ae kc" href="https://javarevisited.blogspot.com/2014/06/synchronousqueue-example-in-java.html" rel="noopener ugc nofollow" target="_blank">同步队列</a> : <strong class="ak">同步队列定义为最多包含一个元素的队列，当一个元素必须被推入队列，而队列中已经有一个元素时，那么执行该操作的线程被阻塞，然后在移除该元素后，另一个元素被插入，反之亦然。</strong></h2><p id="dde3" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated"><strong class="ix hj">不断学习，不断成长，不断探索！</strong></p><p id="eb9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">祝一切顺利！</p><p id="e0b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更多有趣和信息丰富的文章和提示请关注我的<a class="ae kc" href="https://swapnilkant11.medium.com/" rel="noopener"> <strong class="ix hj">媒体</strong> </a> <strong class="ix hj">和</strong><a class="ae kc" href="https://www.linkedin.com/in/swapnil-kant-279a3b148/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">Linkedin</strong></a></p></div></div>    
</body>
</html>