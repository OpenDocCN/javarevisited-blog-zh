<html>
<head>
<title>Event Driven Microservices with Spring Cloud Stream and RabbitMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Cloud Stream和RabbitMQ的事件驱动微服务</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/event-driven-microservices-with-spring-cloud-stream-and-rabbitmq-add4166fe223?source=collection_archive---------0-----------------------#2021-06-18">https://medium.com/javarevisited/event-driven-microservices-with-spring-cloud-stream-and-rabbitmq-add4166fe223?source=collection_archive---------0-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="76da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于REST的应用程序主宰了微服务的世界。当我们谈论微服务时，一个自然的假设是一组单独的服务通过HTTP(S) REST相互通信。但是事件驱动的微服务在任何基于云的现代架构中都扮演着重要而关键的角色。</p><p id="eec3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用事件来传递应用程序状态或数据并不是一个新概念。几十年来，组织一直在使用像IBM MQ这样的消息传递系统。但是这些都是重量级的、商业的，并且需要专门的基础设施来维护。</p><p id="b392" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着AMQP协议和它的几个开源实现的引入，事件的使用变得容易采用了。</p><p id="fcb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在事件驱动架构中，应用程序通过发送和/或接收事件或消息来相互通信。这些可以只包含关于状态/状态变化的元数据或主体中的实际内容本身。通信可以是点对点或发布-订阅。</p><h2 id="a219" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">春云流</h2><p id="35fc" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated"><a class="ae kd" href="https://spring.io/projects/spring-cloud-stream" rel="noopener ugc nofollow" target="_blank">春云流</a>是春云生态系统内的一个项目。它是一个框架，提供了一个基于Spring的编程模型，并在消息中间件之上添加了一个抽象层。</p><p id="f912" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它使Spring应用程序能够无缝地连接到底层基础设施，而不用担心样板代码。<a class="ae kd" rel="noopener" href="/javarevisited/10-best-spring-framework-books-for-java-developers-360284c37036"> Spring </a> (VMWare)维护RabbitMQ、<a class="ae kd" rel="noopener" href="/javarevisited/top-10-apache-kafka-online-training-courses-and-certifications-621f3c13b38c"> Kafka </a>、Kafka Streams和Amazon Kinesis的绑定器实现，而Google PubSub、Azure EventHub、Apache RocketMQ和Solace PubSub绑定器由相应的组织维护。</p><p id="fbaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">春云流有两种不同的用途</p><ul class=""><li id="7cf9" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">使用<a class="ae kd" href="https://spring.io/projects/spring-cloud-dataflow" rel="noopener ugc nofollow" target="_blank"> Spring Cloud数据流</a>创建流数据管道</li><li id="1a0d" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">使用点对点或发布-订阅模型创建事件驱动的微服务</li></ul><p id="27ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文解释了后者——用RabbitMQ使用Spring Cloud Stream开发<a class="ae kd" rel="noopener" href="/javarevisited/10-best-java-microservices-courses-with-spring-boot-and-spring-cloud-6d04556bdfed">事件驱动的微服务</a>。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><a href="https://www.java67.com/2021/04/5-free-microservice-courses-for-java.html"><div class="er es ks"><img src="../Images/b4631c042c11e3e57e3a678a1a989605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*Y7e_0n81_Mev69sunSDxBg.png"/></div></a><p class="la lb et er es lc ld bd b be z dx translated">春天的云流和兔子</p></figure><h2 id="e9a4" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">兔子q</h2><p id="5394" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">RabbitMQ是一个广受欢迎的消息平台。它有开源版和商业版。它是轻量级的，可以很容易地部署在笔记本电脑上；直接或使用Docker</p><p id="9bba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用Docker图像:</strong></p><p id="c5ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RabbitMQ可以使用下面的docker命令安装。它将从<a class="ae kd" href="https://hub.docker.com/_/rabbitmq" rel="noopener ugc nofollow" target="_blank"> docker hub </a>安装最新版本，前提是你已经登录了docker hub。</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="b6fd" class="jd je hi lf b fi lj lk l ll lm">docker pull rabbitmq</span></pre><p id="ebae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ln">运行容器时，不要运行rabbitmq容器，因为它不提供任何GUI来浏览交换和队列</em></p><p id="054c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用下面的命令运行管理插件。它将启动一个带有管理GUI的rabbitmq容器。</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="719d" class="jd je hi lf b fi lj lk l ll lm">docker run -d --hostname my-rabbit --name some-rabbit rabbitmq:3-management</span></pre><p id="800e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用默认凭证为<code class="du lo lp lq lf b">guest</code>的<a class="ae kd" href="http://localhost:15672/" rel="noopener ugc nofollow" target="_blank">http://localhost:15672/</a>来访问UI。</p><h2 id="8a25" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">微服务</h2><p id="3d72" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">让我们来看看3种简单的微服务——生产者、处理器和消费者。生产者将通过一个<a class="ae kd" href="https://javarevisited.blogspot.com/2018/02/top-20-spring-rest-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"> REST端点</a>接受一个字符串，并向RabbitMQ主题发布一条消息。处理器将订阅主题，将字符串转换为大写并发布到输出主题。消费者将订阅主题并在控制台中打印值。这3个服务将展示Spring Cloud Stream中的源-处理器-接收器概念。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es lr"><img src="../Images/05ecd4432ddee7082ff6418a4974b305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*-NmpO3WcuoWEBhbcsIgywA.png"/></div><p class="la lb et er es lc ld bd b be z dx translated">春天的云流和兔子</p></figure><p id="b9f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着<a class="ae kd" rel="noopener" href="/javarevisited/6-best-online-courses-to-learn-functional-programming-in-java-for-beginners-1dab627b63ca">功能编程</a>的引入，源、处理器和接收器的设置变得更加容易。在本文中，我们将使用函数式编程。</p><p id="9eff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有3个服务的最终代码都可以在<a class="ae kd" href="https://github.com/smoothed9/spring-cloud-stream-rabbit" rel="noopener ugc nofollow" target="_blank"> Git repo </a>中找到。</p><blockquote class="ls lt lu"><p id="bad2" class="if ig ln ih b ii ij ik il im in io ip lv ir is it lw iv iw ix lx iz ja jb jc hb bi translated">由于RabbitMQ将一个主题表示为一个交换和一个或多个绑定到该交换的队列，所以本文中可以互换使用world主题和交换</p></blockquote><h2 id="505e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">生产者</h2><p id="78df" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">所有3个服务都需要来自<a class="ae kd" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> start.spring.io </a>的<code class="du lo lp lq lf b">Cloud Stream</code>、<code class="du lo lp lq lf b">Spring for RabbitMQ </code>和<code class="du lo lp lq lf b">lombok</code>依赖项。因为生产者将通过REST端点接受请求，所以它也需要<code class="du lo lp lq lf b">Web</code>依赖。这在春云流中被称为<code class="du lo lp lq lf b">Source</code> a服务。</p><p id="f278" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个简单的<a class="ae kd" rel="noopener" href="/javarevisited/21-spring-mvc-rest-interview-questions-answers-for-beginners-and-experienced-developers-21ad3d4c9b82">控制器</a>，它接受一个字符串并将其发送给一个主题。</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="b244" class="jd je hi lf b fi lj lk l ll lm">import lombok.extern.slf4j.Slf4j;<br/>import org.springframework.cloud.stream.function.StreamBridge;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.PathVariable;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>@Slf4j<br/>@RestController<br/>public class ValueController {<br/><br/>    private StreamBridge streamBridge;<br/><br/>    public ValueController(StreamBridge streamBridge) {<br/>        this.streamBridge = streamBridge;<br/>    }<br/><br/>    @GetMapping("values/{value}")<br/>    public ResponseEntity&lt;String&gt; values(@PathVariable String value) {<br/>        <em class="ln">log</em>.info("Sending value {} to topic", value);<br/>        streamBridge.send("values-topic", value);<br/>        return ResponseEntity.<em class="ln">ok</em>("ok");<br/>    }<br/>}</span></pre><p id="bf47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，Producer微服务中没有任何代码或配置将其链接到RabbitMQ。在依赖项中添加RabbitMQ绑定器为我们完成了所有的绑定。这使得切换底层消息传递提供者变得非常容易。</p><h2 id="38c2" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">处理器</h2><p id="14ae" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">处理器是纯<a class="ae kd" rel="noopener" href="/javarevisited/5-best-courses-to-learn-spring-cloud-and-microservices-1ddea1af7012">春云流</a>应用。它不断地监听一个主题，并在接收到一条消息后，对其进行处理并发布到一个输出主题。因此，该服务只需要<code class="du lo lp lq lf b">Cloud Stream</code>和<code class="du lo lp lq lf b">Spring for RabbitMQ</code>依赖项。</p><p id="9743" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加一个组件类来处理消息。</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="896b" class="jd je hi lf b fi lj lk l ll lm">import lombok.extern.slf4j.Slf4j;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.stereotype.Component;<br/><br/>import java.util.function.Function;<br/><br/>@Slf4j<br/>@Component<br/>public class ValueProcessor {<br/><br/>    @Bean<br/>    public Function&lt;String, String&gt; convertToUppercase() {<br/>        return (value) -&gt; {<br/>            <em class="ln">log</em>.info("Received {}", value);<br/>            String upperCaseValue = value.toUpperCase();<br/>            <em class="ln">log</em>.info("Sending {}", upperCaseValue);<br/>            return upperCaseValue;<br/>        };<br/>    }<br/>}</span></pre><p id="1b98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理器被表示为一个<code class="du lo lp lq lf b">java.util.Function</code>，它接受一个字符串并以一个字符串作为响应。<a class="ae kd" rel="noopener" href="/javarevisited/8-best-lambdas-stream-and-functional-programming-courses-for-java-developers-3d1836a97a1d">功能编程</a>无需任何配置。</p><p id="8a11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当应用程序启动时，Spring会自动创建一个输入主题，并将这个方法注册为一个监听器。收到消息后，代码会将输入转换为大写，并将其发送到输出主题。<a class="ae kd" rel="noopener" href="/javarevisited/3-best-spring-professionals-certification-books-and-courses-for-java-developers-935296c3709"> Spring </a>也会自动创建一个输出主题。</p><p id="08f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这些主题是用默认的命名标准创建的。它们被创建为<code class="du lo lp lq lf b">javaMethodName-in-&lt;index&gt;</code>和<code class="du lo lp lq lf b">javaMethodName-out-&lt;index&gt;</code>，其中<code class="du lo lp lq lf b">index</code>对应于应用实例的索引。</p><p id="a9e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，当这个应用程序在本地运行时，交换将被创建为<code class="du lo lp lq lf b">convertToUppercase-in-0</code>和<code class="du lo lp lq lf b">convertToUppercase-out-0</code>。但是生产者微服务将该事件发布到名为<code class="du lo lp lq lf b">values-topic</code>的交易所。因此，除非我们覆盖由Spring创建的默认交换名称，否则由生产者发送的消息将不会被处理器读取，因为它们将发送和监听不同的交换。</p><p id="cd77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用以下配置将处理器映射到<code class="du lo lp lq lf b">value-topic</code></p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="9e37" class="jd je hi lf b fi lj lk l ll lm">spring:<br/>  cloud:<br/>    stream:<br/>      bindings:<br/>        convertToUppercase-in-0:<br/>          destination: values-topic<br/>          group: processor<br/>        convertToUppercase-out-0:<br/>          destination: uppercase-values-topic</span></pre><p id="8e61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加<code class="du lo lp lq lf b">group</code>是可选的，但是它将创建一个消费者组和一个持久队列。离开<code class="du lo lp lq lf b">group</code>将导致创建一个匿名队列，当应用程序停止时，这个队列将被销毁。消费者组也有助于高可用性和负载平衡，但是由于这是一个只有一个实例的示例应用程序，添加<code class="du lo lp lq lf b">group</code>的主要原因是为了避免创建匿名队列。</p><p id="7af6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出交换/主题名称也在同一个yml中定义。下一个服务(消费者)必须侦听这个交换来读取消息。</p><h2 id="5620" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">消费者</h2><p id="f984" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">消费者的依赖关系列表与处理器相同。它是一个终端服务，在<a class="ae kd" rel="noopener" href="/hackernoon/top-5-spring-boot-and-spring-cloud-books-for-java-developers-75df155dcedc?source=---------23------------------">春云流</a>中被称为<code class="du lo lp lq lf b">Sink</code>。</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="3195" class="jd je hi lf b fi lj lk l ll lm">import lombok.extern.slf4j.Slf4j;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.stereotype.Component;<br/><br/>import java.util.function.Consumer;<br/><br/>@Slf4j<br/>@Component<br/>public class ValuesConsumer {<br/><br/>    @Bean<br/>    public Consumer&lt;String&gt; onReceive() {<br/>        return (message) -&gt; {<br/>          <em class="ln">log</em>.info("Received the value {} in Consumer", message);<br/>        };<br/>    }<br/>}</span></pre><p id="8b5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，<code class="du lo lp lq lf b">Sink</code>服务是通过创建一个充当接收者的bean】来定义的。因为这使用了<a class="ae kd" href="https://javarevisited.blogspot.com/2020/04/top-5-courses-to-learn-functional-programming-in-java-with-lambda-and-stream.html" rel="noopener ugc nofollow" target="_blank"> Functional programmin </a> g，所以默认绑定是用方法名创建的，如处理器部分所述。为了使用处理器发送给<code class="du lo lp lq lf b">uppercase-topic</code>的消息，需要添加一个配置。</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="4d8b" class="jd je hi lf b fi lj lk l ll lm">spring:<br/>  cloud:<br/>    stream:<br/>      bindings:<br/>        onReceive-in-0:<br/>          destination: uppercase-values-topic<br/>          group: consumer</span></pre><p id="0683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们就创建了一个功能齐全的春季云流。最终代码在<a class="ae kd" href="https://github.com/smoothed9/spring-cloud-stream-rabbit" rel="noopener ugc nofollow" target="_blank"> Git </a>中。让我们测试一下，看看它的表现如何。</p><h1 id="5117" class="ly je hi bd jf lz ma mb jj mc md me jn mf mg mh jq mi mj mk jt ml mm mn jw mo bi translated">测试</h1><p id="7cea" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">启动所有3项服务。通过传递小写字符串来调用生产者。例如，<code class="du lo lp lq lf b"><a class="ae kd" href="http://localhost:8080/values/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/values/hello</a></code></p><p id="c2ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这些是异步的流应用程序，浏览器中的响应仅指示来自生成器的成功。处理器的日志应该显示以下消息</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="9caa" class="jd je hi lf b fi lj lk l ll lm">Received hello<br/>Sending HELLO</span></pre><p id="605b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">消费者的日志应该显示以下消息</p><pre class="kt ku kv kw fd le lf lg lh aw li bi"><span id="f9a4" class="jd je hi lf b fi lj lk l ll lm">Received the value HELLO in Consumer</span></pre><p id="96a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这表明URL中给出的输入字符串按预期通过了所有3个服务。</p><h1 id="ed79" class="ly je hi bd jf lz ma mb jj mc md me jn mf mg mh jq mi mj mk jt ml mm mn jw mo bi translated">结论</h1><p id="1903" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">使用Spring Cloud Stream开发事件驱动的微服务简单易行。由于对函数式编程的支持，这可以用非常少的代码和配置来完成。</p><p id="1b65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的微服务中可以明显看出，Spring Cloud Stream避免了对任何样板代码的需求，并消除了代码或配置中对特定消息中间件实现的任何依赖。</p><p id="58bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将RabbitMQ更改为另一个实现，如Azure ServiceBus或EventHub，就像更改<a class="ae kd" rel="noopener" href="/javarevisited/5-best-gradle-courses-and-books-to-learn-in-2021-93f49ce8ff8e"> Gradle </a>依赖关系一样简单。这有助于团队将其内部事件驱动的微服务迁移到任何公共云中，而无需进行任何代码或配置更改。我将在随后的文章中讨论这个问题。</p></div></div>    
</body>
</html>