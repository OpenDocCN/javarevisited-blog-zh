<html>
<head>
<title>Java - Null Handling With Optionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可选的Java空处理</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-null-handling-with-optionals-b2ded1f48b39?source=collection_archive---------2-----------------------#2021-05-24">https://medium.com/javarevisited/java-null-handling-with-optionals-b2ded1f48b39?source=collection_archive---------2-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/814d1211d30551ce0a92269c5e54d543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*TkT0qHp1C5B4crZY1TWX_w.png"/></div></figure><p id="ac05" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将讨论java的一个基本主题，即空处理，我们将用Java 8中引入的选项来做这件事，我们将用例子来详细说明这件事。</p><p id="f053" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将创建可选的返回方法，还将看到使用可选的数据库操作的Spring方式。首先，让我们记住什么是NullPointerException，然后看看什么是Optionals。</p><p id="dcd0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在Java中，如果我们想创建一个变量，我们首先声明它，然后初始化它。当我们使用一个不指向内存(未初始化)的引用并对其进行操作(例如调用方法)时，我们会得到NullPointerException。你可以在下面看到一个例子。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="266c" class="jt ju hi jp b fi jv jw l jx jy">Object someObject = null; // created null variable<br/>someObject.toString(); // method call over null variable</span></pre><p id="6e6b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，我们有一个名为someObject的未初始化对象，并试图调用它的toString方法。因为它没有被初始化，也没有指向内存中的任何地方，所以它最终会抛出<a class="ae jz" href="https://javarevisited.blogspot.com/2013/05/ava-tips-and-best-practices-to-avoid-nullpointerexception-program-application.html" rel="noopener ugc nofollow" target="_blank"> NullPointerException </a>。现在，如果我们刷新一下记忆，我们就能得到期权。</p><h2 id="b44d" class="jt ju hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">1-什么是可选的？</h2><p id="25f3" class="pw-post-body-paragraph im in hi io b ip kt ir is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj hb bi translated">可选类提供了一种使用fluent API以优雅的方式处理可空对象的方法。使用提供的API，如果对象存在(非空)，我们将处理该对象。让我们看看它是什么样子的</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="e07e" class="jt ju hi jp b fi jv jw l jx jy">Object someObject = null;<br/>Optional&lt;Object&gt; objectOptional = Optional.<em class="ky">ofNullable</em>(someObject);<br/>System.<em class="ky">out</em>.println(objectOptional.isPresent()); // prints false</span></pre><p id="cfb6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如上所述，我们将someObject变量设置为null，然后创建了包装null对象的<a class="ae jz" href="https://javarevisited.blogspot.com/2017/04/10-examples-of-optional-in-java-8.html#axzz6ccm5KWKs" rel="noopener ugc nofollow" target="_blank">可选对象</a>。然后，我们用isPresent方法检查变量是否为null。让我们尝试使用非空对象，看看当我们将非空对象传递给可选包装器时，它是否打印为true。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="886f" class="jt ju hi jp b fi jv jw l jx jy">Object someObject2 = new Object();<br/>Optional&lt;Object&gt; objectOptional2 = Optional.<em class="ky">ofNullable</em>(someObject2);<br/>System.<em class="ky">out</em>.println(objectOptional2.isPresent()); // prints true</span></pre><h2 id="c66f" class="jt ju hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">2-可选类的方法</h2><p id="4430" class="pw-post-body-paragraph im in hi io b ip kt ir is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj hb bi translated">现在，让我们看看可以使用什么方法来充分利用可选类。</p><p id="094c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以从创造性的方法开始。这些创建方法是可选类中的静态方法。</p><ul class=""><li id="d3c6" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj"> ofNullable(T值)</strong>，创建可选包装一个可以为空或非空的对象。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="0bd8" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;Object&gt; optional = Optional.<em class="ky">ofNullable</em>(new Object());</span></pre><ul class=""><li id="8335" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj">(T值)</strong>，创建一个不能为空的可选包装对象。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b0aa" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;Object&gt; optional = Optional.<em class="ky">of</em>(new Object());</span></pre><p id="cb83" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可能会问“如果我们确保传递的对象不为空，我为什么要使用它”。在某些情况下，您可能需要在方法中返回一个可选对象，作为实现接口方法的结果，因此您可能需要此方法。</p><ul class=""><li id="3a33" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj"> empty() </strong>，创建空的可选对象，这意味着可选对象中不存在任何值。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="41ed" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;Object&gt; optional = Optional.<em class="ky">empty</em>();</span></pre><p id="9ea5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们看看检查值的存在的方法。</p><ul class=""><li id="7990" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><a class="ae jz" href="https://www.java67.com/2018/06/java-8-optional-example-ispresent-orElse-get.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> isPresent() </strong> </a>，如果可选包含非空值，则返回true，否则返回false。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="7739" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;Object&gt; optional = Optional.<em class="ky">ofNullable</em>(new Object());<br/>System.<em class="ky">out</em>.println(optional.isPresent()); // prints true</span></pre><ul class=""><li id="0436" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj"> ifPresent(消费者&lt;？super T &gt; consumer) </strong>，如果Optional中的值存在，您可以运行自己的逻辑。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d6bf" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;String&gt; stringOptional = Optional.<em class="ky">of</em>("Hi!");<br/>Optional&lt;String&gt; stringOptionalNull = Optional.<em class="ky">empty</em>();<br/><br/>stringOptional.ifPresent(System.<em class="ky">out</em>::println); // prints "Hi!"<br/>stringOptionalNull.ifPresent(System.<em class="ky">out</em>::println); // prints nothing</span></pre><p id="c01e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以在传统的if语句中使用isPresent，也可以选择ifPresent作为处理现有值的优雅方式。</p><p id="f11e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果值不存在，我们有时需要运行一些逻辑，比如提供备份值。让我们看看如何处理不存在的值。</p><ul class=""><li id="3d17" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj"> orElse(T other) </strong>，如果存在，则返回Optional内部的值，否则返回给定值作为参数。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b657" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;String&gt; stringOptionalNull = Optional.<em class="ky">empty</em>();<br/>String backupValue = stringOptionalNull.orElse("Hi!");<br/>System.<em class="ky">out</em>.println(backupValue); // prints "Hi!"</span></pre><p id="ff8c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如您所见，stringOptionalNull是一个空的可选值，我们提供了一个备份值，以防由于orElse方法而不存在。所以，它打印出给orElse方法的值。</p><ul class=""><li id="0bcc" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj"> orElseGet(供应商&lt;？扩展T &gt; other) </strong>，返回Optional内部的值(如果存在)，否则运行提供的逻辑，然后返回其结果。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="a0f2" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;String&gt; stringOptionalNull = Optional.<em class="ky">empty</em>();<br/>String backupValue = stringOptionalNull.orElseGet(() -&gt; "Hi!");<br/>System.<em class="ky">out</em>.println(backupValue); // prints "Hi!"</span></pre><p id="7959" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们在一系列操作后提供一个备份值，就可以利用orElseGet方法。</p><figure class="jk jl jm jn fd ij er es paragraph-image"><div class="er es li"><img src="../Images/64f8026c795ca3c368f9b81857775872.png" data-original-src="https://miro.medium.com/v2/resize:fit:192/format:webp/1*ZzbqXjQih9trFcSvU2cdzg.png"/></div><p class="lj lk et er es ll lm bd b be z dx translated">以下重要说明</p></figure><p id="fab9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在谈论另一个方法之前，我们将看到orElse和orElseGet方法之间的一个重要区别。当你给orElse方法提供一个函数时，不管这个值是否在Optional中，它总是运行给定的方法。对于orElseGet方法，如果该值存在于Optional中，它将不会运行给定的方法。让我们看一个例子。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="23ab" class="jt ju hi jp b fi jv jw l jx jy">public static void main(String[] args) {<br/>    Optional&lt;String&gt; stringOptional = Optional.<em class="ky">of</em>("I exist..");<br/>    String value = stringOptional.orElse(<em class="ky">getStr</em>());<br/>    String value2 = stringOptional.orElseGet(() -&gt; <em class="ky">getStr</em>());</span><span id="385a" class="jt ju hi jp b fi ln jw l jx jy">}</span><span id="b6da" class="jt ju hi jp b fi ln jw l jx jy">public static String getStr() {<br/>    System.<em class="ky">out</em>.println("I am being evaluated");<br/>    return "Hi!";<br/>}</span><span id="d7d8" class="jt ju hi jp b fi ln jw l jx jy">// Above program prints only one "I am being evaluated"</span></pre><p id="f89d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们首先创建了一个值为“我存在”的可选字符串。然后，我们通过将getStr()方法作为参数来应用orElse方法。正如我们之前说过的，即使价值存在，orElse也会评估赋予它的方法。所以，它会打印“我正在接受评估”。然后，我们有orElseGet方法和给定的lambda表达式。这一次，它不会运行给定的lambda，因为值是存在的。如果该值不存在，例如最初的Optional.empty()，它将打印两个“我正在被评估”。让我们继续我们将涉及的最后一个功能。</p><ul class=""><li id="e2df" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj">orelsthrow(供应商&lt;？扩展X &gt; exceptionSupplier) </strong>，在值不存在的情况下抛出提供的异常。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="99bb" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;String&gt; stringOptionalNull = Optional.<em class="ky">empty</em>();<br/>String backupValue = stringOptional.orElseThrow(RuntimeException::new);</span><span id="4c6f" class="jt ju hi jp b fi ln jw l jx jy">// Result<br/>// Exception in thread "main" java.lang.RuntimeException<br/> // at java.util.Optional.orElseThrow(Optional.java:290)<br/> // at optional.Demo.main(Demo.java:29)</span></pre><p id="53c6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以看到orElseThrow抛出了异常，因为Optional中的值不存在。</p><ul class=""><li id="820e" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj">地图(功能&lt;？超T，？扩展U &gt;映射器)</strong>，通过给定的映射函数映射可选内部的值。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="35b4" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;String&gt; stringOptional = Optional.<em class="ky">of</em>("Hi, there!");<br/>int length = stringOptional.map(String::length).orElse(0);</span></pre><p id="60c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的代码片段显示了最初的字符串可选到整数的映射。</p><ul class=""><li id="be72" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj">过滤器(谓词&lt;？超级T &gt;谓词)</strong>，用给定的谓词过滤可选对象内部的值。</li></ul><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="6cf6" class="jt ju hi jp b fi jv jw l jx jy">Optional&lt;String&gt; stringOptional = Optional.<em class="ky">of</em>("I love java");<br/>stringOptional.filter(str -&gt; str.endsWith("java")).ifPresent(System.<em class="ky">out</em>::println);</span></pre><p id="1161" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的代码块将运行ifPresent中的代码块，因为我们应用于可选对象的过滤器评估为true。</p><p id="9310" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，让我们看看可以用来获取可选对象内部值的最基本的方法。</p><ul class=""><li id="ad8d" class="kz la hi io b ip iq it iu ix lb jb lc jf ld jj le lf lg lh bi translated"><strong class="io hj"> get() </strong>，简单返回可选对象内部的值。</li></ul><p id="56c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们需要首先通过存在检查小心地使用get函数。如果可选对象内部不存在值，那么该方法将抛出<a class="ae jz" href="http://javarevisited.blogspot.sg/2012/02/how-to-solve-javautilnosuchelementexcep.html" rel="noopener ugc nofollow" target="_blank"><strong class="io hj">NoSuchElementException</strong></a>。所以，我们可以如下使用它，或者只使用ifPresent方法。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="15ac" class="jt ju hi jp b fi jv jw l jx jy">if (someConditional.isPresent()) {<br/>    Object value = someConditional.get();<br/>}</span></pre><h2 id="cc09" class="jt ju hi bd ka kb kc kd ke kf kg kh ki ix kj kk kl jb km kn ko jf kp kq kr ks bi translated">例子</h2><p id="46d0" class="pw-post-body-paragraph im in hi io b ip kt ir is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj hb bi translated">由于我们已经介绍了可选方法，我们可以看看<a class="ae jz" rel="noopener" href="/javarevisited/11-advanced-core-java-online-courses-to-join-in-2021-46011661257a">核心Java </a>和<a class="ae jz" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring应用</a>中的一些例子。</p><p id="2e1b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">想象一下，我们有一个作为缓存的类，我们可以获得带有String类型键的对象。在这种情况下，使用Optionals不是很有意义吗？因为我们可能没有与给定键相关联的对象。让我们看看它的实际效果</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="3848" class="jt ju hi jp b fi jv jw l jx jy">public enum  ObjectCache {<br/>    <em class="ky">INSTANCE</em>;<br/>    <br/>    private final Map&lt;String, Object&gt; objectMap = new HashMap&lt;&gt;();<br/>    <br/>    public Optional&lt;Object&gt; get(String key) {<br/>        return Optional.<em class="ky">ofNullable</em>(objectMap.get(key));<br/>    }<br/>    <br/>    public void add(String key, Object value) {<br/>        objectMap.put(key, value);<br/>    }<br/>    <br/>    public Optional&lt;Object&gt; delete(String key) {<br/>        return Optional.<em class="ky">ofNullable</em>(objectMap.remove(key));<br/>    }<br/>}</span></pre><p id="fc34" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在ObjectCache类中，我们有三个与objectMap交互的方法。当我们使用带有键的get方法时，它可能不总是有关联的对象，如果我们对返回的空对象进行操作，我们将面临<a class="ae jz" href="https://www.java67.com/2021/05/how-to-solve-nullpointerexception-in-java.html" rel="noopener ugc nofollow" target="_blank"> NullPointerException </a>。但是在上面的类中，我们返回了Optional，客户端可以通过我们之前讨论过的方法来使用它，以确保空安全。</p><p id="d526" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一个用例可以是Spring应用程序。在数据层，我们执行一些查询，它们从数据库<a class="ae jz" rel="noopener" href="/javarevisited/8-free-oracle-database-and-sql-courses-for-beginners-f4e9b25b33c4">返回值</a>。使用与上面相同的逻辑，它可能没有相应的值，所以它可能返回null值。在这种情况下，最好返回包装在选项中的值。让我们看看。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="e859" class="jt ju hi jp b fi jv jw l jx jy">@Repository<br/>public interface UserRepository extends JpaRepository&lt;User, String&gt; {<br/>    Optional&lt;User&gt; findByUsername(String username);<br/>    Optional&lt;User&gt; findByEmail(String email);<br/>}</span></pre><p id="7c17" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，我们有两种方法。例如，对于findByUsername方法，我们传递Username，它从数据库返回相关的用户。但是，这样的用户可能不存在。在这种情况下，我们最好将用户包装在Optional中返回，以便更好地处理空值。</p><p id="d49f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这篇文章中，我讨论了Java中可选的空处理。我希望你喜欢它。更多类似文章，你可以关注我。</p><p id="9e34" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jz" href="https://github.com/kurular4/medium-java/tree/master/optionals" rel="noopener ugc nofollow" target="_blank">https://github . com/kurural 4/medium-Java/tree/master/optionals</a></p></div></div>    
</body>
</html>