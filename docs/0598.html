<html>
<head>
<title>Java Tips &amp; Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java技巧和窍门</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-tips-tricks-4b188e70e170?source=collection_archive---------1-----------------------#2020-07-22">https://medium.com/javarevisited/java-tips-tricks-4b188e70e170?source=collection_archive---------1-----------------------#2020-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d5f8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在你进入这个大游戏之前知道这些</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2514d29b05aa9eb8646c9590837a47c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qjUqlxNeto5-45Dt"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@raduflorin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉杜·弗罗林</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a689" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Java…所以，所有阅读这篇文章的人都知道，它是世界上最流行的编程语言之一，被设计成可以在任何平台上不间断地运行。无论是Windows应用程序、Web应用程序、移动应用程序、网络应用程序、消费电子产品，Java无处不在。几十年来，Java见证了其编程效率的持续发展，并且没有显示出受欢迎程度下降的迹象，因此，对于任何希望作为开发人员拥有稳定未来的人来说，Java都是值得学习的。无论你是Java专家还是新手，熟悉好的编程实践都会节省大量时间。因此，让我们来看看一些java技巧和提示，以节省时间，优化和提高代码质量。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="ddb0" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated"><strong class="ak"> 1。</strong> <strong class="ak">字符串优化</strong></h2><p id="d6d3" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated"><em class="lr"> String </em>对象在Java中是不可变的，这意味着<em class="lr"> String </em>内容一旦创建就不可更改。<em class="lr">字符串</em>可以由:</p><ul class=""><li id="82ba" class="ls lt hi jq b jr js ju jv jx lu kb lv kf lw kj lx ly lz ma bi translated"><strong class="jq hj">将一个<em class="lr">字符串</em>直接赋值给一个<em class="lr">字符串</em>引用</strong></li><li id="77ae" class="ls lt hi jq b jr mb ju mc jx md kb me kf mf kj lx ly lz ma bi translated"><strong class="jq hj">由建造师</strong></li></ul><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="203a" class="kr ks hi mh b fi ml mm l mn mo">String str1 = "I am a string";<br/>String str2 = new String("I am a string via a constructor");</span></pre><p id="4243" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一种方法是创建<em class="lr">字符串</em>的更好方法。使用构造函数创建<em class="lr">字符串</em>会浪费大量内存空间，因为对象不共享存储空间，即使对于相同的内容也是如此，而第一个方法确实共享相同内容的存储空间。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/a9399e3bbe58940a758d3b3bbe6f6439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNOBtmLR_2P8teVuPHXhRA.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">字符串文字与字符串对象示例—图片来自<a class="ae jn" href="https://www.ntu.edu.sg/home/ehchua/programming/java/J3d_String.html" rel="noopener ugc nofollow" target="_blank"> NTU </a></p></figure><p id="27a8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">特别是，避免在循环中使用第二种方法，因为到现在为止，你都可以理解在每次迭代中会创建新的不必要的对象，浪费大量的存储空间。</p><blockquote class="mq mr ms"><p id="07bd" class="jo jp lr jq b jr js ij jt ju jv im jw mt jy jz ka mu kc kd ke mv kg kh ki kj hb bi translated">如果<em class="hi">字符串</em>的内容被频繁修改，请使用<em class="hi"> StringBuffer </em>或<em class="hi"> StringBuilder </em>类，因为这些类支持可变的<em class="hi">字符串</em>。</p></blockquote><h2 id="b653" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated"><strong class="ak"> 2。字符串串联</strong></h2><p id="5263" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">在这种情况下，您会看到<em class="lr">字符串连接，</em>我知道使用'+'运算符连接字符串是大多数人首先想到的事情。但是你知道吗，这并不是做这项工作的最佳和唯一的方法。对此有4种方法。</p><ul class=""><li id="ebd7" class="ls lt hi jq b jr js ju jv jx lu kb lv kf lw kj lx ly lz ma bi translated"><strong class="jq hj">使用'+'运算符</strong></li></ul><p id="b4ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是连接多个<em class="lr">字符串</em>的最简单的方法，但是会占用额外的内存并降低程序的性能。尤其是当你在一个循环中串联多个<em class="lr">字符串</em>的时候。但这并不意味着你应该避免这种方法。您仍然可以使用它在一条语句中连接<em class="lr">字符串</em>。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="64cf" class="kr ks hi mh b fi ml mm l mn mo">String name = "S"+"a"+"m";</span></pre><ul class=""><li id="acf5" class="ls lt hi jq b jr js ju jv jx lu kb lv kf lw kj lx ly lz ma bi translated"><strong class="jq hj">使用<em class="lr"> concat() </em>方法</strong></li></ul><p id="d829" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种方法很少使用。性能比使用“+”操作符要好，但仍然较慢。</p><ul class=""><li id="9077" class="ls lt hi jq b jr js ju jv jx lu kb lv kf lw kj lx ly lz ma bi translated"><strong class="jq hj">使用StringBuffer </strong></li></ul><p id="2f9f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种方法比上面两种快多了。StringBuffer 对于多线程操作是同步的，这意味着这个方法是线程安全的。由于同步方法，这比<em class="lr"> StringBuilder </em>慢。</p><ul class=""><li id="f284" class="ls lt hi jq b jr js ju jv jx lu kb lv kf lw kj lx ly lz ma bi translated"><strong class="jq hj">StringBuilder类的Append方法</strong></li></ul><p id="ef02" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这类似于<em class="lr"> StringBuffer </em>，除了<em class="lr"> StringBuilder </em>对于多线程操作是不同步的。如果使用for循环连接多个字符串，那么应该使用<em class="lr"> StringBuilder </em>。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="2a13" class="kr ks hi mh b fi ml mm l mn mo">String name = <br/>new StringBuilder().append("S").append("a").append("m").toString();</span></pre><p id="3fb3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，如果我为你总结一下，当从部件创建<em class="lr">字符串</em>时，使用<em class="lr"> StringBuilder </em>(单线程)或<em class="lr"> StringBuffer </em>(多线程)。对于使用For循环的<em class="lr">字符串串联</em>，使用<em class="lr"> StringBuilder </em>，对于单语句<em class="lr">字符串串联</em> <em class="lr">可以使用'+'运算符。</em></p><h2 id="ca04" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated"><strong class="ak"> 3。</strong> <strong class="ak">字符串中单引号和双引号的使用</strong></h2><p id="0c1e" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">简而言之，单引号用于字面c <em class="lr"> hars </em>，而双引号用于字面<em class="lr">字符串</em>。在下面的代码片段中，字母“M”和“Y”将是相应的输出。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="9b31" class="kr ks hi mh b fi ml mm l mn mo">System.out.println("M");<br/>System.out.println('Y');</span></pre><p id="cd26" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，你觉得下面的代码怎么样？</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="af49" class="kr ks hi mh b fi ml mm l mn mo">System.out.println("M" +"Y");<br/>System.out.println('M'+'Y');</span></pre><p id="d86d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如你所猜测的，第一个输出是我的，但是第二个输出不是我的，而是166。添加两个<em class="lr">字符</em>将返回一个<em class="lr"> int </em>。这里，两个<em class="lr">字符</em>的ASCII值将被相加，以返回一个<em class="lr"> int </em>。</p><p id="8909" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您想知道如何将<em class="lr">字符</em>连接成<em class="lr">字符串</em>，有几种方法可以做到。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="0448" class="kr ks hi mh b fi ml mm l mn mo">System.out.println('M'+""+'Y');<br/>System.out.println(""+'M'+'Y');</span></pre><p id="b04e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以上两种方法都会返回<em class="lr">字符串</em> MY。此外，还有更多的方法，比如上一节提到的<em class="lr"> StringBuffer </em>和<em class="lr"> StringBuilder </em>。</p><h2 id="5788" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated"><strong class="ak"> 4。</strong> <strong class="ak">浮点vs双精度</strong></h2><p id="de68" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">这两种数据类型都用来表示浮点数，并且众所周知，<em class="lr"> double </em>更精确。</p><p id="c8d5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">强烈建议使用<em class="lr">双</em>超过<em class="lr">浮动</em>，特别是如果你不能保证你的数字在<em class="lr">浮动</em>指定的范围内。</p><p id="542e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是注意<em class="lr">双</em>是有代价的；它很贵，因为它占用的内存空间是浮点型的两倍。</p><h2 id="67a3" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated"><strong class="ak"> 5。最好避免大小数和大整数</strong></h2><p id="8a9c" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">也可以用<em class="lr"> BigDecimal </em> <strong class="jq hj"> </strong>和<strong class="jq hj"/><em class="lr">big integer</em><strong class="jq hj"/>来表示，这是表示数字的确切方式。</p><p id="b727" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您正在处理不同精度的浮点数，或者如果您正在处理要求精度的货币，那么<em class="lr"> BigDecimal </em>可能是您的选择。但它需要更多的内存，编程算法有点困难，并且比使用双大大降低了所有计算的速度。</p><p id="6964" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以强烈建议避免使用<em class="lr"> BigDecimal </em>和<strong class="jq hj"> </strong> <em class="lr"> BigInteger </em>，只有在没有其他办法的情况下才使用它们。</p><h2 id="00d2" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated"><strong class="ak"> 6。尽可能使用原语</strong></h2><p id="b7ec" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">包装类对于将原始数据类型转换成对象有很大的帮助。然而，原语简单、更快，并且是避免开销的简单方法。因此，最好用<em class="lr"> int </em>代替<em class="lr"> Integer </em>或<em class="lr"> float </em>代替<em class="lr"> Float </em>。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="bbc2" class="kr ks hi mh b fi ml mm l mn mo">//using primitive data type<br/>int num = 5;</span><span id="9996" class="kr ks hi mh b fi mw mm l mn mo">//using wrapper class<br/>Integer wrapNum = 5;</span></pre><p id="896c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，由于<em class="lr">包装类</em>处理对象，比较它们不会像处理原语那样给出想要的结果。这样做的原因是，它最终将比较对象，而不是这些对象中的内容。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="003c" class="kr ks hi mh b fi ml mm l mn mo">int num1 = 5;<br/>int num2 = 5;</span><span id="2523" class="kr ks hi mh b fi mw mm l mn mo">Integer wrapNum1 = 3;<br/>Integer wrapNum2 = 3;</span><span id="f5e6" class="kr ks hi mh b fi mw mm l mn mo">System.out.println(num1 == num2);<br/>System.out.println(wrapNum1 == wrapNum2);</span></pre><p id="6be8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一次打印将是<em class="lr">真</em>，但是第二次打印将是<em class="lr">假</em>，因为在那里比较的是对象，而不是值。</p><h2 id="352a" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated"><strong class="ak"> 7。</strong> <strong class="ak">处理空指针异常</strong></h2><p id="fa38" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated"><em class="lr">空指针异常</em>是一个运行时异常，当应用程序试图使用带有空值的对象引用时抛出。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="93d9" class="kr ks hi mh b fi ml mm l mn mo">String fruit;<br/>spellChecker(fruit);</span></pre><p id="0c89" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，一个空引用变量作为一个方法的参数被传递。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="8120" class="kr ks hi mh b fi ml mm l mn mo">positionLocator(null);</span></pre><p id="924f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的代码片段中，null被直接传递给一个函数。在这两种情况下，很有可能抛出<em class="lr"> NullPointerException </em>。</p><p id="0ece" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个异常可以通过使用<em class="lr"> if-else条件</em>来修复。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="6314" class="kr ks hi mh b fi ml mm l mn mo">public class NullPointerExceptionExample{<br/>    public static void main(String args[]){<br/>        String fruit = "apple";<br/>        positionLocator(null);<br/>}</span><span id="17db" class="kr ks hi mh b fi mw mm l mn mo">//Using an if-else condition<br/>    static void positionLocator(String fruit){<br/>        if(fruit != null){<br/>           System.out.println("Second character: "+fruit.charAt(0));<br/>        }<br/>        else {<br/>           System.out.println("NullPointerException thrown");<br/>        }<br/>    }</span><span id="1add" class="kr ks hi mh b fi mw mm l mn mo">}</span></pre><h2 id="fe19" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated"><strong class="ak"> 8。使用分析器优化你的代码</strong></h2><p id="d163" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">编写代码并编译它以获得所需的输出是不够的。我们必须尽可能以最佳性能编写代码。为了实现这一点，最好有一种方法来检查代码背后发生了什么，比如，内存是如何分配的，需要改进的地方，以及使用一种编码方法对另一种编码方法的影响。为此，我们可以使用<em class="lr"> Java Profilers </em> <strong class="jq hj">。</strong></p><p id="c7c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lr"> Java Profiler </em>是一个在JVM级别监控Java字节码结构和操作的工具。使用这些分析器，我们可以找出程序中的性能、内存使用、内存泄漏等，然后我们可以很容易地找出代码中需要更改、优化或删除的内容。</p><p id="e20a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有许多可用的剖析器，如<em class="lr"> JProfiler、XRebel、</em>和<em class="lr"> New Relic </em>，但这些剖析器都有独特的特征，更适合性能调试的某个方面。因此，应该根据所需的分析级别来选择分析器，为了获得更好的结果，可以组合使用多个分析器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/f58f21bbca865c96825333a329c05bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilas3JtIfLS4ygV84DQVow.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">应用程序的内存分配—来自<a class="ae jn" href="https://stackoverflow.com/questions/27150682/jprofile-how-to-indentify-why-this-memory-in-application-keep-incresing-in-its" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>的图像</p></figure><p id="aa11" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可以在找到更多关于<em class="lr"> Java Profilers </em> <a class="ae jn" href="https://stackify.com/java-profilers-3-types/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h2 id="b576" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated"><strong class="ak"> 9。数组与数组列表</strong></h2><p id="7c5e" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">这两者的主要区别是<em class="lr">数组</em>是固定大小的，所以一旦你创建了<em class="lr">数组</em>你就不能改变它，但是<em class="lr">数组列表</em>不是固定大小的。您可以创建<em class="lr">数组列表</em>的实例，而无需指定其大小。因此，如果你创建一个<em class="lr"> ArrayList </em>的实例而没有指定它的大小，Java将创建一个默认大小的<em class="lr"> ArrayList </em>的实例。</p><p id="2c9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦一个<em class="lr">数组列表</em>满了，它会调整自己的大小。事实上，<em class="lr"> ArrayList </em>是由数组内部支持的。因此，当调整一个<em class="lr">数组列表</em>的大小时，它会稍微降低性能，因为旧的<em class="lr">数组</em>的内容必须被复制到新的<em class="lr">数组</em>中。</p><p id="7476" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同时，在创建一个<em class="lr">数组</em>时，必须直接或间接地指定它的大小。另外<em class="lr">数组</em>可以存储原语和对象，而<em class="lr">数组列表</em>只能存储对象。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="bf17" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望这篇文章对你有所帮助。希望尽快带来更多文章。感谢您的阅读。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="bacd" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">资源</h2><ul class=""><li id="bd09" class="ls lt hi jq b jr lm ju ln jx my kb mz kf na kj lx ly lz ma bi translated"><a class="ae jn" href="https://stackify.com/java-performance-tuning/" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Java性能调优自Stackify </em> </a></li><li id="1160" class="ls lt hi jq b jr mb ju mc jx md kb me kf mf kj lx ly lz ma bi translated"><a class="ae jn" href="https://www.javacodegeeks.com/2015/06/java-programming-tips-best-practices-beginners.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Java编程最佳实践和技巧来自JavaCodeGeeks </em> </a></li><li id="0c6a" class="ls lt hi jq b jr mb ju mc jx md kb me kf mf kj lx ly lz ma bi translated"><a class="ae jn" href="https://www.ntu.edu.sg/home/ehchua/programming/java/J3d_String.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Java字符串是从</em></a><em class="lr"/><a class="ae jn" href="https://www.ntu.edu.sg/home/ehchua/programming/java/J3d_String.html" rel="noopener ugc nofollow" target="_blank"><em class="lr">【NTU】</em></a></li><li id="36b4" class="ls lt hi jq b jr mb ju mc jx md kb me kf mf kj lx ly lz ma bi translated"><a class="ae jn" href="https://www.educative.io/edpresso/how-to-resolve-the-javalangnullpointerexception" rel="noopener ugc nofollow" target="_blank"> <em class="lr">如何解决edpresso的NullPointerException</em></a></li><li id="a917" class="ls lt hi jq b jr mb ju mc jx md kb me kf mf kj lx ly lz ma bi translated"><a class="ae jn" href="https://www.java67.com/2015/05/4-ways-to-concatenate-strings-in-java.html" rel="noopener ugc nofollow" target="_blank"><em class="lr">Java中串接字符串的4种方法来自Java67 </em> </a></li></ul></div></div>    
</body>
</html>