<html>
<head>
<title>Securing your rest API with SpringSecurity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SpringSecurity保护您的rest API</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/securing-your-rest-api-with-springsecurity-8ba440fe7b58?source=collection_archive---------0-----------------------#2021-03-08">https://medium.com/javarevisited/securing-your-rest-api-with-springsecurity-8ba440fe7b58?source=collection_archive---------0-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="22cd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">执行订单66 —春季安全教程</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/7811d504e106ff4f2ab9f5509fbdc156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*vVNRSi6bmrQOYsgW5UgOBA.jpeg"/></div></figure><h1 id="a371" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">我们将做什么</h1><p id="c989" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在前面的步骤中在<a class="ae kt" rel="noopener" href="/javarevisited/building-a-simple-rest-api-with-springboot-3f2e4b123ebb">中创建了我们的API之后，我们现在将使用Spring Security来保护它。<br/>为了做到这一点，我们需要向pom.xml文件添加2个依赖项</a></p><pre class="iy iz ja jb fd ku kv kw kx aw ky bi"><span id="0b50" class="kz jg hi kv b fi la lb l lc ld">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><h1 id="3a4e" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">它会是什么样子</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/02/spring-security-interview-questions-answers-java.html#axzz6lIcZ8tnd"><div class="er es le"><img src="../Images/2e879d774efae27918ba5aac64c0e808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nhII1S2DrVWCyljQouUNw.png"/></div></a></figure><h1 id="ea9c" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">执行66号命令</h1><h2 id="d0b3" class="kz jg hi bd jh lf lg lh jl li lj lk jp kg ll lm jr kk ln lo jt ko lp lq jv lr bi translated">账户实体</h2><p id="eedf" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">为了保护我们的API，我们将使用一些<a class="ae kt" href="https://javarevisited.blogspot.com/2013/07/role-based-access-control-using-spring-security-ldap-authorities-mapping-mvc.html" rel="noopener ugc nofollow" target="_blank">角色</a>，因此为了实现这一点，我们将创建一个使用这些角色的帐户实体。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="9ba1" class="kz jg hi bd jh lf lg lh jl li lj lk jp kg ll lm jr kk ln lo jt ko lp lq jv lr bi translated">仓库</h2><p id="344f" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">为了知道试图使用我们的API的用户是否存在，以及是否有关联的角色，我们还需要创建链接到Account实体的存储库。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="afd9" class="pw-post-body-paragraph jx jy hi jz b ka lu ij kc kd lv im kf kg lw ki kj kk lx km kn ko ly kq kr ks hb bi translated">当我们之前创建<code class="du lz ma mb kv b">CloneRepository </code>时，我们不需要在其中创建任何方法，因为我们使用的所有方法都已经通过<a class="ae kt" href="http://www.java67.com/2012/08/what-is-inheritance-in-java-oops-programming-example.html" rel="noopener ugc nofollow" target="_blank">继承</a>实现了。这里我们需要一个特定的方法，就像上面的<em class="mc">findonebysUsername</em>一样，通过这个方法，我们的存储库将知道我们只搜索一个与参数上传递的字符串username匹配的结果。(如果你想知道它是如何工作的，请参见<a class="ae kt" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods" rel="noopener ugc nofollow" target="_blank"> Spring Data JPA </a> doc)。</p><h2 id="aafd" class="kz jg hi bd jh lf lg lh jl li lj lk jp kg ll lm jr kk ln lo jt ko lp lq jv lr bi translated">控制器</h2><p id="d99e" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">既然我们已经创建了将具有连接到我们的API的角色的帐户，我们可以更新我们的控制器，使它在其方法上接受这些角色。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="923d" class="pw-post-body-paragraph jx jy hi jz b ka lu ij kc kd lv im kf kg lw ki kj kk lx km kn ko ly kq kr ks hb bi translated">如您所见，我们的方法现在有了<code class="du lz ma mb kv b">@PreAuthorize</code>注释，该注释指出了可以访问它的角色。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="7ff1" class="pw-post-body-paragraph jx jy hi jz b ka lu ij kc kd lv im kf kg lw ki kj kk lx km kn ko ly kq kr ks hb bi translated">那么，我的API现在安全了吗？回应是<strong class="jz hj">没有</strong>！<br/>我们已经创建了account实体及其存储库，我们已经升级了控制器以指示它将使用的角色，但是我们还没有实现安全配置。<br/>那么现在让我们来实现它。</p><h1 id="bec8" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">配置</h1><p id="3cd6" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">为了使上述所有代码正常运行，我们将实现安全性。为此，我们将在一个配置类中扩展<strong class="jz hj">WebSecurityConfigurerAdapter</strong>。</p><h2 id="3b7c" class="kz jg hi bd jh lf lg lh jl li lj lk jp kg ll lm jr kk ln lo jt ko lp lq jv lr bi translated">配置</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="bd13" class="pw-post-body-paragraph jx jy hi jz b ka lu ij kc kd lv im kf kg lw ki kj kk lx km kn ko ly kq kr ks hb bi translated">正如您在第一个配置方法中看到的，我们指出了可以访问端点的角色。<br/>在第二种方法中，我们描述了将用于认证用户的服务。</p><h2 id="5951" class="kz jg hi bd jh lf lg lh jl li lj lk jp kg ll lm jr kk ln lo jt ko lp lq jv lr bi translated">认证服务</h2><p id="7b7a" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">为了认证我们的用户，我们需要创建一个服务来实现来自<a class="ae kt" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-security-and-oauth2-with-spring-boot-for-java-developers-8f0222d6066d?source=---------5-----------------------"> Spring Security </a>包的<strong class="jz hj">userdailsservice</strong>，尤其是方法<em class="mc">loaduserbysusername</em>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="435b" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">测试我们的API</h1><p id="6fcf" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">为了测试我们的API，我们需要首先启动我们的应用程序。然后，我们可以尝试使用<a class="ae kt" rel="noopener" href="/javarevisited/7-best-courses-to-learn-postman-tool-for-web-service-and-api-testing-f225c138fa5a?source=---------13------------------"> postman </a>或任何其他允许您进行HTTP调用的工具来连接到我们在控制器中创建的入口点。</p><p id="4765" class="pw-post-body-paragraph jx jy hi jz b ka lu ij kc kd lv im kf kg lw ki kj kk lx km kn ko ly kq kr ks hb bi translated">这些示例将与我们创建API时的示例相同，但是使用了基本的身份验证。<br/>为了测试我的API，我创建了两个账户，它们将被预加载到数据库中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="6b9e" class="pw-post-body-paragraph jx jy hi jz b ka lu ij kc kd lv im kf kg lw ki kj kk lx km kn ko ly kq kr ks hb bi translated">所以现在，如果我试图用错误的凭证访问一个数据点，我将得到一个<a class="ae kt" href="https://developer.mozilla.org/fr/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> 401错误</a>。</p><pre class="iy iz ja jb fd ku kv kw kx aw ky bi"><span id="ac69" class="kz jg hi kv b fi la lb l lc ld">{<br/>  "timestamp": "2021-03-08T09:45:09.332+00:00",<br/>  "status": 401,<br/>  "error": "Unauthorized",<br/>  "message": "Unauthorized",<br/>  "path": "/kamino/order66"<br/>}</span></pre><p id="2a6d" class="pw-post-body-paragraph jx jy hi jz b ka lu ij kc kd lv im kf kg lw ki kj kk lx km kn ko ly kq kr ks hb bi translated">如果我在没有适当角色的情况下试图访问一个数据点，我将得到一个<a class="ae kt" href="https://developer.mozilla.org/fr/docs/Web/HTTP/Status/403" rel="noopener ugc nofollow" target="_blank"> 403错误</a>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mk"><img src="../Images/6e04b7f41f2dab047315f4550729c49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XoDajP-iUhuuSZyhF9cOFA.png"/></div></div></figure><p id="5035" class="pw-post-body-paragraph jx jy hi jz b ka lu ij kc kd lv im kf kg lw ki kj kk lx km kn ko ly kq kr ks hb bi translated">我在异常处理程序中截取了我的403错误，以获得比异常堆栈跟踪更具可读性的内容。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="12dc" class="pw-post-body-paragraph jx jy hi jz b ka lu ij kc kd lv im kf kg lw ki kj kk lx km kn ko ly kq kr ks hb bi translated">感谢您的阅读，和以前一样，本教程中使用的代码可以在<a class="ae kt" href="https://github.com/ErwanLT/HumanCloningFacilities" rel="noopener ugc nofollow" target="_blank">this Github repository</a>branch security中找到。</p></div></div>    
</body>
</html>