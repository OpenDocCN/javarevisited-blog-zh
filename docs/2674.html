<html>
<head>
<title>Process and Thread Context Switching, Do You Know the Difference?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进程和线程上下文切换，你知道区别吗？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/process-and-thread-context-switching-do-you-know-the-difference-updated-8fd93877dff6?source=collection_archive---------3-----------------------#2022-12-31">https://medium.com/javarevisited/process-and-thread-context-switching-do-you-know-the-difference-updated-8fd93877dff6?source=collection_archive---------3-----------------------#2022-12-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="a68b" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">Java多线程——进程和线程</h2><div class=""/><div class=""><h2 id="c5da" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">一篇关于进程和线程、它们的区别以及上下文切换的文章。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jg"><img src="../Images/c7fc844db2290f5828a8e780ea7a9a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*g9tvxtrvc8NOCYJ_dpcC4A.png"/></div><p class="jo jp et er es jq jr bd b be z dx translated"><strong class="bd js">进程和线程-作者图片</strong></p></figure><p id="4032" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">我见过程序员对进程和线程相关的概念有点困惑。还有许多人在与进程和线程上下文切换作斗争。所以在这篇文章中，我将讨论这两个概念。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="3b87" class="kw kx hi bd js ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">什么是过程？</h1><p id="2c1a" class="pw-post-body-paragraph jt ju hi jv b jw ln is jy jz lo iv kb kc lp ke kf kg lq ki kj kk lr km kn ko hb bi translated">程序是一组指令。它存储在计算机的磁盘上，因此它是<strong class="jv hs"> <em class="ls">无源</em> </strong>。当同一个程序被加载到主内存中，操作系统分配一些堆内存给这个正在执行的程序(应用程序)时，称为<strong class="jv hs">进程</strong>。因此，进程就是正在执行的程序。所以我们可以说是<strong class="jv hs">主动</strong>。</p><p id="e624" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">当一个进程从辅助存储器加载到主存储器，而另一个进程从主存储器卸载到辅助存储器时，称为进程的<strong class="jv hs">交换</strong>。</p><p id="128a" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">与过程相关的信息存储在一个叫做PCB(过程控制块)的东西里。通常，进程id、进程号、进程状态、程序计数器、寄存器和打开的文件都存储在PCB中。该PCB存放在受保护的存储区域，以避免正常用户访问，因为它包含重要信息。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><a href="http://www.java67.com/2012/12/what-is-difference-between-thread-vs-process-java.html"><div class="er es lt"><img src="../Images/eb351e6c850ba1610364640c86fc1ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*QNJEMjHpyff8oS0qc8t9uA.png"/></div></a><p class="jo jp et er es jq jr bd b be z dx translated"><strong class="bd js"> PCB —作者图片</strong></p></figure><p id="c30b" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">一个流程可以通过使用<strong class="jv hs"> <em class="ls"> fork </em> </strong>系统调用来创建子流程。有不同类型的调度程序为进程执行不同的操作。</p><p id="8b25" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">让我们看看调度程序的类型及其作用:</p><p id="6380" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated"><strong class="jv hs">短期调度程序(CPU调度程序):</strong>使用调度算法从主存储器(就绪队列)中选择一个进程在CPU中进行处理。</p><p id="f83e" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated"><strong class="jv hs">长期调度器(作业调度器):</strong>哪些进程应该放在主存(就绪队列)，哪些应该放在二级内存，都是由这个调度器来完成的。</p><p id="e407" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated"><strong class="jv hs">中期调度器:</strong>进程的交换由中期调度器完成。</p><p id="6438" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">一个进程可以有多个线程来执行不同的任务。每个进程都有自己的内存(称为堆),不在不同的进程之间共享。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="9fad" class="kw kx hi bd js ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">什么是线程？</h1><p id="1813" class="pw-post-body-paragraph jt ju hi jv b jw ln is jy jz lo iv kb kc lp ke kf kg lq ki kj kk lr km kn ko hb bi translated">线程是进程的一个片段或一部分，它执行进程的一些任务。一个进程可以有多个线程，这些线程可以在该进程中并发运行。每个线程都有自己的线程栈，但是一个进程的多个线程共享该进程的一个公共堆区。因此线程是轻量级的，比进程更快。</p><blockquote class="lu"><p id="1006" class="lv lw hi bd lx ly lz ma mb mc md ko dx translated">局部变量存储在线程堆栈中，它们不会在多个线程之间共享。</p><p id="8853" class="lv lw hi bd lx ly lz ma mb mc md ko dx translated">对象的字段存储在堆上，因此它们在多个线程之间共享。</p></blockquote></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="5db5" class="kw kx hi bd js ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">进程和线程的实际例子是什么？</h1><p id="bd60" class="pw-post-body-paragraph jt ju hi jv b jw ln is jy jz lo iv kb kc lp ke kf kg lq ki kj kk lr km kn ko hb bi translated">正在执行的java应用程序就是一个<strong class="jv hs">进程</strong>的例子。该应用程序在执行时被分配了一些堆内存。该应用有一个名为<code class="du me mf mg mh b"><strong class="jv hs">main</strong></code> <strong class="jv hs"> </strong>的<strong class="jv hs">线程</strong> <em class="ls"> </em>，负责执行我们的代码。</p><p id="33b3" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">类似地，我们可以在同一个应用程序中创建多个线程来执行不同的任务。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="866a" class="kw kx hi bd js ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">进程和线程有什么区别？</h1><ul class=""><li id="de27" class="mi mj hi jv b jw ln jz lo kc mk kg ml kk mm ko mn mo mp mq bi translated">进程是正在执行的程序，而线程是进程的一部分。</li><li id="eca9" class="mi mj hi jv b jw mr jz ms kc mt kg mu kk mv ko mn mo mp mq bi translated">该进程比线程花费更多的时间来创建和终止。</li><li id="06a1" class="mi mj hi jv b jw mr jz ms kc mt kg mu kk mv ko mn mo mp mq bi translated">该进程比线程消耗更多的资源(内存、IO等)。</li><li id="ee8e" class="mi mj hi jv b jw mr jz ms kc mt kg mu kk mv ko mn mo mp mq bi translated">进程不共享内存(堆),而线程共享公共堆内存。</li><li id="5c8d" class="mi mj hi jv b jw mr jz ms kc mt kg mu kk mv ko mn mo mp mq bi translated">进程上下文切换需要更多的时间，并且由操作系统完成，而线程上下文切换需要更少的时间，并且不需要操作系统调用。</li></ul></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="cb53" class="kw kx hi bd js ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">进程和线程上下文切换有什么区别？</h1><ul class=""><li id="0dfb" class="mi mj hi jv b jw ln jz lo kc mk kg ml kk mm ko mn mo mp mq bi translated">当<strong class="jv hs"> <em class="ls">操作系统的调度器</em> </strong>保存运行程序(当前进程)的当前状态(包括PCB的状态)并切换到另一个进程时，进程上下文切换发生；而当<strong class="jv hs"> <em class="ls"> CPU </em> </strong>保存线程的当前状态并切换到同一进程的另一个线程时，线程上下文切换发生。</li><li id="1854" class="mi mj hi jv b jw mr jz ms kc mt kg mu kk mv ko mn mo mp mq bi translated">当PCS发生时，处理器的高速缓存和转换后援缓冲区被刷新，但是TCS处理器的高速缓存和转换后援缓冲区保持它们的状态。</li><li id="d961" class="mi mj hi jv b jw mr jz ms kc mt kg mu kk mv ko mn mo mp mq bi translated">PCS涉及改变<strong class="jv hs"> <em class="ls">过程控制块</em> </strong>的巨大成本，因此效率较低且速度较慢，而在TCS的情况下，不需要交换PCB，因此效率较高且速度较快。</li></ul></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="0d66" class="kw kx hi bd js ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">线程和CPU内核之间的关系是什么？</h1><p id="7923" class="pw-post-body-paragraph jt ju hi jv b jw ln is jy jz lo iv kb kc lp ke kf kg lq ki kj kk lr km kn ko hb bi translated"><strong class="jv hs"><em class="ls">CPU核心是计算机中央处理器(CPU)中能够独立执行指令的物理处理单元。另一方面，线程是进程中的一个执行单元，它代表一系列可以由CPU独立执行的指令。</em>T24】</strong></p><p id="89b8" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">一般来说，一个CPU上可以同时执行的线程数量受到CPU中可用内核数量的限制。每个内核一次可以执行一个线程，因此拥有多个内核可以并行执行多个线程，从而有可能提高性能。</p><p id="8efc" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">然而，线程和CPU内核之间的关系比一对一的映射更复杂。</p><p id="a6a9" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">在现代计算机系统中，操作系统可以在不同的内核上动态调度线程，并且单个内核可以在多个线程之间切换，以便最大化地利用可用资源和CPU内核。</p><p id="6046" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">此外，一些系统还可能使用超线程等技术，将单个物理内核视为多个虚拟内核，从而有可能同时执行更多线程。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="72fd" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated"><em class="ls">本文到此为止。希望你喜欢。</em></p><h1 id="1688" class="kw kx hi bd js ky mw la lb lc mx le lf ix my iy lh ja mz jb lj jd na je ll lm bi translated">您可以关注<a class="nb nc ge" href="https://medium.com/u/2c3b611409dc?source=post_page-----8fd93877dff6--------------------------------" rel="noopener" target="_blank">维克拉姆·古普塔</a>了解类似内容。</h1><div class="nd ne ez fb nf ng"><a rel="noopener follow" target="_blank" href="/javarevisited/a-complete-guide-on-executorservice-in-java-67528f1a535b"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hs fi z dy nl ea eb nm ed ef hr bi translated">Java ExecutorService完全指南</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">Executor、ExecutorService和ThreadPoolExecutor是执行器的工厂方法。和理解未来物体…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu jm ng"/></div></div></a></div><div class="nd ne ez fb nf ng"><a rel="noopener follow" target="_blank" href="/javarevisited/how-to-create-java-thread-using-thread-and-runnable-2023-14e965474a7"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hs fi z dy nl ea eb nm ed ef hr bi translated">如何使用Thread和Runnable创建Java线程？</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">了解创建线程的方法以及如何启动它们。</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">medium.com</p></div></div><div class="np l"><div class="nv l nr ns nt np nu jm ng"/></div></div></a></div><div class="nd ne ez fb nf ng"><a rel="noopener follow" target="_blank" href="/@basecs101/synchronization-in-java-all-you-need-to-know-latest-6f86185ddf3"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hs fi z dy nl ea eb nm ed ef hr bi translated">Java中的同步:您需要知道的一切</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">如何在java编程中使用同步多线程:完全指南</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">medium.com</p></div></div><div class="np l"><div class="nw l nr ns nt np nu jm ng"/></div></div></a></div></div></div>    
</body>
</html>