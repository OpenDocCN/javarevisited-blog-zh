<html>
<head>
<title>Think twice whether you need Hibernate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">三思是否需要休眠</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/think-twice-whether-you-need-hibernate-8b2a8fb0cdc2?source=collection_archive---------0-----------------------#2021-07-27">https://medium.com/javarevisited/think-twice-whether-you-need-hibernate-8b2a8fb0cdc2?source=collection_archive---------0-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b406039021832860766758f231412057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LAxjS2U-hoXPO6Ty"/></div></div><p class="iq ir et er es is it bd b be z dx translated">托拜厄斯·菲舍尔在Unsplash<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="c0b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我经常看到人们如何将冬眠纳入一个项目，而不是真正考虑他们是否真的需要它。过了一段时间，当服务越来越多的时候，他们开始怀疑这是不是一个错误。</p><p id="504e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们试着提前考虑hibernate的利弊，这样下次我们就可以决定是否需要在新的微服务中添加这种依赖性。也许简单的<a class="ae iu" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25"> Spring JDBC </a>是有意义的，没有所有JPA的复杂性？</p><h1 id="fe83" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">一堆不明显的东西</h1><p id="49d9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Hibernate可能看起来像是大量的注释，可以神奇地从数据库中选择所有内容并保存。我们只需要正确地添加<strong class="ix hj"> <em class="kw"> @ManyToMany </em> </strong>、<strong class="ix hj"> <em class="kw"> @OneToMany </em> </strong>等注释即可。</p><p id="abc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你深入挖掘，许多程序员在工作面试中不能准确地说出他们的应用程序是如何工作的。例如，在下面的代码中，我们没有在任何地方显式调用<code class="du kx ky kz la b">save()</code>方法，但是更改将保存在数据库中。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><p class="iq ir et er es is it bd b be z dx translated">该实体将在数据库中更新</p></figure><p id="f518" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对我来说，这种代码让阅读变得非常困难。代码审查人员将花费大量时间来弄清楚发生了什么。下一次你不得不修复一个bug的时候，这将会花费很多时间。</p><h1 id="379f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">懒惰抓取问题</h1><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="3302" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个常见的情况是在事务中使用延迟获取。向实体添加一个惰性字段并在事务中引用它来获取数据似乎很有诱惑力。<br/>然后再加一个字段，再加一个。除了几个对象的1-2个字段，我们很可能不需要所有的数据。但结果是，应用程序向数据库发送了5-10个请求，完全拉出了对象。相反，可以只写一个select请求必要的数据。</p><p id="a5ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果对字段的访问发生在服务(和事务)之外，仍然有这样荒谬的结构向代码审查者问好:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><p class="iq ir et er es is it bd b be z dx translated">荒谬的构造获取一个懒惰的对象</p></figure><p id="dfb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">似乎可以使用<strong class="ix hj"><em class="kw"/></strong>抓取或<strong class="ix hj"> <em class="kw"> @EntityGraph </em> </strong>。但是<strong class="ix hj"> <em class="kw">急切</em> </strong>影响其他代码，<strong class="ix hj"> <em class="kw"> @EntityGraph </em> </strong>需要单独请求(如果我们已经在写了，还需要hibernate吗？).</p><h1 id="b681" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">N+1选择问题</h1><p id="bfde" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">用hibernate编写批量插入的代码不是一件容易的事情。不要忘记:</p><ol class=""><li id="f6d0" class="lh li hi ix b iy iz jc jd jg lj jk lk jo ll js lm ln lo lp bi translated">添加一个属性到<strong class="ix hj"><em class="kw">application . yml</em></strong><code class="du kx ky kz la b">spring.jpa.properties.hibername.jdbc.batch_size: 50</code></li><li id="2f57" class="lh li hi ix b iy lq jc lr jg ls jk lt jo lu js lm ln lo lp bi translated">创建一个按批次大小递增的序列<br/> <code class="du kx ky kz la b">CREATE SEQUENCE account_id_seq START 1 INCREMENT BY 50;</code></li><li id="e4f0" class="lh li hi ix b iy lq jc lr jg ls jk lt jo lu js lm ln lo lp bi translated">设置序列发生器以同时使用多个序列值。否则，<a class="ae iu" rel="noopener" href="/javarevisited/top-5-hibernate-online-training-courses-for-beginners-and-advance-java-programmers-469460596b2b">休眠</a>将参考序列N次。</li></ol><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="1d42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">人们经常忘记序列生成器，这完全否定了批量插入的整个优化。</p><p id="416c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一切配置良好，Hibernate 真正方便的是级联批量插入。由于hibernate首先请求id，这允许为相关实体的级联保存设置外键。通过遵循相同的场景，您可以在没有Hibernate的情况下做到这一点。</p><p id="fec0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要忘记使用<strong class="ix hj"> <em class="kw"> @BatchSize </em> </strong>来批量选择与<strong class="ix hj"> <em class="kw"> @ManyToMany </em> </strong>或<strong class="ix hj"> <em class="kw"> @OneToMany </em> </strong>注释关联的实体。否则，将执行N+1个请求。</p><p id="053e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您仍然决定使用<a class="ae iu" rel="noopener" href="/javarevisited/top-5-books-to-learn-hibernate-for-java-developers-b2cb4b16ccd6"> Hibernate </a>，我建议在您的测试中使用<a class="ae iu" href="https://github.com/quick-perf/quickperf" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> QuickPerf </strong> </a>库来确定到底有多少对数据库的请求被执行。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><p class="iq ir et er es is it bd b be z dx translated">使用QuickPerf检查选择次数</p></figure><h1 id="ec4a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">二级缓存</h1><p id="9a8c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">最后，值得一提的是Hibernate中的二级缓存。如果使用标准的Ehcache实现，那么当应用程序伸缩时，不同的实例将在缓存中存储不同的数据。</p><p id="557a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，服务的响应可能取决于请求到达的实例。</p><p id="57b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了避免这种情况，最好现在就开始使用Spring Cache。然后，在扩展时，连接一个分布式实现(Redis、Hazelcast、Apache Ignite等)就足够了。).</p><p id="21c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还要提醒你，在使用Hibernate 的<a class="ae iu" href="https://javarevisited.blogspot.com/2017/03/difference-between-first-and-second-level-cache-in-Hibernate.html" rel="noopener ugc nofollow" target="_blank"> L2缓存时，每个请求仍然会获得一个到数据库的连接。</a></p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div><p class="iq ir et er es is it bd b be z dx translated">甚至为缓存的实体获取JDBC连接</p></figure><h1 id="72a2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="9d41" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我不是想说你千万不要用<a class="ae iu" href="https://www.java67.com/2016/02/top-20-hibernate-interview-questions.html" rel="noopener ugc nofollow" target="_blank"> Hibernate </a>。在某些情况下，它会很有用。但我想说，你应该在一个项目的早期就一直思考这个问题，以免将来后悔。</p></div></div>    
</body>
</html>