<html>
<head>
<title>Spring MVC Part 1: The Big Picture [Updated]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring MVC第1部分:大图[更新]</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-mvc-part-1-build-your-first-hello-world-web-application-2c6e1ad54e5e?source=collection_archive---------1-----------------------#2022-12-11">https://medium.com/javarevisited/spring-mvc-part-1-build-your-first-hello-world-web-application-2c6e1ad54e5e?source=collection_archive---------1-----------------------#2022-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5f2a74943c78bd3d53747165bc4337e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BqsbjlXpX1kQoycz"/></div></div></figure><h2 id="f46b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">在本文中，我们将讨论以下主题:</h2><ul class=""><li id="a9d5" class="jo jp hi jq b jr js jt ju jb jv jf jw jj jx jy jz ka kb kc bi translated">Spring MVC架构简介</li><li id="f8b1" class="jo jp hi jq b jr kd jt ke jb kf jf kg jj kh jy jz ka kb kc bi translated">如何配置您的开发环境来使用<a class="ae ki" rel="noopener" href="/javarevisited/my-favorite-spring-mvc-courses-for-java-developers-5ede7f85dd88"> Spring MVC </a></li></ul><p id="2fdc" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">我们将从概述<a class="ae ki" href="https://javarevisited.blogspot.com/2017/06/how-spring-mvc-framework-works-web-flow.html" rel="noopener ugc nofollow" target="_blank"> Spring MVC架构</a>开始，包括它的主要特性和好处。然后，我们将讨论如何设置您的开发环境，包括您使用<a class="ae ki" href="https://www.java67.com/2017/11/top-5-free-core-spring-mvc-courses-learn-online.html" rel="noopener ugc nofollow" target="_blank"> Spring MVC </a>所需的工具和依赖项。到本文结束时，您将对Spring MVC以及如何在自己的web开发项目中使用它有更好的理解。</p><h2 id="ba8f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">[1]Spring MVC架构介绍</h2><ol class=""><li id="d065" class="jo jp hi jq b jr js jt ju jb jv jf jw jj jx jy la ka kb kc bi translated">介绍</li></ol><p id="991d" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">Spring MVC遵循MVC设计模式，将应用程序分成三个主要组件:模型、视图和控制器。</p><p id="8790" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">模型是保存将在视图中显示的数据的对象。该模型通常用于存储来自数据库、服务或其他数据源的数据。然后将模型传递给视图，视图使用模型中的数据生成发送给客户端的<a class="ae ki" href="http://javarevisited.blogspot.sg/2014/09/how-to-parse-html-file-in-java-jsoup-example.html" rel="noopener ugc nofollow" target="_blank"> HTML </a>、<a class="ae ki" href="https://javarevisited.blogspot.com/2022/03/3-examples-to-parse-json-in-java-using.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>或其他输出。</p><p id="8581" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">视图负责呈现应用程序的用户界面。它将模型中的数据呈现给用户，并为用户提供了一种与应用程序交互的方式。该视图可以使用不同的技术来实现，比如JSP、Thymeleaf。</p><p id="fb31" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">控制器是架构的核心组件。它负责处理来自客户端的传入请求，并返回适当的响应。控制器包含方法，这些方法通常是简单的方法，在响应返回视图名称的传入请求时执行。在Spring MVC中，控制器方法被映射到特定的URL和HTTP方法，这样当从客户端收到请求时，就会调用适当的控制器方法来处理请求。然后，控制器方法返回的视图名称用于向客户端呈现响应。</p><p id="1804" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">2.工作流(从接收请求到生成响应)。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/e9af3edba7048bb19c6317dd81db254b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHl4BFGP9gu7pGOL8skoYg.png"/></div></div><p class="lg lh et er es li lj bd b be z dx translated">spring mvc基本工作流</p></figure><p id="e8de" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">3.说明</p><ul class=""><li id="c279" class="jo jp hi jq b jr kl jt ko jb lk jf ll jj lm jy jz ka kb kc bi translated">当客户机向服务器端发送HTTP请求时，web容器(如Tomcat)接收请求并处理它。</li></ul><p id="392a" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">什么是web容器？</p><p id="972f" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">web容器维护servlets的生命周期。如果您不是来自JEE世界，Servlet只是一个可以处理HTTP请求的简单类。我们的DispatcherServlet仍然是一个简单的Servlet，我们将使用一个web容器来维护它的生命周期。</p><ul class=""><li id="79b5" class="jo jp hi jq b jr kl jt ko jb lk jf ll jj lm jy jz ka kb kc bi translated">web容器(如Tomcat)将http请求传递给DispatcherServlet进行进一步处理。</li></ul><p id="ccab" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">什么是DispatcherServlet？</p><p id="2059" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">DispatcherServlet是Spring MVC架构的一个关键组件，这是一个用Java构建web应用程序的模型-视图-控制器(MVC)框架。DispatcherServlet扮演前端控制器的角色，前端控制器是一种设计模式，它定义了一种集中式请求处理机制来处理所有传入的请求，并将它们分派给适当的处理程序组件。</p><p id="06d9" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">当HTTP请求被发送到Spring MVC应用程序时，DispatcherServlet接收请求并检查请求URL、HTTP方法和其他请求参数。然后，它使用配置的处理程序映射将请求映射到适当的处理程序方法，这通常是一个处理请求并生成响应的控制器方法。DispatcherServlet还使用已配置的视图解析器将处理程序方法返回的视图名称解析为具体的视图组件，如JSP页面或百里香模板，以呈现响应。</p><p id="3e71" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">/!\我们将在本文接下来的部分详细介绍每一个步骤</p><h2 id="3f6d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">[2]配置开发环境</h2><p id="989e" class="pw-post-body-paragraph kj kk hi jq b jr js km kn jt ju kp kq jb ln ks kt jf lo kv kw jj lp ky kz jy hb bi translated">作为一个IDE，我使用IntelliJ Ultimate版本(你可以使用你喜欢的IDE)和Tomcat作为web容器。</p><p id="0be2" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">在这一部分，我们将不使用Spring Boot，因为它为我们做了大量的内部配置。</p><ul class=""><li id="3c11" class="jo jp hi jq b jr kl jt ko jb lk jf ll jj lm jy jz ka kb kc bi translated">步骤1:创建一个maven项目(选择webapp原型来生成一个简单的maven web应用程序项目)</li></ul><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/c269a706bcbac46554ccc44c57b12a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhh-Cd-wiggICS0Yc0BGiA.png"/></div></div><p class="lg lh et er es li lj bd b be z dx translated">项目创建</p></figure><ul class=""><li id="0cb6" class="jo jp hi jq b jr kl jt ko jb lk jf ll jj lm jy jz ka kb kc bi translated">第2步:进入maven repository并搜索Spring Web MVC，将依赖项添加到pom.xml文件中</li></ul><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="7503" class="lw ir hi ls b be lx ly l lz ma">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;LOad Maen changes<br/>  &lt;version&gt;5.3.23&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><ul class=""><li id="7bb7" class="jo jp hi jq b jr kl jt ko jb lk jf ll jj lm jy jz ka kb kc bi translated">第三步:设置你的服务器(例如:Tomcat)。</li></ul><p id="c7d9" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">要设置您的服务器配置，请检查此链接:</p><div class="mb mc ez fb md me"><a href="https://www.jetbrains.com/idea/guide/tutorials/working-with-apache-tomcat/using-existing-application/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hj fi z dy mj ea eb mk ed ef hh bi translated">在现有应用程序中使用Apache Tomcat</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">如果您不是从头开始创建一个新项目，而是有一个运行在Tomcat上的现有项目，您可以…</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">www.jetbrains.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms io me"/></div></div></a></div><ul class=""><li id="78e9" class="jo jp hi jq b jr kl jt ko jb lk jf ll jj lm jy jz ka kb kc bi translated">步骤4: DispatcherServlet配置</li></ul><p id="8ccf" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">有许多方法可以配置我们的DispatcherServlet，但是不要担心，我们将介绍所有的方法。</p><p id="fc94" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">1- XML方法</p><p id="d1aa" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">DispatcherServlet在基于Spring MVC的应用程序中充当前端控制器，它将接受任何到达我们应用程序的请求，然后它将决定(使用内部处理程序映射)要执行的正确端点。所以在您的web.xml( <code class="du mt mu mv ls b">WEB-INF </code>文件夹)文件中添加这个配置。</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="b665" class="lw ir hi ls b be lx ly l lz ma">&lt;!DOCTYPE web-app PUBLIC<br/> "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"<br/> "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;<br/><br/>&lt;web-app&gt;<br/>  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;<br/>  <br/>  <br/>  &lt;servlet&gt;<br/>    &lt;servlet-name&gt;frontcontroller-dispatcher&lt;/servlet-name&gt;<br/>    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet<br/>    &lt;/servlet-class&gt;<br/>  &lt;/servlet&gt;<br/>  <br/>  &lt;servlet-mapping&gt;<br/>    &lt;servlet-name&gt;frontcontroller-dispatcher&lt;/servlet-name&gt;<br/>    &lt;url-pattern&gt;/&lt;/url-pattern&gt;<br/>  &lt;/servlet-mapping&gt;<br/>  <br/>&lt;/web-app&gt;</span></pre><p id="8c91" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">当我们将应用程序部署到我们的服务器(例如:Tomcat)时，web容器将读取web.xml文件来实例化DispatcherServlet类并配置它的映射。(Servlet生命周期将由web容器处理)</p><p id="59ac" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">注意:当一个web应用程序被部署到Tomcat时，Tomcat会读取web部署描述符一次，以获取应用程序的配置和设置。之后，Tomcat将配置和设置存储在内存中，以便它可以针对每个传入的请求快速有效地访问它们。</p><p id="2dff" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">如果我们现在运行我们的应用程序，我们将会遇到异常</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="e8ee" class="lw ir hi ls b be lx ly l lz ma">Caused by: java.io.FileNotFoundException: Could not open ServletContext resource [/WEB-INF/frontcontroller-dispatcher-servlet.xml]</span></pre><p id="9c22" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">为什么？</p><p id="b21b" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">DispatcherServlet使用各种对象来完成工作，比如处理程序映射、视图解析器和控制器。默认情况下，DispatcherServlet会查找名为we b-INF/[您的dispatcher-servlet在web.xml中的名称]-servlet.xml的文件。</p><p id="c83c" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">在WEB-INF文件夹中创建一个名为[您的dispatcher-servlet name in WEB . XML]-servlet . XML的文件。</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="11aa" class="lw ir hi ls b be lx ly l lz ma">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;beans <br/> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br/> xmlns:context="http://www.springframework.org/schema/context"<br/> xmlns:mvc="http://www.springframework.org/schema/mvc"<br/> xsi:schemaLocation="http://www.springframework.org/schema/beans<br/>    http://www.springframework.org/schema/beans/spring-beans.xsd<br/>    http://www.springframework.org/schema/context<br/>    http://www.springframework.org/schema/context/spring-context.xsd<br/>    http://www.springframework.org/schema/mvc<br/>    http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;<br/><br/>    &lt;!-- component scanning --&gt;<br/>    &lt;context:component-scan base-package="com.medium" /&gt;<br/><br/>    &lt;!-- Define Spring MVC view resolver --&gt;<br/>    &lt;bean        class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;<br/>        &lt;property name="prefix" value="/WEB-INF/views/" /&gt;<br/>        &lt;property name="suffix" value=".jsp" /&gt;<br/>    &lt;/bean&gt;<br/>&lt;/beans&gt;</span></pre><p id="a4fb" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">DispatcherServlet创建一个WebApplicationContext，这是一个IOC容器(WebApplicationContex textends application context，用于独立的应用程序)。WebApplicationContext处理应用程序中的所有beans。我们刚刚创建的文件是WebApplicationContext的配置文件。当我们启用组件扫描时，WebApplicationContext自动为每个用<code class="du mt mu mv ls b">@Component</code>或其子注释之一注释的类创建一个bean，例如<code class="du mt mu mv ls b">@Repository</code>、<code class="du mt mu mv ls b">@Controller</code>、<code class="du mt mu mv ls b">@RestController</code>和<code class="du mt mu mv ls b">@Service </code> …</p><p id="be70" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">如您所见，我们在XML文件中显式配置了一个名为InternalResourceViewResolver的bean。这是Spring中视图解析器模式的实现之一。</p><p id="64ac" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">什么是视图解析模式？</p><p id="a55f" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">视图解析器模式是web应用程序开发中使用的一种设计模式，用于将控制器返回的逻辑视图名称解析为应该呈现给客户端的物理视图(例如:JSP或HTML文件)。</p><p id="4f17" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">现在创建一个控制器来测试dispatcherServlet配置</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="c059" class="lw ir hi ls b be lx ly l lz ma">@Controller<br/>public class MediumController {<br/><br/>    @GetMapping("/")<br/>    public String meth1(){<br/>        return "hello";<br/>    }<br/>}</span></pre><p id="4739" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">要在Spring MVC中创建新的JSP页面，您可以遵循以下步骤:</p><ol class=""><li id="5e47" class="jo jp hi jq b jr kl jt ko jb lk jf ll jj lm jy la ka kb kc bi translated">在web应用程序的<code class="du mt mu mv ls b">WEB-INF</code>目录中，创建一个名为<code class="du mt mu mv ls b">views</code>的新目录。</li><li id="51b7" class="jo jp hi jq b jr kd jt ke jb kf jf kg jj kh jy la ka kb kc bi translated">在<code class="du mt mu mv ls b">views</code>目录中，创建一个名为<code class="du mt mu mv ls b">hello.jsp</code>的新JSP文件。</li><li id="c7fd" class="jo jp hi jq b jr kd jt ke jb kf jf kg jj kh jy la ka kb kc bi translated">在<code class="du mt mu mv ls b">hello.jsp</code>文件中，添加页面的HTML代码。</li><li id="726f" class="jo jp hi jq b jr kd jt ke jb kf jf kg jj kh jy la ka kb kc bi translated">如果您想为您的JSP文件使用不同的文件扩展名(例如<code class="du mt mu mv ls b">.html</code>，您可以转到<code class="du mt mu mv ls b">dispatcher-servlet</code>配置文件(位于<code class="du mt mu mv ls b">WEB-INF/[dispatcher-servlet name in web.xml]-servlet.xml</code>)并更改<code class="du mt mu mv ls b">viewResolver</code> bean的后缀。例如，如果您想使用<code class="du mt mu mv ls b">.html</code>作为文件扩展名，您可以将后缀从<code class="du mt mu mv ls b">.jsp</code>改为<code class="du mt mu mv ls b">.html</code>。</li><li id="acda" class="jo jp hi jq b jr kd jt ke jb kf jf kg jj kh jy la ka kb kc bi translated">如果希望将JSP文件存储在不同的位置，可以在<code class="du mt mu mv ls b">dispatcher-servlet</code>配置文件中更改<code class="du mt mu mv ls b">viewResolver</code> bean的前缀。这将告诉Spring MVC在哪里寻找您的JSP文件。</li></ol><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/71012135119942a43224f77e69aa5562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOrugKkwDEh3UHhEPhkd8Q.png"/></div></div><p class="lg lh et er es li lj bd b be z dx translated">带有xml配置的项目结构</p></figure><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/22faf812619a986cd2133b55d7894e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MO-8UaUoapjf_HXco5FmDA.png"/></div></div><p class="lg lh et er es li lj bd b be z dx translated">jsp页面运行成功</p></figure><p id="6496" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">干得好！您已经成功完成了hello world项目。</p><p id="a581" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">2.带有WebApplicationInitializer接口的Java配置</p><p id="e41f" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">删除Spring MVC应用程序中的<code class="du mt mu mv ls b">web.xml</code>文件。</p><p id="4dc1" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">值得注意的是，如果没有<code class="du mt mu mv ls b">web.xml</code>文件或上下文配置文件，您的web应用程序将没有<code class="du mt mu mv ls b">DispatcherServlet</code>来处理传入的请求。这意味着您将无法响应来自客户端的请求，并且您的web应用程序将无法正常运行。要解决这个问题，您需要创建一个实现<code class="du mt mu mv ls b">WebApplicationInitializer</code>接口的类，并使用它为您的web应用程序配置和初始化<code class="du mt mu mv ls b">DispatcherServlet</code>。</p><p id="a625" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">如果Tomcat没有找到web.xml，它会在部署web应用程序时自动寻找实现<code class="du mt mu mv ls b">WebApplicationInitializer</code>接口的类。如果找到这样的类，它将使用它来配置和初始化web应用程序，而不是使用web.xml文件。</p><p id="943b" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">例如:</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="848a" class="lw ir hi ls b be lx ly l lz ma">public class MyWebApplicationInitializer implements WebApplicationInitializer {<br/>  public void onStartup(ServletContext servletContext) {<br/>    // Load the XML configuration file<br/>    XmlWebApplicationContext appContext = new XmlWebApplicationContext();<br/>    appContext.setConfigLocation("/WEB-INF/my-config.xml");<br/><br/>    // Create and register the DispatcherServlet<br/>    ServletRegistration.Dynamic dispatcher = servletContext.addServlet("dispatcher", new DispatcherServlet(appContext));<br/>    dispatcher.setLoadOnStartup(1);<br/>    dispatcher.addMapping("/");<br/>  }<br/>}</span></pre><p id="5049" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">3.具有AbstractAnnotationConfigDispatcherServletInitializer类的Java配置</p><p id="ec3c" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">AbstractAnnotationConfigDispatcherServletInitializer是一个抽象类，它有3个抽象方法，我们应该覆盖这些方法来配置我们的dispatcherServlet</p><p id="4c2d" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">1- getServletMapping()来配置dispatcherServlet的映射</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="a070" class="lw ir hi ls b be lx ly l lz ma">protected String[] getServletMappings() {<br/>    return new String[]{"/"}; // give your mapping to this anounymous array <br/>}</span></pre><p id="aabf" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">2- getServletConfigClasses()来初始化我们的webApplicationContext</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="66f1" class="lw ir hi ls b be lx ly l lz ma">protected Class&lt;?&gt;[] getServletConfigClasses() {<br/>    Class[] classes = {MyConfig.class} ;<br/>    return classes ;<br/>}</span></pre><p id="0765" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">MyConfig类是一个配置类(替换包含我们的bean或使用组件扫描来查找我们的bean的xml文件)</p><p id="38d1" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">例如:</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="4490" class="lw ir hi ls b be lx ly l lz ma">@Configuration<br/>@ComponentScan("com.medium")<br/>public class MyConfig {<br/>}</span></pre><p id="2511" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">当DispatcherServlet查找applicationContext时，它将使用该类来查找我们应该实例化的所有bean(即控制器、服务bean、存储库等)。) .</p><p id="0c94" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">最终类应该是这样的:</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="2bc1" class="lw ir hi ls b be lx ly l lz ma">public class MyAppConfig extends AbstractAnnotationConfigDispatcherServletInitializer {<br/>    protected Class&lt;?&gt;[] getRootConfigClasses() {<br/>        return new Class[0];<br/>    }<br/><br/>    protected Class&lt;?&gt;[] getServletConfigClasses() {<br/>        Class[] classes = {MyConfig.class} ;<br/>        return classes ;<br/>    }<br/><br/>    protected String[] getServletMappings() {<br/>        return new String[]{"/"};<br/>    }<br/>}</span></pre><p id="8174" class="pw-post-body-paragraph kj kk hi jq b jr kl km kn jt ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz jy hb bi translated">注意:默认情况下，我们的WebApplicationContext中没有添加ViewResolver，所以我们需要在容器中添加一个。我们可以通过在之前创建的配置类(例如MyConfig)中创建一个bean来实现，如下所示:</p><pre class="lc ld le lf fd lr ls lt bn lu lv bi"><span id="291f" class="lw ir hi ls b be lx ly l lz ma">@Configuration<br/>@ComponentScan("com.medium")<br/>public class MyConfig {<br/><br/>    @Bean<br/>    ViewResolver viewResolver(){<br/>         InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver();<br/>         internalResourceViewResolver.setPrefix("/WEB-INF/views/");<br/>        internalResourceViewResolver.setSuffix(".jsp");<br/>        return  internalResourceViewResolver;<br/>    }<br/>}</span></pre></div></div>    
</body>
</html>