<html>
<head>
<title>Software Design Patterns: Factory and Builder in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计模式:简而言之的工厂和构建者</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/design-patterns-101-factory-vs-builder-vs-fluent-builder-da2babf42113?source=collection_archive---------0-----------------------#2021-01-04">https://medium.com/javarevisited/design-patterns-101-factory-vs-builder-vs-fluent-builder-da2babf42113?source=collection_archive---------0-----------------------#2021-01-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/af8d1c53b762b4fa00c4ea57166aa67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9sZ4Q6Y2Tv_wWaZ8POAKA.jpeg"/></div></div></figure><div class=""/><p id="9a9f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的学生经常问的一个问题是，在使用这些名称的软件设计模式方面，工厂和构建者之间有什么不同，如果有的话。此外，他们还询问了GoF模式中描述的构建器和所谓的Fluent-builder之间的区别，后者通常在调用管道中的方法时用在<a class="ae jo" rel="noopener" href="/javarevisited/7-best-java-collections-and-stream-api-courses-for-beginners-in-2020-3ad18d52c38"> Java Stream API </a>中。</p><p id="9398" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它们是<strong class="is hu">创造模式</strong>，适合特定情况的对象创造机制的模板。对象创建的基本形式(new运算符调用构造函数)到处都会导致设计问题并增加复杂性。</p><p id="66c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住，大规模编程和小规模编程是不一样的:在任何地方创建对象对你的学校作业都有用，但是它的伸缩性不好。将对象创建定位在一个地方作为一个实体或组件的责任是很重要的，例如在工厂或构建器中。如何选择这个或那个？各适合什么情况？让我们来谈谈他们中的每一个，他们的相似之处和不同之处。</p><h1 id="0f8c" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">工厂</h1><p id="9d8e" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">工厂是用于创建其他对象的对象。工厂是构造函数的<strong class="is hu">包装器，也就是说，它被用来<strong class="is hu">在一个方法调用</strong>中构建一个完整的对象。</strong></p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ks"><img src="../Images/44968b63b30e3b4ade29186984554969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CA7pFO9wAZKtjLtKilsQg.jpeg"/></div></div><p class="kx ky et er es kz la bd b be z dx translated">图一。工厂模式—创建形状(矩形和椭圆形)的工厂示例。</p></figure><p id="7f7c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">定义了两个接口来强制属性:<strong class="is hu">工厂</strong>和<strong class="is hu">产品</strong> <em class="lb">。</em></p><ul class=""><li id="04f7" class="lc ld ht is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated"><strong class="is hu">工厂</strong>接口为需要新对象时调用的方法定义了签名。一个工厂可以生产一种或多种产品。因此，它可能有不同的方法，通常带有前缀<em class="lb"> create() </em>，每种类型的产品一个方法，或者使用参数来指定要构造什么。工厂实现了这个接口。</li><li id="d440" class="lc ld ht is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated"><strong class="is hu">产品</strong>接口没有定义任何具体内容。它将根据所解决的问题进行定制。产品实现这个接口。</li></ul><p id="cc82" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">a类<strong class="is hu">客户</strong>使用<strong class="is hu">工厂</strong>并得到一个<strong class="is hu">产品</strong>。注意，<strong class="is hu">客户端</strong> <em class="lb"> </em>如何依赖于<strong class="is hu">工厂</strong>和<strong class="is hu">产品</strong>的接口，而不是这些接口的具体实现。这为多态性打开了一扇大门——<strong class="is hu">客户端</strong>可以与<strong class="is hu">工厂</strong>和<strong class="is hu">产品</strong>的任何子(专门化)一起工作。</p><p id="6cb8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，用于绘制形状的软件可以使用能够创建圆形和矩形的工厂(特别是形状工厂)。其设计如图1所示。代码呢？从类图来看，这非常简单。让我们从上往下看。图2、3、4和5显示了一个类<em class="lb">客户机</em>的源代码，它使用<em class="lb">工厂</em>来创建<em class="lb">产品</em>对象，特别是椭圆和矩形对象。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图二。Client.java——利用工厂创造产品的主要方法</p></figure><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图3。Factory.java——关键思想，工厂创造方法</p></figure><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图4。Product.java——绘制方法是产品功能(它不是来自模式)</p></figure><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图5。ShapeFactory.java——形状工厂的一个实现</p></figure><p id="0f7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你熟悉设计模式<a class="ae jo" rel="noopener" href="/javarevisited/design-patterns-101-hello-singleton-2d3f227c7729"> <strong class="is hu"> Singleton </strong> </a>，考虑一下组合和创建Singleton-Factory的可能性，也就是说，每当任何地方需要一个新的对象(产品)时，可以调用一个工厂实例。</p><h1 id="8e9c" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">建设者</h1><p id="e274" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">构建器是对象的<strong class="is hu">包装器。当一个物体不能在一个单独的步骤</strong>中生产时，使用<strong class="is hu">。构建器隔离了产品的内部表示和产品构建的步骤。使用构建器模式来避免产品具有多个构造器，每个构造器具有不同数量的参数，例如，作为一个为对象中的属性提供默认值的选项。</strong></p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/9020a977e64134b53802abf5b5c24dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysls5RLCRXw4RiVHKKIFEA.jpeg"/></div></div><p class="kx ky et er es kz la bd b be z dx translated">图6。构建器模式</p></figure><p id="e3c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lb"/><strong class="is hu">建造者</strong>创造出<strong class="is hu">产品</strong>，就像<strong class="is hu">工厂</strong>所做的那样。但是现在，不是只有一个创建产品的请求，而是有几个对构建器中的方法的调用。每次电话都会给产品添加一个新的零件。当构建器被提供了所有需要的东西后，可以调用它的方法<em class="lb"> get() </em>来用构建器之前收到的元素组装新产品。</p><p id="bcf4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图6显示了构建<em class="lb"> Box </em>对象的<em class="lb"> BoxBuilder </em>的设计。图7、8和9显示了我们新类的源代码。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图7。Client.java——使用生成器创建产品的主要方法</p></figure><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图8。Builder.java——任何想要实现生成器的类的契约</p></figure><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图9。BoxBuilder.java——盒子的建造者</p></figure><p id="ada8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当获取每个属性的值是一个复杂的过程时，在客户端和构建者之间添加一个类是一个好主意，通常被标识为Director，它可以是<em class="lb">客户端</em>的联系点，并负责创建、计算或收集数据(产品属性的值)。Director可以有一个构建器实例，并将产品的装配委托给它。主管调用构建器中的方法，构建器一步一步地构建产品，为每一步提供所需的数据。</p><h1 id="8d16" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">流畅的建设者</h1><p id="eaa0" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Fluent构建器的设计依赖于<strong class="is hu">方法链</strong>。这样做的目的是提高代码的可读性。例如，当使用Fluent Builder时，图7中的代码会发生变化(变为图10所示的代码)。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图10。Client.java——使用fluent builder创建产品的主要方法</p></figure><p id="52bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意第6到9行中的方法是如何链接的。我们需要什么来实现这一点？构建器中的一个简单更新:将返回类型从void替换为Builder，并使方法返回this(当前对象)。因此，在对setter方法的每次调用中，都返回构建器<em class="lb">的</em>对象。返回的Builder对象可以调用另一个setter方法，依此类推。实现这一点的代码如图11和12所示。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图11。FluentBuilder.java——任何想要实现Fuent生成器的类的契约</p></figure><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lq lr l"/></div><p class="kx ky et er es kz la bd b be z dx translated">图9。BoxFluentBuilder.java——盒子物品的流畅建造者</p></figure><p id="7d82" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个非常简单的实现，但它表明了这个想法。</p><p id="2552" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你熟悉<strong class="is hu"> </strong> <a class="ae jo" href="https://www.eclipse.org/modeling/emf/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu"> Eclipse建模框架</strong> </a>，你会注意到工厂和单体模式的扩展使用。如果你读过Java  中的<strong class="is hu"> </strong> <a class="ae jo" rel="noopener" href="/javarevisited/a-beginners-guide-to-functional-programming-with-java-5987101b3713"> <strong class="is hu">函数式编程，我相信Fluent-Builder看起来很熟悉。而且，如果你有机会使用深度学习框架，比如<a class="ae jo" rel="noopener" href="/mlearning-ai/neural-networks-getting-started-with-eclipse-deeplearning4j-897f3662832b"><strong class="is hu">Deep Learning 4j</strong></a>，你在创建神经网络时就已经注意到了Fluent-Builder。</strong></a></p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="410d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望你喜欢阅读。请在下面留下您的评论或问题。</p><p id="7ee1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我经常写关于软件和人工智能的文章——如果你想阅读我未来的文章，那么请<a class="ae jo" href="https://mscjaviergs.medium.com/?source=about_page-------------------------------------" rel="noopener">给我一个关注</a>、<a class="ae jo" href="https://mscjaviergs.medium.com/subscribe?source=about_page-------------------------------------" rel="noopener">订阅</a>，或者对最近的一篇文章说<em class="lb">你好</em>。</p></div></div>    
</body>
</html>