<html>
<head>
<title>(Not So Obvious) Tips To Write Better DTOs in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(不太明显)用Java编写更好的dto的技巧</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/not-so-obvious-tips-to-write-better-dtos-in-java-c6116895b180?source=collection_archive---------0-----------------------#2021-04-23">https://medium.com/javarevisited/not-so-obvious-tips-to-write-better-dtos-in-java-c6116895b180?source=collection_archive---------0-----------------------#2021-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0ed4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何编写简化代码的dto？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/51b7a02232efa4839fd11698858786e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hx7KkA0bMq9vG2Upl3a2yQ.jpeg"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">由米莎·叶利舍耶夫在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="d2e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">今天，应用程序趋向于更加分布式。我们需要编写更多的代码来连接其他服务，并且仍然尽量保持简单。</p><p id="e6e3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了使用来自外部服务的数据，我们通常将JSON有效负载转换为数据传输对象(d to)。处理dto的代码会很快变得复杂<strong class="jq hj">，</strong>，但是一些技巧会有所帮助。我们可以编写更易于交互的dto，使客户端代码更易于编写和阅读。结合使用，这些建议有助于保持简单。</p><h1 id="5f40" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">DTO从手册中序列化</h1><p id="be6f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">让我们从使用JSON的典型方式开始。下面是一个JSON结构。它代表了里贾纳披萨。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="7343" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了在我的应用程序中使用这些数据，我创建了一个名为<code class="du lj lk ll lm b">PizzaDto</code>的简单DTO。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="5246" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lj lk ll lm b">PizzaDto</code>是一个<a class="ae jn" href="https://en.wikipedia.org/wiki/Plain_old_Java_object" rel="noopener ugc nofollow" target="_blank">普通的旧Java对象</a>:一个有属性、getters、setters的对象，仅此而已。它反映了JSON结构，所以object和JSON之间的转换只是一行代码。下面是一个关于<a class="ae jn" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank">杰克逊图书馆</a>的例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="d2cf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">转换很简单。那么，有什么问题呢？</p><p id="9bd9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在现实生活中，dto可能相当复杂。创建和初始化DTO的代码可能非常庞大:有时有几十行代码。有时更多。这是一个问题，因为复杂的代码包含更多的bug，并且对变化的响应更慢。</p><p id="241b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我简化DTO创建的第一次旅行是使用一个<a class="ae jn" rel="noopener" href="/javarevisited/how-to-create-an-immutable-list-list-and-map-in-java-5ac1254c128"> <strong class="jq hj">不可变的</strong> </a> DTO:一个创建后不能修改的DTO。</p><p id="dad0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你不熟悉这个想法，这听起来可能有点奇怪，所以让我们集中讨论这个话题。</p><h1 id="d923" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">创建不可变的dto</h1><p id="df41" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">简单地说，当一个对象的状态在构造后不能改变时，它就是不可变的。</p><p id="379a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们重写<code class="du lj lk ll lm b">PizzaDto</code>，使其成为不可变的<a class="ae jn" href="https://javarevisited.blogspot.com/2010/10/why-string-is-immutable-or-final-in-java.html#axzz4sZOoYUxv" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="5fcf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不可变版本没有设置器。所有属性都是最终的，必须在构造时初始化。</p><p id="4921" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如你所见，配料清单并不是按原样存储的。相反，我使用<code class="du lj lk ll lm b">List.copyOf()</code>来保存输入的不可修改的<a class="ae jn" href="https://javarevisited.blogspot.com/2018/02/java-9-example-factory-methods-for-collections-immutable-list-set-map.html" rel="noopener ugc nofollow" target="_blank">副本。这可以防止客户修改储存在DTO中的配料。</a></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="ddbd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这很重要，因为没有蘑菇的里贾纳披萨绝对不是里贾纳披萨。</p><p id="e538" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">更严重的是，<a class="ae jn" href="https://www.java67.com/2018/01/effective-java-3rd-edition-by-joshua-bloch-must-read-book-for-java-develoeprs.html" rel="noopener ugc nofollow" target="_blank"><em class="ln">Effective Java</em></a>的作者Joshua Bloch给出了创建不可变类的建议:</p><blockquote class="lo lp lq"><p id="6d1c" class="jo jp ln jq b jr js ij jt ju jv im jw lr jy jz ka ls kc kd ke lt kg kh ki kj hb bi translated">如果您的类有任何引用可变对象的字段，请确保该类的客户端无法获取对这些对象的引用约书亚·布洛赫</p></blockquote><p id="e198" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你的DTO的任何属性是可变的，你需要制作<strong class="jq hj">防御副本</strong>。有了防御副本，你的DTO就不会被外部修改。</p><p id="4184" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"><em class="ln">Post Publish edit:</em></strong><em class="ln">从Java 16开始，</em> <a class="ae jn" href="https://docs.oracle.com/en/java/javase/16/language/records.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln">记录</em> </a> <em class="ln">提供了一种更简洁的创建不可变类的方法。</em></p><p id="87ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好的。现在我们有了一个不可改变的DTO。但是它是如何简化代码的呢？</p><h1 id="b4fe" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">不变性的好处</h1><p id="ded2" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">不变性带来了许多好处，但这里是我最喜欢的:不可变变量是无副作用的。</p><p id="d9df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们通过一个例子来看看这一点。这段代码中有一个错误:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="887e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">运行这段代码后，<code class="du lj lk ll lm b">pizza</code>没有预期的状态。哪一行导致了问题？</p><p id="88ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将考虑两个答案:首先是可变变量，然后是不可变变量。</p><p id="a2df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一个回答，用一个<strong class="jq hj">可变</strong>披萨。<code class="du lj lk ll lm b">pizza</code>由<code class="du lj lk ll lm b">make()</code>创建，但可以在<code class="du lj lk ll lm b">verify()</code>和<code class="du lj lk ll lm b">serve()</code>内修改。因此，bug可能来自这3行中的任何一行。</p><p id="68a3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，第二个答案，用一个<strong class="jq hj">不变的</strong>披萨。<code class="du lj lk ll lm b">make()</code>返回一个披萨，但是<code class="du lj lk ll lm b">verify()</code>和<code class="du lj lk ll lm b">serve()</code>不能修改它。问题只能来自<code class="du lj lk ll lm b">make()</code>。在这里，投资的范围要小得多。这个bug更容易被发现。</p><p id="7ddf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们使用不可变变量时，调试更容易。但是还有更多。</p><p id="cde5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当一个比萨饼无效时，<code class="du lj lk ll lm b">verify()</code>可能抛出一个异常来中断这个过程。让我们改变这一点。我们希望<code class="du lj lk ll lm b">verify()</code>修复无效的披萨。</p><p id="3889" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然比萨饼是不可改变的，<code class="du lj lk ll lm b">verify()</code>不能只是修复它。它必须创建并返回一个修改过的比萨饼，并且必须修改客户端代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="06b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个新版本中，很明显<code class="du lj lk ll lm b">verify()</code>返回了一个新的、固定的披萨。不变性使你的代码更加明确。变得更容易阅读，更容易进化。</p><p id="0a76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可能不知道，但是我们每天都在使用不可变对象。<code class="du lj lk ll lm b">java.lang.String</code>、<code class="du lj lk ll lm b">java.math.BigDecimal</code>、<code class="du lj lk ll lm b">java.io.File</code>是不可变的。不变性提供了<a class="ae jn" href="https://www.youtube.com/watch?v=FQERMVABRrQ" rel="noopener ugc nofollow" target="_blank">许多其他优势</a>。约书亚·布洛赫(Joshua Bloch)在他的<a class="ae jn" href="https://www.oreilly.com/library/view/effective-java/9780134686097/" rel="noopener ugc nofollow" target="_blank"> <em class="ln">有效Java </em> </a>中，简单地建议“最小化可变性”。</p><blockquote class="lo lp lq"><p id="5cc8" class="jo jp ln jq b jr js ij jt ju jv im jw lr jy jz ka ls kc kd ke lt kg kh ki kj hb bi translated">不可变类比可变类更容易设计、实现和使用。它们更不容易出错，也更安全。约书亚·布洛赫</p></blockquote><p id="8827" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，有趣的问题是:我们能把它用于我们的dto吗？</p><h1 id="f963" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">不可变DTOs有意义吗？</h1><p id="662d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">DTO的目的是在进程间传送数据。它被初始化，然后，它的状态不应该演变。要么它将被<a class="ae jn" href="https://www.java67.com/2016/10/3-ways-to-convert-string-to-json-object-in-java.html" rel="noopener ugc nofollow" target="_blank">序列化为JSON </a>，要么它将被客户端使用。这使得<strong class="jq hj">不变性</strong>成为一种自然的契合。不可变的DTO将在进程间传送数据，并保证数据不会被改变。</p><p id="3602" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">那么，为什么我首先写一个可变的<code class="du lj lk ll lm b">PizzaDto</code>，而不是一个不可变的？问题是，我非常确定我的JSON库需要DTO上的getters和setters。</p><p id="e60c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">原来我错了！</p><h1 id="ae51" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">Jackson的不可变dto</h1><p id="1644" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated"><a class="ae jn" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank"> Jackson </a>是Java中最常见的JSON库。</p><p id="c8dc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当你的DTO有getters和setters时，<a class="ae jn" href="https://www.java67.com/2015/02/how-to-parse-json-tofrom-java-object.html" rel="noopener ugc nofollow" target="_blank"> Jackson可以将对象映射到JSON </a>而不需要任何额外的配置。但是对于不可变对象，Jackson需要一点帮助。它需要知道如何构造对象。</p><p id="12db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对象的构造函数必须用<code class="du lj lk ll lm b">@JsonCreator</code>注释，每个参数必须用<code class="du lj lk ll lm b">@<a class="ae jn" href="https://javarevisited.blogspot.com/2017/10/jackson-json-parsing-error.html" rel="noopener ugc nofollow" target="_blank">JsonProperty</a></code>注释。让我们在DTO的构造函数上添加这些注释。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="47df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">仅此而已。我们有一个不可变的DTO，Jackson可以把它转换成JSON，再转换回object。</p><h1 id="ca8e" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">具有Gson和Moshi的不可变dto</h1><p id="2e72" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Gson 和<a class="ae jn" href="https://github.com/square/moshi" rel="noopener ugc nofollow" target="_blank">魔石</a>是杰克森的两个替代品。</p><p id="bbc1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有了这些库，将JSON转换成不可变的DTO更加简单，因为它们不需要任何额外的注释。</p><p id="d534" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是，为什么杰克逊需要注释，而Gson和Moshi不需要？</p><p id="f7ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这不是魔法。实际上，当<a class="ae jn" href="https://www.java67.com/2017/05/how-to-convert-java-object-to-json-using-Gson-example-tutorial.html" rel="noopener ugc nofollow" target="_blank"> Gson </a>和Moshi从JSON生成一个对象时，他们通过反射创建并初始化它。最后，他们只是不使用构造函数。</p><p id="a900" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我不太喜欢这种方法。这是一种误导，因为开发人员可能会将一些逻辑放入构造函数中，而永远不知道它没有被调用。相比之下，我觉得杰克逊要安全得多。</p><h1 id="3a7f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">避免空值</h1><p id="d0ab" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">杰克逊还有一个优点。如果我们在构造函数中加入一些逻辑，无论DTO是由应用程序代码创建的，还是由JSON生成的，它都会被调用。</p><p id="66d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以利用这一点，避免空值。我们可以改进构造函数，用非空值初始化字段。</p><p id="25b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在下面的代码片段中，当输入为null时，字段用空值初始化。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="2111" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">很多时候，空和<code class="du lj lk ll lm b">null</code>没什么区别。如果我们用空值替换空值，客户端可以使用DTO属性，而无需首先检查它是否为空。另外，它降低了获得<a class="ae jn" href="https://www.java67.com/2019/06/top-25-java-exception-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank"> NullPointerExceptions </a>的机会。</p><p id="d343" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">根据这个技巧，您可以编写更少的代码，并提高健壮性。我们怎样才能做得更好？</p><h1 id="d727" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后但同样重要的是，与建设者一起创造DTO</h1><p id="8b72" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我使用另一个技巧来简化DTO初始化。对于每个DTO，我创建一个<a class="ae jn" href="http://javarevisited.blogspot.sg/2012/06/builder-design-pattern-in-java-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">建造者</strong> </a>同伴。构建器提供了一个流畅的API来简化DTO初始化。</p><p id="8c94" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个使用构建器创建PizzaDto的示例:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="264f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于复杂的dto，构建者使代码更具表现力。这种模式如此出色，以至于Joshua Bloch几乎用它来开始他的<a class="ae jn" href="https://www.oreilly.com/library/view/effective-java/9780134686097/" rel="noopener ugc nofollow" target="_blank"> <em class="ln">有效Java </em> </a>。</p><blockquote class="lo lp lq"><p id="342b" class="jo jp ln jq b jr js ij jt ju jv im jw lr jy jz ka ls kc kd ke lt kg kh ki kj hb bi translated">这个客户端代码易于编写，更重要的是易于阅读。约书亚·布洛赫</p></blockquote><p id="012f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它是如何工作的？builder对象只是存储值，直到我们调用<code class="du lj lk ll lm b">build()</code>，它实际上用存储的值创建了所需的对象。</p><p id="ae8b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里有一个<code class="du lj lk ll lm b">PizzaDto</code>的例子。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="6db3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有些人使用<a class="ae jn" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Lombok </a>在编译时创建构建器。这使得dto变得简单。</p><p id="2329" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我更喜欢用<a class="ae jn" href="https://plugins.jetbrains.com/plugin/6585-builder-generator" rel="noopener ugc nofollow" target="_blank">生成器IntelliJ插件</a>生成生成器代码。然后，我可以添加方法重载，就像我在前面的代码片段中做的那样。构建器更加灵活，客户端代码更加精简。</p><h1 id="7a21" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="9a4c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这些是我用来写dto的主要技巧。一起使用，它们真的改善你的代码。代码库变得更容易阅读，更容易维护，并且最终更容易与您的团队共享。</p><p id="e569" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢阅读。我希望你学到了一些技巧。如果您有任何反馈，或者您有其他与d to相关的提示，请留下您的评论。我很想读一读！</p><p id="f2d6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">也感谢贡献者:hélose hem Bert的早期评论和Julien Sobczak的宝贵反馈。最后，<a class="ae jn" href="https://medium.com/javarevisited" rel="noopener">Java访问了</a>。这篇文章的出版吸引了更多的人。</p><h1 id="af61" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">资源</h1><h2 id="e49c" class="lu kl hi bd km lv lw lx kq ly lz ma ku jx mb mc kw kb md me ky kf mf mg la mh bi translated">书</h2><ul class=""><li id="257c" class="mi mj hi jq b jr lc ju ld jx mk kb ml kf mm kj mn mo mp mq bi translated"><a class="ae jn" href="https://www.oreilly.com/library/view/effective-java/9780134686097/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">有效Java </strong> </a>，作者约书亚·布洛赫，2017</li></ul><h2 id="d485" class="lu kl hi bd km lv lw lx kq ly lz ma ku jx mb mc kw kb md me ky kf mf mg la mh bi translated">正式会议</h2><ul class=""><li id="8853" class="mi mj hi jq b jr lc ju ld jx mk kb ml kf mm kj mn mo mp mq bi translated"><a class="ae jn" href="https://www.youtube.com/watch?v=FQERMVABRrQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">永恒性的力量和实用性</strong> </a>，文卡特·苏布拉马年，2018</li></ul></div></div>    
</body>
</html>