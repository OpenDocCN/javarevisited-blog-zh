<html>
<head>
<title>Caching made easy in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot让缓存变得简单</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/caching-made-easy-in-spring-boot-27d1a545905c?source=collection_archive---------1-----------------------#2021-06-14">https://medium.com/javarevisited/caching-made-easy-in-spring-boot-27d1a545905c?source=collection_archive---------1-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/87a3e629f33578621bc17443f7580597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8A-eDn1kCcjC4yeRugtdeA.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">阿卡什·卡帕拉维尼的照片</p></figure><p id="f0e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">缓存是从多方面改善系统的常见做法。它有助于使您的系统具有弹性、可伸缩性、快速，甚至根据您的用例节省一些钱。</p><p id="2d7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果数据库中的一些值经常被读取，那么缓存它们是个好主意。这可能是您发送给新注册用户的电子邮件的内容、每天都在变化的引人注目的横幅文本，或者是您禁止用户参与可疑活动的小时数。</p><p id="7b1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这些被频繁访问，您可以将它们存储在应用程序属性中，甚至存储在您的代码中，但是之后您必须重新部署以使更改生效。这些是最有可能由业务团队设置的事情类型，所以如果他们决定改变某些东西，部署应用程序是一种矫枉过正的行为。所以你最好给他们一个门户来更新它们，在你的应用程序中，你把它们存储在数据库和缓存中，比如redis。</p><p id="2992" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，说够了，让我们看看代码。假设我们的应用程序中有以下实体:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="10e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只是简单的键值存储来存储通用配置。但事实是，我们的应用程序非常受欢迎，每秒钟被访问一千次。由于每秒创建1000个数据库连接有点耗费资源，或者我们的数据库可能是云中的nosql，需要为每个读、写操作付费……所以我们决定缓存它。</p><p id="1340" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的计划是，每当我们试图从数据库中读取时，首先检查缓存。如果在缓存中找到，就从缓存中读取，而不是访问数据库。如果没有找到，那么从数据库中读取并填充缓存。</p><p id="d868" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看看<strong class="ix hj">的KeyValuePairServiceImpl </strong>可能是什么样子:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="3816" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个方法<strong class="ix hj"> checkInCache </strong>中，我们首先在redis中查找这个键，如果没有找到，那么从db中读取并用这个方法<strong class="ix hj"> getFromDb </strong>更新缓存。</p><p id="4a74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hj">保存</strong>方法中，我们保存在数据库中，同时更新缓存。</p><p id="ab9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，我明白了，与redis相关的逻辑可以被分离到不同的服务或存储库中，这可能会使这个文件看起来不那么难看。但你还是要在某个地方处理这件事，对吗？</p><p id="b9b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，实际上你不必！关于spring的事情是，它有如此多的常见用例，以至于在你了解它之后，你会觉得它是如此的明显，以至于你开始觉得有点愚蠢。至少当我第一次在Spring中发现<strong class="ix hj">缓存抽象的时候，我是这样认为的。</strong></p><p id="2117" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相信我，非常简单直观。</p><p id="5939" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们重写<strong class="ix hj">KeyValuePairServiceImpl</strong>，这样就不用担心缓存什么的了。只有方法和存储库。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="2728" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看到了吗？我们完全去除了与redis的交互，而不仅仅是重构。完全移除。这里的每一个方法应用程序都将直接与数据库交互。</p><p id="e2e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果我们想让<strong class="ix hj"> findByKey </strong>方法可缓存，我们只需要在它上面添加一个注释。这是什么？……有什么猜测吗？？</p><p id="0b4f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，字面意思是<strong class="ix hj"> @Cachable </strong>，里面有一些参数。</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="1070" class="ke kf hi ka b fi kg kh l ki kj">@Override<br/>@Cacheable(value="myAwesomeCache",key="#key")<br/>public KeyValuePair findByKey(String key) {<br/><br/>        return keyValuePairRepository.findByKey(key);<br/><br/>}</span></pre><p id="ddd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，<strong class="ix hj"> myAwesomeCache </strong> <em class="kk"> </em>只是一个任意的名字，不强制但建议使用。因为多个应用程序使用同一个redis实例是很正常的。可能会出现这样的情况，多个应用程序用同一个键缓存某些东西！该值参数有助于防止这种情况。</p><p id="1abf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> #key </strong>这里很重要。它将对应于我们希望在缓存期间用作键的带注释的方法参数。如果方法看起来像这样:</p><p id="4657" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">公钥值对findByKey(字符串myKey)</p><p id="8c62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">@Cacheble批注的key参数的值需要是<strong class="ix hj"> #myKey </strong>。</p><p id="9ae4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还剩下一点点配置。在您的应用程序的RedisConfig中，您必须添加另一个名为<strong class="ix hj">RedisCacheConfiguration</strong>的<strong class="ix hj"> Bean </strong>。这里是我的Redis配置看起来像:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="7a57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一些行动。为了测试，我很快添加了一个与服务交互的控制器类。使用它，我们将输入一些数据并尝试检索它。</p><p id="7d80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先让我们用下面的cURL创建一个问候条目。</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="c601" class="ke kf hi ka b fi kg kh l ki kj">curl -X POST "http://localhost:8080/" -H  "accept: */*" -H  "Content-Type: application/json" -d "{\"key\":\"greetings\",\"value\":\"Hello people of the world!\"}"</span></pre><p id="90a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在检索它之前，让我们看看我的redis是什么样子的:</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="05b7" class="ke kf hi ka b fi kg kh l ki kj">127.0.0.1:6379&gt; KEYS *;</span><span id="6c31" class="ke kf hi ka b fi kl kh l ki kj">127.0.0.1:6379&gt;</span></pre><p id="150d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是啊，空的。</p><p id="be6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还使用了<a class="ae iu" rel="noopener" href="/javarevisited/7-best-free-postgresql-courses-for-beginners-to-learn-in-2021-3bf369d73794"> postgres </a>作为我的db，并从应用程序属性中打开了sql日志记录。因此，每当数据库命中发生时，我们将能够在控制台中看到它。</p><p id="9097" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们试着检索问候。</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="2e07" class="ke kf hi ka b fi kg kh l ki kj">➜  curl -X GET "http://localhost:8080/greetings" -H  "accept: */*"</span><span id="e079" class="ke kf hi ka b fi kl kh l ki kj">{"id":4,"key":"greetings","value":"Hello people of the world!"}</span></pre><p id="84e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，它返回了我们插入的问候语，并在控制台中找到了以下日志:</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="13f0" class="ke kf hi ka b fi kg kh l ki kj">Hibernate: select keyvaluepa0_.id as id1_0_, keyvaluepa0_.key as key2_0_, keyvaluepa0_.value as value3_0_ from key_value_pair keyvaluepa0_ where keyvaluepa0_.key=?</span></pre><p id="0f51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们再次尝试检索相同的条目。但是..这次控制台中没有日志，也就是数据库中没有命中！</p><p id="a6ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们看一下redis中可用的键，我们会看到:</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="7b08" class="ke kf hi ka b fi kg kh l ki kj">127.0.0.1:6379&gt; KEYS *;</span><span id="a41f" class="ke kf hi ka b fi kl kh l ki kj">127.0.0.1:6379&gt; 1) "myAwesomeCache::greetings"</span></pre><p id="c373" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，Redis中有一个条目，关键字是<strong class="ix hj">问候语</strong>。这意味着在查询数据库之前，应用程序会查看缓存并做出响应。现在，如果您从redis中删除，它将再次从数据库中提取。</p><p id="7ee8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，假设您必须更新问候语。你可以很容易地用控制器做到这一点，它将更新数据库。但是旧值仍将在缓存中。为了解决这个问题，我们需要像这样注释save方法:</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="bf36" class="ke kf hi ka b fi kg kh l ki kj">@Override<br/>@CacheEvict(value = "myAwesomeCache", key = "#keyValuePair.key")<br/>public void save(KeyValuePair keyValuePair) {<br/>    keyValuePairRepository.save(keyValuePair);</span><span id="dc27" class="ke kf hi ka b fi kl kh l ki kj">}</span></pre><p id="2fec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它要做的是，在保存到<a class="ae iu" rel="noopener" href="/javarevisited/7-free-courses-to-learn-database-and-sql-for-programmers-and-data-scientist-e7ae19514ed2">数据库</a>之前，它将从redis中删除与out参数keyValuePair的key属性具有相同键的条目。因此，下次检索时，新值将被填充到缓存中。</p><p id="a366" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可能会出现这样一种情况，您不想缓存所有内容。例如，在这种情况下，我们可以使用KeyValuePair来存储许多东西，并且只想缓存包含满足所需条件的键的对象。比如以“frequent _”字符串开头。这是很有可能的:</p><pre class="jt ju jv jw fd jz ka kb kc aw kd bi"><span id="b88f" class="ke kf hi ka b fi kg kh l ki kj">@Cacheable(value="myAwesomeCache",key="#key", condition = "#key.startsWith('frequent_')")</span></pre><p id="f787" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天就到这里，我相信我已经表达了我想要分享的想法。如果您有任何反馈，请随时提供。</p><p id="09b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个演示的所有代码都可以在这里下载<a class="ae iu" href="https://github.com/Ruhshan/spring-boot-caching-demo" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a398" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意安全，戴口罩！</p><p id="75ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐缓存！</p></div></div>    
</body>
</html>