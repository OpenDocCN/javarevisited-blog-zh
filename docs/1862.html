<html>
<head>
<title>Spring Data — Never Rollback Readonly Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring数据—从不回滚只读事务</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-never-rollback-readonly-transactions-ffc21958b0d0?source=collection_archive---------0-----------------------#2022-01-06">https://medium.com/javarevisited/spring-never-rollback-readonly-transactions-ffc21958b0d0?source=collection_archive---------0-----------------------#2022-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你开发一个后端应用程序时，你必须处理数据。在大多数情况下，关系数据库是一个存储。因此，事务的使用几乎是不可避免的。</p><p id="75cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有请求可以分为两类。那些读取数据的(<em class="jd">只读事务</em>)。以及那些还可以更新数据的(<em class="jd">读写事务</em>)。Spring Data提供了一种管理数据库事务的便捷方式。但是它的简单可能隐藏了潜在的问题。例如，不明智地应用<code class="du je jf jg jh b">@Transactional(readOnly = true)</code>注释会降低代码的可重用性，并引入一些意想不到的错误。我这么说是什么意思？让我们深入了解一下。</p><p id="1190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的例子都取自<a class="ae ji" href="https://github.com/SimonHarmonicMinor/spring-boot-readonly-transactions" rel="noopener ugc nofollow" target="_blank">这个库</a>。您可以克隆它并在本地运行测试。</p><p id="63d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的栈是Spring Boot+Hibernate+PostgreSQL。</p><h1 id="ce53" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">领域</h1><p id="347f" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">假设我们正在开发一个控制远程服务器的系统。这里是<code class="du je jf jg jh b">Server</code>实体。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="bc48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每台服务器都有名称、运行状态(是否打开)和类型。</p><h1 id="6eed" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">操作限制</h1><p id="03b8" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">服务器不能随机打开。我们有一个应该遵守的政策。</p><blockquote class="kt ku kv"><p id="c116" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><em class="hi">如果服务器已经开机，则不能被触发开机。每种类型的最大开启服务器数量为3。</em></p></blockquote><p id="841f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们声明一个检查所述需求的服务。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="1b06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du je jf jg jh b">Server</code>不存在，则<code class="du je jf jg jh b">NoSuchElementException</code>出现。如果不允许合闸操作，则进入<code class="du je jf jg jh b">OperationRestrictedException</code>。</p><blockquote class="kt ku kv"><p id="28a4" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><em class="hi"/><code class="du je jf jg jh b"><em class="hi">serverRepository.countAllByTypeAndIdNot</em></code><em class="hi">方法返回给定类型的服务器数量，不包括具有所提供ID的服务器。</em></p></blockquote><p id="1c04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果用户试图打开一个服务器(或一组服务器)，那么<code class="du je jf jg jh b">checkSwitchOn</code>可能会被直接调用。任何从事务代理抛出的<code class="du je jf jg jh b">RuntimeException</code>将当前事务设置为<a class="ae ji" href="https://docs.spring.io/spring-framework/docs/4.2.x/spring-framework-reference/html/transaction.html" rel="noopener ugc nofollow" target="_blank">仅回滚</a>。这在大多数情况下非常有用，它有助于将独立的工作单元组合成一个可靠的业务案例。</p><p id="0b29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何，有时这种方法会导致意想不到的问题。你看，<code class="du je jf jg jh b">checkSwitchOn</code>方法没有做任何改变。这就是为什么我们添加了<code class="du je jf jg jh b">readOnly = true</code>属性。但是如果验证没有通过，事务将被回滚。那么，只读事务中的<em class="jd">回滚</em>和<em class="jd">提交</em>有什么区别呢？除非您尝试抑制异常，否则没有任何区别。</p><h1 id="dad6" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">问题</h1><p id="4b13" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">假设用户看到一个可用服务器表。每一行都有一个按钮，用于发送请求来打开特定的服务器。还有一件事。如果服务器无法打开，用户不希望收到错误消息。相反，应该禁用该按钮。因此，我们需要提前检索服务器的状态。</p><p id="c7d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是可能的解决方案。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="3d5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">getServersSwitchOnStatus</code>方法接受应该检查的服务器id集合。有3种可能的状态。</p><ol class=""><li id="6dfb" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><code class="du je jf jg jh b">ALLOWED</code> —服务器可以打开</li><li id="a4dc" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du je jf jg jh b">SERVER_IS_ABSENT</code> —缺少具有给定ID的服务器</li><li id="3762" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du je jf jg jh b">RESTRICTED</code> —服务器无法打开</li></ol><p id="3d71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候写一些测试了。让我们从一个简单的快乐路径开始。</p><blockquote class="kt ku kv"><p id="3331" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><em class="hi">有3台服务器，每台都可以成功开机。</em></p></blockquote><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><a href="https://www.java67.com/2018/02/5-free-eclipse-and-junit-online-courses-java-developers.html"><div class="er es ln"><img src="../Images/0dfd50647e8bd584b2ca3205f37d8aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a5EJ41VlmVuUn4Tx.png"/></div></a></figure><p id="44b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那很容易。我们写点更复杂的吧。</p><blockquote class="kt ku kv"><p id="9550" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><em class="hi">有3台服务器。第一个是</em> <code class="du je jf jg jh b"><em class="hi">JBOSS</em></code> <em class="hi">并且已经开机。第二个是</em> <code class="du je jf jg jh b"><em class="hi">TOMCAT</em></code> <em class="hi">关闭。第三个是</em> <code class="du je jf jg jh b"><em class="hi">WEB_LOGIC</em></code> <em class="hi">关闭。但是还有另外3台</em> <code class="du je jf jg jh b"><em class="hi">WEB_LOGIC</em></code> <em class="hi">类型的服务器处于开启状态。</em></p></blockquote><p id="c794" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，这意味着只能打开<code class="du je jf jg jh b">TOMCAT</code>服务器。另外两个要绑定<code class="du je jf jg jh b">RESTRICTED</code>运行状态。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="8e83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，测试没有通过。</p><figure class="km kn ko kp fd kq er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/04/top-5-junit-and-unit-testing-courses-java-programmers.html#axzz6ccm5KWKs"><div class="er es lq"><img src="../Images/2d3adb7078781f2806f2a2378a74efb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5IiUPOKwb5mY0kze.png"/></div></a></figure><pre class="km kn ko kp fd lr jh ls lt aw lu bi"><span id="8629" class="lv jk hi jh b fi lw lx l ly lz">Transaction silently rolled back <br/>because it has been marked as rollback-only</span></pre><blockquote class="kt ku kv"><p id="cd0e" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><em class="hi">我在我的文章</em> <a class="ae ji" href="https://dev.to/kirekov/spring-data-transactional-caveats-19di" rel="noopener ugc nofollow" target="_blank"> <em class="hi">《春季数据—交易注意事项》</em> </a> <em class="hi">中描述过类似的障碍。你可以在那里找到更多信息。</em></p></blockquote><p id="850b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了揭示问题的原因，我们需要弄清楚Spring中的事务是如何管理的。</p><figure class="km kn ko kp fd kq er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/08/top-5-spring-data-jpa-courses-for-java.html"><div class="er es ma"><img src="../Images/663232f3042f9c573c36cf2d778fa923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mvk3JeaZJLpJ97Ex.png"/></div></a></figure><p id="a151" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认交易<a class="ae ji" href="https://www.baeldung.com/spring-transactional-propagation-isolation" rel="noopener ugc nofollow" target="_blank">传播</a>为<code class="du je jf jg jh b">REQUIRED</code>。因此，所有对<code class="du je jf jg jh b">ServerRestrictions.checkSwitchOn</code>的后续调用都在同一个事务中执行。如果任何<code class="du je jf jg jh b">RuntimeException</code>离开了<a class="ae ji" href="https://spring.io/blog/2012/05/23/transactions-caching-and-aop-understanding-proxy-usage-in-spring" rel="noopener ugc nofollow" target="_blank">事务代理</a>的范围，问题就出现了。当它发生时，Spring将当前事务标记为<em class="jd">仅回滚</em>。如果后面的执行尝试提交更改，就会出现我们前面描述的错误。</p><blockquote class="kt ku kv"><p id="6408" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><em class="hi">到</em> <code class="du je jf jg jh b"><em class="hi">ServerAllowedOperations.getServersSwitchOnStatus</em></code> <em class="hi">方法结束时会发生提交尝试。</em></p></blockquote><p id="16da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理这种情况有几种方法。最简单的方法是强制<code class="du je jf jg jh b">ServerRestrictions.checkSwitchOn</code>方法在一个单独的事务中运行。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/06/top-6-spring-framework-online-courses-Java-programmers.html"><div class="er es mb"><img src="../Images/38e5c60c9afa3826d29f73f5e018610e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eN6zkJtIVxlPM1l7.png"/></div></a></figure><p id="62f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么能解决问题？让我们再来看看这个模式。</p><figure class="km kn ko kp fd kq er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/05/top-20-spring-boot-interview-questions-answers.html"><div class="er es ma"><img src="../Images/a7df0f89854dd965ca647f38d7803575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5-3cSmiMNbmhMYXu.png"/></div></a></figure><p id="c102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个<code class="du je jf jg jh b">RuntimeException</code>抛出<code class="du je jf jg jh b">ServiceRestrictions.checkSwitchOn</code>方法时，只影响单独的事务。开始于<code class="du je jf jg jh b">ServerAllowedOperations.getServersSwitchOnStatus</code>调用的那个一直在继续。</p><p id="0a56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，有一个警告应该提到。每检查一个服务器，就有一个新的事务开始。在我们的例子中，有3台服务器。因此，我们有4个交易，而不是一个。这可能会降低性能。随着服务器数量的增加，情况会变得更糟。</p><p id="fdcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢天谢地，有一个更好的方法。正如我在文章开头所说的，回滚只读事务是没有意义的。所以，我们来放一些额外的配置。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="2a19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">属性<code class="du je jf jg jh b">noRollbackFor</code>告诉Spring不要在异常引发时设置<em class="jd">仅回滚</em>标志。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mc"><img src="../Images/e80e8152a8b66fd636685b9a19a1b762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nrN3WLHdenwWCsh9.png"/></div></div></figure><p id="124e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经达到了既定的目标。</p><ol class=""><li id="0afd" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">该请求正在单个事务中处理。</li><li id="cab7" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">只读块中的异常不会导致回滚。</li></ol><p id="1548" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何，我们必须记住在每次声明只读服务方法时添加<code class="du je jf jg jh b">noRollBackFor</code>属性。有没有更好的解决办法？有一个。拥抱<a class="ae ji" href="https://www.logicbig.com/tutorials/spring-framework/spring-web-mvc/meta-annotation.html" rel="noopener ugc nofollow" target="_blank">春元注解</a>！</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="9888" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">ReadTransactional</code>注释充当<code class="du je jf jg jh b">@Transactional(readOnly = true, noRollbackFor = Exception.class)</code>用法的别名。然而，原始注释具有许多其他属性(<code class="du je jf jg jh b">isolation</code>、<code class="du je jf jg jh b">propagation</code>等)。).如果想要覆盖它们呢？Spring也有一个解决方案。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="1c61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">AliasFor</code>注释用法引用了不同注释的属性。</p><blockquote class="kt ku kv"><p id="32c0" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><em class="hi">这种图案在春季广泛使用。查看</em> <code class="du je jf jg jh b"><em class="hi">GetMapping</em></code> <em class="hi">或</em> <code class="du je jf jg jh b"><em class="hi">PostMapping</em></code> <em class="hi">申报单。它们不过是通用的</em> <code class="du je jf jg jh b"><em class="hi">RequestMapping</em></code> <em class="hi">注释的别名。</em></p></blockquote><p id="c4b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是最终版本。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mc"><img src="../Images/4227bd9b1942c604d45d447b966cec29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AA3NI5OxP_0KfU5g.png"/></div></div></figure><h1 id="d822" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">与读写操作相结合</h1><p id="7959" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">这个<code class="du je jf jg jh b">ReadTransactional</code>注释用法如何处理读写查询？如果任何异常被抑制，它会影响更新请求中的提交阶段吗？</p><p id="8149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，如果你应用正确，它不能。执行任何更新的方法都应该用常规的<code class="du je jf jg jh b">Transactional</code>注释来标记。而那些只是用<code class="du je jf jg jh b">ReadTransactional</code>读取数据的。</p><p id="5a66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们举一个微不足道的例子来证明这个想法。如果用户想要打开服务器，验证应该继续进行。如果失败，事务将回滚。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><blockquote class="kt ku kv"><p id="38a8" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><em class="hi">我把</em> <code class="du je jf jg jh b"><em class="hi">checkSwitchOn</em></code> <em class="hi">刷新后手动修改到数据库中。如果一切正常，回滚应该会完全取消请求。</em></p></blockquote><p id="7c48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候创建测试了。让我们来看看这个场景。</p><blockquote class="kt ku kv"><p id="c98e" class="if ig jd ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><em class="hi">关闭</em> <code class="du je jf jg jh b"><em class="hi">JBOSS</em></code> <em class="hi">类型的服务器。但是已经有3个</em> <code class="du je jf jg jh b"><em class="hi">JBOSS</em></code> <em class="hi">服务器开启。所以，手术必须失败。</em></p></blockquote><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><figure class="km kn ko kp fd kq er es paragraph-image"><a href="https://medium.com/javarevisited/5-courses-to-learn-junit-and-mockito-in-2019-best-of-lot-f217d8b93688"><div class="er es mh"><img src="../Images/44446b74e78007ac31bb0109ecb51e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hatc7dMxEtYlMHIH.png"/></div></a></figure><p id="90cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务器保持关闭状态，因为验证没有通过。因此，业务案例的行为正确。</p><p id="e99e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">具体是怎么运作的？看看下面的模式。</p><figure class="km kn ko kp fd kq er es paragraph-image"><a href="https://www.java67.com/2017/11/top-5-free-core-spring-mvc-courses-learn-online.html"><div class="er es ma"><img src="../Images/9b1dd684ae276d57d49425121996718a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cbvJcCKcwlAqkAM5.png"/></div></a></figure><p id="0ab5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<code class="du je jf jg jh b">ServerRestrictions.checkSwitchOn</code>抛出异常时，Spring跳过设置仅回滚标志。但是当异常离开<code class="du je jf jg jh b">ServerUpdateService.switchOnServer</code>的范围时，Spring执行回滚而不是提交。因为这个方法没有设置<code class="du je jf jg jh b">noRollBackFor</code>属性。</p><h1 id="c888" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">结论</h1><p id="738e" class="pw-post-body-paragraph if ig hi ih b ii kh ik il im ki io ip iq kj is it iu kk iw ix iy kl ja jb jc hb bi translated">在我看来，这是Spring生态系统中处理事务的最佳方式。它帮助我们区分只读和读写请求，最终可以在一个复杂的业务单元中进行组合。如果您有任何问题或建议，请在下面留下您的评论。感谢阅读！</p><h1 id="31d5" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">资源</h1><ol class=""><li id="6b1e" class="kz la hi ih b ii kh im ki iq mi iu mj iy mk jc le lf lg lh bi translated"><a class="ae ji" href="https://github.com/SimonHarmonicMinor/spring-boot-readonly-transactions" rel="noopener ugc nofollow" target="_blank">带有示例的存储库</a></li><li id="f9d1" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><a class="ae ji" href="https://jakarta.ee/" rel="noopener ugc nofollow" target="_blank">雅加达EE </a></li><li id="1d60" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><a class="ae ji" href="https://dev.to/kirekov/spring-data-transactional-caveats-19di" rel="noopener ugc nofollow" target="_blank">春季数据—交易警告</a></li><li id="7520" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><a class="ae ji" href="https://docs.spring.io/spring-framework/docs/4.2.x/spring-framework-reference/html/transaction.html" rel="noopener ugc nofollow" target="_blank">仅回滚标志说明</a></li><li id="02c0" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><a class="ae ji" href="https://www.baeldung.com/spring-transactional-propagation-isolation" rel="noopener ugc nofollow" target="_blank">春季交易传播</a></li><li id="56a1" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><a class="ae ji" href="https://spring.io/blog/2012/05/23/transactions-caching-and-aop-understanding-proxy-usage-in-spring" rel="noopener ugc nofollow" target="_blank">了解Spring中的代理用法</a></li><li id="9a65" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><a class="ae ji" href="https://www.logicbig.com/tutorials/spring-framework/spring-web-mvc/meta-annotation.html" rel="noopener ugc nofollow" target="_blank">弹簧元注释</a></li></ol></div></div>    
</body>
</html>