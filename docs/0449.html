<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/javarevisited/merging-integration-unit-and-functional-test-reports-with-jacoco-de5cde9b56e1?source=collection_archive---------1-----------------------#2020-05-23">https://medium.com/javarevisited/merging-integration-unit-and-functional-test-reports-with-jacoco-de5cde9b56e1?source=collection_archive---------1-----------------------#2020-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="2ce7" class="hg hh hi bd hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie bi translated">用JaCoCo合并集成、单元和功能测试报告</h2><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es if"><img src="../Images/f9cf619cea7fb3eaba60891d8ad76e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bjYsqATaRTyFsZCb30MCg.jpeg"/></div></div><p class="ir is et er es it iu bd b be z dx translated">jaco和公司:)</p></figure><p id="b2fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">代码覆盖率是任何软件开发中的一个重要方面。它告诉您测试执行了多少代码。作为一种工具，它在单元/集成测试的开发过程中非常有用，因为它有助于突出您的测试在代码中可能错过的路径。</p><p id="7596" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">例如，如果您正在测试的代码有一个<em class="jq"> if..然后..else </em>条件和您的测试调用带有参数的代码，这些参数导致<em class="jq"> if </em>条件块被测试，而不是<em class="jq"> else </em>块，代码覆盖率有助于突出显示未测试的代码。</p><p id="9ccf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">有许多工具可以生成代码覆盖率报告。JaCoCo是一个免费的Java代码覆盖库，它是由<a class="ae jr" href="https://www.eclemma.org/jacoco/" rel="noopener ugc nofollow" target="_blank"> EclEmma </a>团队基于多年来使用和集成现有库的经验而创建的<em class="jq">。</em></p><p id="78bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">在maven项目的<code class="du js jt ju jv b">pom.xml</code>中配置jacoco，为单元和集成生成覆盖报告，这对于开始使用jacoco来说非常容易。但是，在某些时候，您需要一个合并的报告，同时考虑单元、集成和功能测试报告。</p><p id="6239" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">在这篇博客中，我们将详细介绍生成单元、集成和功能测试单独覆盖报告所需的配置选项。由于我们使用不同的框架进行测试，如<a class="ae jr" rel="noopener" href="/javarevisited/5-courses-to-learn-junit-and-mockito-in-2019-best-of-lot-f217d8b93688"> Junit </a>和<a class="ae jr" href="https://cucumber.io/" rel="noopener ugc nofollow" target="_blank"> Cucumber </a> / <a class="ae jr" href="https://github.com/intuit/karate" rel="noopener ugc nofollow" target="_blank">空手道</a> Jacoco也将帮助生成一个整合了合并覆盖数据的整体覆盖报告。</p><h1 id="0a6b" class="jw hh hi bd hj jx jy jz hn ka kb kc hr kd ke kf hv kg kh ki hz kj kk kl id km bi translated">设置</h1><p id="f88a" class="pw-post-body-paragraph iv iw hi ix b iy kn ja jb jc ko je jf hs kp jh ji hw kq jk jl ia kr jn jo jp hb bi translated">我们将在这里建立的多模块maven项目由3个maven模块组成。</p><p id="a79d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated"><em class="jq">模块1 </em>和<em class="jq">模块2 </em>由一个具有某些功能的领域java类组成，并有各自的单元集成测试类。</p><p id="53fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated"><em class="jq">模块3 </em>包含黄瓜功能测试，也包含合并jacoco报告的配置。</p><p id="f33a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">pom模块和属性的片段如下所示:</p><figure class="ig ih ii ij fd ik er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/04/top-5-junit-and-unit-testing-courses-java-programmers.html"><div class="er es ks"><img src="../Images/67d34006f2cb8e1a52b7a8b84df90e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*nEy8IagxiXp6YqjIXjmmBA.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">主pom.xml</p></figure><p id="10dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">我们还配置了一些pom配置文件，这将有助于激活<em class="jq">单元</em>、<em class="jq">集成测试</em>和<em class="jq">测试全部</em>配置文件。</p><figure class="ig ih ii ij fd ik er es paragraph-image"><a href="https://www.java67.com/2018/02/5-free-eclipse-and-junit-online-courses-java-developers.html"><div class="er es kt"><img src="../Images/d12a6d0963c3282d4f6496ccb5a4536b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*2hcney3W0eM5Zx_XUJCN6w.png"/></div></a><p class="ir is et er es it iu bd b be z dx translated">单元和集成测试的概要文件。</p></figure><h1 id="9795" class="jw hh hi bd hj jx jy jz hn ka kb kc hr kd ke kf hv kg kh ki hz kj kk kl id km bi translated">配置surefire插件</h1><p id="a3a1" class="pw-post-body-paragraph iv iw hi ix b iy kn ja jb jc ko je jf hs kp jh ji hw kq jk jl ia kr jn jo jp hb bi translated">Surefire插件在构建生命周期的测试阶段用于执行应用程序的单元测试。我们可以使用<code class="du js jt ju jv b">excludes</code>属性在测试阶段排除我们不希望surefire插件包含的测试文件。</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div class="er es ku"><img src="../Images/cfaf0017f1dce772dd2907088d688a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*3zS3oJ2z_ft1MHu9qPRU-w.png"/></div><p class="ir is et er es it iu bd b be z dx translated">surefire插件</p></figure><h1 id="7829" class="jw hh hi bd hj jx jy jz hn ka kb kc hr kd ke kf hv kg kh ki hz kj kk kl id km bi translated">配置故障保护插件</h1><p id="96df" class="pw-post-body-paragraph iv iw hi ix b iy kn ja jb jc ko je jf hs kp jh ji hw kq jk jl ia kr jn jo jp hb bi translated"><em class="jq">故障保护</em>插件用于项目<strong class="ix kv">的集成测试。</strong>它有两个目标:</p><ol class=""><li id="25a3" class="kw kx hi ix b iy iz jc jd hs ky hw kz ia la jp lb lc ld le bi translated"><em class="jq">集成-测试— </em>这个目标默认绑定到<em class="jq">集成-测试</em>阶段。</li><li id="3227" class="kw kx hi ix b iy lf jc lg hs lh hw li ia lj jp lb lc ld le bi translated"><em class="jq">验证— </em>验证集成测试是否通过。默认情况下，该目标被绑定到<em class="jq">验证</em>阶段。</li></ol><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es lk"><img src="../Images/8a94285520485578d00eee4ce9aea41b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYKo2rEi6OXtNYQXJ_jD1A.png"/></div></div><p class="ir is et er es it iu bd b be z dx translated">故障保护插件</p></figure><h1 id="4674" class="jw hh hi bd hj jx jy jz hn ka kb kc hr kd ke kf hv kg kh ki hz kj kk kl id km bi translated">包括jacoco插件</h1><p id="93d7" class="pw-post-body-paragraph iv iw hi ix b iy kn ja jb jc ko je jf hs kp jh ji hw kq jk jl ia kr jn jo jp hb bi translated">Jacoco将测试覆盖数据的收集与覆盖报告的生成分开。下面的<code class="du js jt ju jv b">&lt;execution&gt;</code>块告诉jacoco启动单元测试和集成测试的代理。</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div class="er es ll"><img src="../Images/f85a6cdae27772bd00ddd3241804e869.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*uMV42m3pQz894Nbo60D1hw.png"/></div><p class="ir is et er es it iu bd b be z dx translated">jacoco代理初始化。</p></figure><p id="1c08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">现在，我们在模块3中配置jacoco插件来执行黄瓜测试，关于<em class="jq"> argLine </em>有一个重要的注意事项需要注意并牢记在心。<em class="jq"> argLine </em>帮助保存测试执行的命令行参数，稍后帮助生成合并报告。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><figure class="ig ih ii ij fd ik er es paragraph-image"><div class="er es lt"><img src="../Images/ff1a4da2cf69c6dca25d56519ad44df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*bpCWQYyyosqfd8i5hTXFjw.png"/></div></figure><p id="e8e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">现在我们将在module3中配置jacoco maven插件，用于在不同的执行步骤中合并和聚合jacoco报告。现在我们将在插件中添加不同的目标。</p><blockquote class="lu lv lw"><p id="c656" class="iv iw jq ix b iy iz ja jb jc jd je jf lx jg jh ji ly jj jk jl lz jm jn jo jp hb bi translated"><em class="hi"> report-aggregate </em>:从reactor中的多个项目创建一个结构化的代码覆盖报告(HTML、XML和<a class="ae jr" href="https://www.java67.com/2019/05/how-to-read-csv-file-in-java-using-jackson-library.html" rel="noopener ugc nofollow" target="_blank"> CSV </a>)。该报告是从该项目依赖的所有模块中创建的。</p></blockquote><figure class="ig ih ii ij fd ik er es paragraph-image"><div class="er es ma"><img src="../Images/b3ab59710194b96f48a3c2a04a7788ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*AxJ8L7695Icm0oWxDbI8sA.png"/></div><p class="ir is et er es it iu bd b be z dx translated">报告-汇总</p></figure><blockquote class="lu lv lw"><p id="37cc" class="iv iw jq ix b iy iz ja jb jc jd je jf lx jg jh ji ly jj jk jl lz jm jn jo jp hb bi translated"><em class="hi">合并</em>:这个目标有助于合并一组执行数据文件(*。exec)合并到一个文件中。</p></blockquote><p id="148a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">因为每个模块都有单独的*。jacoco生成的exec文件。这个<em class="jq">合并</em>目标将那些在<code class="du js jt ju jv b">includes</code>属性中指定的文件合并成一个单一的聚合文件，并保存到<code class="du js jt ju jv b">destFile</code>中的给定位置。</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es lt"><img src="../Images/4895a0e7fb1cb876738846a764884949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*XKJRVK9QYlYc0709m3dZSw.png"/></div></div><p class="ir is et er es it iu bd b be z dx translated">合并报告。</p></figure><p id="2ed4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">我们还可以从日志中看到目标<em class="jq">报告——聚合</em>和<em class="jq">合并</em>,如下所示:</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es mb"><img src="../Images/0f8fbf1368833f00bd57c680fe9104d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FAOgXVrALKskMvNYkSL-Gg.png"/></div></div><p class="ir is et er es it iu bd b be z dx translated">聚合和合并日志。</p></figure><p id="f440" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">现在添加一个额外的附加条件层，你可以在插件中添加一个<code class="du js jt ju jv b">check</code>目标，它将验证执行块中给出的<code class="du js jt ju jv b">rules</code>，如果不满足规则，构建将失败。<code class="du js jt ju jv b">dataFile</code>属性指定了检查规则所依据的合并报告位置。</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div class="er es mc"><img src="../Images/891509449c4ee1ff5b908849cba2779b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*xWXie_QmjBJae0GMG7sIyQ.png"/></div><p class="ir is et er es it iu bd b be z dx translated">检查执行情况。</p></figure><p id="3a15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">这就结束了jacoco的插件配置。您可以检查源代码以获得项目中使用的依赖项的准确列表。</p><p id="014a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">现在，如果您运行<code class="du js jt ju jv b">mvn clean install -P testAll</code>，这将激活<em class="jq"> testAll </em> profile并生成jacoco合并报告。</p><p id="2960" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">现在你可以通过打开<em class="jq">module 3/target/site/jacoco-aggregate/index . html</em>文件在浏览器中查看合并后的报告。</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es md"><img src="../Images/a7650fcea468e3bd8b9f248ed9f318b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZP4SDor-srvAUe9XhJZ-ZQ.png"/></div></div><p class="ir is et er es it iu bd b be z dx translated">index.html</p></figure><p id="8e81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">现在，我们将尝试忽略模块3黄瓜测试，并查看对jacoco报告的影响。您可以通过简单地忽略特征文件中指定的标签来实现这一点。运行该命令:<code class="du js jt ju jv b">mvn clean install -P testAll -Dcucumber.options="--tags ~@Concatenation"</code></p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es me"><img src="../Images/c6c14ff5bb85bdbeb315bdc6890bdee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GzoyKtu4Pma8GdolPr3hw.png"/></div></div><p class="ir is et er es it iu bd b be z dx translated">忽略黄瓜测试。</p></figure><p id="7889" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">结果显示<em class="jq">模块1 </em>的函数<code class="du js jt ju jv b">concatenation</code>没有被调用，因此覆盖率降低，构建失败。</p><h1 id="8aeb" class="jw hh hi bd hj jx jy jz hn ka kb kc hr kd ke kf hv kg kh ki hz kj kk kl id km bi translated">摘要</h1><p id="06a7" class="pw-post-body-paragraph iv iw hi ix b iy kn ja jb jc ko je jf hs kp jh ji hw kq jk jl ia kr jn jo jp hb bi translated">我们现在已经看到了如何配置jacoco以及fail safe和sure fire插件来获得maven项目中的整体代码覆盖率。如果您需要在jacoco及其规则中进行额外的配置，请访问官方的<a class="ae jr" href="https://www.eclemma.org/jacoco/trunk/doc/maven.html" rel="noopener ugc nofollow" target="_blank">文档</a>。我们还试图通过使用cucumber测试框架，用<em class="jq">模块3 </em>来增加<em class="jq">模块1 </em>的覆盖率。如果使用空手道API测试框架来代替cucumber，将会遵循类似的方法。要了解更多空手道与弹簧靴的结合，请访问我的<a class="ae jr" href="https://github.com/PraveenGNair/sample-products-service" rel="noopener ugc nofollow" target="_blank"> repo </a>。</p><p id="69a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf hs jg jh ji hw jj jk jl ia jm jn jo jp hb bi translated">源代码可在<a class="ae jr" href="https://github.com/PraveenGNair/jacoco-multi-module-sample" rel="noopener ugc nofollow" target="_blank">这里</a>获得。快乐学习！！</p></div></div>    
</body>
</html>