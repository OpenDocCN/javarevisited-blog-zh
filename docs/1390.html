<html>
<head>
<title>Scaling WebSockets in Spring services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Spring服务中扩展WebSockets</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/scaling-websockets-in-spring-services-27023f59868c?source=collection_archive---------0-----------------------#2021-07-18">https://medium.com/javarevisited/scaling-websockets-in-spring-services-27023f59868c?source=collection_archive---------0-----------------------#2021-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/27f00e81741166a0aec86961fdb3f81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r5rAIdXR-Vovd5aE"/></div></div><p class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@archduk3?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡尔·内曾·洛文</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2ddb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们有一个简单的聊天应用程序，其中前端通过rest和用于聊天的WebSockets与后端通信。我们意识到应用程序的一个实例开始无法处理负载。</p><p id="5991" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">扩展使用WebSockets的微服务不是一件简单的事情。在默认的循环负载平衡器下简单地启动另一个实例，我们可能会遇到这样的情况:一个用户连接到实例A，第二个用户连接到实例b。现在，我们的后端必须以某种方式知道将传入的消息发送到哪里。</p><h1 id="6ccc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">定制负载平衡器</strong></h1><p id="1d02" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">想到的第一个选择是编写一个智能负载平衡器，将用户从同一个聊天重定向到同一个实例。</p><p id="ba8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里会出现几个问题:</p><ol class=""><li id="dccd" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">如果用户同时与许多人通信，那么对于每个聊天，您需要打开一个新的WebSocket连接。</li><li id="0fae" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">如果聊天的人太多，那么一个后端实例可能无法应付。对于聊天来说，这不太可能，但是聊天的例子过于简单了。现实生活中，这个问题并不少见。</li></ol><h1 id="0235" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">消息代理</strong></h1><p id="aac9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">所以我们走一条不同的路。幸运的是，除了WebSockets的内存代理之外，<a class="ae iu" rel="noopener" href="/javarevisited/10-best-spring-framework-books-for-java-developers-360284c37036"> Spring </a>还有一个代理中继，它将队列的处理委托给第三方代理。</p><p id="9379" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是选择经纪人的时候了。选项很多，我们不会面面俱到。最受欢迎的:</p><ol class=""><li id="c80b" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">Apache Kafka 不太适合，因为它不是为大量动态生成的队列而设计的。</li><li id="f76a" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">Redis PUB/SUB能最好地处理这种负载，但是你不能把它从Spring的盒子里拿出来。</li><li id="3993" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">其他选项有RabbitMQ和ActiveMQ。</li></ol><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div><p class="iq ir et er es is it bd b be z dx translated">设置代理中继</p></figure><h1 id="becd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">路线命名</strong></h1><p id="0683" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果我们选择RabbitMQ，路由命名可能会有问题。如果我们使用标准斜线路径，那么我们可以看到消息:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="5952" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重点是RabbitMQ不允许标准路由后面有斜杠。因此，如果我们向路由<code class="du lq lr ls lt b">/topic/</code>或<code class="du lq lr ls lt b">/queue/</code>发送消息，那么名称中不应该有其他斜杠。这里最简单的方法是通过用点替换斜线来重命名前端和后端的所有目的地。</p><p id="2c1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果前端(或另一个通过WebSockets连接的应用程序)有不同的发布周期，情况会变得更加复杂。或者您需要保持与其他版本的兼容性。在这种情况下，您可以编写一个拦截器来替换消息中的目的地。</p><p id="301c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是您应该记住，Spring在将订阅发送到MessageChannel之前会保存订阅，因此您必须在发送到代理本身和从代理接收的阶段替换目的地。您可以在<a class="ae iu" href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow" rel="noopener ugc nofollow" target="_blank"> Spring文档</a>中看到完整的通信模式。</p><p id="a5f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的另一个解决方案是使用不同的代理。比如ActiveMQ就没有这个问题。</p><h1 id="a124" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">订阅映射</strong></h1><p id="d28c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您的应用程序将控制器中的<strong class="ix hj"><em class="lu">@ subscribe mapping</em></strong>注释用于委托给外部代理(<code class="du lq lr ls lt b">/topic/</code>，<code class="du lq lr ls lt b">/queue/</code>)的路由，这也将是一个问题。</p><p id="563b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当<a class="ae iu" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25"> Spring </a>接收到带有这种目的地的消息时，它保存订阅，然后绕过控制器将消息发送给代理。因此，用<strong class="ix hj"><em class="lu">@ subscribe mapping</em></strong>标注的方法将永远不会被调用。</p><p id="b6a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有两个解决方案。第一个解决方案不需要改变业务逻辑，而第二个解决方案需要:</p><ol class=""><li id="ed88" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">您可以添加一个BeanPostProcessor，它将扫描带有该注释的所有方法，并在<strong class="ix hj"><em class="lu">session subscribeevent</em></strong>事件上调用它们。这里的主要问题是，<strong class="ix hj"><em class="lu">SessionSubscribeEvent</em></strong>是在订阅消息发送到代理之前引发的。因此，当我们调用一个向主题发送内容的方法时，可能会出现一种情况，但用户自己还没有订阅这个主题。这个问题的解决方案很棘手，需要通过拦截器等待调度事件。</li><li id="de13" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">可以用<strong class="ix hj"><em class="lu">@ get mapping</em></strong>REST注释替换控制器中的<strong class="ix hj"><em class="lu">@ subscribe mapping</em></strong>。因此，初始状态不是由WebSockets获得，而是由<a class="ae iu" rel="noopener" href="/javarevisited/top-5-books-and-courses-to-learn-restful-web-services-in-java-using-spring-mvc-and-spring-boot-79ec4b351d12?source=---------17------------------"> REST </a>获得。这样的解决方案也需要前端方面的改变。</li></ol><h1 id="324c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">结论</strong></h1><p id="961b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果在构建应用程序时没有考虑到这一点，那么扩展使用WebSockets的微服务可能会更加复杂。主要的解决方案是使用外部消息代理。当您第一次连接消息代理时，应用程序可能无法正常工作。但主要问题只有两个(路线命名，<strong class="ix hj"><em class="lu">@ subscribe mapping</em></strong>)，而且都有解决方案。</p></div></div>    
</body>
</html>