<html>
<head>
<title>Spring @Transactional mistakes everyone did</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring @每个人都会犯的事务性错误</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-transactional-mistakes-everyone-did-31418e5a6d6b?source=collection_archive---------0-----------------------#2021-08-04">https://medium.com/javarevisited/spring-transactional-mistakes-everyone-did-31418e5a6d6b?source=collection_archive---------0-----------------------#2021-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bfbb82131cbd67da8ae09c8954ab1ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hq7L7ZZAF6BC09QN"/></div></div><p class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土银行</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="eb74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大概用的最多的一个Spring注释就是<strong class="ix hj"> <em class="jt"> @Transactional </em> </strong>。尽管它很受欢迎，但它有时会被误用，导致一些事情不是软件工程师想要的。</p><p id="02ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我收集了我个人在项目中遇到的问题。我希望这个列表能帮助你更好地理解事务，并帮助你解决一些问题。</p><h1 id="0344" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">1.同一类中的调用</h1><p id="30e3" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated"><strong class="ix hj"><em class="jt">@ Transactional</em></strong>很少被足够多的测试覆盖，这就导致了有些问题乍一看是看不出来的。因此，您可能会遇到以下代码:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div><p class="iq ir et er es is it bd b be z dx translated">批注在registerAccount方法中不起作用</p></figure><p id="2b4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，当调用<code class="du ld le lf lg b">registerAccount()</code>时，保存用户和创建团队不会在普通事务中执行。<strong class="ix hj"><em class="jt">@ Transactional</em></strong>由<a class="ae iu" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop" rel="noopener ugc nofollow" target="_blank">面向方面编程</a>提供支持。因此，当一个bean被另一个bean调用时，就会发生处理。在上面的示例中，方法是从同一个类中调用的，因此不能应用任何代理。其他标注如<a class="ae iu" href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="jt">@ Cacheable</em></strong></a>也是如此。</p><p id="7d9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个问题可以用三种基本方法解决:</p><ol class=""><li id="4e58" class="lh li hi ix b iy iz jc jd jg lj jk lk jo ll js lm ln lo lp bi translated">自我注射</li><li id="4db9" class="lh li hi ix b iy lq jc lr jg ls jk lt jo lu js lm ln lo lp bi translated">创建另一个抽象层</li><li id="5e97" class="lh li hi ix b iy lq jc lr jg ls jk lt jo lu js lm ln lo lp bi translated">通过包装<code class="du ld le lf lg b">createAccount()</code>调用，在<code class="du ld le lf lg b">registerAccount()</code>方法中使用<strong class="ix hj"> TransactionTemplate </strong></li></ol><p id="c838" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一种方法似乎不太明显，但这样一来，如果<strong class="ix hj"><em class="jt">@ Transactional</em></strong>包含参数，我们就避免了逻辑的重复。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div><p class="iq ir et er es is it bd b be z dx translated">该注释在registerAccount方法中起作用</p></figure><p id="dcc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你用Lombok，别忘了在你的lombok.config 中添加<a class="ae iu" href="https://stackoverflow.com/questions/59505213/how-to-use-lazy-annotation-in-a-class-constructor-with-lombok" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="jt"> @Lazy </em> </strong>。</a></p><h1 id="c20c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">2.处理不是所有的异常</h1><p id="7d48" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">默认情况下，回滚只发生在<a class="ae iu" href="http://www.java67.com/2012/12/difference-between-runtimeexception-and-checked-exception.html" rel="noopener ugc nofollow" target="_blank">运行时异常</a>和<a class="ae iu" href="https://javarevisited.blogspot.com/2013/06/10-java-exception-and-error-interview-questions-answers-programming.html#axzz6kGEVKsf7" rel="noopener ugc nofollow" target="_blank">错误</a>时。同时，代码可能包含已检查的异常，其中也有必要回滚事务。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div><p class="iq ir et er es is it bd b be z dx translated">如果需要在出现StripeException时回滚，请将roll back设置为</p></figure><h1 id="a9c4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">3.事务隔离级别和传播</h1><p id="3ce7" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">通常，开发人员添加注释时并没有真正考虑他们想要实现什么样的行为。几乎总是使用默认隔离级别<code class="du ld le lf lg b">READ_COMMITED</code>。</p><p id="e065" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">理解<a class="ae iu" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)" rel="noopener ugc nofollow" target="_blank">隔离级别</a>对于避免以后很难调试的错误至关重要。</p><p id="1c16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果您生成报告，您可以通过在事务期间多次执行相同的查询来选择默认隔离级别的不同数据。当并行事务在此时提交某个东西时，就会发生这种情况。使用<code class="du ld le lf lg b">REPEATABLE_READ</code>将有助于避免这种情况，并节省大量故障排除时间。</p><p id="9bfc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不同的传播有助于在我们的业务逻辑中绑定事务。例如，如果您需要在另一个<a class="ae iu" href="https://javarevisited.blogspot.com/2011/11/database-transaction-tutorial-example.html" rel="noopener ugc nofollow" target="_blank">事务</a>中运行一些代码，而不是在外部事务中，您可以使用<code class="du ld le lf lg b">REQUIRES_NEW</code>传播来挂起外部事务，创建一个新的，然后恢复外部事务。</p><h1 id="8b0f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">4.事务不锁定数据</h1><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="3b6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时，当我们在<a class="ae iu" rel="noopener" href="/javarevisited/top-5-courses-to-learn-mysql-in-2020-4ffada70656f">数据库</a>中选择一些东西，然后更新它，并认为由于所有这些都是在一个事务中完成的，并且事务具有原子性属性，因此这段代码作为单个请求执行。</p><p id="f2ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问题是没有任何东西阻止另一个应用程序实例作为第一个实例同时调用<code class="du ld le lf lg b">findAllByStatus</code>。因此，该方法将在两个实例中返回相同的数据，并且数据将被处理两次。</p><p id="c979" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两种方法可以避免这个问题。</p><h2 id="e4a5" class="lv jv hi bd jw lw lx ly ka lz ma mb ke jg mc md ki jk me mf km jo mg mh kq mi bi translated">选择更新(悲观锁定)</h2><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div><p class="iq ir et er es is it bd b be z dx translated">PostgreSQL中的选择更新</p></figure><p id="2a1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的示例中，当执行select时，这些行被阻塞，直到更新结束。该查询返回所有已更改的行。</p><h2 id="b3fa" class="lv jv hi bd jw lw lx ly ka lz ma mb ke jg mc md ki jk me mf km jo mg mh kq mi bi translated">实体的版本控制(乐观锁定)</h2><p id="3912" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">这种方式有助于避免堵塞。这个想法是给我们的实体添加一个列<code class="du ld le lf lg b">version</code>。因此，只有当数据库中实体的版本与应用程序中的版本相匹配时，我们才能选择数据并更新它。在使用<a class="ae iu" href="https://spring.io/projects/spring-data-jpa" rel="noopener ugc nofollow" target="_blank"> JPA </a>的情况下，可以使用<strong class="ix hj"><em class="jt">@版本</em> </strong>标注。</p><h1 id="7e0a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">5.两个不同的数据源</h1><p id="9db5" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">例如，我们创建了一个新版本的数据存储区，但仍需要在一段时间内维护旧版本。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="f4e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，在这种情况下，只有一个<code class="du ld le lf lg b">save</code>会被事务处理，即在那个被认为是默认的<a class="ae iu" href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">transactional manager</strong></a>中。</p><p id="fc31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25">弹簧</a>在这里提供了两种选择。</p><h2 id="1d83" class="lv jv hi bd jw lw lx ly ka lz ma mb ke jg mc md ki jk me mf km jo mg mh kq mi bi translated">ChainedTransactionManager</h2><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="b18d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ChainedTransactionManager是声明多个数据源的一种方式，在这种方式中，在出现异常的情况下，回滚将以相反的顺序发生。因此，对于三个数据源，如果第二个数据源在提交期间发生错误，只有前两个数据源会尝试回滚。第三个已经提交了更改。</p><h2 id="da5b" class="lv jv hi bd jw lw lx ly ka lz ma mb ke jg mc md ki jk me mf km jo mg mh kq mi bi translated">JtaTransactionManager</h2><p id="1519" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">该管理器允许使用基于两阶段提交的完全受支持的分布式事务。但是，它将管理委托给后端JTA提供商。可能是Java EE服务器，也可能是独立解决方案(<a class="ae iu" href="https://www.atomikos.com/" rel="noopener ugc nofollow" target="_blank"> Atomikos </a>、<a class="ae iu" href="https://github.com/bitronix/btm" rel="noopener ugc nofollow" target="_blank"> Bitrionix </a>等)。).</p><h1 id="2b00" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="8c40" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">交易是一个棘手的话题，知识上经常会有问题。大多数时候，它们没有被测试完全覆盖，因此大多数错误只能在代码审查中被注意到。如果事故发生在生产中，找到根本原因总是一个挑战。</p><p id="6138" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能喜欢的其他<strong class="ix hj"> Java和Spring文章</strong> <strong class="ix hj">和资源</strong></p><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/javarevisited/5-best-spring-data-jpa-courses-for-java-developers-45e6438be3c9"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">面向Java开发人员的5门最佳Spring Data JPA深度课程</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">我最喜欢的学习Spring Data JPA的在线课程，适合初学者和有经验的Java程序员</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">thmedium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na io mm"/></div></div></a></div><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/javarevisited/12-advanced-spring-framework-courses-for-java-programmers-a273f6e4448c"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">面向Java程序员的12门高级Spring框架课程</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">我最喜欢的高级Spring框架课程，适合Java程序员学习Spring Boot，Hibernate，Spring Cloud…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mv l"><div class="nb l mx my mz mv na io mm"/></div></div></a></div><div class="mj mk ez fb ml mm"><a href="https://javarevisited.blogspot.com/2020/05/top-20-spring-boot-interview-questions-answers.html" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">面向Java开发人员的20大Spring Boot面试问题及答案</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">Java开发人员好，毫无疑问，Spring Boot现在是开发Java应用程序的标准方式，使用…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="mv l"><div class="nc l mx my mz mv na io mm"/></div></div></a></div><blockquote class="nd ne nf"><p id="d6e8" class="iv iw jt ix b iy iz ja jb jc jd je jf ng jh ji jj nh jl jm jn ni jp jq jr js hb bi translated">如果你不是媒体成员，我强烈推荐你加入媒体，阅读不同领域伟大作家的精彩故事。你可以<strong class="ix hj">在这里加入介质</strong><a class="ae iu" rel="noopener" href="/@somasharma_81597/membership"><strong class="ix hj"/></a></p></blockquote></div></div>    
</body>
</html>