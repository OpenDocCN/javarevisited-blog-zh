<html>
<head>
<title>Software Design Patterns: Decorator in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计模式:装饰者</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/software-design-patterns-decorator-in-a-nutshell-eefd2025ea3c?source=collection_archive---------1-----------------------#2021-01-30">https://medium.com/javarevisited/software-design-patterns-decorator-in-a-nutshell-eefd2025ea3c?source=collection_archive---------1-----------------------#2021-01-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/68bd68f8f81030d17f0c8a840a3c9e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVsD0An-1NdHqpbXOWuOYw.jpeg"/></div></div></figure><div class=""/><p id="7824" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们来谈谈<strong class="is hu">结构设计模式</strong>。模式帮助我们连接类和对象，以便形成更大的结构。<strong class="is hu">装饰</strong>是<strong class="is hu"> </strong>结构类别<strong class="is hu">中的一种图案。</strong></p><h1 id="113c" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">目标</h1><p id="0a65" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">装饰模式<strong class="is hu">允许扩展(装饰)一个对象的功能。它是继承的另一种选择。Decorator在运行时为特定的实例提供新的功能，而继承在编译时添加功能，这种变化会影响新类的所有实例。</strong></p><p id="5e43" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，从类<strong class="is hu"> Person </strong>中，我们可以扩展类<strong class="is hu"> Student </strong>，为Person添加功能，然后我们可以选择创建Person(简单的那个)或Student(有额外功能的那个)的实例:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="03c4" class="la jp ht kw b fi lb lc l ld le">Person javier = new Person();<br/>Student mary = new Student();</span></pre><p id="2397" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">装饰器的主要思想是实现类似的结果，但是使用的方法在代码中可能如下所示:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="cce4" class="la jp ht kw b fi lb lc l ld le">Person javier = new Person();<br/>StudentCredential <strong class="kw hu">studentCredential</strong> = new StudentCredential();<br/>javier.<strong class="kw hu">add</strong>(studentCredential);</span></pre><p id="0b68" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通过添加以前没有的<em class="lf"> </em>来装饰一个<strong class="is hu"> Person </strong>实例。我们创建了一个完全独立于的新类，拥有我们想要添加到另一个类中的任何新特性或行为，而不是应用继承和添加东西到新类中。</p><p id="9378" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么时候使用继承，什么时候使用装饰模式？嗯，要考虑的最重要的因素之一是是否需要多态行为。如果你不需要多态，你可能不应该使用继承。🤔</p><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/b9db87bb7bb1efce14ced0e5db886d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oK2Z1S8TfrsmUt7OuPQEew.jpeg"/></div></div><p class="lh li et er es lj lk bd b be z dx translated">图一。物品和装饰者可以多次装饰。一个球可以用一个盒子来装饰，这个盒子可以用另一个盒子来装饰，以此类推。因为UI元素可以被添加到一个面板，该面板可以被添加到另一个面板，等等。</p></figure><p id="64f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们用另一个特性来改进我们的方法。想象一个有一个类<strong class="is hu">球</strong>和一个类<strong class="is hu">盒</strong>的系统。我们想用一个<strong class="is hu">盒子</strong>对象来装饰一个<strong class="is hu">球</strong>对象。</p><p id="09a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这听起来类似于<strong class="is hu">个人</strong>和<strong class="is hu">学生凭证</strong>的例子。容易实现。如果我们想把装有球的盒子放在另一个盒子里，或者把一个球和一个盒子放在一起，另一个球放在另一个盒子里，或者你能想象到的任何其他组合。</p><p id="a7e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这听起来熟悉吗？如图1所示，只要把我们的类<strong class="is hu"> Ball </strong>想象成类<strong class="is hu"> JButton </strong>(在Java API中)，把我们的类<strong class="is hu"> Box </strong>想象成类<strong class="is hu"> JPanel </strong>(在Java API中)。Java中的面板和小部件(<strong class="is hu"> JButton </strong>、<strong class="is hu"> JLabel </strong>等)与装饰范例一起工作。小部件是基本元素。源代码应该是这样的:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2034" class="la jp ht kw b fi lb lc l ld le">JPanel p1 = new JPanel();<br/>JPanel p2 = new JPanel();<br/>JPanel p3 = new JPanel();<br/>JButton b1 = new JButton ("one");<br/>JButton b2 = new JButton ("two");<br/>p1.add(b1);<br/>p2.add(b2);<br/>p3.add(p1);<br/>p3.add(p1);</span></pre><h1 id="b4ea" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">解决办法</h1><p id="a655" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">与许多其他模式一样，故事从接口开始。这个接口将是装饰者和项目的公共父接口。让我们称我们的项目为组件，即创建一个类<strong class="is hu">组件</strong>。我们的类<strong class="is hu">球</strong>是<strong class="is hu">组件</strong>的专门化；还有我们班<strong class="is hu">的包厢</strong>的一个专精<strong class="is hu">的装潢师</strong>。并且，我们可以添加更多，比如一个类<strong class="is hu">包</strong>，它也是<strong class="is hu">装饰</strong>的一个专门化。我们使用继承是因为我们需要多态。🙂</p><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/7a4b141b00a609ed385b3ef6d5776638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiKlRJqfy9L0Fvm6-evDtQ.jpeg"/></div></div><p class="lh li et er es lj lk bd b be z dx translated">图二。装饰模式的类图</p></figure><p id="9333" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的类族如图2所示。黄色显示的核心包括接口，它是我们的顶级类<strong class="is hu">组件</strong>和<strong class="is hu">装饰器</strong>的父类。并且，我们的<strong class="is hu">组件</strong>和<strong class="is hu">装饰器</strong>专门化(<strong class="is hu">球</strong>、<strong class="is hu">盒</strong>和<strong class="is hu">袋</strong>)的示例以蓝色显示。</p><p id="95e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只需添加一个元素，我们的工作就完成了:一个<strong class="is hu">装饰器</strong>和<strong class="is hu">组件接口</strong>之间的<em class="lf">聚合</em>关系。这是解决方案的核心。我们定义了"<em class="lf"/><em class="lf">装饰器可以有一个组件接口"</em>(聚合)。因此，“一个<em class="lf">装饰器可以有一个组件”</em>或<em class="lf">”</em><em class="lf">装饰器可以有另一个装饰器”</em><em class="lf">“新的装饰器可以有一个组件或一个附加的装饰器”</em>，以此类推。然后，仅仅是因为多态性的魔力:</p><ul class=""><li id="a530" class="ll lm ht is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">一个<strong class="is hu">盒</strong>可以有一个<strong class="is hu">球</strong>；</li><li id="43ff" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">一个<strong class="is hu">盒</strong>可以有一个<strong class="is hu">盒</strong>，盒内可以有一个<strong class="is hu">球</strong>；</li><li id="885c" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">一个<strong class="is hu">框</strong>可以为空(因为这是聚合，不是合成)；</li></ul><p id="7def" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，只需将多重性<em class="lf"> * </em>添加到聚合关系中，就可以定义:</p><ul class=""><li id="4658" class="ll lm ht is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">一个<strong class="is hu">箱</strong>可以有一个或多个<strong class="is hu">球</strong>实例；而且，</li><li id="4893" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">一个<strong class="is hu">盒子</strong>可以有一个或多个<strong class="is hu">盒子</strong>实例，每个盒子可以有一个或多个<strong class="is hu">球</strong>实例。</li></ul><p id="7cf0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">方法<em class="lf"> operation() </em>以及类<strong class="is hu"> Box </strong>中的具体变量或者类<strong class="is hu"> Bag </strong>中的具体方法都只是例子。可以根据需要对它们进行命名和定制。让我们在一个例子的源代码中回顾一下。</p><h1 id="e87a" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">例子</h1><p id="8101" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">装饰模式是多重继承的一种特别有趣的替代方式。想象一下一个班<strong class="is hu">人</strong>专管一个班<strong class="is hu">老师</strong>和一个班<strong class="is hu">学生</strong>。然后我们想创建一个继承自老师和学生的类，因为助教是被雇佣来教书的学生。我们已经创建了一个循环依赖。</p><p id="b8e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一些语言，比如Java，不允许多重继承，而其他语言可能容易受到钻石问题的影响。使用decoration，解决方案就像在基类(组件)Person中添加两个decorators(大概是<strong class="is hu">教学凭据</strong>和<strong class="is hu">学生凭据</strong>)一样简单。</p><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/a3362d75cfbf119ffa80578e05b73f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCwK2y8JpmHKCcn1k6C5TQ.jpeg"/></div></div><p class="lh li et er es lj lk bd b be z dx translated">图3。应用装饰模式的另一个例子</p></figure><p id="39e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们做一些类似的事情。我们正在开发一个<strong class="is hu">伴侣</strong>(聊天机器人、虚拟代理或类似的东西)，我们希望定义不同类型的伴侣，包括提供帮助的伴侣(一个<strong class="is hu">帮助者伴侣</strong>)和提供情感支持的伴侣(一个<strong class="is hu">情感伴侣</strong>)。</p><p id="2003" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用继承，解决方案看起来很简单。但是，如果我们想有一个伴侣，同时又是情感和帮助者，这种情况就有问题了。一个装饰者用一个优雅的解决方案来解决这种情况，这个方案将一个同伴的核心和它的不同个性分开。图3显示了该解决方案的设计。源代码如以下段落所示。</p><p id="ff3f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先是界面——我们层次结构的顶端。我们所有的同伴都有一个在名为<em class="lf"> doSomething()的方法中定义的行为。</em></p><figure class="kr ks kt ku fd hk"><div class="bz dy l di"><div class="lz ma l"/></div><p class="lh li et er es lj lk bd b be z dx translated">图4。Companion.java</p></figure><p id="155a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两个类实现接口；因此，该族分为一个核心项目分支和一个可能的装饰品分支。在我们的例子中，<strong class="is hu"> BasicCompanion </strong>是核心实体的类，而<strong class="is hu"> CompanionDecorator </strong>是装饰者的公共父类。我们的基本陪伴是一种行为仅限于打招呼“你好！”</p><figure class="kr ks kt ku fd hk"><div class="bz dy l di"><div class="lz ma l"/></div><p class="lh li et er es lj lk bd b be z dx translated">图5。BasicCompanion.java</p></figure><p id="d20c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hu">company decorator</strong>中，我们有3个重要元素:</p><ul class=""><li id="1700" class="ll lm ht is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">属性伴侣(满足聚合关系的那个)；</li><li id="ccd3" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">一个方法<em class="lf"> add() </em>，它将帮助我们稍后为属性提供一个值；而且，</li><li id="c6e8" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">接口方法的覆盖——关键思想，<strong class="is hu">装饰器中的动作调用被装饰的项目中的动作。</strong>我们的方法<em class="lf"> doSomething() </em>在<strong class="is hu"> CompanionDecorator </strong>中调用doSomething()方法在任何被装饰的项目(<strong class="is hu"> Companion </strong> object)中。</li></ul><figure class="kr ks kt ku fd hk"><div class="bz dy l di"><div class="lz ma l"/></div><p class="lh li et er es lj lk bd b be z dx translated">图6。CompanionDecorator.java</p></figure><p id="1b08" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，<strong class="is hu"> CompanionDecorator </strong>专攻<strong class="is hu"> HelperCompanion </strong>和<strong class="is hu"> AffectiveCompanion </strong>。注意，艰苦的工作已经在父类中完成了——子类只需要覆盖<em class="lf"> doSomething() </em>方法，添加它们自己的行为。<strong class="is hu"> HelperCompanion </strong>印<em class="lf">“我是来帮你的”</em><strong class="is hu">affective companion</strong>印<em class="lf">“我是来给你加油的”。</em></p><figure class="kr ks kt ku fd hk"><div class="bz dy l di"><div class="lz ma l"/></div><p class="lh li et er es lj lk bd b be z dx translated">图7。HelperCompanion.java</p></figure><figure class="kr ks kt ku fd hk"><div class="bz dy l di"><div class="lz ma l"/></div><p class="lh li et er es lj lk bd b be z dx translated">图8。AffectiveCompanion.java</p></figure><p id="ad24" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将这些部分放在一起，我们可以创建如图9中Main类所示的同伴。</p><figure class="kr ks kt ku fd hk"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="bd32" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出会是这样的:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ed62" class="la jp ht kw b fi lb lc l ld le">Hello!<br/>Hello! I am here to help you. <br/>Hello! I am here to cheer you. I am here to help you.</span></pre></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="2211" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没什么特别的，但你已经知道了。其他重要的创建模式包括适配器、桥、复合和代理。他们都是另一个故事的素材。希望你喜欢阅读。请在下面留下您的评论或问题。</p></div></div>    
</body>
</html>