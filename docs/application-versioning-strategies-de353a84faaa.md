# 应用程序版本控制策略

> 原文：<https://medium.com/javarevisited/application-versioning-strategies-de353a84faaa?source=collection_archive---------0----------------------->

![](img/67601f2503a1d1960d96b8e2eccab89b.png)

照片由[安格尔·坎普](https://unsplash.com/@angelekamp?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

有许多方法可以对应用程序进行版本控制。有些是很久以前出现的，对 web 开发没什么意义。尽管如此，它们仍在继续使用。在本文中，我们将考虑各种版本控制选项，以及在什么情况下适合使用它们。

# **语义版本化**

`<major>.<minor>.<patch>[.<build number>]` (1.20.11，1.20.11.403)

1.  major——增加主版本通常会破坏兼容性，允许开发人员删除不赞成使用的 API 或修改现有的 API。用户知道它，并不期待一个平稳的更新。
2.  次要—版本增量意味着在不破坏兼容性的情况下添加新功能。
3.  补丁-也称为 bugfix 版本，包括修复安全漏洞等。
4.  内部版本号—也可以添加内部版本号。

[语义版本化](https://semver.org/) (SemVer)是最常见的版本化方法，因此它在任何地方都被使用，包括 web(例如在版本化微服务中)。但是 web 上的 API 本身已经有了版本控制，客户端看到的是 API 的版本，而不是应用程序。

SemVer 非常适合版本库，例如，数据库。因此，用户将立即知道他们是否可以轻松升级。

# **日历版本**

`<year>.<month>.<patch>`(2022 . 07 . 01)
`<year>.<minor>.<patch>`(2022.1，2022.1.1)

[日历版本化](https://calver.org/) (CalVer)用在你不在乎兼容性的时候。对于这种情况，使用 SemVer 会导致第一个数字`1`永远存在。

这种版本控制对于本地软件来说尤其重要(例如， [IntelliJ Idea](https://www.jetbrains.com/idea/) 使用它)，并且对于外部用户来说最有意义。

# **基于 Sprint 的版本控制**

`<symbol><sprint number>[.<patch>]` (M27，M27.1)

当开发过程基于 Scrum sprints，并且发布是在 sprint 结果之后进行的，那么一个合理的解决方案是基于 sprint 编号对产品进行[版本化。这里的第一个字符帮助您不要将这种版本控制策略与所有其他策略混淆。如果最新版本需要修补程序，则会添加修补程序后缀。](https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/)

在这种方法中，所有的数字对团队来说都是清楚的，他们不会告诉客户任何事情。但通常情况下，用户对 web 应用中的版本并不感兴趣。

# **释放流量**

现在有很多工作流:Git 流、GitHub 流、GitLab 流、基于 Trunk 的开发等。

让我们仔细考虑一下选择使用哪一个的因素。

## 应用程序大小

如果一个小团队开发应用程序，Git 流可能是不必要的开销。创建这些特性分支非常耗时，而且对于由几个团队开发的 monolith 应用程序来说更有意义。对于微服务，使用基于主干的方法要容易得多。

## 发布周期和测试

不同的应用程序有不同的发布周期。Web 应用程序每天可以发布多次。

对于内部产品，情况正好相反。用户不希望过于频繁地更新产品，因为它总是一件大事。因此，这类产品通常会在构建版本时经历额外的测试周期。这意味着根据测试的结果，有选择地提交修复。

## 支持的基线数量

如果您正在开发 web 应用程序，通常只有最新版本就足够了。

相反，当开发一个库，或者例如一个数据库时，支持几个以前的版本是必要的。这迫使我们在项目中保留几个基线，并想出一种方法来将新的修复反向移植到所有基线。

## **分店 vs 标签**

有两种方法来固定一个版本。您可以在 commit 上创建版本号标记，或者从 master 上切断 release 分支(代码冻结)。

这两种方法都是有效的，并且适用于不同类型的产品。
一般来说，由于不变性，标记方法更好，这减少了出错的机会。
在本地产品或多个基线的情况下，发布分支对于方便后向移植更有意义。

# **结论**

有相当多的版本控制选项，每一个都有其使用案例。所以不要盲目的把语义版本化作为最流行的一种。也许在您的特定项目中，其他方法会更适合开发人员或最终用户，也更容易理解。