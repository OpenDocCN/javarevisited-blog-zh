<html>
<head>
<title>Java ThreadLocal — The Boon and The Bane</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java线程本地——好处和坏处</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-threadlocal-the-boon-and-the-bane-18263fa4f64?source=collection_archive---------1-----------------------#2020-01-31">https://medium.com/javarevisited/java-threadlocal-the-boon-and-the-bane-18263fa4f64?source=collection_archive---------1-----------------------#2020-01-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4c19b433a7b96d6f8df259032b9551a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YFwubHcgFFx3Gz5Q"/></div></div><p class="iq ir et er es is it bd b be z dx translated">供图— <a class="ae iu" href="https://unsplash.com/photos/Koxa-GX_5zs" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="b222" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近，我和我的团队正在对某段代码(特别是一个HTTP端点)进行一些性能测试，这段代码很大程度上是继承的，但也有一些我们自己的添加。</p><p id="2c3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了确保操作的整体延迟满足新增加的SLA需求，我们开始使用<a class="ae iu" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank"> Jmeter </a>执行负载测试。</p><p id="ef4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继承的代码还将一些消息异步发布到我们的内部<em class="jt">消息总线</em>，以供其他系统和分析管道使用。高层流程看起来像这样。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/06/top-5-java-multithreading-and-concurrency-courses-experienced-programmers.html#axzz6CcaEOhxJ"><div class="er es ju"><img src="../Images/51fcf7b90ba922071065d764f9b4a248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RXBx_wf4T5aPhf-g.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">消息发布的基本高层流程。为简洁起见，省略了其他不相关的细节。</p></figure><p id="37f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">消息发布库是使用<a class="ae iu" href="https://stomp.github.io/" rel="noopener ugc nofollow" target="_blank"> Stomp </a>协议构建的，由另一个团队管理。</p><p id="4bdd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://javarevisited.blogspot.com/2012/02/producer-consumer-design-pattern-with.html#axzz5gssD6l67" rel="noopener ugc nofollow" target="_blank">消息生产者</a>(如上所示)是一个共享实例，在多个线程间共享是安全的，每个进程一个实例(生产者建立了到消息代理的物理TCP连接)就足够了。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div><p class="iq ir et er es is it bd b be z dx translated">片段1。在端点控制器代码中使用的消息发布者的单个实例。</p></figure><p id="b906" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当这个端点上的负载增加到与预期的额外生产负载相匹配时，我们开始观察到性能下降。</p><p id="3e19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过查看线程的健康状况来检查Java进程，以获得系统中任何问题的良好指示，这始终是一个很好的实践。JVisualVM 是洞察健康过程的有用工具。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html"><div class="er es kb"><img src="../Images/6b2fd940f9fdac59e7dae4db435d821a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D10Ey2WPbw8SdrPW.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">可视化虚拟机输出</p></figure><p id="b5b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意线程<strong class="ix hj"> *default-dispatcher-* </strong>。这些线程的任务是发布消息。然而，那些线程时间线中的红色块表示它们在对象监视器上等待了很长时间(Java世界中的<em class="jt">同步</em>块、<em class="jt">独占重入锁</em>)。</p><blockquote class="kc kd ke"><p id="e1bf" class="iv iw jt ix b iy iz ja jb jc jd je jf kf jh ji jj kg jl jm jn kh jp jq jr js hb bi translated">绿色区域表示线程处于运行状态。</p><p id="c1f1" class="iv iw jt ix b iy iz ja jb jc jd je jf kf jh ji jj kg jl jm jn kh jp jq jr js hb bi translated">红色区域表示等待锁/条件且不做任何有用工作的线程。</p><p id="1f73" class="iv iw jt ix b iy iz ja jb jc jd je jf kf jh ji jj kg jl jm jn kh jp jq jr js hb bi translated">理想情况下，应该避免这种红色块，因为它们会严重影响应用程序的并发性以及整体性能。</p></blockquote><p id="4299" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于线程队列中的消息堆积，这对堆大小也有不利影响。</p><p id="cf75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">原因</strong></p><p id="0337" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在进行线程转储时，我们意识到这个库在内部使用了流/阻塞I/O，这意味着流不能在线程间安全地共享。</p><p id="cc7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这需要为读/写锁定流，从而序列化多个线程对它的访问。</p><p id="dc56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了缓解这个问题，我们有以下选择。</p><div class="ki kj ez fb kk kl"><a href="https://javarevisited.blogspot.com/2019/10/the-java-developer-roadmap.html#123" rel="noopener  ugc nofollow" target="_blank"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hj fi z dy kq ea eb kr ed ef hh bi translated">2020年Java开发者路线图</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">大家好，首先祝大家2020新年快乐。我已经分享了很多成为网络的路线图…</h3></div><div class="kt l"><p class="bd b fp z dy kq ea eb kr ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz io kl"/></div></div></a></div><h1 id="8652" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">每条消息的生产者</h1><p id="1108" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">为每个消息创建一个新的生产者(有效地建立到消息代理的新连接),并在使用时关闭。</p><p id="a2b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">优点</strong></p><ul class=""><li id="eed6" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">容易实现。</li><li id="b2d0" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">线程之间没有共享，这意味着线程之间没有争用。</li></ul><p id="909f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">缺点</strong></p><ul class=""><li id="3072" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">每个连接建立都必须支付TCP握手的费用(这是一个昂贵的提议)。</li><li id="0b81" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">这将直接影响性能，延迟将再次变高，导致消息堆积，因为发布速率将始终落后于消息创建速率。</li></ul><h1 id="6613" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">每个线程的生产者</h1><p id="eea5" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">这是我们想到探索优秀的Java <a class="ae iu" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html" rel="noopener ugc nofollow" target="_blank"> ThreadLocal </a>的地方。ThreadLocal本质上是状态的独立副本，排除了它们之间的任何状态(变量)共享，因为每个线程都独占访问由静态thread local维护的状态副本。</p><p id="8a95" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面代码片段1中的代码被修改成</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div><p class="iq ir et er es is it bd b be z dx translated">代码片段2:为生产者使用ThreadLocal。</p></figure><p id="96f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更改后的虚拟虚拟机快照看起来好得多，因为不再有红色块，并且它阻止了缓慢的内存增长。此外，线程的数量(由应用程序容器管理)是有限的，因此额外连接的有效数量在可接受的范围内。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/a281a71640642ba3b25b5171924d5e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wWVGx2rdvqUi-N5l.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">请注意没有监视器块的调度程序线程。</p></figure><p id="76b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">令我们震惊的是，在这个补丁上线几个小时后，与消息代理的物理连接就一飞冲天了。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/1058215a5dc8839faff7dd48027f0da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z3ETRK2E83X-asQD.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">请注意连接从6–8K(正常)增加到36K</p></figure><p id="26a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到代理的物理连接的增加对依赖于消息代理基础设施的其他应用程序产生了负面影响。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/2656ecf273b3de5e5c9bf73294d02422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kY0YC42oflgMB6XY.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">有延迟峰值的示例应用程序。</p></figure><p id="71ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">为什么会这样？</strong></p><p id="a857" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">容器管理的线程池通常有一个空闲超时，这意味着线程在一段时间不活动后变得空闲，容器管理的线程池会丢弃它们。在实践中，这是一个非常合理的场景，因为交通在一天中会发生变化。</p><p id="3986" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，即使线程被丢弃，维护消息总线生产者(映射到物理连接)的threadlocal仍然是打开的。</p><p id="46a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这显然意味着物理连接会堆积起来，因为线程池会通过其线程工厂请求新的线程来处理未来的请求。</p><p id="b9dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务器上的物理连接需要更长的时间才能关闭(通常处于CLOSE_WAIT状态)。</p><p id="d7d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ThreadLocals不提供任何清理资源的机会，这可能会导致非常严重的不良影响，如上所述。</p><p id="6d61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第一课</strong></p><blockquote class="kc kd ke"><p id="5300" class="iv iw jt ix b iy iz ja jb jc jd je jf kf jh ji jj kg jl jm jn kh jp jq jr js hb bi translated">当使用容器管理的动态线程池时，应该避免将物理资源包装在线程局部变量中，因为缺少清理机会会使这些资源处于悬空状态，可能会耗尽共享资源配额。</p><p id="5b7d" class="iv iw jt ix b iy iz ja jb jc jd je jf kf jh ji jj kg jl jm jn kh jp jq jr js hb bi translated">如果你使用这个来缓存任何这样的连接到云消息代理，数据库，重新考虑你的选择。</p><p id="d5f2" class="iv iw jt ix b iy iz ja jb jc jd je jf kf jh ji jj kg jl jm jn kh jp jq jr js hb bi translated">除非您能够完全控制线程池，并且愿意为保持空闲线程运行付出代价，否则最好避免使用ThreadLocal来缓存昂贵的资源。</p></blockquote><div class="ki kj ez fb kk kl"><a rel="noopener follow" target="_blank" href="/javarevisited/what-java-programmers-should-learn-in-2020-648050533c83"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hj fi z dy kq ea eb kr ed ef hh bi translated">2020年Java程序员该学什么？</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">2020年Java程序员可以学习的有用工具、技术、框架和库</h3></div><div class="kt l"><p class="bd b fp z dy kq ea eb kr ed ef dx translated">medium.com</p></div></div><div class="ku l"><div class="mu l kw kx ky ku kz io kl"/></div></div></a></div></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><h1 id="a28b" class="la lb hi bd lc ld nc lf lg lh nd lj lk ll ne ln lo lp nf lr ls lt ng lv lw lx bi translated">潜在修复</h1><p id="f0e7" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">然而，我们仍然需要解决这个问题。我将在此提出两种解决方案。</p><h1 id="b263" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">每个演员的制片人</h1><p id="9618" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">这是我的同事<a class="ae iu" rel="noopener" href="/@mahendrachhimwal">摩哂陀·奇姆瓦尔</a>提议的我们为用例实现的解决方案(fix)。</p><p id="83ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的应用程序大量使用了优秀的<a class="ae iu" href="https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf" rel="noopener ugc nofollow" target="_blank"> Actor </a>模型，以及它在Java/Scala中有价值的实现<a class="ae iu" href="https://doc.akka.io/docs/akka/current/actors.html" rel="noopener ugc nofollow" target="_blank"> Akka </a>。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="2f5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">为什么会这样？</strong></p><ul class=""><li id="9e33" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">参与者是软件抽象，不像线程这样的物理资源，通常由应用程序容器管理。</li><li id="f486" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">参与者占用的内存和其他资源可以忽略不计，因此维护这样一个参与者池的成本可以忽略不计。</li><li id="f6b3" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">由于threadlocal的优势，不能在actor外部访问Actor的内部状态。</li><li id="d391" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">所使用的Actor池完全由应用程序控制，可以在没有任何空闲超时的情况下运行，这是ThreadLocal方法失败的主要原因。</li></ul><h1 id="b79c" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">生产者群体</h1><p id="a9f2" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">不想只为这个用例引入Actor框架的应用程序可以为它们昂贵的资源实现一个池。通常我们会看到HTTP连接、DB连接、LDAP连接等等的池实现。</p><p id="6c1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您没有现成的池实现，您可以使用众所周知的<a class="ae iu" href="https://commons.apache.org/proper/commons-pool/index.html" rel="noopener ugc nofollow" target="_blank"> Apache Commons Pool </a>库来编写一个。</p><p id="5187" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您的应用程序可以调整池的大小(取决于负载)，它可以确保一次只有一个线程可以访问池化的资源，从而避免线程之间的任何争用。</p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><h1 id="a2d0" class="la lb hi bd lc ld nc lf lg lh nd lj lk ll ne ln lo lp nf lr ls lt ng lv lw lx bi translated">结论</h1><ul class=""><li id="2e1f" class="md me hi ix b iy ly jc lz jg nh jk ni jo nj js mi mj mk ml bi translated">ThreadLocals是标准JDK中可用的优秀构造，允许多线程应用程序很好地伸缩。</li><li id="1b22" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">但是，应该非常小心在threadlocal中管理的资源。</li><li id="1841" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><em class="jt">避免</em>:映射到JVM边界之外的物理资源的对象(特别是对于托管线程池)。这种资源的例子:数据库连接、文件句柄、网络套接字等。</li><li id="61e1" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><em class="jt">好的候选对象</em>:需要在应用程序的不同位置访问的上下文/会话对象，或者每个线程安全拥有的任何对象。</li><li id="3186" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">ThreadLocals用于正确的用例具有正确的对象可能是一件好事，而它们可能会以严重的方式严重影响您的应用程序或任何依赖系统。</li></ul></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><h1 id="e1cf" class="la lb hi bd lc ld nc lf lg lh nd lj lk ll ne ln lo lp nf lr ls lt ng lv lw lx bi translated">资源</h1><ul class=""><li id="8a8f" class="md me hi ix b iy ly jc lz jg nh jk ni jo nj js mi mj mk ml bi translated"><a class="ae iu" href="https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf" rel="noopener ugc nofollow" target="_blank">演员</a> <em class="jt">模特计算</em></li><li id="6130" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><a class="ae iu" href="https://doc.akka.io/docs/akka/current/typed/guide/introduction.html" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> Akka框架</em> </a></li><li id="cf00" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><a class="ae iu" href="https://commons.apache.org/proper/commons-pool/index.html" rel="noopener ugc nofollow" target="_blank"><em class="jt">Apache Commons Pool</em></a></li></ul><h1 id="2d10" class="la lb hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">信用</h1><p id="4ed0" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated">非常感谢<a class="ae iu" rel="noopener" href="/@mahendrachhimwal"> <em class="jt">摩哂陀·奇姆瓦尔</em> </a>帮我准备了本文所需的图表。也感谢加吉·达斯古普塔提供的宝贵反馈。</p><p id="a4fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能喜欢的其他<strong class="ix hj"> Java并发文章</strong></p><ul class=""><li id="2ac4" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated"><strong class="ix hj">2020年Java开发者路线图(</strong> <a class="ae iu" href="https://javarevisited.blogspot.com/2019/10/the-java-developer-roadmap.html#123" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">路线图</strong> </a> <strong class="ix hj"> ) </strong></li><li id="46a9" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj"> 10个Java多线程和并发最佳实践(</strong> <a class="ae iu" href="https://javarevisited.blogspot.com/2015/05/top-10-java-multithreading-and.html#axzz5Neevu8QO" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">文章</strong> </a> <strong class="ix hj"> ) </strong></li><li id="06bc" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj">Java中50大多线程与并发问题(</strong> <a class="ae iu" href="http://javarevisited.blogspot.sg/2014/07/top-50-java-multithreading-interview-questions-answers.html#axzz4jaJmaqbE" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">问题</strong> </a> <strong class="ix hj"> ) </strong></li><li id="8292" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj">Java并发高手前5本书(</strong> <a class="ae iu" href="https://javarevisited.blogspot.com/2016/06/5-books-to-learn-concurrent-programming-multithreading-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">本书</strong> </a> <strong class="ix hj"> ) </strong></li><li id="e786" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj">Java中CyclicBarrier和CountDownLatch的区别？(</strong> <a class="ae iu" href="http://www.java67.com/2012/08/difference-between-countdownlatch-and-cyclicbarrier-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">回答</strong> </a> <strong class="ix hj"> ) </strong></li><li id="560d" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj">Java中如何避免死锁？(</strong> <a class="ae iu" href="https://javarevisited.blogspot.com/2018/08/how-to-avoid-deadlock-in-java-threads.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">回答</strong> </a> <strong class="ix hj"> ) </strong></li><li id="ee85" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj">理解Java程序中数据和代码的流动(</strong> <a class="ae iu" href="https://javarevisited.blogspot.com/2019/02/thread-code-and-data-how-multithreading-java-program-execute.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">回答</strong> </a> <strong class="ix hj"> ) </strong></li><li id="0007" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj">2020年实践中的Java并发还有效吗(</strong> <a class="ae iu" href="https://javarevisited.blogspot.com/2018/07/is-java-concurrency-in-practice-still-relevant-in-era-of-java8.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">答</strong> </a> <strong class="ix hj"> ) </strong></li><li id="97ad" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj">如何使用wait-notify在Java中进行线程间通信？(</strong> <a class="ae iu" href="https://javarevisited.blogspot.com/2013/12/inter-thread-communication-in-java-wait-notify-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">回答</strong> </a> <strong class="ix hj"> ) </strong></li><li id="cc47" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj">2020年成为更好的Java开发者的10个小技巧(</strong> <a class="ae iu" href="https://javarevisited.blogspot.com/2018/05/10-tips-to-become-better-java-developer.html#axzz61Tq0rRG1" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">小技巧</strong> </a> <strong class="ix hj"> ) </strong></li><li id="df86" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><strong class="ix hj"> 5门课程深入学习Java多线程(</strong> <a class="ae iu" href="https://javarevisited.blogspot.com/2018/06/top-5-java-multithreading-and-concurrency-courses-experienced-programmers.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">门课程</strong> </a> <strong class="ix hj"> ) </strong></li></ul><p id="bdd1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您阅读本文。如果你喜欢这篇文章或跟帖面试问题，请分享给你的朋友和同事。如果您有任何问题或反馈，请留言。</p></div></div>    
</body>
</html>