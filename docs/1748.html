<html>
<head>
<title>Type-Theory Use Case: Validator Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型理论用例:验证器树</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/type-theory-use-case-validator-tree-e48418fe13e2?source=collection_archive---------2-----------------------#2021-11-18">https://medium.com/javarevisited/type-theory-use-case-validator-tree-e48418fe13e2?source=collection_archive---------2-----------------------#2021-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇短文中，我们探索了如何从玩弄函数和类型理论思维中获益，以解决编程中常见的具体问题。语言是Java(但是不要用Spring)，我们关注的用例是验证器树的主题。</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/01/adapter-vs-decorator-vs-facade-vs-proxy-pattern-java.html"><div class="er es jd"><img src="../Images/d3c2996a339b38f4c4ac5af2302e9dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*n7gO7B6TSaVefIzUofjMcA.jpeg"/></div></a><p class="jl jm et er es jn jo bd b be z dx translated">一棵小树——如果它不明显的话</p></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="2a20" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">我们的最终目标</h1><p id="cdb4" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在整篇课文中，我们将经常引用下面的典型例子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://www.java67.com/2012/09/top-10-java-design-pattern-interview-question-answer.html"><div class="er es kz"><img src="../Images/ae7ae9b18040d5f56a51b75a7e548aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*NUoR50AynjlAz7gf.png"/></div></a><p class="jl jm et er es jn jo bd b be z dx translated">我们的模型示例</p></figure><p id="abd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，先生/女士，你答对了！这是一个简化的电子邮件地址格式验证器。</p><p id="3d5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是我们对不同输入运行此树时的期望输出:</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="3d07" class="lf jx hi lb b fi lg lh l li lj">Input: null reference<br/>  Error list: [<br/>                Input cannot be null<br/>              ]</span><span id="2da1" class="lf jx hi lb b fi lk lh l li lj">Input: hello<br/>  Error list: [<br/>                Input does not contain one @ symbol<br/>              ]</span><span id="21e6" class="lf jx hi lb b fi lk lh l li lj">Input: ju@<br/>  Error list: [<br/>                Local Length must be 3 chars long at least,<br/>                Domain cannot be blank<br/>              ]</span><span id="f1cd" class="lf jx hi lb b fi lk lh l li lj">Input: @jude<br/>  Error list: [<br/>                Local cannot be blank,<br/>                Local Length must be 3 chars long at least<br/>              ]</span><span id="6094" class="lf jx hi lb b fi lk lh l li lj">Input: @<br/>  Error list: [<br/>                Local cannot be blank,<br/>                Local Length must be 3 chars long at least,<br/>                Domain cannot be blank<br/>              ]</span><span id="9dcc" class="lf jx hi lb b fi lk lh l li lj">Input: ju@de@keyser<br/>  Error list: [<br/>                Input contains too many @ symbols<br/>              ]</span><span id="bc1d" class="lf jx hi lb b fi lk lh l li lj">Input: jude+123@keyser<br/>  Error list: [<br/>                Local cannot contain a '+' segment<br/>              ]</span><span id="37f4" class="lf jx hi lb b fi lk lh l li lj">Input: jude@keyser<br/>  Error list: []</span></pre><p id="b9f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标是用一种以类型为主要对象的函数式编程来实现这个机器。</p><h1 id="05bf" class="jw jx hi bd jy jz ll kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt bi translated">履行</h1><p id="93f4" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们提出的实现基于函数式编程，遵循类型理论方法。</p><p id="0e69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引用透明性，纯函数，不可变数据，…在这篇阅读中忘掉它们。这一次，我们将把注意力从这些方面转移到其他方面:类型，以及我们如何组合它们。</p><p id="4300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不会介绍很多材料，因为我们更喜欢直观和熟悉的东西。如果下面的术语不会让读者感到恐慌，读者可以理所当然地认为他知道得够多了:</p><ul class=""><li id="51e4" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated"><strong class="ih hj">类型定义</strong>:定义一个类型(=:=运算符)是什么意思</li><li id="6155" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated"><strong class="ih hj">箭头运算符</strong>:从给定的两种类型<code class="du me mf mg lb b">A</code>和<code class="du me mf mg lb b">B</code>(函数类型)中创建箭头类型<code class="du me mf mg lb b">A -&gt; B</code>的方法</li><li id="9736" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated"><strong class="ih hj">布尔模式匹配</strong>:就像模式匹配一样，但是有布尔判别式(所以，换句话说，if-then-else)</li><li id="1ea1" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated"><strong class="ih hj">产品类型</strong>:从给定的两种类型<code class="du me mf mg lb b">A</code>和<code class="du me mf mg lb b">B</code>中创建产品<code class="du me mf mg lb b">A x B</code>的一种方法(把它当成一对)</li><li id="4eaf" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated"><strong class="ih hj">复数monad </strong>:讲“很多事”的手工词汇，所以实际上:一个列表；我们用后缀<code class="du me mf mg lb b">-s</code>来表示。</li></ul><h2 id="a043" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">引入功能验证器类型</h2><p id="1d05" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们真正想从验证器中得到什么？非常简单:一种将输入映射到失败列表的方法:</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="0df2" class="lf jx hi lb b fi lg lh l li lj">Validator =:= Input -&gt; Failure-s</span></pre><p id="8a38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何用Java翻译它？嗯，可能有许多方法，但我们选择了这一种，因为我们发现它非常方便:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mu"><img src="../Images/62522cb1c1520055d4bec6a74fc850de.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*rFzOVBVNoLLHfQZSLdVMbA.png"/></div><p class="jl jm et er es jn jo bd b be z dx translated">验证器类型，如箭头输入-&gt;失败-s</p></figure><p id="89c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很容易理解为我们想要将一个<code class="du me mf mg lb b">Input</code>映射到一个复数形式的<code class="du me mf mg lb b">Failure</code>。我们选择了内置的标准<code class="du me mf mg lb b">List</code>接口，因为它有一个<code class="du me mf mg lb b">isEmpty</code>方法来快速模式匹配列表是否为空？)，并且它与<code class="du me mf mg lb b">Stream</code>接口具有良好的互操作性，这是Java中最接近monad的概念。</p><h2 id="576a" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">验证器的和</h2><p id="a20c" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们建议对同类验证器进行如下求和运算:</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="3cd3" class="lf jx hi lb b fi lg lh l li lj">(Validator1 + Validator2)(ipt) = Validator1(ipt) + Validator2(ipt)</span></pre><p id="ecc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，我们用一个总和来丰富验证器类型，与复数类型的总和相兼容。中性元素的一个自然选择是平凡的验证器，它验证一切:</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="1b80" class="lf jx hi lb b fi lg lh l li lj">neutralValidator = input -&gt; emptyList</span></pre><p id="f5bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java没有真正的列表求和，也没有操作符重载。因此，我们建议使用下面的静态助手(我们称之为<em class="mv">链</em>，而不是<em class="mv">总和</em>，因为我们认为这样听起来更直观):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="er es mw"><img src="../Images/ca2431fdda3091346402125ec9fe4302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zy0_cFRwAYWrLouo3RM7lg.png"/></div></div><p class="jl jm et er es jn jo bd b be z dx translated">用类似求和的方法链接验证器</p></figure><p id="5b57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">中性元素是<code class="du me mf mg lb b">chain()</code>的结果，或者简称为<code class="du me mf mg lb b">emptyList()</code>。</p><h2 id="262a" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">验证器的组成</h2><p id="5b01" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">成功时阻止验证或委托其子节点的验证器节点背后的机制是我们的组合概念(“然后”的措辞)。我们用基本布尔模式匹配来实现它:</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="a336" class="lf jx hi lb b fi lg lh l li lj">(Validator1 # Validator2)(input) = if Validator1(input) is empty<br/>                                     then Validator2(input)<br/>                                     else Validator1(input)</span></pre><p id="39b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不打算设计类似于<code class="du me mf mg lb b">Function</code>的<code class="du me mf mg lb b">andThen</code>方法，因为它也不是我们为sum选择的方法。我们建议使用以下可变静态运算符:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nb"><img src="../Images/b1588b48def5a398f5214c96db1e1270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*kz2TGPpeuRF-sJ_rnpJLhw.png"/></div><p class="jl jm et er es jn jo bd b be z dx translated">作为验证器组合的树映射</p></figure><h2 id="bd32" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">验证器的拉回</h2><p id="d137" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">最后是最后一个映射:通过外部映射拉回验证器的方法。给定一个<code class="du me mf mg lb b">Output -&gt; Failure-s</code>和一个映射<code class="du me mf mg lb b">Input -&gt; Output</code>，我们可以通过常规的箭头组合在输入上推断出一个新的验证器(请原谅我糟糕的分类理论图):</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="f61d" class="lf jx hi lb b fi lg lh l li lj">Input ----&gt; Output ----&gt; Failure-s<br/>  |                         |<br/>   \ - - - - - - - - - - - /</span></pre><p id="8d01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们选择使用内置的<code class="du me mf mg lb b">Function</code>类型来编码“常规映射”的概念，利用方法引用实例化来轻松桥接任何类型的函数类型。</p><p id="63e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的建议还是基于一个可变的静态帮助器:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nc"><img src="../Images/0a855c4a32473274ebf328a2676b4602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*OgyftXDa0wq_5dkgHTXeyw.png"/></div><p class="jl jm et er es jn jo bd b be z dx translated">通过常规映射拉回验证器</p></figure><h2 id="7d61" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">作曲很好，但我们需要一个开始</h2><p id="8188" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">到目前为止，我们仅仅描述了如何构建验证器(求和、回调和通过特殊的树转换器)。</p><p id="b236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本类型作为一个<code class="du me mf mg lb b">Input -&gt; Failure-s</code>足够通用，适合任何类型的实现(方法引用，一个类，一个singleton Spring组件，以防你还没有放弃Spring，…)。提供一种从谓词创建验证器的简单方法也不错，因为它们可能是非常基本的验证的需要。</p><p id="baca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们寻求一种转换器</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="e406" class="lf jx hi lb b fi lg lh l li lj">TEST : Failure x Predicate&lt;Input&gt; -&gt; Validator&lt;Input, Failure&gt;</span><span id="3b37" class="lf jx hi lb b fi lk lh l li lj">TEST(failure, predicate) -&gt; if predicate is true<br/>                                 then neutralElement<br/>                                 else of(failure)</span></pre><p id="4df9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面利用了列表单子上的两个可能单位(其中空的是空列表单子上的单位，也是列表单子的中性；而<code class="du me mf mg lb b">of</code>是非空列表的单位)。</p><p id="e1a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再说一次，Java方法真的很简单(只要避免去上课，你不需要它…真的):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nd"><img src="../Images/063bc54a60536565f2f3076978cf4bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*xz-jHI9Q3hWTSiHMKwvXmw.png"/></div><p class="jl jm et er es jn jo bd b be z dx translated">将谓词和错误转换为验证器的测试映射。</p></figure><h1 id="e735" class="jw jx hi bd jy jz ll kb kc kd lm kf kg kh ln kj kk kl lo kn ko kp lp kr ks kt bi translated">一起</h1><h2 id="ac82" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">图书馆代码</h2><p id="96b8" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">以下是我们从文章中提炼出来的完整库代码:</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-java-design-pattern-courses-for-developers.html"><div class="er es ne"><img src="../Images/754d86d9477085be195d381a7329d67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYhC4dggYDp7RrI-6wUe_A.png"/></div></a><p class="jl jm et er es jn jo bd b be z dx translated">完整的代码，没有进口</p></figure><p id="851e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我让它适应最大80个字符的宽度，只是因为我觉得它很酷。警告抑制是由于编译器所说的“堆污染”；在我们的情况下，这很好。</p><h2 id="411a" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">模型示例</h2><p id="d0bf" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">现在是模型示例实现:</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://www.java67.com/2018/05/top-20-system-design-interview-questions-answers-programming.html"><div class="er es kz"><img src="../Images/ae7ae9b18040d5f56a51b75a7e548aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*NUoR50AynjlAz7gf.png"/></div></a><p class="jl jm et er es jn jo bd b be z dx translated">我们的模型例子(同上；为了清楚起见，我们重复)</p></figure><p id="b2b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们把它作为一个练习，用上面介绍的符号和记号写下完整的模型树。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nf"><img src="../Images/f3b91349d0f33ab4f8063b6f36753e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*43YPN5K4BM4NBU7e6Bi-sA.png"/></div><p class="jl jm et er es jn jo bd b be z dx translated">模型示例实现</p></figure><p id="8066" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以根据需要重用验证器:在某个地方使它成为静态的，在另一个可配置的验证器上动态地组合它，…无论什么。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="ed5a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">外卖的</h1><h2 id="1ebb" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">面向数据的编程？</h2><p id="7316" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在一种一切都是类的语言中，没有类的设计是相当具有挑战性的。最近的Java版本允许某种更简单的语法:尽管编译器将lambda表达式和方法引用解释为匿名类，并相应地实例化对象，但外观还是很不错的。</p><p id="51f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的关键点是:不要匆忙进入数据和类。你并不总是需要数据。</p><p id="04ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们已经看到的，工作的主要部分是关于函数组合。在这幅图中，<code class="du me mf mg lb b">test</code>工厂方法可以被认为是唯一的“数据持有者”，它自己的一半DNA是一个<code class="du me mf mg lb b">Predicate</code>。</p><h2 id="b9a6" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">函数式编程还是面向对象编程？</h2><p id="23a5" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们的方法带有一点函数式编程的味道。</p><p id="3235" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们选择使用的基本类型显然是功能性的。但是我们并没有仅仅使用“纯静态函数”。相反，我们首先设计了一个类型，其目的是创建对象(可能通过方法引用或lambda表达式，但任何其他实现都可以)。</p><p id="1160" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用静态方法进行设计不会给实现组合的方式带来如此大的灵活性(特别是在Java中，内置方法不能作为参数传递):在Java中只有一种方式来组合方法，而且看起来像是一个汇编跳转。</p><p id="037c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拥有<em class="mv">功能对象</em>极大地改善了合成特性，并帮助我们导出合成和求和特性。(这些操作符在我们的文本中是静态的，但是也可以分别编码为<code class="du me mf mg lb b">Validator#add</code>和<code class="du me mf mg lb b">Validator#andThen</code>方法)。拉回是一个简单的练习，因为构图已经在<code class="du me mf mg lb b">Function</code>物体上可用。</p><h2 id="53fd" class="lf jx hi bd jy mh mi mj kc mk ml mm kg iq mn mo kk iu mp mq ko iy mr ms ks mt bi translated">面向类型的编程？</h2><p id="fd25" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们在这里采用的方法可能会令人惊讶。</p><p id="2f5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Java中，你经常会发现像“产品是记录”和“联合是密封的类型/枚举”这样的措辞快捷方式。虽然这些结构肯定部分地反映了这些概念，但是还有更多要说！我们已经在这里展示了方法参数已经可以被认为是产品。重载提供了一种谈论联合的方式。这里已经足够完美了…</p><p id="fe7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们放弃了在核心Java的类型系统中反映产品、联合、拉回…的任务。它不是人们所说的“旨在实现这一目标的语言”。<em class="mv">然而，这并不意味着我们抛弃了类型理论</em>，恰恰相反！我们已经展示了您可以使用它，如果不是在语法级别，至少作为一个元级别。</p><p id="df59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用标准的OOP模式，如工厂方法、装饰器等来展示本文的内容，这无疑是另一种看待事物的方式。类型理论的优势在于它的代数性:在理论上，当我们思考模式时，我们有一个代数(<code class="du me mf mg lb b">x, |, -&gt;, ...</code>)来指导和帮助我们。这是标准模式无法比拟的:它们本质上是非结构化的，可能是在代码中，也可能是在纸上。</p><p id="1f78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以给出的关于类型理论的要点是:<em class="mv">类型也可以用作模式，它们在存在时摇摆不定！毫无疑问，强制记录类型和密封类型是我们不应该丢弃的强大工具。但是类型也可以有不同的用法，比如模式。在我们看来，这种基于类型理论的方法弥补了GoF中标准面向对象模式所缺乏的:一种易于组合模式的代数。</em></p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="d70f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你喜欢:-)</p><p id="6a2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有代码在gist:<a class="ae ng" href="https://gist.github.com/Judekeyser/d2f316861deeeac8d861bcfb97816701" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Jude keyser/d2f 316861 dee EAC 8d 861 bcfb 97816701</a></p></div></div>    
</body>
</html>