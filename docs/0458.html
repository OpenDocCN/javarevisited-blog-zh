<html>
<head>
<title>Let’s Learn Together Sessions: Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们一起学习会话:Redis</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/lets-learn-together-sessions-redis-4663d57cc136?source=collection_archive---------2-----------------------#2020-05-26">https://medium.com/javarevisited/lets-learn-together-sessions-redis-4663d57cc136?source=collection_archive---------2-----------------------#2020-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1d1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文简要介绍了Redis，它是最流行的内存数据存储、数据库、缓存和消息代理NoSQL解决方案之一。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e6b8f5addbcdb2fa708f6e60d0f491ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hWBfDX_GBE5Rzd0x"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="e661" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">什么是Redis？</strong></h1><p id="d77d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Redis是速度最快的内存数据存储之一，其数据库模型基于键值存储。Redis的名字来源于单词“<strong class="ih hj"> Re </strong> mote”、“<strong class="ih hj">Di</strong>dictionary”和“<strong class="ih hj"> S </strong> erver”的缩写。它是由<a class="ae jt" href="https://github.com/antirez" rel="noopener ugc nofollow" target="_blank"> Salvatore Sanfilippo </a>开发的，旨在提高他的初创公司的可扩展性性能，该公司提供名为<a class="ae jt" href="http://lloogg.com/" rel="noopener ugc nofollow" target="_blank">lloogg.com</a>的实时分析服务。</p><p id="188e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Redis是用C语言编写的开源解决方案，发布在Github上</strong>。另一方面，Redis还有一个<a class="ae jt" href="https://spdx.org/licenses/BSD-3-Clause.html" rel="noopener ugc nofollow" target="_blank"> BSD3-Clause商业许可</a>，它保护源代码和二进制形式的再分发和使用，以及印刷条款。</p><p id="53fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis有一个很大的开源社区，不仅支持它保持其简单性和性能，还为不同的模块和设计增加了企业能力和功能以及集成。</p><p id="2608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个名为Redis Labs的社区是一家私人公司，于2011年由Ofer Bengal(T21)和Yiftach Shoolman(T23)创建。Redis的创始人Salvatore Sanfilippo也是Redis实验室的成员，该实验室领导Redis的开源开发。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/f027a889ac406415781932b1432c28ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*m_40QBYl3CcNHl6UwfQTFw.jpeg"/></div><p class="jp jq et er es jr js bd b be z dx translated">Redis实验室的创始人Yiftach Shoolman(左)和Ofer Bengal(右)。</p></figure><p id="9ec5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">有许多客户端可以与不同的语言一起使用Redis，如</strong><a class="ae jt" rel="noopener" href="/javarevisited/10-best-places-to-learn-java-online-for-free-ce5e713ab5b2"><strong class="ih hj">Java</strong></a><strong class="ih hj"/><a class="ae jt" rel="noopener" href="/javarevisited/7-free-courses-to-learn-node-js-in-2020-2f1dd6722b49?source=---------10------------------"><strong class="ih hj">node . js</strong></a><strong class="ih hj"/><a class="ae jt" rel="noopener" href="/javarevisited/9-free-c-programming-courses-for-beginners-2486dff74065"><strong class="ih hj">C</strong></a><strong class="ih hj"/><a class="ae jt" rel="noopener" href="/javarevisited/5-best-c-c-sharp-programming-courses-for-beginners-in-2020-494f7afc7a5c"><strong class="ih hj">C #</strong></a><strong class="ih hj"/><a class="ae jt" rel="noopener" href="/javarevisited/7-free-courses-to-learn-swift-programming-language-in-2020-f40ac9d3ee53?source=---------7------------------"><strong class="ih hj">Swift</strong></a><strong class="ih hj">，</strong>您可以通过下面的链接找到Redis客户备选方案和Redis社区推荐的客户:</p><div class="ky kz ez fb la lb"><a href="https://redis.io/clients" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">雷迪斯</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">快速和轻型Redis客户端库扩展Hiredis:线程安全，写复制，自动重新连接，同步池…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">redis.io</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jn lb"/></div></div></a></div><p id="b918" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Redis支持许多基于键值的数据结构，如</strong> <a class="ae jt" href="https://www.java67.com/2013/02/10-examples-of-hashmap-in-java-programming-tutorial.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">哈希</strong> </a> <strong class="ih hj">，</strong> <a class="ae jt" href="https://javarevisited.blogspot.com/2012/06/hashset-in-java-10-examples-programs.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">集合</strong> </a> <strong class="ih hj">，</strong> <a class="ae jt" href="https://javarevisited.blogspot.com/2012/11/difference-between-treeset-hashset-vs-linkedhashset-java.html#axzz6hX6XfwBD" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">排序集合</strong> </a> <strong class="ih hj">，</strong> <a class="ae jt" href="https://www.java67.com/2012/07/how-to-iterate-loop-traverse-list-java.html" rel="noopener ugc nofollow" target="_blank">列表 </a> <strong class="ih hj">。</strong>此外，Redis支持发布/订阅消息代理，其中发布的消息被分配给通道，而不知道连接的订户。连接到相关频道的订户接收发布的消息。</p><p id="4645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Redis提供了改进的读取性能、稳定的故障转移机制和更快的数据恢复</strong>，这得益于其主从复制和分片机制的支持。</p><p id="23d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis还支持持久化到磁盘。您可以轻松启用或禁用此属性，并对其进行参数化管理。(每天9:00或每小时等指定时间段自动启动，或通过“<strong class="ih hj">bgsave”</strong>命令手动调用，或关机时自动触发)。所以Redis是设计一致的和分区容忍的数据存储的一个很好的选择。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/94b0dd97cb5ed9817130023f80fa5f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hl7pdzQFoxUjMR0p46g5wA.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">图片来源:【https://datasciencepedia.com/】T4:::CAP定理</p></figure><p id="571d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Redis通过主从复制机制提供高可用的结构</strong>。您可以通过添加新节点或删除节点来轻松扩展Redis。这是一种非常安全和稳定的方法，可以根据您的应用程序需求来扩展您的应用程序。</p><h1 id="4916" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Redis用在哪里？</h1><p id="2da9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Redis在许多不同的部门和领域用于不同的目的。使用Redis的知名公司有Twitter、Github、Pinterest、Snapchat、Stackoverflow等等…</p><p id="2d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Redis的一个主要用例是缓存。</strong>减少数据访问延迟时间，提高数据操作(访问或写入)性能。它提供了快速的响应时间，对于大多数或经常使用的数据甚至低于1毫秒。您可以通过一些配置提高响应时间和写入时间性能，例如从从节点读取和写入主节点功能等</p><p id="fa8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于其模式匹配和不同的数据结构支持，Redis也是发布/订阅和队列机制的一个很好的选择。您可以创建基于房间或频道的聊天应用程序、实时内容流以及社交媒体feed基础架构。</p><p id="4862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Redis还被前端和后端应用程序用于内存会话存储</strong>。它以高度可伸缩和持久的方式存储会话数据、用户会话和凭证。</p><p id="9cdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Redis有序集合数据结构是游戏开发者开发实时排行榜</strong>功能的首选解决方案。许多流行的游戏开发公司，如Roblox和Jelly Button Games等，以及领先的游戏直播公司，如Twitch，都使用Redis作为他们的内存数据存储需求。您可以通过以下链接获得游戏行业Redis实验室的详细文档和解决方案:</p><div class="ky kz ez fb la lb"><a href="https://redislabs.com/redis-enterprise/industries/gaming/" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">用于游戏开发的Redis企业数据库| Redis实验室</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">Redis广泛用于游戏应用程序，通过排行榜对多人游戏中的玩家进行排名…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">redislabs.com</p></div></div><div class="lk l"><div class="lr l lm ln lo lk lp jn lb"/></div></div></a></div><p id="1d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了这些用例之外，您还可以为许多域选择Redis，以提高应用程序的可伸缩性和性能。<br/> <strong class="ih hj">让我们看看，Redis是如何提供这一点的？</strong></p><h1 id="2188" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">它是如何工作的？</h1><p id="5fed" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果您已经决定使用Redis，您必须首先选择要使用的Redis模式。Redis为用户提供以下四种不同的模式:</p><ul class=""><li id="fa73" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">独立模式</li><li id="1e3f" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">复制模式</li><li id="94ae" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">集群模式</li><li id="6026" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">哨兵模式</li></ul><p id="f4b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Redis独立模式在可扩展性方面类似于关系数据库。</strong>它支持垂直可扩展性，但由于单点故障而不支持高可用性。独立模式很容易设置，但不建议用于生产环境。</p><p id="e583" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二种模式，复制模式，由于其主从结构，解决了独立模式的可用性问题。</strong>有主节点和一些副本。主节点向副本更新新数据，副本之间没有网络和数据传输。复制模式的主要问题是弹性。您必须手动应用操作和管理节点。如果主服务器关闭，您必须手动将复制副本分配为新的主服务器，并重新启动所有客户端。</p><p id="fb8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Sentinel模式已被开发作为前两个节点的替代，以解决恢复能力问题。</strong>除主节点或从节点外，还有前哨节点。Sentinel模式旨在提高主从节点和sentinel模式的恢复能力。每个节点都知道谁是主节点，并在回退情况下自动升级新的主节点。</p><p id="add3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哨兵模式使用<strong class="ih hj">法定人数系统</strong>来提供主提升流程。仲裁是指分配新主机所需的最小节点数。仲裁数量可以根据您的Redis哨兵设计(主人或奴隶的数量-哨兵的数量等)和您的资源进行更改。哨点监控、分析和报告群集。如果主节点关闭，它会在其他节点之间创建一个连接，并分配一个新的主节点。或者它会从群集中提取不正常的应用程序，并在运行正常时将其重新连接到群集。</p><p id="0d28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最后一种模式，集群模式，通过多主机配置提供了弹性和可扩展性功能。</strong>被认为是一个主人，N个奴隶。主节点负责所有的写操作，从节点只是只读的。这减少了主节点上的流量，并防止了读取操作的延迟。</p><p id="64bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在集群模式下，数据被分成16k个存储桶。每个存储桶分配给一个主存储桶，至少复制两次。在群集模式下，每个节点可以是主节点，也可以是副本节点。对于一个高度可用和稳定的集群结构，必须至少有6个节点(其中3个必须是主节点，3个必须是从节点),因此如果您想在集群模式下使用Redis，与其他部署模式相比，您需要更多的资源。</p><p id="af52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，您还必须检查客户端对所选开发语言上的集群模式的支持，因为所有Redis客户端都不支持集群模式。</p><p id="d209" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于本文，我开发了一个支持三种模式的演示项目:独立、sentinel和集群。因此，您可以通过启用相关配置和Redis实用程序类来使用您选择的部署模式。</p><h1 id="ff88" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">从哪里开始？</strong></h1><p id="d5df" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">首先，你必须从<a class="ae jt" href="https://redis.io/download" rel="noopener ugc nofollow" target="_blank"> Redis.io下载页面</a>下载稳定的Redis版本。这个下载页面只适用于<a class="ae jt" rel="noopener" href="/javarevisited/6-free-courses-to-learn-bash-shell-scripting-in-linux-and-unix-a50461ecd4fe"> Unix </a>或<a class="ae jt" rel="noopener" href="/javarevisited/7-best-linux-courses-for-developers-cloud-engineers-and-devops-in-2021-7415314087e1"> Linux </a>分布式计算机。如果你想在Windows机器上安装Redis，你可以使用下面的微软档案页面链接。</p><div class="ky kz ez fb la lb"><a href="https://github.com/MicrosoftArchive/redis/releases" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">microsoftarchive/redis</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">今天就创建您的免费GitHub帐户，订阅这个新版本库，并与50…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">github.com</p></div></div><div class="lk l"><div class="mg l lm ln lo lk lp jn lb"/></div></div></a></div><p id="49ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">redis安装完成后，您可以安装redis-cli包来管理您的Redis集群，并在您的Redis服务器上进行查询。要安装redis-cli，您可以使用以下npm命令:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="6058" class="mm jv hi mi b fi mn mo l mp mq">npm install -g redis-cli</span></pre><p id="e7d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在您的机器上启动一个简单的Redis服务器，您必须转到<strong class="ih hj"> /usr/local/etc </strong>文件夹，执行不带任何参数的<strong class="ih hj"> redis-server </strong>命令。如果运行Redis服务器时不带参数，它会自动在端口6379上创建一个Redis服务器。它使用默认的redis配置，名为redis.conf，位于/usr/local/etc文件夹下。如果一切顺利，您将看到下面的屏幕:)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mr"><img src="../Images/b761238663c9cc33e4916d98805bd015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4I9DrESmkYrru6Kh-QMIw.png"/></div></div></figure><p id="e8d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以使用redis-cli检查Redis的运行状况，也可以使用以下命令:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="bcdb" class="mm jv hi mi b fi mn mo l mp mq">my-pc:etc rootuser$ redis-cli<br/>127.0.0.1:6379&gt; ping<br/>PONG<br/>127.0.0.1:6379&gt;</span></pre><p id="271a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我已经说过的，Redis提供了许多数据结构，如散列、集合、列表、计数和有序集合等。Redis文档告诉您如何使用这些数据结构，以及如何用基本的CRUD操作(设置、获取、更新、删除)来管理数据。例如，如果您在Redis集群上使用散列，那么您可以使用下面的<strong class="ih hj"> hmset </strong>命令将数据添加到散列中:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="45fd" class="mm jv hi mi b fi mn mo l mp mq">hmset student_id name "George" major "Mathematics"</span></pre><p id="3a58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以使用带有student_id参数的<strong class="ih hj"> hmget </strong>命令访问该数据的任何字段，如下所示:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="4bdc" class="mm jv hi mi b fi mn mo l mp mq">hmget student_id name</span></pre><p id="38df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis提供了一系列非常好的命令来管理您的数据。您可以通过以下Redis文档链接获得完整的命令列表:</p><div class="ky kz ez fb la lb"><a href="https://redis.io/commands" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">命令参考- Redis</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">命令信息命令名[命令名...]获取特定Redis命令详细信息的数组</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">redis.io</p></div></div><div class="lk l"><div class="ms l lm ln lo lk lp jn lb"/></div></div></a></div><h1 id="0754" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何用Java使用Redis？</h1><p id="00d5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果您想在Java中使用Redis，您必须从<a class="ae jt" href="https://redis.io/clients#java" rel="noopener ugc nofollow" target="_blank"> Redis clients页面</a>中检查建议的Redis客户端。有一堆开源的Redis Java客户端，但其中有三个是Redis社区推荐的:Jedis、莴苣、Redisson。</p><p id="11c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我的演示项目，我需要使用多个Redis模式，独立、sentinel和集群。因为Jedis支持所有这些模式，所以我选择Jedis作为我的Java客户端。另外，其他两个推荐的客户端支持这三种模式，所以您也可以在您的应用程序中使用它们。我没有试过其他客户，所以我无法比较。</p><p id="2890" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在Spring boot项目上使用Jedis，您必须添加<a class="ae jt" rel="noopener" href="/javarevisited/6-best-maven-courses-for-beginners-in-2020-23ea3cba89"> Maven </a>或<a class="ae jt" rel="noopener" href="/javarevisited/5-best-gradle-courses-and-books-to-learn-in-2021-93f49ce8ff8e"> Gradle </a>依赖项，如下所示:</p><h2 id="61ff" class="mm jv hi bd jw mt mu mv ka mw mx my ke iq mz na ki iu nb nc km iy nd ne kq nf bi translated">maven--&gt;</h2><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="a792" class="mm jv hi mi b fi mn mo l mp mq">&lt;dependency&gt;<br/>   &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br/>   &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="c858" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Gradle-&gt;T7】</strong></p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="b895" class="mm jv hi mi b fi mn mo l mp mq">compile group: 'redis.clients', name: 'jedis'</span></pre><p id="f5fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用Jedis，你必须用一个<strong class="ih hj"> JedisPool </strong>对象初始化一个Jedis池。您可以将Redis特定的连接配置作为配置添加到Jedis池中。我将为三种Redis模式使用相同的连接配置，因此我创建了一个抽象类，称为RedisConfiguration，它创建了一个简单的Jedis池配置，该配置是从<a class="ae jt" rel="noopener" href="/javarevisited/top-10-free-interactive-programming-courses-from-educative-for-beginners-to-learn-in-2021-713cbf96d4eb">generic Java</a><strong class="ih hj">GenericObjectPoolConfig</strong>类扩展而来的，如下所示:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="1789" class="mm jv hi mi b fi mn mo l mp mq">public abstract class RedisConfiguration {<br/><br/>    public JedisPoolConfig getJedisPoolConfig(){<br/><br/>        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();<br/><br/>        jedisPoolConfig.setBlockWhenExhausted(false); <br/>        jedisPoolConfig.setMaxIdle(15);  <br/>        jedisPoolConfig.setMinIdle(1);  <br/>        jedisPoolConfig.setMaxTotal(20); <br/><br/>        return jedisPoolConfig;<br/>    }<br/>}</span></pre><p id="ba16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个参数<strong class="ih hj">“blockWhenExchausted”</strong>设置为false，以便当客户端尝试请求连接并且没有Redis服务器可用时，触发客户端返回错误。<strong class="ih hj">“MaxIdle”</strong>属性表示池的最大空闲(由应用程序使用并在池中等待使用)连接数。该属性的默认值是8，但是我们将它设置为15，以允许更多的客户端连接到该池。<strong class="ih hj"> "MinIdle" </strong>属性定义使池工作的最小空闲连接数。默认值为0，但是您可以像上面的示例一样更改该值。您可以使用<strong class="ih hj">“max total”</strong>属性来限制总连接数(空闲+已用)。</p><p id="391f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将这个配置池用于所有的Redis模式，但是您可以为不同的Redis模式创建不同的配置。然后，我用不同的配置类创建了Jedis池和Jedis集群对象配置:</p><ul class=""><li id="bb55" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">再孤立配置</li><li id="6cdc" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">重新感知配置</li><li id="e932" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">rediscluster配置</li></ul><p id="2939" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于独立配置，我们使用池配置创建了一个JedisPool对象，我们在上面定义的池配置如下:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="a2ee" class="mm jv hi mi b fi mn mo l mp mq">JedisPoolConfig jedisPoolConfig = getJedisPoolConfig();<br/><br/><br/>return new JedisPool(jedisPoolConfig,<br/>        appConf.getRedis().getStandalone().getHost(),<br/>        appConf.getRedis().getStandalone().getPort(),<br/>        appConf.getRedis().getStandalone().getTimeout());</span></pre><p id="1d1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从应用程序配置文件中设置主机、端口和超时值。我们使用端口6379在本地主机上启动Redis服务器，并将超时值设置为3秒，如下所示:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="7f17" class="mm jv hi mi b fi mn mo l mp mq">redis.standalone.host= localhost<br/>redis.standalone.port= 6379<br/>redis.standalone.timeout = 3000</span></pre><p id="45af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于sentinel配置，我们创建了一个<strong class="ih hj"> JedisSentinelPool </strong>对象，类似于独立配置中的<strong class="ih hj"> JedisPool </strong>对象。对于sentinel模式，我们在端口5000、5001、5002中创建了三个sentinel节点。JedisSentinelPool对象创建过程实现如下:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="bd4b" class="mm jv hi mi b fi mn mo l mp mq">@Bean<br/>public JedisSentinelPool getJedisSentinel(){<br/><br/>    String[] sentinelNodes = appConf.getRedis().getSentinel().getHost().split(";");<br/><br/>    Set sentinels = new HashSet&lt;&gt;();<br/><br/><br/>    for(String sentinelNode : sentinelNodes){<br/><br/>        if(sentinelNode!= null &amp;&amp;<br/>                !sentinelNode.isEmpty()){<br/>            sentinels.add(sentinelNode);<br/><br/>        }<br/><br/>    }<br/><br/>    JedisPoolConfig jedisPoolConfig = getJedisPoolConfig();<br/><br/>    return new JedisSentinelPool("mymaster",sentinels,jedisPoolConfig,appConf.getRedis().getSentinel().getTimeout());<br/><br/>}</span></pre><p id="6feb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从application.configuration逐一添加了所有主机，超时值也来自配置文件:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="763c" class="mm jv hi mi b fi mn mo l mp mq">redis.sentinel.host= 127.0.0.1:5000;127.0.0.1:5001;127.0.0.1:5002<br/>redis.sentinel.timeout = 3000</span></pre><p id="037a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">集群模式配置与独立和sentinel配置略有不同。集群模式有自己的池结构，而不是创建池对象，因此我们可以创建一个简单的JedisCluster对象来连接Redis集群:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="4b24" class="mm jv hi mi b fi mn mo l mp mq">@Bean<br/>public JedisCluster getJedisCluster(){<br/><br/>    String[] clusterNodes = appConf.getRedis().getCluster().getHost().split(";");<br/><br/><br/>    Set&lt;HostAndPort&gt; clusters = new HashSet&lt;&gt;();<br/><br/><br/>    for(String clusterNode : clusterNodes){<br/><br/>        if(clusterNode!= null &amp;&amp;<br/>                !clusterNode.isEmpty()){<br/><br/>            String[] clusterNodeEndpoint = clusterNode.split(":");<br/><br/>            if(clusterNodeEndpoint.length == 2)<br/>                clusters.add(new HostAndPort(clusterNodeEndpoint[0],Integer.parseInt(clusterNodeEndpoint[1])));<br/><br/>        }<br/><br/>    }<br/><br/>    JedisPoolConfig jedisPoolConfig = getJedisPoolConfig();<br/><br/>    return new JedisCluster(clusters,<br/>            appConf.getRedis().getCluster().getTimeout(),<br/>            appConf.getRedis().getCluster().getTimeout(),jedisPoolConfig);<br/><br/><br/>}</span></pre><p id="64e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经用HostAndPort对象分别分配了集群节点。我们创建了6个节点(其中3个是主节点，3个是从节点)，端口从7000到7005。此外，与其他配置不同，我们将套接字超时值设置为3秒。我们还像其他配置一样添加了池配置，以覆盖Redis集群的默认池机制。我们从应用程序配置文件中获取如下配置参数:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="b9c6" class="mm jv hi mi b fi mn mo l mp mq">redis.cluster.host= 127.0.0.1:7000;127.0.0.1:7001;127.0.0.1:7002;127.0.0.1:7003;127.0.0.1:7004;127.0.0.1:7005<br/>redis.cluster.timeout = 3000</span></pre><p id="79ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在演示项目中使用所有三种模式。为此，您需要将ActiveRedisMode属性设置为所需的模式，如下所示:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="2013" class="mm jv hi mi b fi mn mo l mp mq"># Redis Modes -&gt; standalone,sentinel,cluster<br/><br/>activeRedisMode= standalone</span></pre><p id="0cd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建一个独立的Redis服务器，转到<strong class="ih hj"> /usr/local/etc </strong>文件夹并执行<strong class="ih hj"> redis-server </strong>命令。对于sentinel Redis模式，您可以遵循以下Redis文档页面上的说明:</p><div class="ky kz ez fb la lb"><a href="https://redis.io/topics/sentinel" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">Redis哨兵文件</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">Redis Sentinel为Redis提供了高可用性。实际上，这意味着使用Sentinel您可以创建一个…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">redis.io</p></div></div><div class="lk l"><div class="ng l lm ln lo lk lp jn lb"/></div></div></a></div><p id="1d98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建包含6个集群节点的Redis集群，可以遵循Redis页面上的集群文档:</p><div class="ky kz ez fb la lb"><a href="https://redis.io/topics/cluster-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">Redis集群教程- Redis</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">这份文件是一个温和的介绍Redis集群，这并没有使用难以理解的概念…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">redis.io</p></div></div><div class="lk l"><div class="nh l lm ln lo lk lp jn lb"/></div></div></a></div><p id="717d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我的演示项目，我创建了一个简单的名为Student的POJO类。我想用Redis " <strong class="ih hj"> hash" </strong>对象存储Redis中的所有学生，我还需要用基本的CRUD操作管理学生。为此，我们创建了一个名为“<strong class="ih hj"> RedisCacheManager”的单一接口。</strong>我们向管理器类添加了以下功能:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="a855" class="mm jv hi mi b fi mn mo l mp mq">public interface RedisCacheManager {<br/><br/>    StudentCacheObject getObjectFromHashWithKey(String key);<br/><br/>    String getSingleFieldFromHashWithKey(String key, String valueType);<br/><br/>    void updateObjectInHashWithKey(String key, StudentCacheObject studentCacheObject);<br/><br/>    void setNewObjectToHashWithKey(StudentCacheObject studentCacheObject);<br/><br/>    void removeSingleValueFromHashWithKey(String key, String removedType);<br/><br/>    void removeObjectFromHashWithKey(String key);<br/><br/>    List&lt;StudentCacheObject&gt; getAllObjects();<br/><br/>}</span></pre><p id="fb84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前两种方法是经典的get操作。第一种方法返回Student hash对象中的所有对象字段，而第二种方法只返回Student的所需字段，如email和GPA等。Redis散列对象上的任何get操作都是通过使用<strong class="ih hj"> "hget" </strong>或"<strong class="ih hj"> hgetall" </strong>命令来完成的。如果你想到达一个散列对象中的单个字段，你必须使用<strong class="ih hj">“hget”</strong>命令。另一方面，必须使用<strong class="ih hj"> "hgetall" </strong>命令从hash对象中获取所有字段。我们为所有三个Redis模式管理器类定义了这两个对象，如下面的代码片段所示:(RedisStandaloneCacheManager，RedisSentinelCacheManager，RedisClusterCacheManager)</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="f57c" class="mm jv hi mi b fi mn mo l mp mq">public StudentCacheObject getObjectFromHashWithKey(String key) {<br/>    Map&lt;String, String&gt; redisMap = redisClient.hgetAll(key);<br/>    ObjectMapper mapper = new ObjectMapper();<br/><br/>    return mapper.convertValue(redisMap, StudentCacheObject.class);<br/>}<br/><br/>public String getSingleFieldFromHashWithKey(String key, String valueType) {<br/>    return redisClient.hget(key, valueType);<br/>}</span></pre><p id="5578" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时我们需要更新数据库<a class="ae jt" rel="noopener" href="/javarevisited/8-free-oracle-database-and-sql-courses-for-beginners-f4e9b25b33c4">中某个对象的某些字段。对于这些类型的操作，我们可以使用更新操作。在Redis散列数据结构中，没有独特的更新方法。我们使用<strong class="ih hj"> "hmset" </strong>命令用期望的参数更新已经定义的对象。<strong class="ih hj">" updateObjectInHashWithKey "</strong>方法提供使用Key更新Student hash对象中的任何字段:</a></p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="4809" class="mm jv hi mi b fi mn mo l mp mq">public void updateObjectInHashWithKey(String key, StudentCacheObject studentCacheObject) {<br/><br/>    if (studentCacheObject == null)<br/>        throw new IllegalArgumentException("[(updateObjectInHashWithKey)] Student object cannot be null");<br/><br/>    if (key == null)<br/>        throw new IllegalArgumentException("[(updateObjectInHashWithKey)] Key cannot be null");<br/><br/>    Map&lt;String, String&gt; studentObjectMap = convertStudentObjectToMapObject(studentCacheObject);<br/><br/>    redisClient.hmset(key, studentObjectMap);<br/>}</span></pre><p id="5f47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经典API中另一个最常用的操作是插入或添加操作。<br/>“setNewObjectToHashWithKey”方法用于添加一个新的学生对象，其参数在Redis中定义。<strong class="ih hj">“hm set”</strong>命令用于在Redis中添加一个新的对象到hash中。<br/>我们实施了如下操作:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="d1cb" class="mm jv hi mi b fi mn mo l mp mq">public void setNewObjectToHashWithKey(StudentCacheObject studentCacheObject) {<br/><br/>    if (studentCacheObject == null)<br/>        throw new IllegalArgumentException("[(setNewObjectToHashWithKey)] Student object cannot be null");<br/><br/>    if (studentCacheObject.getStudentId() == null)<br/>        throw new IllegalArgumentException("[(setNewObjectToHashWithKey)] Student id cannot be null");<br/><br/>    Map&lt;String, String&gt; studentObjectMap = convertStudentObjectToMapObject(studentCacheObject);<br/><br/>    redisClient.hmset(studentCacheObject.getStudentId(), studentObjectMap);<br/><br/>}</span></pre><p id="f64e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您可以向Redis添加一个新对象，那么您应该能够随时删除它。或者您可能想要移除对象的单个区域。可以用Redis中的<strong class="ih hj"> "hdel" </strong>命令从对象中删除一个字段或字段列表。以下两个流程完全满足这一需求:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="c2c7" class="mm jv hi mi b fi mn mo l mp mq">public void removeSingleValueFromHashWithKey(String key, String removedType) {<br/><br/>    redisClient.hdel(key, removedType);<br/>}<br/><br/>public void removeObjectFromHashWithKey(String key) {<br/><br/>    redisClient.hdel(key, "studentId", "name", "email", "major", "gpa");<br/>}</span></pre><p id="fabb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个方法，<strong class="ih hj">“getAllObjects”</strong>是另一个get操作，它逐个返回Redis中的所有学生对象。对于这个过程，我们首先使用<strong class="ih hj">“keys”</strong>命令获取Redis服务器上的所有密钥。然后我们使用<strong class="ih hj">“hgetall”</strong>命令获取Redis hash对象的所有字段。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="5407" class="mm jv hi mi b fi mn mo l mp mq">public List&lt;StudentCacheObject&gt; getAllObjects() {<br/><br/>    List&lt;StudentCacheObject&gt; studentCacheObjectList = new ArrayList&lt;&gt;();<br/><br/>    Set&lt;String&gt; keys = redisClient.keys("*");<br/>    if (!CollectionUtils.<em class="ni">isEmpty</em>(keys)) {<br/>        for (String key : keys) {<br/><br/>            Map&lt;String, String&gt; redisObjectMap = redisClient.hgetAll(key);<br/><br/>            ObjectMapper mapper = new ObjectMapper();<br/><br/>            studentCacheObjectList.add(mapper.convertValue(redisObjectMap, StudentCacheObject.class));<br/>        }<br/><br/>        return studentCacheObjectList;<br/>    }<br/><br/>    return null;<br/>}</span></pre><p id="333d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于演示应用程序，我们还创建了一个<a class="ae jt" href="https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html" rel="noopener ugc nofollow" target="_blank">控制器类</a>来测试我们的Redis散列功能。StudentController类可以用不同的Redis模式测试所有这些方法。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="8cdd" class="mm jv hi mi b fi mn mo l mp mq">@PostMapping("/addNewStudent")<br/>public String addNewStudent(StudentCacheObject studentCacheObject) {<br/><br/>    redisCacheManager.setNewObjectToHashWithKey(studentCacheObject);<br/><br/>    return "OK";<br/>}<br/><br/><br/>@GetMapping("/getStudentInfo")<br/>public StudentCacheObject getStudentInfo(@RequestParam String studentId) {<br/><br/>    StudentCacheObject studentCacheObject = redisCacheManager.getObjectFromHashWithKey(studentId);<br/><br/>    if(studentCacheObject.getStudentId() == null)<br/>        throw new NullPointerException("Student does not exist on system.");<br/><br/>    return studentCacheObject;<br/>}<br/><br/>@GetMapping("/getStudentSingleField")<br/>public String getStudentSingleField(@RequestParam String studentId,@RequestParam String fieldType) {<br/><br/>    return redisCacheManager.getSingleFieldFromHashWithKey(studentId,fieldType);<br/><br/>}<br/><br/>@GetMapping("/getAllStudents")<br/>public List&lt;StudentCacheObject&gt; getAllStudents(){<br/><br/>    return redisCacheManager.getAllObjects();<br/><br/>}<br/><br/>@PutMapping("/updateStudentInfo")<br/>public String updateStudentInfo(@RequestParam String studentId,<br/>                                StudentCacheObject studentCacheObject) {<br/><br/>    redisCacheManager.updateObjectInHashWithKey(studentId, studentCacheObject);<br/><br/>    return "OK";<br/><br/>}<br/><br/>@DeleteMapping("/removeStudent")<br/>public String removeStudent(@RequestParam String studentId) {<br/><br/>    redisCacheManager.removeObjectFromHashWithKey(studentId);<br/><br/>    return "OK";<br/>}</span></pre><h1 id="c209" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="c2c6" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Redis是数据库世界中非常快速的内存数据存储。使用Redis和类似的数据存储，可以横向扩展数据库并提高数据性能。</p><p id="4589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis根据您的需求和资源为您提供不同的分销模式。您可以使用Redis作为基本的数据存储，缓存您经常访问的数据，以便进行更强大、更快速的数据操作和处理。</p><p id="96e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，您可以将Redis视为会话存储、发布/订阅机制、实时社交媒体提要和评论数据结构，甚至游戏排行榜功能的替代数据存储解决方案。</p><p id="73ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis支持许多不同的数据结构，从简单的散列对象到计数器对象。你可以在许多操作系统上使用Redis Unix、<a class="ae jt" rel="noopener" href="/javarevisited/top-10-courses-to-learn-linux-command-line-in-2020-best-and-free-f3ee4a78d0c0"> Linux、</a>甚至Windows(带有微软扩展)。</p><p id="56d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多Redis客户端使得管理许多编程语言的Redis成为可能，如<a class="ae jt" href="https://javarevisited.blogspot.com/2018/01/top-10-udemy-courses-for-java-and-web-developers.html" rel="noopener ugc nofollow" target="_blank"> Java </a>、<a class="ae jt" rel="noopener" href="/javarevisited/9-free-c-c-sharp-courses-and-tutorials-for-beginners-and-intermediate-programmers-best-of-lot-dc8c793aab31?source=---------16------------------"> C # </a>、<a class="ae jt" rel="noopener" href="/javarevisited/8-advanced-python-programming-courses-for-intermediate-programmer-cc3bd47a4d19"> Python </a>和<a class="ae jt" rel="noopener" href="/javarevisited/top-10-online-courses-to-learn-node-js-in-depth-8ef0e31ca139"> Node.js </a>等</p><p id="4acb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis很好学，文档和社区真的很强大，与日俱增。Redis实验室还为Redis提供开源和企业解决方案。</p><p id="cdd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在Node.js应用程序上使用Redis作为高可用的数据存储解决方案，并强烈推荐Redis您尝试在您的后端和前端系统中满足您的数据存储需求。</p></div><div class="ab cl nj nk gp nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hb hc hd he hf"><p id="7655" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码在<a class="ae jt" href="https://github.com/justayar/SpringBootTemplates/tree/master/redis" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Github </strong> </a>上有。</p></div></div>    
</body>
</html>