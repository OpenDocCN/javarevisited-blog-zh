<html>
<head>
<title>SOLID Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的原则</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/solid-principles-9693dc6b73b8?source=collection_archive---------0-----------------------#2022-04-21">https://medium.com/javarevisited/solid-principles-9693dc6b73b8?source=collection_archive---------0-----------------------#2022-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0821" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用代码示例复习。</h2></div><h1 id="30cf" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">介绍</h1><p id="4d22" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">SOLID是一个软件开发原则，它是构建软件时要遵循的指导方针，以使软件更容易扩展和维护。他们因罗伯特·c·马丁而出名。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/07/10-object-oriented-design-principles.html"><div class="er es km"><img src="../Images/2f7a751fc6b28be1055de4f06e691b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEvB69AvTojn3sqnJbzseA.png"/></div></a></figure><p id="2f03" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">这些原则概述了设计软件的最佳实践，同时考虑了项目的长期维护和扩展。采用这些技术还可以帮助一个人避免代码味道，重构自己的代码，并设计敏捷或适应性软件。</p><p id="a9bb" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">实心代表:</p><ul class=""><li id="9363" class="kz la hi jr b js ku jv kv jy lb kc lc kg ld kk le lf lg lh bi translated">S —单一责任原则(<a class="ae kl" href="https://javarevisited.blogspot.com/2017/04/single-responsibility-principle-example.html" rel="noopener ugc nofollow" target="_blank"> SRP </a></li><li id="6ca7" class="kz la hi jr b js li jv lj jy lk kc ll kg lm kk le lf lg lh bi translated">O —开闭原理(<a class="ae kl" href="https://javarevisited.blogspot.com/2015/07/strategy-design-pattern-and-open-closed-principle-java-example.html" rel="noopener ugc nofollow" target="_blank"> OCP </a>)</li><li id="1b58" class="kz la hi jr b js li jv lj jy lk kc ll kg lm kk le lf lg lh bi translated">李斯科夫替代原理</li><li id="6071" class="kz la hi jr b js li jv lj jy lk kc ll kg lm kk le lf lg lh bi translated">I —接口隔离原则(ISP)</li><li id="3198" class="kz la hi jr b js li jv lj jy lk kc ll kg lm kk le lf lg lh bi translated">d——依赖性反转原理(DIP)</li></ul><blockquote class="ln"><p id="5984" class="lo lp hi bd lq lr ls lt lu lv lw kk dx translated">扎实的原则相辅相成，共同努力，达到设计良好的软件的共同目的。</p></blockquote><h1 id="3d8b" class="ix iy hi bd iz ja jb jc jd je jf jg jh io lx ip jj ir ly is jl iu lz iv jn jo bi translated">单一责任原则</h1><blockquote class="ma mb mc"><p id="f651" class="jp jq md jr b js ku ij ju jv kv im jx me kw ka kb mf kx ke kf mg ky ki kj kk hb bi translated">每个软件组件应该有且只有一个职责。</p></blockquote><p id="3f8f" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">这里的组件可以是Java类、方法或模块。如果我们考虑瑞士刀和普通刀，传统刀坚持SRP，因为它只有一个责任。</p><h2 id="5de7" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">内聚力</h2><p id="3759" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">内聚性是一个软件组件的各个部分是如何相互关联的。更高的凝聚力有助于更好地坚持单一责任原则</p><p id="bb97" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">Below Circle类的calculateArea()方法和calculatePerimeter()方法的内聚性很高，而它与drawCircle()和fillCircle()方法的内聚性很低。</p><pre class="kn ko kp kq fd mv mw mx my aw mz bi"><span id="fb2e" class="mh iy hi mw b fi na nb l nc nd">public class Circle {<br/>    private int radius;<br/><br/>    public int calculateArea(){}<br/><br/>    public int calculatePerimeter(){}<br/><br/>    public void drawCircle(){}<br/><br/>    public void fillCircle(){}<br/>}</span></pre><p id="d83f" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">因此，需要将这些方法放在不同的类中，如下所示。</p><pre class="kn ko kp kq fd mv mw mx my aw mz bi"><span id="2a94" class="mh iy hi mw b fi na nb l nc nd">// Responsibility - Measurements of the Circle</span><span id="ea60" class="mh iy hi mw b fi ne nb l nc nd">public class Circle {<br/>    private int radius;<br/><br/>    public int calculateArea(){}<br/><br/>    public int calculatePerimeter(){}<br/>}<br/><br/>// Responsibility - Rendering the circle</span><span id="8e18" class="mh iy hi mw b fi ne nb l nc nd">public class CircleUI {<br/>    public void drawCircle(){}<br/><br/>    public void fillCircle(){}<br/>}</span></pre><h2 id="dbc9" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">连接</h2><p id="be05" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">耦合被定义为各种软件组件之间的相互依赖程度。松散耦合有助于更好地坚持单一责任原则。</p><h2 id="707d" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">鲍勃大叔对SRP的最新定义</h2><p id="cb49" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">每个软件组件都应该有且只有一个改变的理由。</p><p id="2566" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">改变的理由更多→未来的改变更多bugs数量更多→花的钱更多。</p><h1 id="ea40" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">开闭原则(OCP)</h1><blockquote class="ma mb mc"><p id="4198" class="jp jq md jr b js ku ij ju jv kv im jx me kw ka kb mf kx ke kf mg ky ki kj kk hb bi translated">软件组件对于修改应该是封闭的，但是对于扩展应该是开放的。</p></blockquote><h2 id="09fc" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">关闭以进行修改</h2><p id="9992" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">软件组件中增加了新的特性；您不必修改现有的代码。</p><h2 id="838b" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">开放供扩展</h2><p id="dabf" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">一个软件组件应该是可扩展的，可以添加新的特性或新的行为。</p><p id="9103" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">如果我们不遵循开闭原则，我们需要修改现有的代码，然后QE团队需要用完全回归测试新老特性。它也可能在当前特性中引入错误。</p><h1 id="c84b" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">利斯科夫替代原理</h1><blockquote class="ma mb mc"><p id="8507" class="jp jq md jr b js ku ij ju jv kv im jx me kw ka kb mf kx ke kf mg ky ki kj kk hb bi translated">对象应该可以用它们的子类型替换，而不影响程序的正确性。</p></blockquote><p id="8cd7" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">未实现的方法几乎总是被认为是设计缺陷。有两种方法可以解决这个问题:</p><ol class=""><li id="480e" class="kz la hi jr b js ku jv kv jy lb kc lc kg ld kk nf lf lg lh bi translated">打破等级制度</li><li id="65db" class="kz la hi jr b js li jv lj jy lk kc ll kg lm kk nf lf lg lh bi translated">告诉，不要问。</li></ol><h2 id="91db" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">打破等级制度</h2><p id="3a60" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">传统上，继承是用“是-A”的思维方式来处理的。Liskov希望摆脱创建接口的“是-A”方法。</p><p id="00e8" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">f1赛车是汽车的一种。因此，在实现一级方程式赛车时，应该能够扩展赛车类。</p><pre class="kn ko kp kq fd mv mw mx my aw mz bi"><span id="2166" class="mh iy hi mw b fi na nb l nc nd">public class Car {<br/><br/>    public double getCabinWidth() {<br/>        // Implementation<br/>    }<br/>}<br/><br/>public class F1Car extends Car {<br/><br/>    @Override<br/>    public double getCabinWidth() {<br/>        // UNIMPLEMENTED<br/>    }<br/><br/>    public double getCockpitWidth() {<br/>        // Return Cockpit width<br/>    }<br/>}<br/><br/>public class CarUtils {<br/>    public static void main(String [] args) {<br/>        Car Audi = new Car();<br/>        Car Merc = new Car();<br/>        Car FerrariF1 = new F1Car();<br/><br/>        List &lt;Car&gt; cars = new ArrayList&lt;&gt;();<br/>        cars.add(Audi);<br/>        cars.add(Merc);<br/>        cars.add(FerrariF1);<br/><br/>        for(Car car : cars) {<br/>            car.getCabinWidth();<br/>        }<br/>    }<br/>}</span></pre><p id="b47c" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">上面的代码片段不起作用，因为F1Car没有实现getCabinWidth()方法。它只有getCockpitWidth()。利斯科夫的测试失败了。这个问题可以通过<strong class="jr hj"> <em class="md">打破层级</em> </strong>用更抽象的getInteriorWidth()方法引入车辆接口来解决。</p><pre class="kn ko kp kq fd mv mw mx my aw mz bi"><span id="bf91" class="mh iy hi mw b fi na nb l nc nd">public interface Vehicle {<br/>    public double getInteriorWidth();<br/>}<br/><br/>public class Car implements Vehicle {<br/><br/>    private double getCabinWidth() {<br/>        // Implementation<br/>    }<br/><br/>    @Override<br/>    public double getInteriorWidth() {<br/>        return this.getCabinWidth();<br/>    }<br/>}<br/><br/>public class F1Car implements Vehicle{<br/><br/>    private double getCockpitWidth() {<br/>        // Return Cockpit width<br/>    }<br/><br/>    @Override<br/>    public double getInteriorWidth() {<br/>        return this.getCockpitWidth();<br/>    }<br/>}</span></pre><h2 id="e984" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">告诉，不要问</h2><p id="9abc" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">下面的代码片段<strong class="jr hj"> <em class="md">询问</em> </strong>对象类型。相反，它应该<strong class="jr hj"> <em class="md">告诉</em> </strong>获取interiorWidth()的方法。如果一个人能像上面的代码那样重构，他/她就能遵守里斯科夫替代原则。</p><pre class="kn ko kp kq fd mv mw mx my aw mz bi"><span id="cdf1" class="mh iy hi mw b fi na nb l nc nd">public class CarUtils {<br/>    public static void main(String [] args) {<br/>        Car Audi = new Car();<br/>        Car Merc = new Car();<br/>        Car FerrariF1 = new F1Car();<br/><br/>        List &lt;Car&gt; cars = new ArrayList&lt;&gt;();<br/>        cars.add(Audi);<br/>        cars.add(Merc);<br/>        cars.add(FerrariF1);<br/><br/>        for(Car car : cars) {<br/>            if (car instanceof F1Car) {<br/>                ((F1Car) car).getCockpitWidth();<br/>            } else {<br/>                car.getCabinWidth();<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="5650" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">接口隔离原则(ISP)</h1><blockquote class="ma mb mc"><p id="827c" class="jp jq md jr b js ku ij ju jv kv im jx me kw ka kb mf kx ke kf mg ky ki kj kk hb bi translated">不应该强迫任何客户端依赖它不使用的方法</p></blockquote><p id="fe38" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">下面的代码片段有许多未实现的方法。</p><pre class="kn ko kp kq fd mv mw mx my aw mz bi"><span id="85d7" class="mh iy hi mw b fi na nb l nc nd">public interface MultiFuncMachine {<br/><br/>    public void print();<br/>    public void scan();<br/>    public void copy();<br/>    public void fax();<br/>    public void reset();<br/>}<br/><br/>public class Scanner implements MultiFuncMachine{<br/><br/>    @Override<br/>    public void print() {<br/>        // UNIMPLEMENTED<br/>    }<br/><br/>    @Override<br/>    public void scan() {<br/>    }<br/><br/>    @Override<br/>    public void copy() {<br/>        // UNIMPLEMENTED<br/>    }<br/><br/>    @Override<br/>    public void fax() {<br/>        // UNIMPLEMENTED<br/>    }<br/><br/>    @Override<br/>    public void reset() {<br/>    }<br/>}</span></pre><p id="8f70" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">这个问题的解决方案是如下隔离接口。</p><pre class="kn ko kp kq fd mv mw mx my aw mz bi"><span id="1097" class="mh iy hi mw b fi na nb l nc nd">public interface IScan {<br/>    public void scan();<br/>}<br/><br/>public class Scanner implements IScan{<br/><br/>    @Override<br/>    public void scan() {<br/><br/>    }<br/>}</span></pre><h2 id="bce8" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">识别违反ISP的技术</h2><ol class=""><li id="bab3" class="kz la hi jr b js jt jv jw jy ng kc nh kg ni kk nf lf lg lh bi translated">胖接口</li><li id="da44" class="kz la hi jr b js li jv lj jy lk kc ll kg lm kk nf lf lg lh bi translated">低内聚力的界面</li><li id="cd22" class="kz la hi jr b js li jv lj jy lk kc ll kg lm kk nf lf lg lh bi translated">空方法实现</li></ol><h1 id="6195" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">从属倒置原则</h1><blockquote class="ma mb mc"><p id="9c8f" class="jp jq md jr b js ku ij ju jv kv im jx me kw ka kb mf kx ke kf mg ky ki kj kk hb bi translated">高级模块不应该依赖于低级方法。两者都应该依赖于抽象。</p><p id="986d" class="jp jq md jr b js ku ij ju jv kv im jx me kw ka kb mf kx ke kf mg ky ki kj kk hb bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</p></blockquote><figure class="kn ko kp kq fd kr er es paragraph-image"><a href="https://javarevisited.blogspot.com/2012/12/inversion-of-control-dependency-injection-design-pattern-spring-example-tutorial.html"><div class="er es nj"><img src="../Images/2d2af2e7f98eeef451925bf31684c164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bHfryBcI5rOQkf5toMIH1w.png"/></div></a></figure><p id="7a96" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">上图显示，无论是高层方法ProductCatalog还是低层方法SQLProductRepository，都依赖于抽象— ProductRepository。此外，它表明细节依赖于抽象。</p><h2 id="155c" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">依赖注入</h2><p id="8e1d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">理想情况下，上面的productCatalog不需要担心何时何地实例化对象。因此，主程序会将依赖项注入到productCatalog中，而不是productCatalog实例化依赖项。注入可以使用构造函数来完成。</p><h2 id="43dd" class="mh iy hi bd iz mi mj mk jd ml mm mn jh jy mo mp jj kc mq mr jl kg ms mt jn mu bi translated">控制反转(IOC)</h2><p id="84d7" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这不是依赖倒置原则的一部分。然而与之息息相关。通常，<a class="ae kl" href="https://javarevisited.blogspot.com/2022/02/how-to-fix-autowired-no-qualifying-bean.html" rel="noopener ugc nofollow" target="_blank">依赖注入</a>是通过主控制线程完成的。我们需要将依赖注入到一个独立于主控制线程的线程中。这可以通过框架来实现。<a class="ae kl" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring框架</a>用Spring IoC容器做这件事。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/09/spring-interview-questions-answers-j2ee.html"><div class="er es nk"><img src="../Images/9e12bc97e5cfaf132e045120863233de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1S9pWTtHBrCey1wDdDzKQ.png"/></div></a><p class="nl nm et er es nn no bd b be z dx translated">Spring IoC容器</p></figure><p id="d9d1" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">这涵盖了坚实原则背后的概念和基本原理。</p><p id="abdc" class="pw-post-body-paragraph jp jq hi jr b js ku ij ju jv kv im jx jy kw ka kb kc kx ke kf kg ky ki kj kk hb bi translated">感谢阅读。<br/>编码快乐！</p></div></div>    
</body>
</html>