<html>
<head>
<title>The 5 rules for tuning and improving JVM Garbage Collector performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调整和提高JVM垃圾收集器性能的5条规则</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/the-5-rules-for-tuning-and-improving-jvm-garbage-collector-performance-86ac8d290661?source=collection_archive---------2-----------------------#2022-08-09">https://medium.com/javarevisited/the-5-rules-for-tuning-and-improving-jvm-garbage-collector-performance-86ac8d290661?source=collection_archive---------2-----------------------#2022-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2744" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个参数如何影响您的应用程序性能</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2016/08/10-jvm-options-for-java-production-application.html"><div class="er es ix"><img src="../Images/8e6875d557a93e85f11b01d0394fee4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILZvhB71hFHIJXiQ09TfEg.png"/></div></a><p class="jf jg et er es jh ji bd b be z dx translated">杜克向垃圾收集器扔东西</p></figure><p id="370a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当你在编写一些Java应用程序时，通常我们首先关心的是使用的算法和设计模式。当我开始从<a class="ae kf" rel="noopener" href="/javarevisited/the-java-programmer-roadmap-f9db163ef2c2"> Java开发人员</a>向<a class="ae kf" rel="noopener" href="/javarevisited/13-best-courses-to-learn-devops-for-senior-developers-in-2020-a2997ff7c33c"> SRE角色</a>转变时，我开始发现产品团队中正常软件开发过程中的一些差距，其中之一是生产环境中的应用程序性能。如今，仅仅让你的代码在测试/阶段环境中工作并在主分支中合并你的代码是不够的，我们需要进一步思考:这个应用程序在生产中会如何表现？</p><p id="d530" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Java应用程序崩溃的主要原因之一是糟糕的<a class="ae kf" href="https://javarevisited.blogspot.com/2011/11/hotspot-jvm-options-java-examples.html" rel="noopener ugc nofollow" target="_blank"> JVM参数</a>配置。资源分配并不像看起来那么简单，您应该记住这样的事情:硬件细节(CPU、内存)、用户交互、内存中分配了多少对象以及垃圾收集器策略。根据我自己处理这些情况的经验，我可以总结5条规则来付诸实践，以使您的应用程序更加可靠，并避免由于JVM问题而导致的意外停机。</p><h2 id="b1ab" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">监控资源分配</h2><p id="7d1b" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">听起来显而易见，但事实并非如此。我们非常习惯于只监控HTTP请求的成功率和错误率，但是<a class="ae kf" href="https://javarevisited.blogspot.com/2013/06/find-cpu-and-memory-used-by-java-solaris-prstat-command-example.html" rel="noopener ugc nofollow" target="_blank"> CPU和内存使用</a>对于理解应用程序在服务器/容器内部的行为是至关重要的。</p><p id="9679" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">想象一下，如果您处于云环境中，那么您的纵向扩展策略很可能会因为错误的原因而触发，以防您的pod由于资源分配而开始失败，最终整个应用程序崩溃。好消息是市场上已经有了一些好的JVM监控工具，<a class="ae kf" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686"> JVM </a>也提供了一些支持JVM使用度量的配置。</p><div class="lg lh ez fb li lj"><a href="https://docs.oracle.com/cd/E49461_01/doc.70/e52859/cnf_jvmgc.htm#CASCG805" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hj fi z dy lo ea eb lp ed ef hh bi translated">JVM的监控、调优和故障排除</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">您可以同时运行多个录制，并使用不同的设置配置每个录制；特别是，你…</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">docs.oracle.com</p></div></div></div></a></div><p id="8fb1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您正在处理生产中的一些问题，并且想要开始查看<a class="ae kf" href="https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html" rel="noopener ugc nofollow" target="_blank">垃圾收集</a>进程本身，您也可以启用JVM选项来记录GC活动:</p><pre class="iy iz ja jb fd ls lt lu lv aw lw bi"><span id="584c" class="kg kh hi lt b fi lx ly l lz ma">-Xloggc:&lt;home-dir&gt;\logs\gc-%t.log<br/>-XX:+PrintGCDetails<br/>-XX:+PrintGCDateStamps<br/>-XX:+PrintGCTimeStamps<br/>-XX:+PrintGCCause<br/>-XX:+PrintTenuringDistribution<br/>-XX:+UseGCLogFileRotation<br/>-XX:NumberOfGCLogFiles=10<br/>-XX:GCLogFileSize=5M</span></pre><p id="453c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果检索到的日志在开始看起来很难理解，也不用担心。我们有一个神奇的在线工具叫做<a class="ae kf" href="https://gceasy.io" rel="noopener ugc nofollow" target="_blank"> GCEasy </a>。您只需要上传您的日志文件，该工具将自动将这些见解转化为人类可读的图形，以及您当前的日志统计数据。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2020/02/50-garbage-collection-interview-questions-answers-java.html"><div class="er es mb"><img src="../Images/efb09efe4994011731104d0e9abac02a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oss-gEU9GkmZJShLqKkjdQ.png"/></div></a><p class="jf jg et er es jh ji bd b be z dx translated">GCEasy生成的输出</p></figure><p id="a5c3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">分析GC行为现在更容易了，对吗？</p><h2 id="95d4" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">选择正确的GC策略</h2><p id="3f74" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">如果你认为在<a class="ae kf" href="https://javarevisited.blogspot.com/2012/04/difference-between-java-and-javaw.html" rel="noopener ugc nofollow" target="_blank"> JDK </a>中只有一种垃圾收集策略，那么你是对的……但是只是在Java的早期版本中。随着软件产品越来越复杂，<a class="ae kf" href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html" rel="noopener ugc nofollow" target="_blank"> JVM </a>必须为正确的情况提供正确的选项。</p><p id="d3d1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，默认的GC类型是序列化的。这意味着每次运行时，所有应用程序线程都将停止，直到作业完成，然后恢复应用程序。当你有这么多内存来清理的时候会发生什么？</p><p id="6473" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">是的，很有可能你的垃圾收集过程需要更多的资源，然后你的应用程序就会崩溃。现在我们有一个多线程垃圾收集机制，有助于避免停止所有的应用程序线程。<a class="ae kf" href="https://www.baeldung.com/jvm-garbage-collectors" rel="noopener ugc nofollow" target="_blank">这篇文章很好地解释了</a>每种垃圾收集器类型和用例。</p><p id="8388" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">仅仅通过阅读文档，您不会成为JVM垃圾收集器专家。事实上，你需要弄脏你的手，在你的真实环境中观察和监控所有这些类型的行为，这个规则导致了下一个规则。</p><h2 id="5caf" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">在非生产环境中测试您的配置</h2><p id="2920" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">JVM配置参数对您的应用程序性能有很大的影响，所以请不要在生产中测试它。糟糕的配置或对这些参数如何工作的误解可能会导致比最初更糟糕的问题。</p><p id="e28c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">假设您有一个经常崩溃的应用程序，配置了<code class="du mc md me lt b">xmx8g</code>和<code class="du mc md me lt b">xmx16g</code>。如果只是更新内存设置而不进行分析，甚至会降低垃圾收集的性能，因为<a class="ae kf" href="https://javarevisited.blogspot.com/2016/10/how-to-increase-heap-size-of-eclipse-OutOfMemoryError.html" rel="noopener ugc nofollow" target="_blank">更多的可用内存</a>意味着需要清理更多的内存。让非生产环境获得正确的配置参数并执行适当的压力和性能测试非常重要。</p><p id="44cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我发现许多用户喜欢JMeter进行性能测试，但我个人认为，为特定用例进行配置有点困难，例如<em class="mf">“我需要每10分钟将用户负载增加4倍，然后每15分钟增加6倍”</em>。对于这些场景，我发现加特林更加强大和可伸缩:</p><div class="lg lh ez fb li lj"><a href="https://gatling.io" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hj fi z dy lo ea eb lp ed ef hh bi translated">Gatling -专业负载测试工具</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">Gatling是一个用于web应用程序的负载测试工具，是为DevOps和持续集成设计的。试试加特林吧！</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">加特林. io</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml jd lj"/></div></div></a></div><p id="afff" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我强烈建议将所有的测试场景保存在代码版本控制中，并定期执行它们。这种预防性监控将非常有助于在最终用户之前发现问题。</p><h2 id="4247" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">使用IaC解决方案来长期保持您的配置</h2><p id="3ff4" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">一旦你找到了理想的配置，记住:很容易被覆盖。您必须将配置存储在源代码版本控制工具中，以保持历史更新，并允许您的配置在同一服务的其他环境或实例中轻松复制。试想一下，如果您仅仅因为手动更新而丢失了配置值，您将再次面临同样的问题，所有投入的时间和资源都将浪费。</p><h2 id="9b8b" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">在应用程序级别实施定期清理</h2><p id="3cbb" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">我们现在非常清楚在我们的环境中需要注意JVM行为，但是不要忘记这里的主要组件:应用程序。如果您已经正确地配置了所有的值，您正在监视性能，但仍然发现有问题，让我们退一步思考:为什么我们会面临内存错误？我们的产品真的需要在内存中分配所有这些对象吗？</p><p id="b35c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有时，某个框架的糟糕实现(例如:<a class="ae kf" rel="noopener" href="/javarevisited/8-best-spring-and-hibernate-training-courses-for-java-developers-acf09aa0e244"> Hibernate </a>)会导致内存中断，依赖外部数据存储的应用程序也是如此，比如<a class="ae kf" href="https://javarevisited.blogspot.com/2022/02/top-5-courses-to-learn-elasticsearch.html" rel="noopener ugc nofollow" target="_blank"> Elastic </a>，在索引过程中会消耗大量资源。</p><p id="7e45" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在开发阶段，我们有一些助手方法来帮助JVM优化垃圾收集过程，例如:</p><ul class=""><li id="4824" class="mm mn hi jl b jm jn jp jq js mo jw mp ka mq ke mr ms mt mu bi translated">告诉JVM现在是执行垃圾收集器的好时机。这并不意味着GC会立即执行！</li><li id="0be6" class="mm mn hi jl b jm mv jp mw js mx jw my ka mz ke mr ms mt mu bi translated"><code class="du mc md me lt b"><a class="ae kf" href="https://www.java67.com/2016/06/difference-between-final-vs-finally-vs-finalize-in-java.html" rel="noopener ugc nofollow" target="_blank">finalize()</a></code>:该方法继承自<code class="du mc md me lt b">Object</code>类，用于在GC清理对象时执行一些逻辑。</li></ul><p id="e48a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在运行时，您必须监控使用情况。如果您注意到您的用户正在请求比所需更多的资源，并且您的后端进程变得更慢，那么实现缓存层或清理作业可能有助于减少服务器上的内存负载。</p><p id="40e2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">看一看应用程序开发/使用本身可以为您节省大量的调试时间！</p><p id="6053" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">找到完美的平衡和配置并不容易，你必须记住:一切都是短暂的。现在有意义的配置，明天可能就没有意义了，这就是为什么你需要保持积极地监控你的产品/平台。你知道那些调整JVM的规则吗？你知道其他的吗？欢迎在评论区分享！</p><p id="2b65" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下一篇文章再见！</p></div></div>    
</body>
</html>