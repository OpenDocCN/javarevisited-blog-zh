<html>
<head>
<title>Understanding the Algorithm behind Merge Sort for Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解链表合并排序背后的算法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/understanding-the-algorithm-behind-merge-sort-for-linked-lists-79ef7f6f2f94?source=collection_archive---------2-----------------------#2021-08-07">https://medium.com/javarevisited/understanding-the-algorithm-behind-merge-sort-for-linked-lists-79ef7f6f2f94?source=collection_archive---------2-----------------------#2021-08-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es et"><img src="../Images/2d307c743730f8175179d32f4f56d3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bSuYJt1jMocSW7m-4Sgow.jpeg"/></div></div><p class="ip iq et er es ir is bd b be z dx translated">链表的合并排序</p></figure><h2 id="5457" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">什么是合并排序？</h2><p id="0eb6" class="pw-post-body-paragraph jr js hi jt b ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl hb bi translated"><strong class="jt hj">归并排序</strong>是一种著名的优化排序算法，其工作原理是<a class="ae km" href="https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/" rel="noopener ugc nofollow" target="_blank">分而治之</a>。又称为<a class="ae km" href="https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/" rel="noopener ugc nofollow" target="_blank">分治</a>算法，时间复杂度<strong class="jt hj">为<strong class="jt hj"> O(n*logn)的</strong>。</strong></p><h2 id="ded0" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">它是如何工作的？</h2><p id="fa31" class="pw-post-body-paragraph jr js hi jt b ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl hb bi translated"><strong class="jt hj">合并排序</strong>分两步进行:</p><ul class=""><li id="9bb5" class="kn ko hi jt b ju kp jy kq je kr ji ks jm kt kl ku kv kw kx bi translated">将输入列表分成两个子列表，每个子列表具有相同的大小。</li><li id="f87c" class="kn ko hi jt b ju ky jy kz je la ji lb jm lc kl ku kv kw kx bi translated">将两个子列表合并成一个大列表，列表中的每个元素都是有序/排序的。</li></ul><p id="9efa" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">现在，数组的<a class="ae km" href="https://www.java67.com/2018/03/mergesort-in-java-algorithm-example-and.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hj">合并排序</strong>的工作方式就很容易理解了，对于不知道<strong class="jt hj">合并排序</strong>如何工作的人可以参考这个</a><a class="ae km" href="https://www.geeksforgeeks.org/merge-sort/" rel="noopener ugc nofollow" target="_blank">链接</a></p><figure class="lh li lj lk fd ii er es paragraph-image"><a href="https://www.java67.com/2018/03/mergesort-in-java-algorithm-example-and.html"><div class="er es lg"><img src="../Images/841381ac1ed115214a036eaad2d1f861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61Mf0zjVfd1s3_SzUNGxPA.png"/></div></a><p class="ip iq et er es ir is bd b be z dx translated">合并排序的图形表示</p></figure><p id="7682" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">现在，继续讨论<strong class="jt hj">合并排序</strong>如何为<a class="ae km" rel="noopener" href="/javarevisited/top-20-linked-list-coding-problems-from-technical-interviews-90b64d2df093">链表</a>工作，我们将首先看一看<strong class="jt hj">链表合并排序的简单方法</strong></p><h2 id="58e4" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">方法:</h2><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="2a16" class="it iu hi lm b fi lq lr l ls lt">Step1: Call divideList() and find the mid node of the given linked list and also divide the list into two halves</span><span id="6e45" class="it iu hi lm b fi lu lr l ls lt">Step2: Recursively call sortMerge() on both left and right sub-linked list and store the new head of the left and right linked list.</span><span id="a351" class="it iu hi lm b fi lu lr l ls lt">Step3: Call finalMerge() given the arguments new heads of left and right sub-linked lists and store the final head returned after merging.</span><span id="5c19" class="it iu hi lm b fi lu lr l ls lt">Step4: Return the final head of the sorted linked list.</span></pre><p id="4782" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">在上面的段落中，我们已经讨论了<strong class="jt hj">合并排序</strong>是如何工作的，所以这里我们也以类似的方式首先<a class="ae km" href="https://javarevisited.blogspot.com/2017/03/how-to-reverse-linked-list-in-java-using-iteration-and-recursion.html" rel="noopener ugc nofollow" target="_blank">将链表分成两个子列表</a>，然后递归排序这两个子列表，最后合并它们并返回最终列表。</p><p id="5db0" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">讨论算法，它看起来像这样。</p><h2 id="e949" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">算法:</h2><p id="bf1a" class="pw-post-body-paragraph jr js hi jt b ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl hb bi translated">在第一步<strong class="jt hj">中，如前所述，您必须将列表分成两个子列表，如以下算法所述:</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="ce9d" class="it iu hi lm b fi lq lr l ls lt">start fundtion divideList(headList){<br/>    slowPointer = headList<br/>    fastPointer = next of headList<br/>    <br/>    start while(slowPointer is not NULL and (fastPointer is not NULL and next of fastPointer is not NULL)){<br/>          slowPointer = next of slowPointer<br/>          fastPointer = next of next of fastPointer<br/>    end while</span><span id="ab5f" class="it iu hi lm b fi lu lr l ls lt">    return slowPointer</span><span id="a2d7" class="it iu hi lm b fi lu lr l ls lt">end divideList</span></pre><p id="7d66" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">上述将链表分成两半的算法俗称<a class="ae km" href="https://javarevisited.blogspot.com/2013/05/find-if-linked-list-contains-loops-cycle-cyclic-circular-check.html#axzz5jI43Qiwi" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hj">龟兔算法</strong> </a></p><p id="2888" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">现在，在将列表分成两个子列表后，我们将基于实际的<strong class="jt hj">合并排序</strong>算法对两个子列表中的每一个进行排序，如下面的算法所解释的:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="a670" class="it iu hi lm b fi lq lr l ls lt">start function finalMerge(firstListHead, secondListHead) <br/>    firstHalf = new node<br/>    secondHalf = new node<br/>    <br/>    firsthalf = secondHalf /* points to the head node later after sorting */</span><span id="9e23" class="it iu hi lm b fi lu lr l ls lt">   start while(firstListHead is not NULL &amp;&amp; secondListHead is not NULL){<br/>       start if(data of firstListHead node &lt;= data of secondListHead node)<br/>            next of secondHalf = firstListHead<br/>            firstListHead = next of firstListHead<br/>       end if<br/>       start else</span><span id="2d73" class="it iu hi lm b fi lu lr l ls lt">             next of secondHalf = secondListHead<br/>             secondListHead = next of secondListHead<br/>       end else<br/>       secondHalf = next of secondHalf <br/>   end while</span><span id="c826" class="it iu hi lm b fi lu lr l ls lt">   /* If first list is not over */<br/>   start while(firstListHead is not NULL){<br/>       next of secondHalf = firstListHead<br/>       firstListHead = next of firstListHead<br/>   end while<br/>  <br/>   /* If second list is not over */<br/>   start while(secondListHead is not NULL){<br/>       next of secondHalf - secondListHead<br/>       secondListHead = next of secondListHead<br/>   end while</span><span id="6587" class="it iu hi lm b fi lu lr l ls lt">   return next of firstHalf</span><span id="1dcd" class="it iu hi lm b fi lu lr l ls lt">end sortMerge</span></pre><p id="6c88" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">现在，在对列表进行排序后，我们将不得不最终获得完整排序列表的head引用，这个函数也将帮助我们使用<strong class="jt hj"> divideList() </strong>函数获得对列表前半部分<strong class="jt hj">和后半部分</strong>的引用。<a class="ae km" href="https://javarevisited.blogspot.com/2019/04/top-20-searching-and-sorting-algorithms-interview-questions.html" rel="noopener ugc nofollow" target="_blank">算法</a>看起来像这样:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="e952" class="it iu hi lm b fi lq lr l ls lt">start function sortMerge(headList){<br/>   start if(next of headList is NULL)<br/>        return headList<br/>   end if<br/>   <br/>   midNode = new node<br/>   secondHead = new node<br/>   <br/>   midNode = divideList(headList)<br/>   secondHead = next of midNode<br/>   next of midNode = NULL<br/>   <br/>   finalHead = finalMerge(sortMerge(midNode), sortMerge(secondHead))</span><span id="240d" class="it iu hi lm b fi lu lr l ls lt"><br/>   return finalHead</span><span id="344b" class="it iu hi lm b fi lu lr l ls lt">end sortMerge</span></pre><p id="d506" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">现在，最终，这解释了关于<strong class="jt hj">合并排序</strong>如何为链表工作以及列表如何通过<strong class="jt hj">分治</strong>方法排序的完整算法。</p><p id="f044" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">现在，既然你已经知道了问题背后的<a class="ae km" rel="noopener" href="/javarevisited/20-algorithms-coding-problems-to-crack-you-next-technical-interviews-23191f229788">算法</a>，那么你现在可以用你想要的编程语言编写你自己的功能性<strong class="jt hj">代码</strong>。</p><h2 id="b83f" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">预演:</h2><p id="1e16" class="pw-post-body-paragraph jr js hi jt b ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl hb bi translated">现在，以一个未排序的链表为例来考虑这个算法，并像我在这里所做的那样运行你的测试用例:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lv"><img src="../Images/bff574944f4eae1bd3dfd911b7d5dfe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2dUmhmPvyOxiJMH3NccVA.jpeg"/></div></div><p class="ip iq et er es ir is bd b be z dx translated">图:1.1</p></figure><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/53a8b3cd70f66d4f6e998bc4f7e46af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3y04oLdVJTEIslX4S8OvA.jpeg"/></div></div><p class="ip iq et er es ir is bd b be z dx translated">图1.2</p></figure><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lv"><img src="../Images/994652bf45d3991dba66d37c36e4d9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLIZOAiFtlDlYRTq8SEf7w.jpeg"/></div></div><p class="ip iq et er es ir is bd b be z dx translated">图1.3</p></figure><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/a8beba39b4535b2980df5339adcf9f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qixXz67rAKKqDVpATL8AJw.jpeg"/></div></div><p class="ip iq et er es ir is bd b be z dx translated">图:1.4</p></figure><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/a2c19a4fce0f6b62749c73a2e2a1245e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*riWTwIYGCxi42lM_QBrcLw.jpeg"/></div></div><p class="ip iq et er es ir is bd b be z dx translated">图:1.5</p></figure><p id="0da6" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">现在，你可以很容易地联想到列表是如何被一个接一个地排序的，这会让你更清楚这个算法是如何工作的！！</p><h1 id="a9e6" class="lz iu hi bd iv ma mb mc iz md me mf jd mg mh mi jh mj mk ml jl mm mn mo jp mp bi translated">分析:</h1><ul class=""><li id="280f" class="kn ko hi jt b ju jv jy jz je mq ji mr jm ms kl ku kv kw kx bi translated">时间复杂度:<code class="du mt mu mv lm b">O(nlogn)</code>，其中n是链表中的节点数。</li><li id="f238" class="kn ko hi jt b ju ky jy kz je la ji lb jm lc kl ku kv kw kx bi translated">空间复杂度:<code class="du mt mu mv lm b">O(logn)</code>，其中n是链表中节点的个数。因为我们把列表分成两个子列表，所以我们给定的最终空间复杂度是<code class="du mt mu mv lm b">O(logn)</code></li></ul><p id="9d82" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated"><strong class="jt hj">不断学习，不断成长，不断探索！</strong></p><p id="3daa" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated"><strong class="jt hj">万事如意！</strong></p><p id="002b" class="pw-post-body-paragraph jr js hi jt b ju kp jw jx jy kq ka kb je ld kd ke ji le kg kh jm lf kj kk kl hb bi translated">更多有趣和信息丰富的文章和提示请关注我的<a class="ae km" href="https://swapnilkant11.medium.com/" rel="noopener"> <strong class="jt hj"> Medium </strong> </a> <strong class="jt hj">和</strong><a class="ae km" href="https://www.linkedin.com/in/swapnil-kant-279a3b148/" rel="noopener ugc nofollow" target="_blank"><strong class="jt hj">Linkedin</strong></a></p></div></div>    
</body>
</html>