<html>
<head>
<title>Spring Scheduler — Issues with Load balancing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Scheduler —负载平衡的问题</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-scheduler-issues-with-load-balanced-application-eda92720e3dd?source=collection_archive---------2-----------------------#2021-05-30">https://medium.com/javarevisited/spring-scheduler-issues-with-load-balanced-application-eda92720e3dd?source=collection_archive---------2-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2d30e0edc49e506e37431e4927d42f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mGhHMEuU1j6AXq3v"/></div></div><p class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@bbsody?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克西姆·梅尔尼科夫</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b7ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧！我们都开发过带有调度器方法的应用程序，主要用于处理一些与用户/其他服务交互无关的后台任务。在本文中，我们将研究当您开始使用调度程序水平扩展应用程序时出现的问题。水平缩放也称为<strong class="ix hj"> X轴缩放</strong>。这是为了确保我们的应用程序的高可用性，以防某个节点由于某种未知原因而关闭。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/4e26c5d56b6c8fd622aaf078104fa45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*HHDNPTIxajyWb6p4mLFajw.png"/></div><p class="iq ir et er es is it bd b be z dx translated">Chris Richardson所著的《微服务模式》(第1章:逃离巨大的地狱)一书中对扩展的描述。由曼宁出版。</p></figure><p id="9430" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问题:</strong> <br/>我们的扩展应用程序中的调度流程将并行运行多次(基于实例的数量)。但是，大多数时候，这可能不是我们所期望的。下面是我确保一个预定任务只运行一次的一些思考过程。</p><p id="d5a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">思考过程#1 —有条件地启用调度程序方法:<br/> </strong>一个简单而强力的方法是定义一个新的属性，它将告诉是否启用调度程序。下面的代码片段是一个例子。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/02/difference-between-contextconfiguration-and-springapplicationConfiguration-annotations-in-spring-boot-testing.html"><div class="er es jy"><img src="../Images/2ad1a7eda9a5c31dbd9eac74d4872789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUXgz1-0BjT0Prn09GB1vQ.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">ScheduledTasks.java</p></figure><p id="37c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并使用以下命令启动应用程序。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="5711" class="ke kf hi ka b fi kg kh l ki kj">root@XYZ-$ java -jar -Dis.scheduler.enabled=true my-app.jar</span></pre><p id="ab86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你传入<code class="du kk kl km ka b">true</code>, scheduler方法将为任何其他的字符串执行，传入的schedule将不被执行。<br/>但是，这是有条件地启用特定调度程序的最佳方式吗？答案是<strong class="ix hj">不会！</strong>。上面这种方法的问题是，调度将一直被调用，然后我们手动添加一个条件来启用或禁用。如果我们有多个调度器方法，那么这可能会导致在所有调度器方法中添加If条件的样板代码。<br/>更好的方法是利用<code class="du kk kl km ka b">@ConditionalOnProperty</code>注释，在启动时将调度器对象作为bean注入到<a class="ae iu" href="https://javarevisited.blogspot.com/2018/11/top-20-spring-mvc-interview-questions-answers-for-java-developers.html" rel="noopener ugc nofollow" target="_blank"> spring容器池</a>中。要做到这一点，您需要从scheduler类的顶部删除<code class="du kk kl km ka b">@Component </code>注释。如果你想知道这是如何工作的，这很简单。只有当Spring的容器池中有该方法的实例时，Spring的调度程序才会执行任务。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/68c33a558b1bc6f5cf741cec53c56071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sarb6NXiFCsDD--rD-EFug.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">改良ScheduledTasks.java</p></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/64dd65df2ce01bffe8d21f599f2867ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tok64CmtV7zlJpLGFqZBMA.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">ScheduledTasksConfig.java</p></figure><p id="cf1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，通过这种方式，我们可以确保基于给定的属性启用调度程序。这样，我们可以在一个负载平衡的实例中激活调度程序。但是这种方法存在一些问题。你听说过著名的墨菲定律吗？</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/bb9d59775d9bf448a22aeee3ee082c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*Q6U-ehRvYjqb3p_rJcZuGA.png"/></div><p class="iq ir et er es is it bd b be z dx translated">墨菲定律—图片取自MD+DI</p></figure><p id="d202" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，具有启用调度程序的实例的节点很有可能会关闭，这可能会导致服务连续性丧失，从而导致停机。</p><p id="d4d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">思考过程# 2——分离关注点又名功能分解:<br/> </strong>如果你从事微服务架构，那么你可能会遇到这个原则，关注点分离也称为功能分解。功能分解意味着将一个大的复杂应用程序分解成小的功能部分。这也称为Y轴缩放，正如我们在顶部看到的图中提到的。我们可以将我们的应用程序分成多个更小的部分。这样，我们可以在一个单独的<a class="ae iu" rel="noopener" href="/javarevisited/10-best-java-microservices-courses-with-spring-boot-and-spring-cloud-6d04556bdfed">微服务</a>中安排任务。我们可以在单个实例中运行它，因为我们不需要为后台任务分担负载。<br/>但这是总体上的最佳解决方案吗？我会说这是一个很好的解决方案，但我们仍然有一个问题。记得法律吗？如果运行我们的单个实例的节点出现故障，那么这将再次导致停机。</p><p id="4554" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">思考过程#3 —基于公共数据源的锁:<br/> </strong>类似于我们在并行计算中如何锁定资源，我们可以使用基于公共数据源的锁来确保调度的任务只执行一次。这是迄今为止我遇到的最好的方法。正是为了这个目的，<a class="ae iu" href="https://github.com/lukas-krecan" rel="noopener ugc nofollow" target="_blank">卢克Křečan </a>创建了一个名为<a class="ae iu" href="https://github.com/lukas-krecan/ShedLock" rel="noopener ugc nofollow" target="_blank"> ShedLock </a>的插件。ShedLock的高级概念非常简单。当给定的实例正在执行应用程序的调度程序方法时，将使用提供的配置进行数据源更新调用。该配置将包含调度程序的唯一的<code class="du kk kl km ka b">name </code>，它还包含其他3列<code class="du kk kl km ka b">lock_until</code>、<code class="du kk kl km ka b">locked_at</code>和<code class="du kk kl km ka b">locked_by</code>。如果另一个实例试图运行相同的调度程序方法，第一步是检查它是否被锁定，如果被锁定，那么它将不会被执行。让我们看看如何实现这一点。第一步，我们需要以下依赖项。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/5135d7923ade7e0fdbde65e4623ee09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qX1-5mdbFKkuopSTSi5-rQ.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">pom.xml</p></figure><p id="70cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这种情况，我将使用基于MySQL的数据源，但是ShedLock支持许多数据源。我们需要在数据库中有一个名为<code class="du kk kl km ka b">shedlock</code>的表。它可以用下面的DDL创建。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="ea71" class="ke kf hi ka b fi kg kh l ki kj">CREATE TABLE shedlock(name VARCHAR(64) NOT NULL, lock_until TIMESTAMP(3) NOT NULL,<br/>    locked_at TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3), locked_by VARCHAR(255) NOT NULL, PRIMARY KEY (name));</span></pre><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/fd3055a3c04ae54a67f96d99a3cf79ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eqKBAizqQSUeDZ6oW4H84w.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">SchedulerLockConfig.java</p></figure><p id="3b3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，<code class="du kk kl km ka b">defaultLockAtMostFor </code>和<code class="du kk kl km ka b">defaultLockAtLeastFor</code>是我们的应用程序中使用的所有调度器锁的默认配置。“最多锁定”配置指定了从锁定到锁定有效的最长时间。类似地,“至少锁定”配置指定了从锁定到锁定有效的最短时间。<br/>现在让我们看看我们的调度器实现。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/8b4945624d2269be58e9ce75e9eb0a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5Y6URnB4ZydX_2c46vFcQ.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">改良ScheduledTasks.java</p></figure><p id="26d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们运行这个，我们将能够在我们的<code class="du kk kl km ka b">shedlock </code>表中看到这个条目。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/45ea26355c327e2f6bc4eb5150e6ccc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eizn3VZKTY0KgDGsMHonpw.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">执行后关闭</p></figure><p id="d7c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是ShedLock如何工作的高级序列图。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/c9df2a598f72cbbc968ace8228f320a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_KRwHEYA-7kGQwgdD0oBQ.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">shedlock —序列图</p></figure><p id="fd7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想更深入地了解谢德洛克，你可以试着阅读这篇文章，作者是<a class="kv kw ge" href="https://medium.com/u/265903511564?source=post_page-----eda92720e3dd--------------------------------" rel="noopener" target="_blank">达南杰·克尔(Dhananjay Kr)。</a>也可以直接访问ShedLock的GitHub <a class="ae iu" href="https://github.com/lukas-krecan/ShedLock" rel="noopener ugc nofollow" target="_blank">资源库</a>。</p><p id="751c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在我的3个不同的思考过程中，如果你问我哪一个是最好的方法，那么我的建议是使用数字2和3的组合。为每个问题提供不同的微服务总是更好，如果后台进程需要高可用性，那么我们可以继续进行扩展和基于数据源的锁定。</p><p id="4f60" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">参考文献:</strong> <br/> 1。<a class="ae iu" href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/scheduling.html" rel="noopener ugc nofollow" target="_blank">弹簧调度器</a> <br/> 2。<a class="ae iu" href="https://www.baeldung.com/spring-task-scheduler" rel="noopener ugc nofollow" target="_blank">Spring任务调度器指南</a> <br/> 3。<a class="ae iu" href="https://microservices.io/book" rel="noopener ugc nofollow" target="_blank">微服务模式</a> <br/> 4。<a class="ae iu" href="https://github.com/lukas-krecan/ShedLock" rel="noopener ugc nofollow" target="_blank">谢德洛克</a> <br/> 5。<a class="ae iu" href="https://dhananjay4058.medium.com/lock-scheduled-tasks-with-shedlock-and-spring-boot-f67200dad675" rel="noopener">用谢德洛克和Spring Boot锁定@预定任务</a></p></div></div>    
</body>
</html>