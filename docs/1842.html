<html>
<head>
<title>Application Versioning Strategies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用程序版本控制策略</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/application-versioning-strategies-de353a84faaa?source=collection_archive---------0-----------------------#2021-12-27">https://medium.com/javarevisited/application-versioning-strategies-de353a84faaa?source=collection_archive---------0-----------------------#2021-12-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/67601f2503a1d1960d96b8e2eccab89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RVUOih4-b0nvIYg1"/></div></div><p class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@angelekamp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安格尔·坎普</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="22b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有许多方法可以对应用程序进行版本控制。有些是很久以前出现的，对web开发没什么意义。尽管如此，它们仍在继续使用。在本文中，我们将考虑各种版本控制选项，以及在什么情况下适合使用它们。</p><h1 id="e225" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">语义版本化</strong></h1><p id="fcaa" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><code class="du kw kx ky kz b">&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;[.&lt;build number&gt;]</code> (1.20.11，1.20.11.403)</p><ol class=""><li id="f3f8" class="la lb hi ix b iy iz jc jd jg lc jk ld jo le js lf lg lh li bi translated">major——增加主版本通常会破坏兼容性，允许开发人员删除不赞成使用的API或修改现有的API。用户知道它，并不期待一个平稳的更新。</li><li id="2f97" class="la lb hi ix b iy lj jc lk jg ll jk lm jo ln js lf lg lh li bi translated">次要—版本增量意味着在不破坏兼容性的情况下添加新功能。</li><li id="2efe" class="la lb hi ix b iy lj jc lk jg ll jk lm jo ln js lf lg lh li bi translated">补丁-也称为bugfix版本，包括修复安全漏洞等。</li><li id="d5d9" class="la lb hi ix b iy lj jc lk jg ll jk lm jo ln js lf lg lh li bi translated">内部版本号—也可以添加内部版本号。</li></ol><p id="c5d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a> (SemVer)是最常见的版本化方法，因此它在任何地方都被使用，包括web(例如在版本化微服务中)。但是web上的API本身已经有了版本控制，客户端看到的是API的版本，而不是应用程序。</p><p id="4899" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SemVer非常适合版本库，例如，数据库。因此，用户将立即知道他们是否可以轻松升级。</p><h1 id="3d60" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">日历版本</strong></h1><p id="dcda" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><code class="du kw kx ky kz b">&lt;year&gt;.&lt;month&gt;.&lt;patch&gt;</code>(2022 . 07 . 01)<br/><code class="du kw kx ky kz b">&lt;year&gt;.&lt;minor&gt;.&lt;patch&gt;</code>(2022.1，2022.1.1)</p><p id="8831" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://calver.org/" rel="noopener ugc nofollow" target="_blank">日历版本化</a> (CalVer)用在你不在乎兼容性的时候。对于这种情况，使用SemVer会导致第一个数字<code class="du kw kx ky kz b">1</code>永远存在。</p><p id="83c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种版本控制对于本地软件来说尤其重要(例如，<a class="ae iu" href="https://www.jetbrains.com/idea/" rel="noopener ugc nofollow" target="_blank"> IntelliJ Idea </a>使用它)，并且对于外部用户来说最有意义。</p><h1 id="e5d8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">基于Sprint的版本控制</strong></h1><p id="e423" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><code class="du kw kx ky kz b">&lt;symbol&gt;&lt;sprint number&gt;[.&lt;patch&gt;]</code> (M27，M27.1)</p><p id="a4f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当开发过程基于Scrum sprints，并且发布是在sprint结果之后进行的，那么一个合理的解决方案是基于sprint编号对产品进行<a class="ae iu" href="https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/" rel="noopener ugc nofollow" target="_blank">版本化。这里的第一个字符帮助您不要将这种版本控制策略与所有其他策略混淆。如果最新版本需要修补程序，则会添加修补程序后缀。</a></p><p id="6789" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种方法中，所有的数字对团队来说都是清楚的，他们不会告诉客户任何事情。但通常情况下，用户对web应用中的版本并不感兴趣。</p><h1 id="e2d8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">释放流量</strong></h1><p id="efa4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在有很多工作流:Git流、GitHub流、GitLab流、基于Trunk的开发等。</p><p id="1603" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们仔细考虑一下选择使用哪一个的因素。</p><h2 id="938e" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jg lv lw kh jk lx ly kl jo lz ma kp mb bi translated">应用程序大小</h2><p id="b30a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果一个小团队开发应用程序，Git流可能是不必要的开销。创建这些特性分支非常耗时，而且对于由几个团队开发的monolith应用程序来说更有意义。对于微服务，使用基于主干的方法要容易得多。</p><h2 id="39e5" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jg lv lw kh jk lx ly kl jo lz ma kp mb bi translated">发布周期和测试</h2><p id="54be" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">不同的应用程序有不同的发布周期。Web应用程序每天可以发布多次。</p><p id="6dbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于内部产品，情况正好相反。用户不希望过于频繁地更新产品，因为它总是一件大事。因此，这类产品通常会在构建版本时经历额外的测试周期。这意味着根据测试的结果，有选择地提交修复。</p><h2 id="c9ef" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jg lv lw kh jk lx ly kl jo lz ma kp mb bi translated">支持的基线数量</h2><p id="a4a0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您正在开发web应用程序，通常只有最新版本就足够了。</p><p id="77a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相反，当开发一个库，或者例如一个数据库时，支持几个以前的版本是必要的。这迫使我们在项目中保留几个基线，并想出一种方法来将新的修复反向移植到所有基线。</p><h2 id="22d0" class="lo ju hi bd jv lp lq lr jz ls lt lu kd jg lv lw kh jk lx ly kl jo lz ma kp mb bi translated"><strong class="ak">分店vs标签</strong></h2><p id="d7dc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">有两种方法来固定一个版本。您可以在commit上创建版本号标记，或者从master上切断release分支(代码冻结)。</p><p id="23c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两种方法都是有效的，并且适用于不同类型的产品。<br/>一般来说，由于不变性，标记方法更好，这减少了出错的机会。<br/>在本地产品或多个基线的情况下，发布分支对于方便后向移植更有意义。</p><h1 id="1d96" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">结论</strong></h1><p id="931e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">有相当多的版本控制选项，每一个都有其使用案例。所以不要盲目的把语义版本化作为最流行的一种。也许在您的特定项目中，其他方法会更适合开发人员或最终用户，也更容易理解。</p></div></div>    
</body>
</html>