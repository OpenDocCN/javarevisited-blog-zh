<html>
<head>
<title>A Beginners Guide To Spring Beans and IoC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">春豆和IoC初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/a-beginners-guide-to-spring-beans-a88e33f4badc?source=collection_archive---------2-----------------------#2022-03-02">https://medium.com/javarevisited/a-beginners-guide-to-spring-beans-a88e33f4badc?source=collection_archive---------2-----------------------#2022-03-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/a231fd05f2d601bae781cad821763ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*0a4XL2pgdBGbH8UdY-YoQA.jpeg"/></div></figure><p id="a5c9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi jk translated">豆子是弹簧框架的支柱。所有的对象和资源都以beans的形式进行管理。</p><p id="75cd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根据spring.io的官方文档，</p><blockquote class="jt ju jv"><p id="b07d" class="im in jw io b ip iq ir is it iu iv iw jx iy iz ja jy jc jd je jz jg jh ji jj hb bi translated">在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为beans。bean是由<a class="ae ka" href="https://javarevisited.blogspot.com/2011/09/spring-interview-questions-answers-j2ee.html" rel="noopener ugc nofollow" target="_blank"> Spring IoC容器</a>实例化、组装和管理的对象。否则，bean只是应用程序中许多对象中的一个。Beans以及它们之间的依赖关系反映在容器使用的配置元数据中。</p></blockquote><p id="1b03" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">spring beans指的是由Spring IOC容器创建和管理的java对象。为了理解spring beans的用法，我们必须首先了解IOC — <a class="ae ka" href="https://javarevisited.blogspot.com/2012/12/inversion-of-control-dependency-injection-design-pattern-spring-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">控制反转</a>。</p><h1 id="e1a2" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">什么是控制反转？</strong></h1><p id="41e1" class="pw-post-body-paragraph im in hi io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">控制反转构成了Spring框架的核心。它指的是将对象和部分代码的控制移交给框架或容器的机制，最常用于<a class="ae ka" rel="noopener" href="/javarevisited/6-best-object-oriented-programming-books-and-courses-for-beginners-d46235cbda49">面向对象编程</a>。spring容器跟踪所有的对象和它们的依赖关系，并在程序需要的时候让它们可用。它负责维护所有对象的生命周期。</p><h2 id="5474" class="le kc hi bd kd lf lg lh kh li lj lk kl ix ll lm kp jb ln lo kt jf lp lq kx lr bi translated">依赖注入</h2><p id="592e" class="pw-post-body-paragraph im in hi io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">这种控制反转是由Spring 中的IOC容器通过使用一个叫做依赖注入的过程来实现的。它是一种机制，用于通过创建和注入运行时创建对象所需的必要的<a class="ae ka" href="https://javarevisited.blogspot.com/2022/02/how-to-fix-autowired-no-qualifying-bean.html" rel="noopener ugc nofollow" target="_blank">依赖关系</a>来实现对象之间的松散耦合。这不是手工注入依赖项，而是在spring中使用IoC容器实现的。</p><p id="261b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">IOC容器是使用<a class="ae ka" href="https://javarevisited.blogspot.com/2012/11/difference-between-beanfactory-vs-applicationcontext-spring-framework.html#axzz7BnOZ1wuB" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"><em class="jw">application context</em></strong></a>和<strong class="io hj"> <em class="jw"> BeanFactory </em> </strong>接口实现的，包含应用程序的所有必要细节，如bean定义、关于实例化、管理和销毁对象的信息等。</p><p id="b4f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么，Spring中的依赖是如何注入到对象中的呢？</p><p id="d4d4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">依赖关系可以在运行时以三种不同的方式注入到对象中:</p><ul class=""><li id="12ee" class="ls lt hi io b ip iq it iu ix lu jb lv jf lw jj lx ly lz ma bi translated"><a class="ae ka" href="https://javarevisited.blogspot.com/2012/11/difference-between-setter-injection-vs-constructor-injection-spring-framework.html#axzz6qnblZnVj" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">构造函数注入</strong> </a>:这是通过为对象定义一个构造函数来实现的，该构造函数将所有必需依赖项的值作为输入。</li></ul><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="d12c" class="le kc hi mg b fi mk ml l mm mn"><strong class="mg hj">@Autowired</strong><br/>public <strong class="mg hj">OutputService</strong>(<strong class="mg hj">TimerService</strong> timeService, <strong class="mg hj">GreetingService</strong> greetingService, <strong class="mg hj">String</strong> name) {<br/>   this.timeService=timeService;<br/>   this.greetingService=greetingService;<br/>   this.name=name;<br/>}</span></pre><ul class=""><li id="9749" class="ls lt hi io b ip iq it iu ix lu jb lv jf lw jj lx ly lz ma bi translated"><strong class="io hj"> Setter注入</strong>:这是通过为对象中所有必要的依赖关系定义一个Setter来实现的。</li></ul><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="d361" class="le kc hi mg b fi mk ml l mm mn"><strong class="mg hj">@Autowired</strong><br/>public <strong class="mg hj">void</strong> setTimeService(<strong class="mg hj">TimerService</strong> timeService) {<br/>   this.timeService = timeService;<br/>}<br/><br/><strong class="mg hj">@Autowired</strong><br/>public <strong class="mg hj">void</strong> setGreetingService(<strong class="mg hj">GreetingService</strong> greetingService) {<br/>   this.greetingService = greetingService;<br/>}</span></pre><ul class=""><li id="ec46" class="ls lt hi io b ip iq it iu ix lu jb lv jf lw jj lx ly lz ma bi translated"><strong class="io hj">字段注入</strong>:在这种方法中，我们可以在spring中的必填字段上使用<a class="ae ka" href="https://javarevisited.blogspot.com/2021/10/difference-between-autowired-and.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> @Autowired </strong>注释</a>来注入字段级的依赖关系。(仅适用于基于注释的配置)</li></ul><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="b800" class="le kc hi mg b fi mk ml l mm mn"><strong class="mg hj">@Autowired</strong><br/>private <strong class="mg hj">TimerService</strong> timeService;</span><span id="f984" class="le kc hi mg b fi mo ml l mm mn"><strong class="mg hj">@Autowired</strong><br/>private <strong class="mg hj">GreetingService</strong> greetingService;</span></pre><p id="6e13" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在基于xml的配置的情况下，可以通过为bean指定<strong class="io hj"> autowire </strong>属性并为其指定类型来启用自动连接。</p><p id="dbcd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一般来说，这三种方法都可以用于依赖注入。但是，为了保持一致性，最好选择其中任何一个并在项目中使用。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><h1 id="8fa3" class="kb kc hi bd kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky bi translated"><strong class="ak">配置弹簧豆</strong></h1><h2 id="5b75" class="le kc hi bd kd lf lg lh kh li lj lk kl ix ll lm kp jb ln lo kt jf lp lq kx lr bi translated">基于XML的配置</h2><p id="59b0" class="pw-post-body-paragraph im in hi io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">传统上，它们在包含spring应用程序上下文的XML文件中配置。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="3016" class="le kc hi mg b fi mk ml l mm mn">&lt;bean name=”processor” class=”com.example.com.MainProcessor”&gt;&lt;/bean&gt;</span></pre><p id="ccb7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">带有bean定义的示例XML文件:</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="3e1c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以使用应用程序上下文的<strong class="io hj"><em class="jw">classpathmlaplicationcontext</em></strong>实现来加载bean定义或应用程序上下文。</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><h2 id="3e72" class="le kc hi bd kd lf lg lh kh li lj lk kl ix ll lm kp jb ln lo kt jf lp lq kx lr bi translated">基于Java的配置</h2><p id="94b4" class="pw-post-body-paragraph im in hi io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">然而，它们也可以在Spring框架的新版本中使用<a class="ae ka" href="https://www.java67.com/2021/10/pring-bean-example-what-does-bean-annotation-does.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> @Bean </strong>注释</a>来创建</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="bb19" class="le kc hi mg b fi mk ml l mm mn"><strong class="mg hj">@Bean</strong><br/><strong class="mg hj">public</strong> MainProcessor processor() {<br/>  <strong class="mg hj">return</strong> <strong class="mg hj">new</strong> MainProcessor();<br/>}</span></pre><p id="8598" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这两种情况下，我们都为类MainProcessor声明了一个新的bean。在基于注释的配置中，由于我们没有为bean提供任何特定的名称，因此在为这个类创建新bean时，<a class="ae ka" rel="noopener" href="/javarevisited/10-free-spring-boot-tutorials-and-courses-for-java-developers-53dfe084587e"> spring </a>将自动使用bean的方法名称(方法名称的第一个字母将总是被转换为小写)。但是，我们可以显式地提供bean名称，同时将其声明为<strong class="io hj"> @Bean(name="customName") </strong>。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="3225" class="le kc hi mg b fi mk ml l mm mn"><strong class="mg hj">@Bean</strong>(<strong class="mg hj">name</strong>=”customName”<strong class="mg hj">)</strong><br/><strong class="mg hj">public</strong> MainProcessor processor() {<br/>  <strong class="mg hj">return</strong> <strong class="mg hj">new</strong> MainProcessor();<br/>}</span></pre><p id="1d58" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个基于java的配置的例子，相当于上面的基于XML的例子。</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="2378" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这种情况下，可以通过指定配置类，使用应用程序上下文的<strong class="io hj"><em class="jw">AnnotationConfigApplicationContext</em></strong>实现来加载上下文。</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><h2 id="3281" class="le kc hi bd kd lf lg lh kh li lj lk kl ix ll lm kp jb ln lo kt jf lp lq kx lr bi translated">基于注释的配置</h2><p id="9597" class="pw-post-body-paragraph im in hi io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">Spring 2.5引入了新的配置beans的方法，从而不再需要基于XML文件的配置。它引入了几个新的注释，例如:</p><ul class=""><li id="939a" class="ls lt hi io b ip iq it iu ix lu jb lv jf lw jj lx ly lz ma bi translated"><a class="ae ka" href="https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html#axzz6ngd8ND25" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> @Component </strong> </a>:组件注释用于在组件扫描时标记要扫描的类，然后由Spring IOC容器管理，而不是手动为类创建Beans。</li><li id="4656" class="ls lt hi io b ip nd it ne ix nf jb ng jf nh jj lx ly lz ma bi translated"><strong class="io hj"> @Service </strong>、<strong class="io hj"> @Repository </strong>、<strong class="io hj"> @Controller </strong>和<strong class="io hj"> @RestController </strong>:这些是<strong class="io hj"> @Component </strong>注释的特殊形式，在应用程序的不同层之间提供了更好的可读性和模块化。</li></ul><blockquote class="jt ju jv"><p id="3186" class="im in jw io b ip iq ir is it iu iv iw jx iy iz ja jy jc jd je jz jg jh ji jj hb bi translated"><strong class="io hj"> @Service </strong> —用于表示服务层，<br/> <strong class="io hj"> @Repository </strong> —用于表示<a class="ae ka" href="https://javarevisited.blogspot.com/2013/01/data-access-object-dao-design-pattern-java-tutorial-example.html#axzz7CANam4JD" rel="noopener ugc nofollow" target="_blank">数据访问层</a> (DAO)，<br/> <strong class="io hj"> @Controller </strong> —用于表示表示层(用于处理来自UI和MVC设计中的请求)，<br/><a class="ae ka" href="https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html#axzz6grO2U4Lp" rel="noopener ugc nofollow" target="_blank"><strong class="io hj">@ Rest Controller</strong></a>—用于表示具有Rest端点的表示层。</p></blockquote><p id="7a5c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">组件本身可以用来代替其他注释，应用程序可以正常工作，但可能会有一些意外的行为。例如，<strong class="io hj"><em class="jw">PersistenceExceptionTranslationPostProcessor</em></strong>用于捕捉特定于持久性的异常，并将其作为spring的统一运行时异常抛出，它充当了使用<strong class="io hj"> @Repository </strong>注释进行注释的类的顾问。它们还提供了在AOP中实现切入点的机会。</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="80a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，为了让spring自动扫描一个包，并通过启用<strong class="io hj">组件扫描</strong>属性来配置beans。这是可以做到的</p><ul class=""><li id="f8ba" class="ls lt hi io b ip iq it iu ix lu jb lv jf lw jj lx ly lz ma bi translated">通过添加一个附加属性直接从XML文件中获取:</li></ul><blockquote class="jt ju jv"><p id="e5f9" class="im in jw io b ip iq ir is it iu iv iw jx iy iz ja jy jc jd je jz jg jh ji jj hb bi translated"><component-scan base-package="com.infotrends.in.sports"/></p></blockquote><p id="b0a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在使用这种方法时，我们可以使用</p><ul class=""><li id="6325" class="ls lt hi io b ip iq it iu ix lu jb lv jf lw jj lx ly lz ma bi translated">或者使用@ComponentScan注释。</li></ul><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="a9b7" class="le kc hi mg b fi mk ml l mm mn">@ComponentScan(“com.infotrends.in.sports.annotations”)<br/>public class ConfigurationClassName {<br/>}</span></pre><p id="eb68" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过使用@ComponentScan和@Configuration注释以及应用程序上下文的<strong class="io hj"><em class="jw">AnnotationConfigApplicationContext</em></strong>实现，可以直接从java文件加载应用程序上下文。</p><figure class="mb mc md me fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="3ddb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这种情况下，我们可以使用<strong class="io hj"><em class="jw">AnnotationConfigApplicationContext</em></strong>实现来创建应用上下文。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><h1 id="7d2e" class="kb kc hi bd kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky bi translated">自动连接Beans的不同方式</h1><p id="6a05" class="pw-post-body-paragraph im in hi io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">如前所述，通过使用自动连接，我们不必显式地将引用传递给创建bean时所需的不同的依赖关系。它将由Spring IOC容器自动管理。如果没有找到合适的bean用于自动连接，那么抛出<a class="ae ka" href="https://javarevisited.blogspot.com/2016/09/2-reasons-of-orgspringframeworkbeansfactory-beanCreationException-Error-creating-bean-with-name.html" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"><em class="jw">nosuchbeandidefinitionexception</em></strong></a><strong class="io hj"><em class="jw"/></strong>异常</p><p id="3e05" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">配置自动布线的不同方式有:</p><ul class=""><li id="19cc" class="ls lt hi io b ip iq it iu ix lu jb lv jf lw jj lx ly lz ma bi translated"><strong class="io hj">否:</strong>用于禁用bean中的自动连接，我们必须显式地提供对依赖bean的引用。这是XML的默认行为。</li><li id="4615" class="ls lt hi io b ip nd it ne ix nf jb ng jf nh jj lx ly lz ma bi translated"><strong class="io hj"> byName </strong>:在这种情况下，spring将搜索一个与要设置的属性同名的bean。</li><li id="1416" class="ls lt hi io b ip nd it ne ix nf jb ng jf nh jj lx ly lz ma bi translated"><strong class="io hj"> byType </strong>:在这种情况下，spring将搜索与需要设置的属性类型相同的bean。如果需要的类型有多个bean，那么spring将抛出一个<strong class="io hj"><em class="jw">nouniquebeandidefinitionexception</em></strong>异常。如果没有提供特定类型，这是在<strong class="io hj"> @Autowired </strong>注释中使用的默认配置。</li><li id="ee08" class="ls lt hi io b ip nd it ne ix nf jb ng jf nh jj lx ly lz ma bi translated"><strong class="io hj">构造函数</strong>:在这种情况下，spring将根据构造函数参数寻找所需的bean类型。</li></ul><p id="4579" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">举个例子，</p><ul class=""><li id="74e5" class="ls lt hi io b ip iq it iu ix lu jb lv jf lw jj lx ly lz ma bi translated">没有自动连接时，xml文件中的bean定义如下所示:</li></ul><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="c757" class="le kc hi mg b fi mk ml l mm mn">&lt;bean id="is24hrFormat" class="java.lang.Boolean"&gt;<br/>    &lt;constructor-arg type="java.lang.Boolean" value="#{new Boolean(environment['spring.profiles.active']!='dev')}"/&gt;<br/>&lt;/bean&gt;</span><span id="edf5" class="le kc hi mg b fi mo ml l mm mn">&lt;bean id="timerService" class="com.infotrends.in.Springbasics.service.TimerService;"&gt;<br/>    &lt;constructor-arg ref="is24hrFormat"/&gt;<br/>&lt;/bean&gt;</span><span id="5975" class="le kc hi mg b fi mo ml l mm mn">&lt;bean id="greetingService" class="com.infotrends.in.Springbasics.service.GreetingService"&gt;<br/>    &lt;constructor-arg index="0" value="${app.greeting}"/&gt;<br/>&lt;/bean&gt;<br/><strong class="mg hj">&lt;bean id="outputService" class="com.infotrends.in.Springbasics.service.OutputService"&gt;<br/>    &lt;constructor-arg index="0" ref="timerService"/&gt;<br/>    &lt;constructor-arg index="1" ref="greetingService"/&gt;<br/>    &lt;constructor-arg index="2" value="${app.name}"/&gt;<br/>&lt;/bean&gt;</strong></span></pre><ul class=""><li id="7db2" class="ls lt hi io b ip iq it iu ix lu jb lv jf lw jj lx ly lz ma bi translated">但是，使用自动连接，我们可以直接跳过对<strong class="io hj"> timerService </strong>和<strong class="io hj">greeting service</strong>bean的引用，如下所示()</li></ul><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="38e8" class="le kc hi mg b fi mk ml l mm mn">&lt;bean id="is24hrFormat" class="java.lang.Boolean"&gt;<br/>    &lt;constructor-arg type="java.lang.Boolean" value="#{new Boolean(environment['spring.profiles.active']!='dev')}"/&gt;<br/>&lt;/bean&gt;</span><span id="bcad" class="le kc hi mg b fi mo ml l mm mn">&lt;bean id="timerService" class="com.infotrends.in.Springbasics.service.TimerService;"&gt;<br/>    &lt;constructor-arg ref="is24hrFormat"/&gt;<br/>&lt;/bean&gt;</span><span id="7b21" class="le kc hi mg b fi mo ml l mm mn">&lt;bean id="greetingService" class="com.infotrends.in.Springbasics.service.GreetingService"&gt;<br/>    &lt;constructor-arg index="0" value="${app.greeting}"/&gt;<br/>&lt;/bean&gt;<br/><strong class="mg hj">&lt;bean id="outputService" class="com.infotrends.in.Springbasics.service.OutputService"  autowire = "byType"&gt;<br/>    &lt;constructor-arg index="2" value="${app.name}"/&gt;<br/>&lt;/bean&gt;</strong></span></pre><p id="c8b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是自动布线配置byType的一个示例。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><h1 id="6676" class="kb kc hi bd kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky bi translated">结论</h1><p id="50f2" class="pw-post-body-paragraph im in hi io b ip kz ir is it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj hb bi translated">本文简要介绍了Spring bean，以及在基于Spring、使用XML或基于注释的配置中使用它们的不同方式。</p><p id="36a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以在GitHub repo<a class="ae ka" href="https://github.com/Vicky-cmd/SpringMVC" rel="noopener ugc nofollow" target="_blank">https://github.com/Vicky-cmd/SpringMVC</a>中找到用于示例的项目</p></div></div>    
</body>
</html>