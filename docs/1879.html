<html>
<head>
<title>Monitoring close() via References</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过引用监控close()</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/monitoring-close-via-references-c0b111e98a5?source=collection_archive---------1-----------------------#2022-01-14">https://medium.com/javarevisited/monitoring-close-via-references-c0b111e98a5?source=collection_archive---------1-----------------------#2022-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="38bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个故事中，我们研究了一种方法来监控Java中从<code class="du jd je jf jg b">AutoCloseable</code>接口对<code class="du jd je jf jg b">close()</code>方法的调用。所探索的方法依赖于弱引用和幻影引用。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/c2b599ba2a5270f3a92ddb759d65652c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SwPSiUhDnsNe41Ts.jpg"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated"><a class="ae jx" href="https://pixabay.com/photos/monitoring-security-surveillance-1305045/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/photos/monitoring-security-surveillance-1305045/</a></p></figure><p id="f310" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同时阅读:<a class="ae jx" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ref/PhantomReference.html" rel="noopener ugc nofollow" target="_blank">docs.oracle.com/en/java/javase/17/docs/api/<br/>java.base/java/lang/ref/PhantomReference.html</a>，以及其中的参考文献。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="67be" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">一个非范例</h1><p id="750e" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">为了给本文的主题预热，让我们考虑一个被监控的资源处理程序的非常基本的例子:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><a href="https://javarevisited.blogspot.com/2014/10/right-way-to-close-inputstream-file-resource-in-java.html"><div class="er es li"><img src="../Images/4a4f86a72d17f3ff6232306473f0b0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*sjL7JL3tFAFG0Pt4t8-RDA.png"/></div></a><p class="jt ju et er es jv jw bd b be z dx translated">使用finalize进行监控</p></figure><p id="51d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<a class="ae jx" href="http://javarevisited.blogspot.sg/2017/02/use-string-deduplication-to-save-memory-from-duplicates-in-java8.html#axzz53GlhtuGG" rel="noopener ugc nofollow" target="_blank">垃圾收集器</a>试图终结对象时，将会调用<code class="du jd je jf jg b">finalize</code>方法。在该方法中，检查对象是否已经关闭。</p><p id="3d4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的操作是日志记录，但是您可以想象不同的事情。至关重要的一点是，确保不要在其他地方再次强烈引用您的对象，以防止最终对它进行垃圾收集。</p><p id="7c71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标是提供一个类似的行为，而不是重写终结，而是利用引用。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="8015" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">三种参考文献</h1><p id="7727" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated"><em class="lj">(本节是非正式的，旨在刷新记忆，不提供关于该主题的全面指导；主要是因为我不确定能得到全部；随意带点准确度)</em></p><h2 id="499d" class="lk kg hi bd kh ll lm ln kl lo lp lq kp iq lr ls kt iu lt lu kx iy lv lw lb lx bi translated">强引用</h2><p id="1469" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">强引用是引用对象的最标准方式。基本上，当某个变量持有对一个对象的引用时，该对象就是强可达的。通常情况下:</p><pre class="ji jj jk jl fd ly jg lz ma aw mb bi"><span id="9850" class="lk kg hi jg b fi mc md l me mf">var a = new A();<br/>// the object A is strongly reachable,<br/>// as some variable holds a ref to it</span><span id="8f19" class="lk kg hi jg b fi mg md l me mf">a = null;<br/>// the object is not strongly reachable</span></pre><p id="3cd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个对象是强可达的时，它不能被GC单独收集。</p><h2 id="ce72" class="lk kg hi bd kh ll lm ln kl lo lp lq kp iq lr ls kt iu lt lu kx iy lv lw lb lx bi translated">定稿</h2><p id="30d6" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">当GC检测到一个合格的对象时，它将调用它的finalize方法。该对象成为最终对象。这种情况肯定只会发生一次。</p><p id="1f2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在<a class="ae jx" href="https://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html#axzz5WKm9BB8F" rel="noopener ugc nofollow" target="_blank"> finalize方法</a>中将对象引用存储在其他地方(强),终结将不再发生，对象最终也不会被垃圾回收。</p><h2 id="f44d" class="lk kg hi bd kh ll lm ln kl lo lp lq kp iq lr ls kt iu lt lu kx iy lv lw lb lx bi translated">幻影可达</h2><p id="751e" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">当一个对象不是强可达的，并且不是由弱引用(或软引用)持有时，它就是幻影可达的。它还必须已经被最终确定，并且一个<code class="du jd je jf jg b"><a class="ae jx" href="https://javarevisited.blogspot.com/2014/03/difference-between-weakreference-vs-softreference-phantom-strong-reference-java.html" rel="noopener ugc nofollow" target="_blank">PhantomReference</a></code> <a class="ae jx" href="https://javarevisited.blogspot.com/2014/03/difference-between-weakreference-vs-softreference-phantom-strong-reference-java.html" rel="noopener ugc nofollow" target="_blank"> </a>必须引用它。</p><p id="5280" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<code class="du jd je jf jg b">PhantomReference</code>来说，泄漏对对象的引用是不可能的:<code class="du jd je jf jg b">get()</code>方法总是返回null</p><pre class="ji jj jk jl fd ly jg lz ma aw mb bi"><span id="8d5a" class="lk kg hi jg b fi mc md l me mf">var a = new A();<br/>var phantomReference = new PhantomReference&lt;&gt;(a, queue);<br/>// here, the object is still strongly reachable<br/>assert phantomReference.get() == null;<br/>assert a != null;</span><span id="2a63" class="lk kg hi jg b fi mg md l me mf">a = null;<br/>// we stop strongly referencing the object<br/>// the object may, or not, be phantom reachable<br/>// (depending on the finalization)</span><span id="1471" class="lk kg hi jg b fi mg md l me mf">assert phantomReference.get() == null;</span></pre><p id="df1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">queue</code>参数是一个<code class="du jd je jf jg b">java.lang.ref.ReferenceQueue</code>。可以使用线程安全的引用队列来获取幻影可达的幻影引用。在这一点上，我们知道没有其他的引用可以指向我们的对象，它已经被最终确定。</p><h2 id="63d6" class="lk kg hi bd kh ll lm ln kl lo lp lq kp iq lr ls kt iu lt lu kx iy lv lw lb lx bi translated">弱可达的</h2><p id="26bc" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">一个对象是弱可达的，如果它不是强可达的并且某个<code class="du jd je jf jg b">WeakReference</code>引用了它。</p><p id="e752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">WeakReference</code>可以通过<code class="du jd je jf jg b">get()</code>方法取回对象，但是返回的引用是否为null是不确定的。事实上，可以保证当对象仍然是强可达的时候，<code class="du jd je jf jg b">get()</code>方法将返回对象引用。</p><pre class="ji jj jk jl fd ly jg lz ma aw mb bi"><span id="52b7" class="lk kg hi jg b fi mc md l me mf">var a = new A();<br/>var weakReference = new WeakReference&lt;&gt;(a);<br/>// here, the object is still strongly reachable<br/>assert weakReference.get() == a;</span><span id="a207" class="lk kg hi jg b fi mg md l me mf">a = null;<br/>// we stop strongly referencing the object<br/>// the object may, or not, be weakly reachable</span><span id="1021" class="lk kg hi jg b fi mg md l me mf">if ((a = weakReference.get()) != null) {<br/>  // the object is now strongly referenced again!<br/>}</span><span id="1d3b" class="lk kg hi jg b fi mg md l me mf">// only when weakReference.get() == null,<br/>// will the object be finalized.</span></pre><p id="3e7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，弱引用有时足以取回对象，但不足以阻止垃圾回收。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="bb07" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">实现监视器</h1><p id="686a" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">让我们回到监控问题上来。</p><p id="f8fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们想要的是，在另一个监视线程中，保持某些特定资源种类的状态:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><a href="https://www.java67.com/2019/08/best-books-to-learn-java-virtual-machine-in-depth.html"><div class="er es mh"><img src="../Images/8278fdfa2041c68f37ed481f3509bdbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*M-RdJdDTedVeOfLuNo7oSg.png"/></div></a><p class="jt ju et er es jv jw bd b be z dx translated">我们想要监控的资源处理程序</p></figure><p id="ade9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">资源处理程序在初始化时在我们的监视器对象上注册自己。在一个<code class="du jd je jf jg b">close()</code>操作之后，对象提醒监视器释放。</p><p id="84b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lj"/><code class="du jd je jf jg b"><em class="lj">finalize()</em></code><em class="lj">的覆盖仅用于记录目的。</em></p><h2 id="4937" class="lk kg hi bd kh ll lm ln kl lo lp lq kp iq lr ls kt iu lt lu kx iy lv lw lb lx bi translated">监控动态</h2><p id="cf9b" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">监视器应该保持一个对象是否被关闭的状态。这暗示了一些地图<code class="du jd je jf jg b">Object -&gt; Boolean</code>。</p><p id="dbfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做的问题是，监视器持有对对象的强引用，这可能会很成问题，因为监视器不会检测对象是否被垃圾收集:不会！</p><p id="9f70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这句话更像是建议将地图<code class="du jd je jf jg b">PhantomReference -&gt; Boolean</code>与<code class="du jd je jf jg b">ReferenceQueue</code>一起使用。当监控器从队列中轮询一个虚拟的可到达引用时，它可以检查映射并查看相关的<code class="du jd je jf jg b">AutoCloseable</code>是否已经关闭。</p><p id="fc54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们这样做，我们将遇到另一个问题:我们的对象现在不可能提醒监视器它已经关闭。的确，<code class="du jd je jf jg b">PhantomReference</code>不能用来知道它们指的是哪个对象，它们的相等性是由同一性来执行的。这意味着我们不能改变地图来推动关闭状态。</p><p id="a26b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们建议的解决方法是维护另一张<code class="du jd je jf jg b">WeakReference -&gt; PhantomReference</code>地图，并进行以下协作:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html"><div class="er es mi"><img src="../Images/bc37ecd28e2ac1b79852109124c401b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*DyRZTzx3kedSYzqO9opZQw.png"/></div></a><p class="jt ju et er es jv jw bd b be z dx translated">monitor对象，实现Runnable。</p></figure><p id="6c80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当类<code class="du jd je jf jg b">A</code>的<code class="du jd je jf jg b">AutoCloseable</code>对象注册时，它存储一对对自身的引用<code class="du jd je jf jg b">(weakRef, phantomRef)</code>，以及一对<code class="du jd je jf jg b">(phantomRef, Boolean)</code>。</p><p id="ef70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当对象完成其<code class="du jd je jf jg b">close()</code>方法时，调用<code class="du jd je jf jg b">free()</code>方法。此时，该对象仍然是强可达的(它在方法参数中！).弱引用肯定会返回对象引用，根据这一点，我们可以移除弱引用并获得相关联的幻像引用。</p><p id="354d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象不是弱可达的，我们在关闭状态图中挂钩值<code class="du jd je jf jg b">Boolean = TRUE</code>。</p><p id="6c97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当对象将被终结时，引用队列将最终轮询幻象引用，并且监视器将能够检查对象是否确实已被正确关闭。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="274b" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">压力测试！</h1><p id="1d79" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">对于压力测试，我们将运行这个简单的场景:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mj"><img src="../Images/d86ce407b8c34ab819acc764f15dd5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*5vGBUWg8pUdyvtTki3xshQ.png"/></div><p class="jt ju et er es jv jw bd b be z dx translated">压力测试场景</p></figure><p id="d8a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">监视器在另一个线程中运行。对象被创建，然后被关闭，然后对它的唯一强引用被取消。</p><p id="9193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们更新了GC-thread优先级，稍微放松了一下。然后，我们运行了一些压力测试，在我堆上分配了大量的整数，以便进行少量的垃圾收集。对象无法与压力测试共存(我的电脑不够强大)。</p><p id="ebad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果如下:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es mk"><img src="../Images/5836241242115f921fdbf98b3775c647.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*1CRT1cFviaKlIagQRieFpA.png"/></div></figure><p id="63cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，对象终结比队列的轮询结果发生得更快。在<code class="du jd je jf jg b">System.gc()</code>呼叫之后，它会上升一点。只有在第一次压力迭代之后，对象才是幻影可达的，这可能是因为此时系统确实需要内存。</p><p id="f133" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">监视器已成功检测到我们的对象已关闭。</p><p id="a0b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里是同样的测试，当我们注释<code class="du jd je jf jg b">a.close();</code>指令时:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es ml"><img src="../Images/3691510db1e75a14c7331cb908d52bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*xKSrpG8_O7xOWlUQuPPyJg.png"/></div></figure><p id="ac62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事件的顺序没有太大变化。不同的是，我们的监视器成功地探测到物体没有关闭。</p><p id="1ab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便提一下，如果我们忘记从监视器中释放对象，监视器会认为对象从未关闭，并在那个方向发出警告。因此，这是一种悲观的方法。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="2153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天就到这里吧！</p><p id="9187" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你喜欢这本书，它给了你尝试参考特性的动力。</p><p id="7a56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用法可能很酷，比如资源日志。你有其他想法吗？不要犹豫，在评论中分享它们:-)</p></div></div>    
</body>
</html>