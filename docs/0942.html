<html>
<head>
<title>Introduction To Serverless Computing in Amazon Web Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亚马逊网络服务中的无服务器计算简介</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/introduction-to-serverless-computing-in-amazon-web-services-43f51ffeac9f?source=collection_archive---------4-----------------------#2021-01-23">https://medium.com/javarevisited/introduction-to-serverless-computing-in-amazon-web-services-43f51ffeac9f?source=collection_archive---------4-----------------------#2021-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="05c3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">无服务器计算及其优势</strong></h1><p id="6159" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">无服务器计算是云计算中的一种执行模式，服务提供商按需分配服务器所需的所有资源，并代表客户照管这些资源。</p><p id="890e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在这种情况下，定价实际上是基于应用程序的总运行时间和它消耗的资源数量等因素。这反过来简化了部署过程。</p><p id="306b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用无服务器的主要优点是:</p><ol class=""><li id="5302" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated"><strong class="jf hj">无需服务器维护</strong>:在无服务器模式下，所有服务器和硬件配置都由服务提供商管理，并保证SLA中规定的正常运行时间。这也消除了对服务器容量的依赖。</li><li id="f801" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><strong class="jf hj">性价比</strong>:这比用服务器资源运行一个单独的系统要便宜。<a class="ae ku" rel="noopener" href="/javarevisited/7-best-aws-ec2-amazon-elastic-compute-cloud-online-courses-for-beginners-in-2021-f7a1a55ea719"> EC2实例</a>以每小时的速率定价，即使它们处于空闲状态，即实例的处理能力没有被使用。在无服务器架构的情况下，服务器不会一直运行，只有在接收到任何请求进行处理时才是活动的。因此，在这种情况下，用户仅在服务器活动的时间内付费。</li><li id="3e50" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><strong class="jf hj">更好的按需可扩展性</strong>:与受服务器容量限制的基于服务器的应用不同，基于无服务器架构的应用会随着需求的增加而自动扩展。当需求减少时，他们会自动缩减规模。这比为ec2实例设置自动扩展组的过程更简单，也更便宜。</li><li id="d461" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><strong class="jf hj">更快更轻松的部署</strong>:开发人员无需将代码上传至服务器，也无需进行任何后端配置，即可发布新版应用。因此，开发者可以直接上传新版本的代码。像AWS lambda这样的无服务器计算服务也提供了一个在线的想法来直接处理代码并上传。</li><li id="44fb" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><strong class="jf hj">更容易引入新功能</strong>:向应用添加新功能更容易，因为只需要更新基本代码。在AWS Lambda的情况下，甚至许多基础依赖项(如基于所选语言版本的运行时)都已经得到维护并随时可用。此外，还有一个功能是快照应用程序的当前状态，并保存它供以后使用，可以作为版本或别名部署，并可以轻松地在它们之间切换。</li><li id="2cf1" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><strong class="jf hj">延迟增加</strong>:无服务器架构可以全局访问，从而提高性能。该应用程序可以轻松地接受来自全球任何位置的请求。因此，应用程序的响应时间也减少了。</li><li id="184f" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><strong class="jf hj">增加的灵活性</strong>:在<a class="ae ku" href="https://javarevisited.blogspot.com/2020/07/top-6-courses-to-learn-aws-lambda-and-serverless.html#axzz6iYmMFnsA" rel="noopener ugc nofollow" target="_blank">无服务器</a>中实现应用比传统方法更容易，因为我们可以跳过与设置服务器和添加依赖关系相关的步骤，直接跳到决定应用的实际功能并实现它的部分。此外，通过创建不同的功能，可以更容易地为应用程序实现微服务。</li><li id="42b7" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><strong class="jf hj">更多的时间用于设计UX </strong>:由于我们的应用程序的基础设施是由云服务提供商自己提供的，因此可以将更多的时间用于开发我们应用程序的前端和后端。</li></ol><h1 id="231f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak"> AWS Lambda </strong></h1><p id="5976" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">AWS Lambda是由Amazon Web Services提供的事件驱动的无服务器计算服务，它让我们无需配置任何服务器就可以运行响应事件的代码。</p><p id="52c7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它于2014年11月13日作为“功能即服务(FaaS)”工具推出。它允许开发者定义和上传由基于事件的特定触发动作或执行代码执行的功能。</p><p id="1590" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它还允许将调用记录发送到已配置的目的地，如另一个lambda函数、SNS主题、SQS队列或EventBridge事件总线。这些功能也可用于将输入事件数据保存到s3。触发器可以是API Gateway、AWS IOT、<a class="ae ku" rel="noopener" href="/javarevisited/top-10-apache-kafka-online-training-courses-and-certifications-621f3c13b38c"> Apache Kafka </a>等。</p><p id="f261" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">AWS提供的一个额外特性——cloud watch可以与AWS lambda集成，以存储和监控用于调试的日志。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/7e3cb9689d1801801617d8455a0c5ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Jk9nPGJ2CCDqaTNVN-RHg.jpeg"/></div></div><p class="lh li et er es lj lk bd b be z dx translated">使用无服务器架构实现的登录操作的示例流程</p></figure><p id="d514" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">目前，AWS Lambda支持的语言有:</p><ol class=""><li id="5e5d" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated"><a class="ae ku" rel="noopener" href="/javarevisited/7-best-online-courses-to-learn-asp-net-core-and-mvc-in-depth-a68c1b728090?source=---------28------------------">。NET Core 3.1</a>(<a class="ae ku" rel="noopener" href="/javarevisited/5-best-c-c-sharp-programming-courses-for-beginners-in-2020-494f7afc7a5c">c#</a>/powerShell)</li><li id="765b" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><a class="ae ku" href="https://www.java67.com/2019/12/top-5-courses-to-learn-go-or-golang.html" rel="noopener ugc nofollow" target="_blank"> Go </a> 1.x</li><li id="8c16" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><a class="ae ku" rel="noopener" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"> Java 8 </a>，8(Corretto)，11(Corretto-Latest)</li><li id="ee68" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><a class="ae ku" rel="noopener" href="/javarevisited/top-10-online-courses-to-learn-node-js-in-depth-8ef0e31ca139"> Node.js </a> 10x，12x</li><li id="fa74" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><a class="ae ku" rel="noopener" href="/javarevisited/10-best-python-certification-courses-from-coursera-4576890eb6b3"> Python </a> - 2.7，3.6，3.7，3.8(最新)</li><li id="18e0" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><a class="ae ku" rel="noopener" href="/javarevisited/10-best-ruby-on-rails-courses-for-beginners-dca4d66e9f7b">红宝石</a> 2.5，2.7(最新)</li><li id="4553" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">还支持自定义运行时。</li></ol><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ll"><img src="../Images/9e8990186eda4e6450754852cabdccd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmjTsIC04_RGGYTnAUvOXw.png"/></div></div><p class="lh li et er es lj lk bd b be z dx translated">AWS Lambda服务的配置窗格的示例图片。</p></figure><p id="aa69" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上图显示了AWS Lambda函数中可用的各种配置选项</p><ol class=""><li id="f553" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">触发器:触发器是其他AWS服务，如API网关、AWS IOT、SQS等。它可以调用lambda函数。</li><li id="6916" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">目的地:这些是接收成功和失败的调用记录的AWS资源。它们可以被配置为流调用或异步调用。对于成功和失败的执行，这也可以用于在该函数执行之后调用另一个Lambda函数。</li><li id="da8d" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">层:这可用于添加额外的资源，如库、定制运行时和独立于功能代码的项目依赖项，以便不同的功能可以使用。</li><li id="035b" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">标签:这些是键值标签，可以添加到函数中，将它们分成不同的组以便识别。</li><li id="a73b" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">环境变量:这些是键值字符串，存储在基于版本的配置中，可以从代码中访问。</li><li id="9192" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">IAM角色:这个角色是Lamba函数与其他AWS服务和API交互所必需的。</li><li id="4f50" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">Lambda函数权限:用于定义可以调用lambda函数的事件源。</li><li id="6fb7" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">内存分配:这可以在基本设置选项卡中找到，用于配置分配给lambda函数的内存以及CPU资源。这必须在128到10240 MB之间。CPU是根据分配的内存资源调配的。</li><li id="84d8" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">超时设置:这也可以在basic settings选项卡中找到，用于限制每次调用后代码运行的时间。</li><li id="4b04" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">监控:lambda函数可以配置适当的策略来访问cloudwatch日志，以维护用于调试和监控性能的日志。</li></ol><h1 id="0a68" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">亚马逊API网关</strong></h1><p id="e3f5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Amazon API Gateway是一个完全托管的服务，用于使开发人员更容易创建、发布、监控和保护API，这些API充当应用程序/用户从后端服务访问数据或功能的端点，并创建<a class="ae ku" rel="noopener" href="/javarevisited/top-5-books-and-courses-to-learn-restful-web-services-in-java-using-spring-mvc-and-spring-boot-79ec4b351d12?source=---------17------------------"> RESTful </a>和WebSocket APIs以实现API之间的实时交互。这通常与AWS lambda服务一起使用，以创建无服务器堆栈。</p><p id="f76f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">API网关用于封装来自外部的内部云服务。通过使用此服务，可以监视和控制对内部服务的访问。</p><p id="426e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">创建过程中可用的API类型有:</p><ol class=""><li id="c780" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">HTTP API(用于Lambda和HTTP后端)</li><li id="852f" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">WebSocket API(用于Lambda、HTTP和AWS服务-无法导入)</li><li id="bb4b" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">Rest API(用于Lambda、HTTP和AWS服务)</li><li id="8265" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">rest API——用于私有连接，只能在VPCs中访问。</li></ol><p id="928f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">API创建过程分为四个阶段。它们是:</p><ol class=""><li id="6c81" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">API名称和集成:在lambda函数的情况下，集成选项也可以与资源名称和版本一起指定。此外，还可以配置API将与之通信的服务。</li><li id="ac3b" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">配置路由:这里的路由是指配置URL路径参数和方法(ANY、POST、PUT等。)可用于此API。</li><li id="59ce" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">定义阶段:这用于定义API的阶段名。这些是将要部署API的独立环境。这些可以用于维护一个项目的多个环境，其中每个环境都将独立运行，并且可以进行不同的配置。</li><li id="8dca" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">审查和创建阶段:这用于在创建API之前审查一次它的细节。</li></ol><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lm"><img src="../Images/fde5f98d31ffc51e62691e96aae5a576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5RaVW54XqJcqN3Scsg-JA.png"/></div></div></figure><p id="8966" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在API网关中，API的安全性和行为可以分四个阶段进行配置:</p><p id="1d5d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">1.<strong class="jf hj"> <em class="ln">方法请求</em> </strong>用于定义客户端在访问后端的请求中应该发送什么，以及客户端收到的响应。这可以用来限制可以发送到所选方法的请求类型。它提供了设置与请求相关的各种参数的选项，如请求路径、URL查询字符串参数、HTTP请求头、请求正文和SDK设置。可以使用用户定义的模型来指定请求体，这些模型包含JSON请求的模式定义和请求的内容类型。在查询字符串的情况下，它们可以在这里被配置为必需的或可选的。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lo"><img src="../Images/3389ae9e9b4ba4daa367cb54f8af3321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTLHfeucbp38gaNgyWQSVQ.png"/></div></div></figure><p id="b7e2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2.<strong class="jf hj"> <em class="ln">集成请求</em> </strong>用于提供关于API所连接的后端服务的信息。这里，API请求在被发送到所选服务之前被处理。为了调用Lambda函数，必须提供集成类型、Lambda区域和Lambda函数的详细信息。其他可配置的参数有:</p><ul class=""><li id="c98d" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka lp km kn ko bi translated">URL路径参数</li><li id="d6af" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka lp km kn ko bi translated">URL查询字符串参数</li><li id="6abe" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka lp km kn ko bi translated">HTTP标题</li><li id="900a" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka lp km kn ko bi translated">映射模板</li></ul><p id="b95b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">可以使用映射约定- method.request将URL和头参数的值映射到特定值。{ " path " | " query string " | " Header " | " multivaluequerystring " | " multivalueheader " }。{参数名称}，其中<em class="ln">参数名称</em>对应于正在映射的参数。</p><p id="978d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">映射模板用于在将传入的请求发送到后端之前将它们转换为所需的类型，并基于内容类型进行应用。因此，您可以为一个内容类型定义一个映射模板。如果请求中没有指定内容类型，则使用application/json。</p><p id="b823" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">3.<strong class="jf hj"> <em class="ln">集成响应</em> </strong>用于定义如何处理lambda错误或HTTP错误代码等响应代码。可以指定从内部服务获取错误响应，并将它们放在可以发送给客户的响应正文中。这可用于将服务中发生的内部错误映射到可发送给客户端的预定义结构中。</p><p id="2c23" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">4.<strong class="jf hj"> <em class="ln">方法response </em> </strong>用于定义在各种场景下，响应客户端发送的请求，客户端应该收到什么。因此，您可以指定哪些类型的状态代码可以发送回客户端，以及基于内容类型的响应主体的定制头和响应模型。</p></div></div>    
</body>
</html>