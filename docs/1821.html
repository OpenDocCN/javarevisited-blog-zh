<html>
<head>
<title>Spring Boot + JPA — Clear Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot + JPA —清除测试</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-boot-jpa-clear-tests-95804529863b?source=collection_archive---------2-----------------------#2021-12-17">https://medium.com/javarevisited/spring-boot-jpa-clear-tests-95804529863b?source=collection_archive---------2-----------------------#2021-12-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2b07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我写过几篇关于测试Spring Boot应用程序的文章。我们特别讨论了<a class="ae jd" href="https://dev.to/kirekov/spring-boot-testing-data-and-services-288f" rel="noopener ugc nofollow" target="_blank">与数据库</a>和<a class="ae jd" href="https://dev.to/kirekov/spring-boot-testing-testcontainers-and-flyway-2jpd" rel="noopener ugc nofollow" target="_blank">测试容器库</a>的集成测试。但是今天我想谈一个更重要的话题。你看，测试对于构建健壮的软件是必不可少的。但是写得不好的测试就不是这样了。它们会减慢开发过程，使代码难以更改和维护。</p><p id="530a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当涉及到测试时，必须声明测试数据。它可以是中的项、数据库中的记录或分布式队列中的消息。没有数据就无法测试行为。</p><p id="2027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，今天我们讨论使用<a class="ae jd" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e?source=---------39------------------"> Spring Boot </a> + <a class="ae jd" rel="noopener" href="/javarevisited/5-best-spring-data-jpa-courses-for-java-developers-45e6438be3c9"> Spring数据</a> + <a class="ae jd" rel="noopener" href="/javarevisited/top-5-hibernate-online-training-courses-for-beginners-and-advance-java-programmers-469460596b2b"> JPA在数据库中创建测试行的模式。</a></p><p id="9945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在<a class="ae jd" href="https://github.com/SimonHarmonicMinor/spring-boot-testing-data-patterns" rel="noopener ugc nofollow" target="_blank">库</a>中找到所有代码片段。</p><h1 id="46a9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">领域模型</h1><p id="e2e2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">假设我们正在开发<a class="ae jd" rel="noopener" href="/">中型</a>服务。人们可以发表帖子和评论。下面是数据库模式。</p><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/08/top-5-spring-data-jpa-courses-for-java.html"><div class="er es kh"><img src="../Images/545d0eec2fe12b81b5e59c5a79bb0c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*INN5LyGqwaNE286w.png"/></div></a><p class="kp kq et er es kr ks bd b be z dx translated">数据库模式</p></figure><p id="6596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是相应的Hibernate实体。</p><h2 id="69a0" class="kt jf hi bd jg ku kv kw jk kx ky kz jo iq la lb js iu lc ld jw iy le lf ka lg bi translated">邮政</h2><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><h2 id="76b9" class="kt jf hi bd jg ku kv kw jk kx ky kz jo iq la lb js iu lc ld jw iy le lf ka lg bi translated">评论</h2><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><h2 id="abfe" class="kt jf hi bd jg ku kv kw jk kx ky kz jo iq la lb js iu lc ld jw iy le lf ka lg bi translated">用户</h2><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="9f7d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">商业案例</h1><p id="b1c3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">假设我们应该显示排名前N位的帖子，按带有评论的降序排列。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><blockquote class="lj lk ll"><p id="1f02" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">为了简洁起见，我们省略了实现细节，因为这不是本文的主题。您可以在<a class="ae jd" href="https://github.com/SimonHarmonicMinor/spring-boot-testing-data-patterns" rel="noopener ugc nofollow" target="_blank">库</a>中找到完整的工作解决方案。</p></blockquote><p id="58d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候写一些测试了。假设我们有10个帖子。每个帖子有2条评论。我们想要检索前3个帖子。这就是测试的样子。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/04/top-5-junit-and-unit-testing-courses-java-programmers.html"><div class="er es lq"><img src="../Images/3243288622e8637381b49e5670ac067d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZlPFluub5iQfpn_s.png"/></div></a></figure><p id="d1a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个测试通过了。它工作正常。反正有些问题是要提的。</p><ol class=""><li id="1c4e" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">这个阶段太复杂了</li><li id="9952" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated">测试有太多的依赖项</li><li id="afa8" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated">断言含糊不清</li></ol><p id="d30c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在执行查询之前，我们需要在数据库中插入一些记录。在这种情况下，实体通过构造函数被实例化。看起来是个不错的设计选择。所有必需的属性都可以作为参数传递。如果稍后出现另一个字段，它也可以包含在构造函数中。因此，我们可以保证所有的<code class="du ma mb mc md b">non-null</code>字段都存在。</p><p id="f00c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">细节决定成败。</p><ol class=""><li id="858e" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">测试代码变得与构造函数定义过于耦合。你看，可能有大量的测试需要创建帖子、评论和用户。如果这些实体的构造函数中的任何一个通过另一个属性得到增强，那么直接实例化对象的所有代码部分都不会编译。</li><li id="f081" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated">并非所有的实体字段在每个测试用例中都是必要的。例如，在测试<code class="du ma mb mc md b">findTopPosts</code>方法时，我们只对<code class="du ma mb mc md b">Post</code>实体的<code class="du ma mb mc md b">rating</code>值感兴趣。</li><li id="64f8" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated">这些论点不是不言自明的。<code class="du ma mb mc md b">Post</code>实体构造函数有5个位置参数。每次查看测试套件时，您都必须停下来分析将要分配的目标值。</li><li id="cf6b" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated">测试用例是<em class="lm">命令式的</em>而不是<em class="lm">声明式的</em>。为什么这是个问题？因为测试是API契约。写得好的测试就像完美的类文档。</li></ol><p id="a57d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用<a class="ae jd" href="https://martinfowler.com/bliki/ObjectMother.html" rel="noopener ugc nofollow" target="_blank">对象母模式</a>来解决。具有多个创建策略的简单工厂。这就是我们如何实例化新的<code class="du ma mb mc md b">Post</code>对象。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="de0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以为所有实体创建类似的工厂。所以，现在测试看起来像这样。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/feaed24a2b701cab5b3f15154d5ae13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s-kBe1GOioXuNTgU.png"/></div></div></figure><p id="31f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">的确，这样更容易理解流程。它可以用于简单的场景。但是我们假设有几种创建新职位的情况。这将需要添加许多重载方法。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="a804" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du ma mb mc md b">Post</code>实体有更多的字段会怎样？如果这些属性中有一些是可选的呢？想象一下，我们需要多少个<code class="du ma mb mc md b">createPost</code>声明来涵盖所有这些情况。</p><p id="9cd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象母模式通过减少参数的数量部分解决了参数名的问题。无论如何，解决方案远非完美。</p><h1 id="ada4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">测试数据生成器</h1><p id="4d4f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><a class="ae jd" href="https://www.javacodegeeks.com/2014/06/test-data-builders-and-object-mother-another-look.html" rel="noopener ugc nofollow" target="_blank">测试数据生成器</a>是对象母模式的一个替代方案。是典型的<a class="ae jd" href="https://refactoring.guru/design-patterns/builder" rel="noopener ugc nofollow" target="_blank"> GoF模式</a>。但是我们为我们的测试用例做了一些改进。</p><p id="fb17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看一看<code class="du ma mb mc md b">PostTestBuilder</code>。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="b721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它看起来像一个普通的建造者，但有一些细微的不同。</p><p id="31e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，该类实现了提供单个<code class="du ma mb mc md b">build</code>方法的<code class="du ma mb mc md b">Builder</code>接口。你可能会认为这是一个过度的复杂，但很快你就会意识到它的好处。</p><p id="16ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，关系属性。构建者持有<code class="du ma mb mc md b">Builder&lt;User&gt;</code>而不是<code class="du ma mb mc md b">User</code>本身(其他关系也是如此)。这有助于减少客户端代码的冗长。</p><p id="7eca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后是变异子(<code class="du ma mb mc md b">withName</code>、<code class="du ma mb mc md b">withContent</code>等)。)返回一个新的生成器，而不是改变当前生成器的状态。当我们想要创建许多相似的对象，它们只有特定的参数不同时，这是一个有用的特性。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="e88d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重写后的测试如下所示。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="7f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你注意到测试看起来有多干净了吗？我们正在创建10个评分为<code class="du ma mb mc md b">i</code>的帖子。每个帖子有2条评论。太神奇了！</p><p id="2ae8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但可悲的是，它不起作用。</p><pre class="ki kj kk kl fd mo md mp mq aw mr bi"><span id="ee89" class="kt jf hi md b fi ms mt l mu mv">org.hibernate.TransientPropertyValueException: Not-null property references a transient value - transient instance must be saved before current operation</span></pre><p id="54ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">Post.author</code>保存不传播。它可以通过使用<code class="du ma mb mc md b">CascadeType.PERSIST</code>选项来修复。但是也许我们不需要在应用程序中级联作者持久性。所以，仅仅为了让测试“绿色”而改变它是错误的。</p><h1 id="7eb0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">持久包装</h1><p id="e369" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在调用<code class="du ma mb mc md b">build</code>方法时，将创建<code class="du ma mb mc md b">Post</code>实体及其所有关系(作者和评论)。因此，当相应的构建器处理实例化时，我们需要持久化子对象。还记得附加的<code class="du ma mb mc md b">Builder</code>接口吗？它现在会帮助我们。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="08b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">persisted</code>回调返回相同的构建器，该构建器将过早地持久化结果实体。</p><p id="2514" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要将<code class="du ma mb mc md b">TestDBFacade</code>注入到我们的测试套件中。这可以通过使用<code class="du ma mb mc md b">@ContextConfiguration</code>注释来完成。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="4d76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过声明自定义注释，我们可以做得更好。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="a5ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，这就是结果测试。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><blockquote class="lj lk ll"><p id="aee9" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">我们不必用<code class="du ma mb mc md b">persisted</code>回调包装注释，因为<code class="du ma mb mc md b">Post.comments</code>关系已经用<code class="du ma mb mc md b">CascadeType.PERSIST</code>属性标记了。</p></blockquote><p id="8786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在成功了。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es lq"><img src="../Images/c103f3e42275e975eec7312619127094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TKeHe5-w7AOYqrn3.png"/></div></div></figure><p id="0fcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想你已经猜到了，并不是所有的东西都调好了。如果打开SQL日志记录，您会注意到这一点。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="a42f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们期望只有一个用户。但实际上，每个帖子和评论都创建了一个新的。这意味着我们有30个用户。</p><p id="8960" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢天谢地，有一个变通办法。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="0740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">持久性仅在第一次调用时被处理。后面的调用返回保存的实体。</p><blockquote class="lj lk ll"><p id="b815" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">此方法不是线程安全的。然而，在大多数情况下这是可以接受的。因为通常情况下，每个测试场景都是一个按顺序运行的独立操作。</p></blockquote><p id="aada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们要做的就是用<code class="du ma mb mc md b">persistedOnce</code>的用法来改变<code class="du ma mb mc md b">persisted</code>。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="0e73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在只有一个持久用户。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="1bfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个需要重构的是<code class="du ma mb mc md b">PostRepository</code>的用法。我们不需要在特定的Spring数据仓库上添加额外的依赖。我们可以将<code class="du ma mb mc md b">save</code>方法直接添加到<code class="du ma mb mc md b">TestDBFacade</code>中。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><h1 id="33fe" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">明确的主张</h1><p id="55dd" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我想讨论的最后一件事是断言的用法。再看一下现在的测试。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="df4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">size</code>断言是正确的。排序和评论计数检查呢？它们不是透明的。当您浏览代码时，您应该特别注意弄清楚这些断言的目的。</p><p id="ca96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何，这不是唯一的问题。如果他们失败了呢？我们会在日志中看到类似这样的内容。</p><pre class="ki kj kk kl fd mo md mp mq aw mr bi"><span id="77fd" class="kt jf hi md b fi ms mt l mu mv">Posts should be sorted in by rating in descending order<br/>Expected : [posts list]<br/>Actual   : [posts list]<br/><br/>Each post should have 2 comments<br/>Expected : true<br/>Actual   : false</span></pre><p id="d178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没那么描述性。但是有一个更好的选择。</p><h1 id="1a72" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">哈姆克雷斯特</h1><p id="c822" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><a class="ae jd" href="http://hamcrest.org/" rel="noopener ugc nofollow" target="_blank"> Hamcrest </a>是一个断言库，帮助构建<em class="lm">匹配器</em>的声明管道。例如，这就是如何验证帖子计数的方法。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="2675" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与最初的尝试没有太大的不同。另外两个呢？这些断言是面向领域的。Hamcrest不为特定的商业案例提供实用程序。但让Hamrest强大的是定制匹配器。这是一个评论计数验证。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="9c6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ma mb mc md b">matchesSafely</code>方法执行断言本身。在这种情况下，我们检查排序的是否等于初始的。<br/><code class="du ma mb mc md b">describeTo</code>方法给断言分配一个标签。<br/>和<code class="du ma mb mc md b">describeMismatchSafely</code>记录测试失败时的输出。</p><p id="1587" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">断言的用法很简单。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="c029" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设收到的帖子没有预期的评论数。这是失败的测试输出。</p><pre class="ki kj kk kl fd mo md mp mq aw mr bi"><span id="b49c" class="kt jf hi md b fi ms mt l mu mv">Expected: 2 comments in each post<br/>     but: PostView[10] with 3 comments ; PostView[9] with 3 comments ; PostView[8] with 3 comments</span></pre><p id="d804" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在意图很明显了。我们预计每个帖子会有2个评论，但它是3个。比简单的<code class="du ma mb mc md b">expected true but was false</code>表现力强多了。</p><p id="5bab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候为帖子排序顺序验证编写匹配器了。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="00f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个断言。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><blockquote class="lj lk ll"><p id="0974" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated"><code class="du ma mb mc md b">Matchers.is</code>是一个装饰器，让测试看起来更有表现力。尽管它可以被省略。</p></blockquote><p id="ba70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是失败的测试输出。</p><pre class="ki kj kk kl fd mo md mp mq aw mr bi"><span id="d6a7" class="kt jf hi md b fi ms mt l mu mv">Expected: is sorted posts by rating in desc order<br/>     but: [7.0, 8.0, 9.0]</span></pre><p id="6328" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，用户的意图很明显。我们期望收到<code class="du ma mb mc md b">[9, 8, 7]</code>，但收到的是<code class="du ma mb mc md b">[7, 8, 9]</code>。</p><h1 id="2be0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">摘要</h1><p id="c8e3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们做了一些重构。我们来对比一下最初的尝试和最终的版本。</p><h2 id="39f3" class="kt jf hi bd jg ku kv kw jk kx ky kz jo iq la lb js iu lc ld jw iy le lf ka lg bi translated">第一次尝试</h2><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><h2 id="bf43" class="kt jf hi bd jg ku kv kw jk kx ky kz jo iq la lb js iu lc ld jw iy le lf ka lg bi translated">最终版本</h2><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="9ba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个选项是一组命令。很难理解我们到底在测试什么。而第二种方法告诉我们更多关于行为的信息。它更像是描述类的契约的文档。</p><h1 id="8cf6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="bc4b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">曾经听过一句至理名言。</p><blockquote class="lj lk ll"><p id="092f" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">测试是没有测试的代码部分。</p></blockquote><p id="758f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试业务逻辑至关重要。但是更重要的是确保测试不会成为可维护性的负担。</p><p id="8f13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我想告诉你的关于编写清晰测试的全部内容。如果你有任何问题，请在下面留下你的评论。感谢阅读！</p><h1 id="ba57" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">资源</h1><ol class=""><li id="480e" class="lr ls hi ih b ii kc im kd iq mw iu mx iy my jc lw lx ly lz bi translated"><a class="ae jd" rel="noopener" href="/javarevisited/spring-boot-testing-data-and-services-bc8b4c62ee8f?source=friends_link&amp;sk=86148a772616274202776f4515c078e4"> Spring Boot测试—数据和服务</a></li><li id="c8f0" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated"><a class="ae jd" rel="noopener" href="/javarevisited/spring-boot-testing-testcontainers-and-flyway-df4a71376db4?source=friends_link&amp;sk=1d0ffcd36bb4265c2d0120520bc8a567"> Spring Boot测试——测试集装箱和飞行路线</a></li><li id="794a" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated"><a class="ae jd" href="https://github.com/SimonHarmonicMinor/spring-boot-testing-data-patterns" rel="noopener ugc nofollow" target="_blank">带有代码示例的知识库</a></li><li id="0fcd" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated"><a class="ae jd" href="https://martinfowler.com/bliki/ObjectMother.html" rel="noopener ugc nofollow" target="_blank">对象母模式</a></li><li id="a94f" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated"><a class="ae jd" href="https://www.javacodegeeks.com/2014/06/test-data-builders-and-object-mother-another-look.html" rel="noopener ugc nofollow" target="_blank">测试数据生成器</a></li><li id="dccf" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated"><a class="ae jd" href="https://refactoring.guru/design-patterns/builder" rel="noopener ugc nofollow" target="_blank">构建器模式</a></li><li id="5655" class="lr ls hi ih b ii me im mf iq mg iu mh iy mi jc lw lx ly lz bi translated"><a class="ae jd" href="http://hamcrest.org/" rel="noopener ugc nofollow" target="_blank">汉克莱斯特</a></li></ol></div></div>    
</body>
</html>