<html>
<head>
<title>Debugging Gson, Moshi and Jackson JSON Frameworks in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在生产中调试Gson、Moshi和Jackson JSON框架</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/debugging-gson-moshi-and-jackson-json-frameworks-in-production-8c6182d6f001?source=collection_archive---------4-----------------------#2022-07-01">https://medium.com/javarevisited/debugging-gson-moshi-and-jackson-json-frameworks-in-production-8c6182d6f001?source=collection_archive---------4-----------------------#2022-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/02/how-to-setup-remote-debugging-in.html"><div class="er es if"><img src="../Images/65131ba0520a5473e99a5a64b05ee40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LDmYG38yv_dzanNZ-trG7A.png"/></div></a></figure><p id="2e4a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">解析bug是API时代一直给予的礼物。我们使用服务；在调试、QA等方面都非常好用。然后一些用户输入到达web请求，返回一个我们无法解析的结果。不幸的是，现阶段我们无能为力。我们需要了解失败发生的原因，以及如何解决和修复它。</p><p id="2fe6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在生产中，这不是小事。我们可以记录我们进行的所有调用和传递的所有对象。但是这将会破坏我们的性能，并使我们的日志存储费用飞涨。这也可能使我们违反隐私法，因为<a class="ae jk" href="https://www.java67.com/2016/10/3-ways-to-convert-string-to-json-object-in-java.html" rel="noopener ugc nofollow" target="_blank"> JSON数据</a>可能包含私人用户信息。这是生产中的一个常见问题，因为webservice可能会在运行时更改并触发序列化失败。在多语言环境中尤其如此，使用像Jackson这样的API映射的Java类可能会在NodeJS对象的反序列化上失败。</p><p id="8a50" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于JSON处理，Java有三个公共库:</p><ul class=""><li id="ffb0" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><a class="ae jk" href="https://www.java67.com/2019/05/how-to-read-csv-file-in-java-using-jackson-library.html" rel="noopener ugc nofollow" target="_blank">杰克森</a>——三者中最老、最稳定的解析器API</li><li id="949e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://javarevisited.blogspot.com/2022/03/3-examples-to-parse-json-in-java-using.html" rel="noopener ugc nofollow" target="_blank">Gson</a>——谷歌的一个更轻量级的API</li><li id="2f9f" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">Moshi —在服务器中知名度不高(在Android上更受欢迎)。由Gson的作者编写，应被视为其继任者，因为Gson不再被积极维护</li></ul><h1 id="c29c" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Java中JSON解析的基础</h1><p id="09d4" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">这些库在概念上非常相似。它们支持泛型类型的序列化，并将它们映射到对象。我们可以在任意Java对象或对象列表之间进行转换。为了简单起见，我将把重点放在字符串上，因为这是一个关于调试的教程。</p><p id="9fed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在下面的代码片段中，我们使用标准Java POJO(普通旧Java对象)作为User和DBObject值。这些是琐碎的对象，包含相对简单的字段，如字符串、原语、字节数组等。在演示代码中，为了方便起见，我用Lombok创建了它们，但是它们用getter/setter也能很好地工作。这也适用于具有深度嵌套、集合类型等的复杂对象。</p><p id="bdbc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用Jackson，您可以使用如下代码生成一个JSON字符串:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="40d7" class="ll ka hi lh b fi lm ln l lo lp">String json = mapper.writeValueAsString(user);</span></pre><p id="5f91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以使用Jackson来执行对象序列化:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8f75" class="ll ka hi lh b fi lm ln l lo lp">DBObject object = mapper.readValue(json, DBObject.class);</span></pre><p id="fe2d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于Gson，我们可以使用以下方法完成同样的工作:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2f98" class="ll ka hi lh b fi lm ln l lo lp">String json = gson.toJson(user);</span></pre><p id="2a35" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是Gson如何转换成一个对象:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c6d3" class="ll ka hi lh b fi lm ln l lo lp">DBObject object = gson.fromJson(json, DBObject.class);</span></pre><p id="c69e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Moshi有点冗长，但是支持更多的定制特性和类型安全:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e9a3" class="ll ka hi lh b fi lm ln l lo lp">String json = moshi.adapter(User.class).toJson(user);</span></pre><p id="50c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是在Moshi中获取一个对象的代码:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="38db" class="ll ka hi lh b fi lm ln l lo lp">DBObject object = moshi.adapter(DBObject.class).fromJson(json);</span></pre><p id="cd91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，Moshi使用现成的类型适配器。“类型适配器”的概念不是Moshi独有的，它存在于所有这些工具中。它允许我们执行定制的反序列化，特别是“低级”对象/JSON映射。在这种情况下，Moshi将这个API放在最前面</p><h1 id="44cf" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">演示</h1><p id="4b41" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">为了演示调试，我创建了一个简单的JSON数据库应用程序，它允许我们将元素保存为JSON文件。你可以在这里找到完整的源代码。这个演示涵盖了所有三个JSON解析器以及它们的大部分基本特性，比如类型适配器。</p><p id="f1db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以通过提交HTTP头来选择在请求中使用的API，DatabaseWS类中的工厂方法选择正确的实现实例。这样，我们可以像Gson、Jackson或Moshi一样处理任何请求。默认为魔石。</p><p id="17b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个可以在IntelliJ/IDEA中打开的标准Spring Boot项目。本文的其余部分假设您已经安装并运行了Lightrun。如果没有，请在这里免费安装<a class="ae jk" href="https://lightrun.com/free" rel="noopener ugc nofollow" target="_blank">。你可以在这里阅读</a><a class="ae jk" href="https://docs.lightrun.com/" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="66d6" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">创建数据库用户</h1><p id="f8d1" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">在开始之前，我们需要创建一个新的数据库用户。我们可以用下面的命令来实现:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b731" class="ll ka hi lh b fi lm ln l lo lp">curl -X PUT  -H "Content-Type: application/json" -H "Authorization: 45971c45-4049-48f8-970f-04d47be2defc" -d '{"login":"user", "password":"123456", "givenName":"Shai", "surname":"Almog"}' "http://localhost:8080/addUser"</span></pre><p id="1e20" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦执行，您应该会看到一个名为“~/myDB/user.user”的文件。注意~代表当前用户的主目录。该文件应该包含类似于以下JSON的内容:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="71b9" class="ll ka hi lh b fi lm ln l lo lp">{<br/>  "login": "user",<br/>  "givenName": "Shai",<br/>  "surname": "Almog",<br/>  "email": null,<br/>  "hashedPassword": "$2a$10$DeBGvevs8RiHCIdRqa9fo.ED.6K2UYXXgXYF1.6uLxU1yxmq9c8ZK",<br/>  "token": "7e5a50db-f44a-4177-af48-6fa39c127810",<br/>  "password": null<br/>}</span></pre><p id="398f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该文件是由Moshi生成的。如果我们希望为解析器/生成器使用另一个选项，我们可以添加参数:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="3466" class="ll ka hi lh b fi lm ln l lo lp">-H "type: jackson" or -H "type: gson" respectively.</span></pre><h1 id="3173" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">证明</h1><p id="bcd8" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">一旦我们创建了一个用户，我们就可以使用类似如下的curl命令使用身份验证API登录到数据库:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8aaa" class="ll ka hi lh b fi lm ln l lo lp">curl -H "Content-Type: application/json" -H "Authorization: 45971c45-4049-48f8-970f-04d47be2defc" -H "type: jackson" -d '{"login":"shai","password":"123456"}' "http://localhost:8080/auth"</span></pre><p id="0c28" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这种情况下，我选择使用Jackson解析器登录，而不是默认的moshi。这个命令在响应中返回一个令牌，我们可以用它来执行操作。</p><h1 id="136d" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">添加条目</h1><p id="0c0d" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">我们可以使用命令向“数据库”添加记录，例如:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8704" class="ll ka hi lh b fi lm ln l lo lp">curl -H "Content-Type: application/json" -H "Authorization: 45971c45-4049-48f8-970f-04d47be2defc" -H "type: jackson" -d '{"coreData":"FBYWFiEs"}' "http://localhost:8080/create"</span></pre><p id="0b74" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，我们在上面发送的身份验证调用的响应被用在授权头中。</p><p id="e0ba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">数据库中还有其他几个特性，但我现在将跳过它们…</p><h1 id="89b7" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">读取条目</h1><p id="acd6" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">使用反序列化从数据库中读取元素甚至更容易。这是一个简单的REST GET方法:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9603" class="ll ka hi lh b fi lm ln l lo lp">curl -H "Content-Type: application/json" -H "Authorization: 45971c45-4049-48f8-970f-04d47be2defc" -H "type: jackson" "http://localhost:8080/read?id=0ca3edb8-37db-4d97-bbc4-e5222e94db17"</span></pre><p id="a4ad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这种情况下，我再次使用杰克逊，但它应该同样适用于Moshi/Gson。注意，read调用的参数是对象的ID。我们从创建调用接收id作为响应。</p><h1 id="71de" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">检查和调试</h1><p id="b0bb" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">调试Gson、Jackson或Moshi之类的API相当具有挑战性。不像典型的Java APIs在失败时会抛出一个检查过的异常，这些工具通常会记录解析错误。此外，许多序列化错误或问题可能看起来是一个缺少的选项，而不是一个可见的bug。</p><p id="e9a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个类可能有不同的字段名称，或者可能缺少一个额外的字段，因此对象字段可能包含反序列化过程之后的部分信息。不幸的是，当我们拥有类型对象的时候，已经有点太晚了。JSON没了，我们没法跟结果比。我们希望在序列化过程中检查对象。</p><p id="2656" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们继续之前，你需要确保你安装了Lightrun，并且对它的用法有一个基本的了解。你可以从<a class="ae jk" href="https://lightrun.com/free" rel="noopener ugc nofollow" target="_blank">这里</a>安装一个免费版本。</p><p id="c642" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦我们有了这些，我们就可以开始调试了…</p><h1 id="4e5f" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">调试运行中的序列化</h1><p id="c919" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">生成JSON文件的代码通常更容易调试，问题也更少。这是一个简单的起点。我们可以在写入对象的位置放一个快照。例如，在这种情况下，我使用了JSONDatabaseService类，并在writeString方法调用上放置了一个快照。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/18ca4d5598608b51c0af51ce66ba3afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f_wjo_jsWxbd4fOW"/></div></div></figure><p id="c444" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在堆栈中，我可以看到JSON数据和原始对象。这样，我们可以检查两者之间的任何差异。通常，这可能与像Jackson或Gson这样的实现在空对象、日期、时间等方面的默认行为有关。这些细微差别在不同的实现之间有很大的不同。</p><h1 id="f90a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">反序列化</h1><p id="300c" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">将JSON字符串或文件读入一个类是我们大多数人失败的地方。遗漏的名字会被跳过，一个小小的错别字会成为一个巨大的问题。</p><p id="22aa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是在我们将字符串转换为对象之前检查JSON的能力的真正价值。在这个示例中，我们可以通过在<code class="du lv lw lx lh b">JacksonDatabaseService</code>类中放置一个快照来轻松做到这一点。注意这是杰克逊特有的。我们可以对Gson和moshi做同样的事情，将快照放在它们各自的抽象类中。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/56131fe66fb409f417c84462018f73cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*liGIAuKFIMorUrUj"/></div></div></figure><p id="df8b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦这个被放置，我们可以尝试读取一个对象，我们将看到收到的JSON。在这种特殊情况下，从方法参数中获取JSON是微不足道的。然而，这并不是例外，在大多数情况下获取这些数据是可能的。</p><p id="c2d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是查看字段名和各种类型适配器以理解结果对象字段的地方。</p><h1 id="c36e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">一锤定音</h1><p id="b939" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">无论你使用Jackson、Gson还是moshi，Java中的JSON处理总是一个挑战。它们都以大致相同的方式失败，并且经常出现在生产数据中。由于记录数据可能会使我们承担责任和增加成本，我们调试这些API的唯一选择是通过开发人员的可观察性工具，比如Lightrun。</p><p id="d37f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于大多数调试情况，我们可以在API访问上放置一个快照，并检查结果节点、列表等。这通常是帮助我们转换类型表示的通用代码，比如foo类型的对象。我们可以发送/存储的JSON文件，等等。</p></div></div>    
</body>
</html>