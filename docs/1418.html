<html>
<head>
<title>Core Concepts of Object-Oriented Programming-2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程的核心概念-2</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/core-concepts-of-object-oriented-programming-2-956cc0c275ee?source=collection_archive---------3-----------------------#2021-07-29">https://medium.com/javarevisited/core-concepts-of-object-oriented-programming-2-956cc0c275ee?source=collection_archive---------3-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/dc7bba007301e3a2e7995e7569d3dbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*AC1QZht4dO7Htw244R8_sA.jpeg"/></div></figure><blockquote class="im in io"><p id="b8ec" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将讨论面向对象编程的重要概念，这些概念对于创建可扩展的项目非常重要。这是文章的第二部分。你可以通过<strong class="is hj"> </strong> <a class="ae jo" rel="noopener" href="/geekculture/core-concepts-of-object-oriented-programming-1-49397c7e0cbe"> <strong class="is hj">这个环节</strong> </a>找到第一部分。如果你不熟悉面向对象编程，首先你可以看一下<a class="ae jo" href="https://azizkale.medium.com/basic-concepts-of-oop-77cdaecda561" rel="noopener"> <strong class="is hj"> <em class="hi">这篇文章</em> </strong> </a>中主题的一些基本概念。</p></blockquote><p id="fe11" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在本文中，我将继续谈论<strong class="is hj">面向对象编程</strong>的核心概念。</p><p id="7d40" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我将像以前一样使用JAVA作为编程语言，IntelliJ IDEA作为IDE。</p><p id="1a6c" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">要描述的概念如下:</p><ul class=""><li id="2a25" class="js jt hi is b it iu ix iy jp ju jq jv jr jw jn jx jy jz ka bi translated"><a class="ae jo" href="#edc9" rel="noopener ugc nofollow">可比接口</a></li><li id="f71c" class="js jt hi is b it kb ix kc jp kd jq ke jr kf jn jx jy jz ka bi translated"><a class="ae jo" href="#389c" rel="noopener ugc nofollow">最终方法</a></li><li id="ed0c" class="js jt hi is b it kb ix kc jp kd jq ke jr kf jn jx jy jz ka bi translated"><a class="ae jo" href="#b31c" rel="noopener ugc nofollow">静态</a></li><li id="075a" class="js jt hi is b it kb ix kc jp kd jq ke jr kf jn jx jy jz ka bi translated"><a class="ae jo" href="#8be8" rel="noopener ugc nofollow">抽象类和方法</a></li></ul><h2 id="8d5d" class="kg kh hi bd ki kj kk kl km kn ko kp kq jp kr ks kt jq ku kv kw jr kx ky kz la bi translated">可比接口</h2><p id="edc9" class="pw-post-body-paragraph ip iq hi is b it lb iv iw ix lc iz ja jp ld jd je jq le jh ji jr lf jl jm jn hb bi translated">它是一个自动生成的接口，所以你不需要创建它，并提供你比较两个对象。它包括一个名为“<strong class="is hj"> compareTo </strong>”的方法。该方法将一个对象作为输入参数，该对象的类型与其实现的类相同，并返回一个整数<strong class="is hj"/>。</p><p id="77a0" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><em class="ir"> compareTo </em>的主要目的是根据您指定的标准，将同一类别的两个对象进行比较。</p><p id="25d9" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">当我们开始排序或搜索这种类型的对象时，这将非常方便。</p><p id="fe57" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">让我们通过一个例子来更好地理解它:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="4d7f" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我们有一个关于雇员的简单类，我用它的类型实现了comparable接口。并且我指定了<a class="ae jo" href="https://javarevisited.blogspot.com/2011/11/how-to-override-compareto-method-in.html" rel="noopener ugc nofollow" target="_blank"> <em class="ir">比较</em> <strong class="is hj"> <em class="ir"> </em> </strong>方法</a>及其参数。</p><p id="3641" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">现在让我们修改这个方法:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="ed36" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我想根据员工的<em class="ir">工资</em>对他们进行排序。如果工资相等，员工将根据他们的<em class="ir">姓名</em>进行比较。</p><p id="2ef3" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在<strong class="is hj">主</strong>类中，我添加了如下代码:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="96ea" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">输出是:</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="fbe6" class="kg kh hi ln b fi lr ls l lt lu"><strong class="ln hj">name</strong>: Joe <strong class="ln hj">salary</strong>: 1900<br/><strong class="ln hj">name</strong>: Kevin <strong class="ln hj">salary</strong>: 2000<br/><strong class="ln hj">name</strong>: Sara <strong class="ln hj">salary</strong>: 2000<br/><strong class="ln hj">name</strong>: Michael <strong class="ln hj">salary</strong>: 4000</span></pre><h2 id="389c" class="kg kh hi bd ki kj kk kl km kn ko kp kq jp kr ks kt jq ku kv kw jr kx ky kz la bi translated">最终方法</h2><p id="3a8f" class="pw-post-body-paragraph ip iq hi is b it lb iv iw ix lc iz ja jp ld jd je jq le jh ji jr lf jl jm jn hb bi translated">有时您希望保护父类中的方法不被重写。所以没人能在子类中改变(覆盖)你的方法。为此，您应该在父类中的方法开头使用<a class="ae jo" href="https://javarevisited.blogspot.com/2013/12/when-to-make-method-final-in-java.html" rel="noopener ugc nofollow" target="_blank">关键字“<strong class="is hj">final</strong>”</a>。</p><p id="ce6f" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">下面是一个例子:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="5b60" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在<em class="ir">宠物</em>类中，我有一个计算年龄的方法。</p><p id="95d7" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">现在我创建了另一个名为<em class="ir"> Dog </em>的类，它继承了<em class="ir"> Pet </em>类。然后在<em class="ir"> Dog </em>类中，我试图覆盖从父类继承的方法:</p><figure class="lg lh li lj fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/03/finally-java-10-has-var-to-declare-local-variables.html#axzz6qnblZnVj"><div class="er es lv"><img src="../Images/c70be4b0f3fff2ae154174b56c104ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdHbFlmjhTed01T07ecY6w.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图片-1</p></figure><p id="b062" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">正如你在上面看到的，我得到了一个错误。并且上面写着:“<em class="ir">calculatage(int，int)‘不能覆盖‘Pet’中的‘calculatage(int，int)’;被覆盖的方法是最终的</em>”。这意味着该方法受到保护，不会被更改，因为它是一个<strong class="is hj">最终方法</strong>。</p><p id="e7b7" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">你也可以使用最后的<strong class="is hj">关键字</strong>来描述字段。但是，与final方法不同，final字段与继承无关。字段开头的final关键字表示该字段是<em class="ir">常量</em>，换句话说，不能更改。</p><p id="51f4" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">例如，它可以用于数学常数。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="830b" class="kg kh hi ln b fi lr ls l lt lu"><strong class="ln hj">public</strong> <strong class="ln hj">class</strong> <strong class="ln hj">myMathClass</strong>{<br/>   <strong class="ln hj">public</strong> <strong class="ln hj">final</strong> <strong class="ln hj">double</strong> PI = 3.14;<br/>}</span></pre><h2 id="b31c" class="kg kh hi bd ki kj kk kl km kn ko kp kq jp kr ks kt jq ku kv kw jr kx ky kz la bi translated">静态</h2><p id="4aac" class="pw-post-body-paragraph ip iq hi is b it lb iv iw ix lc iz ja jp ld jd je jq le jh ji jr lf jl jm jn hb bi translated"><a class="ae jo" href="https://www.java67.com/2012/11/10-points-about-static-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">静态</strong>关键字</a>一般用于内存管理。例如，在一个类中有一个变量。无论您创建了多少个该类的实例，变量都依赖于您创建的单个对象。所以每次都会重新创建变量。</p><p id="4265" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我们来举个例子；</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="3b3f" class="kg kh hi ln b fi lr ls l lt lu"><strong class="ln hj">public class </strong>MyClass {<br/>    <strong class="ln hj">public int </strong>variable1;<br/>    <strong class="ln hj">public static int </strong>variable2;<br/>    <br/>    MyClass(){<br/>        variable1++;<br/>        variable2++;<br/>    }<br/>}</span></pre><p id="2e0a" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在主c类中，我得到了它的5个实例:</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="71c0" class="kg kh hi ln b fi lr ls l lt lu"><strong class="ln hj">public class </strong>Main {<br/>    <strong class="ln hj">public static void </strong>main(String[] args){<br/>        <strong class="ln hj">for</strong>(int i=1; i &lt;= 5; i++){<br/>            MyClass myclass = new MyClass();<br/>            System.<em class="ir">out</em>.println("variable-1: " + myclass.variable1 + ",variable-2: " + MyClass.<em class="ir">variable2</em>);<br/>        }<br/>    }<br/>}</span></pre><p id="1cea" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">通常，这两个变量都是从头开始创建的，并且必须为“1”。但是，输出是:</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="eab4" class="kg kh hi ln b fi lr ls l lt lu">variable-1: 1,variable-2: 1<br/>variable-1: 1,variable-2: 2<br/>variable-1: 1,variable-2: 3<br/>variable-1: 1,variable-2: 4<br/>variable-1: 1,variable-2: 5</span></pre><p id="457f" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">因为变量1属于对象，而变量2属于类。因此<strong class="is hj">变量2 </strong>被保存在内存中，并且每个<em class="ir">实例</em>都会不断增加。</p><p id="d21b" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">注意，我们通过类名到达<strong class="is hj">变量2 </strong>，而通过对象名到达另一个变量。</p><p id="25ed" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">你也可以<a class="ae jo" href="https://javarevisited.blogspot.com/2013/07/when-to-make-method-static-in-java.html" rel="noopener ugc nofollow" target="_blank">使方法<strong class="is hj">静态</strong></a>。所以方法可以属于类而不是对象。要调用静态方法，您不需要创建对象或访问对象的任何字段。静态方法获取自己的输入参数，并仅基于这些输入返回结果。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="3d10" class="kg kh hi ln b fi lr ls l lt lu"><strong class="ln hj">public static int </strong>add(<strong class="ln hj">int </strong>var1, <strong class="ln hj">int </strong>var2){<br/>    <strong class="ln hj">return </strong>var1 + var2;<br/>}</span></pre><p id="85ba" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">您可以使用类名直接访问该方法:</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="41ae" class="kg kh hi ln b fi lr ls l lt lu"><strong class="ln hj">MyClass</strong>.<em class="ir">add</em>(4,5);</span></pre><h2 id="8be8" class="kg kh hi bd ki kj kk kl km kn ko kp kq jp kr ks kt jq ku kv kw jr kx ky kz la bi translated"><strong class="ak">抽象类和方法</strong></h2><p id="d8e2" class="pw-post-body-paragraph ip iq hi is b it lb iv iw ix lc iz ja jp ld jd je jq le jh ji jr lf jl jm jn hb bi translated">我们已经在另一篇<a class="ae jo" rel="noopener" href="/geekculture/core-concepts-of-object-oriented-programming-1-49397c7e0cbe">文章</a>中介绍了“<strong class="is hj">继承</strong>的概念。首先我们创建了一个名为<strong class="is hj">父类</strong>或<strong class="is hj">超类</strong>的类。然后我们创建了子类或子类来扩展父类。但是我们使用父类只是为了能够用子类扩展它。所以我们不实例化它或者我们不需要从它本身创建对象。</p><p id="183b" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在这种情况下，最好使用<strong class="is hj">抽象类</strong>。抽象类定义了每个子类的行为，但是我们不能直接实例化抽象类本身。</p><p id="d9cf" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">抽象类也允许创建<strong class="is hj">抽象方法</strong>，这些方法必须在扩展抽象类的子类中实现。抽象类中的抽象方法只有头，没有实现。我们在子类中指定它们的身体。</p><p id="c73c" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">让我们看看这个例子:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div><p class="lw lx et er es ly lz bd b be z dx translated">抽象父类</p></figure><p id="83b9" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">和儿童类；</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="340c" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">正如您在示例中看到的，我们通过在抽象类<strong class="is hj"> MyAbstractClass </strong>前面添加关键字“<strong class="is hj"> abstract </strong>”来创建抽象类<strong class="is hj">my abstract class</strong>。在这个类中，我们创建了抽象方法<strong class="is hj"> myMethod </strong>。</p><p id="a08b" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我们用<strong class="is hj"> MyChildClass </strong>扩展了MyAbstractClass，然后重写了子类中的方法。</p></div></div>    
</body>
</html>