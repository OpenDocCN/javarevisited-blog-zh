<html>
<head>
<title>JVM Garbage Collection Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JVM垃圾收集基础知识</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/jvm-garbage-collection-basics-edce6791ae98?source=collection_archive---------2-----------------------#2020-11-30">https://medium.com/javarevisited/jvm-garbage-collection-basics-edce6791ae98?source=collection_archive---------2-----------------------#2020-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/e3acc4246d05d61720b78176b6161374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*lcltbCyP-zVF_X7jojb4-w.jpeg"/></div><p class="im in et er es io ip bd b be z dx translated"><a class="ae iq" href="https://unsplash.com/@prasad_jayakumar/likes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae iq" href="https://unsplash.com/@arteum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Arteum.ro </a>拍摄的照片</p></figure><p id="5049" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">学习JVM垃圾收集和每种收集器算法背后的机制与学习Java语言特性一样重要。算法的高级细节提供了关于对象生命周期、可能的故障(如内存不足异常、内存泄漏等)的观点。，)以及如何避免失败。</p><h1 id="6b47" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">垃圾收集</strong></h1><p id="6bd2" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">垃圾收集是自动内存管理的一种形式。任何垃圾收集器的基本操作都是</p><ul class=""><li id="3235" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">对象内存分配</li><li id="c1b5" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">从GC根开始查找正在使用的对象— <strong class="it hj">标记</strong></li><li id="04e2" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">不使用的自由对象— <strong class="it hj">清扫</strong></li><li id="4d6e" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">压缩内存以防止内存碎片— <strong class="it hj">压缩</strong></li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lg"><img src="../Images/3166ef124ecb5756653df3a5a9cb8952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrfG3vFV4fRofYZnG1Axqg.png"/></div></div></figure><h2 id="af25" class="lp jq hi bd jr lq lr ls jv lt lu lv jz jc lw lx kd jg ly lz kh jk ma mb kl mc bi translated"><strong class="ak">堆内存模型</strong></h2><p id="8f88" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">让我们重温经典，然后再看看闪亮的最新款</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es md"><img src="../Images/5172133e30a63914c1888e324046fcf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfaBln8nWqy5dCE4Dtqq0Q.png"/></div></div><p class="im in et er es io ip bd b be z dx translated">JVM堆的概念视图</p></figure><blockquote class="me mf mg"><p id="9186" class="ir is mh it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hb bi translated">永久生成在JDK 8中已经完全删除。这项工作已经在<a class="ae iq" href="https://bugs.openjdk.java.net/browse/JDK-6964458" rel="noopener ugc nofollow" target="_blank"> bug </a>下完成。选项PermSize和MaxPermSize在JDK 8中也被删除—来源:<a class="ae iq" href="https://blogs.oracle.com/poonam/about-g1-garbage-collector,-permanent-generation-and-metaspace" rel="noopener ugc nofollow" target="_blank">Poonam Parhar的博客</a></p></blockquote><p id="e4df" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">🙇<em class="mh">来源:《</em> <a class="ae iq" href="https://www.java67.com/2019/08/best-books-to-learn-java-virtual-machine-in-depth.html" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> Java性能:深度》作者Scott Oaks —第二版</em> </a></p><p id="1704" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">年轻一代</strong></p><p id="4459" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> <em class="mh">伊甸园</em> </strong></p><ul class=""><li id="bb29" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">对象是在eden中分配的(包含了绝大多数年轻一代)。</li><li id="26b0" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">当年轻代在收集期间被清除时，Eden中的所有对象要么被移动，要么被丢弃:不在使用中的对象可以被丢弃，而在使用中的对象被移动到幸存者空间之一或旧代。</li><li id="0a41" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">由于所有幸存的对象都被移动，年轻代在被收集时会被自动压缩:在收集结束时，Eden和一个幸存空间是空的，年轻代中剩余的对象被压缩到另一个幸存空间中。</li></ul><p id="9415" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> <em class="mh">幸存者空间</em> </strong></p><ul class=""><li id="2114" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">幸存者空间被设计成允许对象(尤其是刚刚分配的对象)在年轻一代中保留几个GC周期。这增加了对象在提升到旧代之前被释放的可能性。</li><li id="f8ab" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">如果幸存者空间太小，对象将直接提升到老一代，这又会导致更多的旧GC周期。</li><li id="82d0" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">处理这种情况的最好方法是增加堆的大小(或者至少是年轻一代),并允许JVM处理幸存者空间。</li><li id="7fbe" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">在极少数情况下，调整保有阈值或幸存空间大小可以防止对象升级到旧代。</li></ul><p id="ede7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">老(或终身)一代</strong></p><ul class=""><li id="16ea" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">随着对象被转移到老一代，最终它也会被填满，JVM需要找到老一代中不再使用的对象并丢弃它们。</li></ul><p id="0bc0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">元空间</strong></p><ul class=""><li id="e1a5" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">当<a class="ae iq" href="http://javarevisited.blogspot.sg/2012/07/when-class-loading-initialization-java-example.html#axzz4uMIMWleJ" rel="noopener ugc nofollow" target="_blank"> JVM加载类</a>时，它必须跟踪关于这些类的某些元数据。这占用了一个单独的堆空间，称为元空间。</li><li id="5fb5" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">元空间中的信息仅由编译器和JVM运行时使用，它保存的数据被称为类元数据。</li></ul><p id="ee9f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">💡元空间不保存类的实际实例(类对象)，或反射对象(例如，方法对象)；这些被保存在常规堆中。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ml"><img src="../Images/828cd6ed6c1fd0d163c171c733cebadc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mv1fzW63IN8gCv3qtTsSag.jpeg"/></div></div><p class="im in et er es io ip bd b be z dx translated">碎片帐集</p></figure><p id="c80f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> GC抑制剂</strong></p><blockquote class="me mf mg"><p id="0088" class="ir is mh it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hb bi translated">繁忙的咖啡店里的咖啡师不会抱怨顾客排起的长队和永无止境的服务。相反，他们会对这项业务感到“高兴”。</p></blockquote><p id="1b61" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">类似地，<a class="ae iq" href="https://www.java67.com/2020/02/50-garbage-collection-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank">垃圾收集</a>也存在，因为应用程序做了一些“重要”的事情，而GC想要确保应用程序的生命延续。下面列出的抑制剂可能会降低GC的工作效率。</p><ul class=""><li id="0051" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated"><strong class="it hj"> <em class="mh">应用程序逻辑(Mutator线程):</em> </strong>当GC线程跟踪对象引用或在内存中移动对象时，它们必须确保应用程序线程没有使用那些对象。当GC四处移动对象时尤其如此:对象的内存位置在操作过程中会发生变化，因此没有应用程序线程可以访问该对象。</li><li id="e959" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated"><strong class="it hj">分配率:</strong>创建需要更多内存分配的新对象的速率</li><li id="f761" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated"><strong class="it hj">实时数据集大小:</strong>对象存活时间不长的可能性会导致整体堆大小的消耗增加。</li><li id="bb61" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated"><strong class="it hj">分配大对象:</strong>在堆受限的情况下，大对象会导致频繁的压缩需求。</li></ul></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h1 id="84f8" class="jp jq hi bd jr js mt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki mx kk kl km bi translated"><strong class="ak">垃圾收集器算法</strong></h1><h2 id="c5b5" class="lp jq hi bd jr lq lr ls jv lt lu lv jz jc lw lx kd jg ly lz kh jk ma mb kl mc bi translated"><strong class="ak">目标</strong></h2><p id="b17a" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">垃圾收集器通常有以下目标(说起来容易做起来难)</p><ul class=""><li id="835d" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">非常短的“停止世界暂停”，目标是几毫秒</li><li id="9bf8" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">暂停时间不会随着堆、活动集或根集的大小而增加</li><li id="a8ec" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">处理从几MB到几TB的堆大小</li><li id="d768" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">高并发性——所有繁重的工作都在<a class="ae iq" rel="noopener" href="/javarevisited/8-best-multithreading-and-concurrency-courses-for-experienced-java-developers-8acfd3b25094"> Java线程</a>继续执行的同时完成</li><li id="fb98" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">高流通量</li><li id="3132" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">易于调整</li></ul><h2 id="4556" class="lp jq hi bd jr lq lr ls jv lt lu lv jz jc lw lx kd jg ly lz kh jk ma mb kl mc bi translated"><strong class="ak">垃圾收集器</strong></h2><blockquote class="me mf mg"><p id="af62" class="ir is mh it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hb bi translated">堆中的数据被划分为多个分配区域(或层代)，这些区域根据对象年龄(即幸存的GC迭代次数)保持独立。虽然有些收集器是单代的，但其他收集器使用两代:(1)年轻一代(进一步分为伊甸园和两个幸存者区域)和(2)老(或终身)一代。<br/>来源:<a class="ae iq" href="https://ionutbalosin.com/2019/12/jvm-garbage-collectors-benchmarks-report-19-12/" rel="noopener ugc nofollow" target="_blank">伊努特·巴洛辛的博客</a></p></blockquote><p id="7b67" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">两代收藏家:</strong></p><p id="ac33" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">串行GC </strong> —该算法使用单线程来执行所有垃圾收集工作，这使得它相对高效，因为线程之间没有通信开销。它最适合单处理器机器，因为它不能利用多处理器硬件。</p><p id="83ca" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">吞吐量(并行)GC — </strong>该算法在年轻一代中使用标记复制，在老一代中使用标记扫描压缩。新旧收集都会触发stop-the-world事件，停止所有应用程序线程来执行垃圾收集。两个收集器都使用多线程运行标记和复制/压缩阶段，因此得名“并行”。</p><p id="b8b0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">并行垃圾收集器适用于多核机器，如果你的<strong class="it hj">的主要目标是增加吞吐量</strong>。由于更有效地利用系统资源，实现了更高的吞吐量:</p><ul class=""><li id="1210" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">在收集过程中，所有内核并行清理垃圾，从而缩短暂停时间</li><li id="a49f" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">在垃圾收集周期之间，两个收集器都不消耗任何资源</li></ul><p id="031d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">垃圾优先(G1) GC — </strong>这个收集器是一个服务器风格的垃圾收集器，面向具有大内存的多处理器机器。它以很高的概率满足垃圾收集(GC)暂停时间目标，同时实现高吞吐量。</p><ul class=""><li id="26c7" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">G1收集器在堆内存模型方面采用了不同的方法。<strong class="it hj"/><a class="ae iq" href="https://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html" rel="noopener ugc nofollow" target="_blank"><strong class="it hj">堆</strong> </a> <strong class="it hj">被分割成一组大小相等的堆区域</strong>，每个堆区域都是一个连续的虚拟内存范围。</li><li id="bee2" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">某些区域集被分配了与旧收集器相同的角色(eden、survivor、old ),但是它们没有固定的大小。</li><li id="fcc6" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">区域大小由JVM在启动时选择。JVM一般以大约2000个区域为目标，大小从1mb到32Mb不等。G1收藏家采取了不同的方法</li></ul><p id="053c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">有关更多详细信息，请参考<a class="ae iq" href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" rel="noopener ugc nofollow" target="_blank">G1气相色谱仪入门</a></p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es my"><img src="../Images/ace8d8c9c31b0eab95cd4176fcc0199c.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*yMz37yVUjHlFjEG6KgLFNg.png"/></div><p class="im in et er es io ip bd b be z dx translated">G1堆分配</p></figure><p id="ff7d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> <em class="mh">单代收藏家:</em> </strong></p><p id="0ae3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">Shenandoah GC—</strong>Shenandoah是一个低暂停时间垃圾收集器，它通过与正在运行的Java程序同时执行更多垃圾收集工作来减少GC暂停时间。Shenandoah <strong class="it hj">大部分GC是并发工作的，包括并发压缩</strong>，这意味着它的暂停时间不再与堆的大小成正比。200 GB堆或2 GB堆的垃圾收集应该具有类似的低暂停行为。</p><p id="74d3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">更多详情，请参考维基中的<a class="ae iq" href="https://wiki.openjdk.java.net/display/shenandoah/Main" rel="noopener ugc nofollow" target="_blank">实施细节</a></p><p id="e80d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> Z GC — </strong> ZGC是一个并发的、单代的、基于区域的、NUMA感知的压缩收集器。停止阶段仅限于根扫描，因此GC暂停时间不会随着堆或活动集的大小而增加。</p><p id="c111" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">欲了解更多详情，请参考YouTube上佩尔·利登关于ZGC的<a class="ae iq" href="https://www.youtube.com/watch?v=88E86quLmQA" rel="noopener ugc nofollow" target="_blank">会议</a></p><p id="d2d2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">最后，</p><p id="02f5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><a class="ae iq" href="https://openjdk.java.net/jeps/318" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> Epsilon GC </strong> </a>(实验)——一个处理内存分配但<strong class="it hj"> <em class="mh">不实现任何实际内存回收机制</em> </strong>的GC。一旦可用的Java堆耗尽，<a class="ae iq" href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html" rel="noopener ugc nofollow" target="_blank"> JVM </a>就会关闭。设计用于内部JDK测试，但可以想象在两种情况下有用</p><ul class=""><li id="7940" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">非常短命的程序</li><li id="81cf" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">精心编写的程序重用内存，从不执行新的分配</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mz"><img src="../Images/bc4d9db40bc655107a35f0ea42301c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AfgCtGD7dSYoMogjrBrpRg.jpeg"/></div></div><p class="im in et er es io ip bd b be z dx translated">垃圾收集算法</p></figure></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="70c3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">出于实际目的，我将只分享与以下三个<a class="ae iq" href="https://en.wikipedia.org/wiki/Java_version_history" rel="noopener ugc nofollow" target="_blank"> Java版本</a>相关的细节</p><ul class=""><li id="9a11" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated">Java SE 8 — LTS</li><li id="8428" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">Java SE 11 — LTS</li><li id="3bec" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">Java SE 15</li></ul><p id="3324" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">有两种可能Java用户(我猜)</p><ol class=""><li id="6e58" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo na ky kz la bi translated"><strong class="it hj">荒野探险者</strong>谁想要探索和使用所有可能的新特性，并跟上Java的最新更新(无论是开发还是生产)。</li><li id="5065" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo na ky kz la bi translated"><strong class="it hj">希望平台稳定可靠的企业用户</strong>。他们通常更喜欢LTS版本。</li></ol><p id="15e4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我希望，有一个Java的巴别塔😄可以连接两个世界的桥梁。当然，我们可以使用Kotlin(改天再写博客)。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es nb"><img src="../Images/1620ad7f0d517ddfb3f6ae2f567b95bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZ51feWto4mnaBjhsTF3EA.png"/></div></div><p class="im in et er es io ip bd b be z dx translated">相对于JDK版本的GC算法状态</p></figure></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="66d5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在我的下一篇博客中，我将详细介绍GC算法，并亲自动手操作GC工具，为性能和健康设置JVM选项<a class="ae iq" href="https://www.java67.com/2016/08/10-jvm-options-for-java-production-application.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="eec0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果你喜欢我的写作风格，请将博客分享/转发给你的开发伙伴😆</p><p id="0ef0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">参考文献</strong></p><ul class=""><li id="b7b2" class="ks kt hi it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la bi translated"><a class="ae iq" href="https://www.oreilly.com/library/view/java-performance-2nd/9781492056102/" rel="noopener ugc nofollow" target="_blank">“Java性能:深度”作者Scott Oaks —第二版</a></li><li id="3a89" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated"><a class="ae iq" href="https://plumbr.io/java-garbage-collection-handbook" rel="noopener ugc nofollow" target="_blank"> Java垃圾收集手册</a></li><li id="8029" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated"><a class="ae iq" href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" rel="noopener ugc nofollow" target="_blank">G1垃圾收集器入门</a></li><li id="4b32" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated"><a class="ae iq" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" rel="noopener ugc nofollow" target="_blank"> Java垃圾收集基础知识</a></li><li id="9155" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated"><a class="ae iq" href="https://blogs.oracle.com/poonam/about-g1-garbage-collector,-permanent-generation-and-metaspace" rel="noopener ugc nofollow" target="_blank">关于G1垃圾收集器、永久生成和元空间</a></li><li id="a6a7" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">JVM垃圾收集器基准报告19.12 </li></ul></div></div>    
</body>
</html>