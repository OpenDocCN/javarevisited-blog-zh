<html>
<head>
<title>Find Pair With A Given Sum In A Sorted Doubly Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在有序双向链表中寻找给定和的对</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/find-pair-with-a-given-sum-in-a-sorted-doubly-linked-list-13fbac7b8a7d?source=collection_archive---------3-----------------------#2021-09-12">https://medium.com/javarevisited/find-pair-with-a-given-sum-in-a-sorted-doubly-linked-list-13fbac7b8a7d?source=collection_archive---------3-----------------------#2021-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/33d0d3338e28d8bbafec056be6de43ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*245dhBXbnU5l1sGf31-f2w.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">双向链表</p></figure><p id="d902" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">链表是准备面试时要学习的最重要的概念和数据结构之一。掌握好<a class="ae js" rel="noopener" href="/javarevisited/top-20-linked-list-coding-problems-from-technical-interviews-90b64d2df093">链表</a>在编码面试中会是一个巨大的加分点。</p><h2 id="2d6d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">问题陈述:</h2><p id="eea7" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">给定一个正相异元素的排序双向链表，任务是在双向链表中寻找其和等于给定值<strong class="iw hj"> num的配对。</strong></p><h2 id="27ff" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">讨论的解决方法:</h2><ul class=""><li id="52df" class="kt ku hi iw b ix ko jb kp jf kv jj kw jn kx jr ky kz la lb bi translated">使用<a class="ae js" href="https://javarevisited.blogspot.com/2015/09/how-to-loop-two-dimensional-array-in-java.html" rel="noopener ugc nofollow" target="_blank">的蛮力方法<strong class="iw hj">嵌套循环</strong>T7】</a></li><li id="3c9f" class="kt ku hi iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated">使用<strong class="iw hj">哈希</strong>的时间优化方法</li><li id="10e2" class="kt ku hi iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated">使用双指针方法<strong class="iw hj">的空间和时间优化方法</strong></li></ul><h2 id="30e1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">这个编码问题的关键是:</h2><ul class=""><li id="76c0" class="kt ku hi iw b ix ko jb kp jf kv jj kw jn kx jr ky kz la lb bi translated">了解<strong class="iw hj">哈希</strong></li><li id="d6ae" class="kt ku hi iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated">了解<a class="ae js" href="https://javarevisited.blogspot.com/2013/05/find-if-linked-list-contains-loops-cycle-cyclic-circular-check.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">双指针</strong>方法</a></li></ul><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="34e9" class="jt ju hi lm b fi lq lr l ls lt">For example:</span><span id="e25e" class="jt ju hi lm b fi lu lr l ls lt">Suppose we have a sorted doubly-linked list as<br/>5 &lt;-&gt; 7 &lt;-&gt; 10 &lt;-&gt; 15 &lt;-&gt; 20</span><span id="54d0" class="jt ju hi lm b fi lu lr l ls lt">and we are given the value of <strong class="lm hj">num </strong>is 17 i.e. <strong class="lm hj">num = 17. </strong>Now we have to find two integers from the sorted doubly-linked list which gives the total sum as <strong class="lm hj">17.</strong></span><span id="3024" class="jt ju hi lm b fi lu lr l ls lt">So, we can clearly see that integers <strong class="lm hj">7 and 10 </strong>together add up to <strong class="lm hj">17, </strong>hence, in this case, the two numbers will be <strong class="lm hj">7 and 10</strong></span></pre><p id="7f87" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">你能用O(1)的空间复杂度在O(n)的时间复杂度内做到吗？</strong></p><p id="9d9c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，暂时忘记你被给予的找出解决方案的时间复杂性，现在，想一想找到问题的解决方案的最基本的方法。</p><figure class="lh li lj lk fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/07/top-10-linked-list-coding-questions-and.html#axzz6fY0boe26"><div class="er es lv"><img src="../Images/2a204e9f4b9bbabd44d4de117c3bf485.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*eYP3RO9mk2OHjEUoUGdaKw.gif"/></div></a><p class="iq ir et er es is it bd b be z dx translated">让我们看看代码:p</p></figure><h2 id="6ea3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">天真的解决方案:</h2><p id="9d5c" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">上述问题的<strong class="iw hj">强力</strong>解决方案是使用一个嵌套循环来获取一个整数，并找到其总和等于给定的<strong class="iw hj"> num的其他整数。</strong></p><p id="0e9d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们来看看这种方法的途径:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="d3d6" class="jt ju hi lm b fi lq lr l ls lt">- Pick the first integer from the doubly-linked list<br/>- Calculate the difference between the given num and the current integer in the doubly-linked list and store it in a variable <strong class="lm hj">diff</strong><br/>- Now, search for <strong class="lm hj">diff</strong> by traversing the complete linked list which will be the second number in the list (if present)</span></pre><p id="cdc6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">该问题的时间复杂度为O(n)，n是双向链表中节点的总数。</strong></p><p id="8301" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，由于这是一个蛮力解决方案，如果你仔细考虑时间复杂度的优化，我们可以有一个稍微优化的解决方案。</p><p id="d927" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你能想到这样的解决办法吗？</p><p id="8e8f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你不能够思考，让我给你一点提示，我们可以在<strong class="iw hj"> O(n)时间内借助<a class="ae js" href="https://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">哈希</strong> </a>解决上述问题。</strong></p><h2 id="4ae4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">哈希解决方案:</h2><p id="e605" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">让我们看一下这个散列算法。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="e8ad" class="jt ju hi lm b fi lq lr l ls lt">start function findPair(reference to the headNode, number)</span><span id="6c12" class="jt ju hi lm b fi lu lr l ls lt">  unordered_set&lt;int&gt; nodeHash;<br/>  <br/>  struct node *headRef = headNode;<br/>  start while(headRef-&gt;next is not NULL)<br/>     insert headRef-&gt;data to nodeHash<br/>  end while</span><span id="3a43" class="jt ju hi lm b fi lu lr l ls lt">  bool nodeFound = false;</span><span id="eb22" class="jt ju hi lm b fi lu lr l ls lt">  start while(headRef-&gt;next is not NULL)<br/>      int diff = number - headRef-&gt;data<br/>      start if(diff is present in nodeHash)<br/>          print(diff and headRef-&gt;data)<br/>          set nodeFound to true<br/>          break the loop<br/>      end if<br/>  end while</span><span id="cedd" class="jt ju hi lm b fi lu lr l ls lt">  start if(nodeFound is false)<br/>      print("Not Found")<br/>  end if</span><span id="7729" class="jt ju hi lm b fi lu lr l ls lt">end findPair</span></pre><p id="04c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，分析上面的方法，我们看到该算法具有O(n) 的<strong class="iw hj">时间复杂度，这足以很好地解决这个问题，但是查看<a class="ae js" href="https://javarevisited.blogspot.com/2019/04/top-20-searching-and-sorting-algorithms-interview-questions.html" rel="noopener ugc nofollow" target="_blank">算法</a>的空间复杂度，我们看到它花费了<strong class="iw hj"> O(n)空间</strong>，就空间复杂度而言，这不是优化的解决方案。</strong></p><p id="5652" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们能做得更好吗？</p><p id="9afd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">想一个方法，我们可以在O(n)时间和O(1)空间中解决这个问题。</p><p id="464a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">是的，我们可以在常数空间中，通过使用两个指针的方法，简单地遍历并找到它，如果它存在的话。</p><p id="4b5e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看这个有效的方法。</p><h2 id="72ac" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">两点解决方案:</h2><p id="63c6" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">让我们看一看这个在空间和时间方面最有效的算法。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0145" class="jt ju hi lm b fi lq lr l ls lt">start function findPair(reference to the headNode, number)<br/>    struct node *headPointer = headNode<br/>    struct node *tailPointer = headNode</span><span id="4a59" class="jt ju hi lm b fi lu lr l ls lt">    start while(tailPointer-&gt;next is not NULL)<br/>        tailPointer = tailPointer-&gt;next<br/>    end while</span><span id="7f33" class="jt ju hi lm b fi lu lr l ls lt">    bool foundNode = false</span><span id="0a03" class="jt ju hi lm b fi lu lr l ls lt">    start while(headPointer is not equal to tailPointer and tailPointer-&gt;next is not equal to headPointer)<br/>          start if(headPointer-&gt;data + tailPointer-&gt;data == number)<br/>                print(headPointer-&gt;data and tailPointer-&gt;data)<br/>                set foundNode as true<br/>                break the loop<br/>          end if<br/>          start else<br/>                start if(headPointer-&gt;data + tailPointer-&gt;data &lt; number)<br/>                      headPointer = headPointer-&gt;next<br/>                end if<br/>                start else<br/>                      tailPointer = tailPointer-&gt;prev<br/>                end else<br/>          end else<br/>    end while</span><span id="6447" class="jt ju hi lm b fi lu lr l ls lt">    start if(foundNode is false)<br/>          print("Not Found")<br/>    end if</span><span id="35c8" class="jt ju hi lm b fi lu lr l ls lt">end findPair</span></pre><p id="77d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，既然你已经知道了问题背后的<a class="ae js" rel="noopener" href="/javarevisited/20-algorithms-coding-problems-to-crack-you-next-technical-interviews-23191f229788">算法</a>，那么你可以用你想要的编程语言编写你自己的功能性<strong class="iw hj">代码</strong>。</p><h2 id="3132" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">分析:</h2><ul class=""><li id="00aa" class="kt ku hi iw b ix ko jb kp jf kv jj kw jn kx jr ky kz la lb bi translated">时间复杂度:<code class="du lw lx ly lm b">O(n)</code>，其中<strong class="iw hj"> n </strong>是给定双向链表的大小，这是因为我们只遍历链表一次。</li><li id="c954" class="kt ku hi iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated">空间复杂度:<code class="du lw lx ly lm b">O(1)</code>，因为我们没有使用任何额外的空间来存储整数或节点。</li></ul><p id="dc00" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">不断学习，不断成长，不断探索！</strong></p><p id="65aa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">万事如意！</strong></p><p id="3201" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">更多有趣和信息丰富的文章和提示请关注我的<a class="ae js" href="https://swapnilkant11.medium.com/" rel="noopener"> <strong class="iw hj">媒体</strong> </a> <strong class="iw hj">和</strong><a class="ae js" href="https://www.linkedin.com/in/swapnil-kant-279a3b148/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">Linkedin</strong></a></p></div></div>    
</body>
</html>