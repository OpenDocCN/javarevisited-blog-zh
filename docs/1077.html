<html>
<head>
<title>When to use Stack Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时使用堆栈数据结构</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/when-to-use-stack-data-structure-9ac3dfa4d10?source=collection_archive---------1-----------------------#2021-03-17">https://medium.com/javarevisited/when-to-use-stack-data-structure-9ac3dfa4d10?source=collection_archive---------1-----------------------#2021-03-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aaf5b495c380907581fefef9ffb26b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BbK2l_HMVoZFbNs2"/></div></div><p class="iq ir et er es is it bd b be z dx translated">德尔祖利亚·扎扎在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="iv"><p id="8797" class="iw ix hi bd iy iz ja jb jc jd je jf dx translated">一个<strong class="ak">栈</strong>是一个抽象的数据类型，由一个预定义的容量组成。它允许以特定的顺序添加和删除元素。当每次添加一个元素时，它都进入堆栈的顶部。堆栈使所有数据只能在一端操作。因此，唯一可以移除的元素是堆栈顶部的元素，并且在给定时间只能读取或移除一个项目。</p></blockquote><p id="70e5" class="pw-post-body-paragraph jg jh hi ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc jf hb bi translated">上述特性使它成为一种后进先出的数据结构。这里，最后插入的元素首先被访问。在堆栈术语中，插入操作称为<strong class="ji hj"> PUSH，</strong>而移除操作称为<strong class="ji hj"> POP </strong>。当堆栈完全充满时，称其处于<strong class="ji hj">溢出</strong>状态，如果完全为空，称其处于<strong class="ji hj">下溢</strong>状态。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/03/difference-between-stack-and-queue-data-structure-in-java.html#axzz5dxZIUUxy"><div class="er es kd"><img src="../Images/c4e9d7b256e422b547c9c8392e85b36a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*pVnQC4WWhYGxvFmRn-Ptqw.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">https://www.programiz.com</p></figure><h1 id="c083" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">堆栈的主要操作</strong></h1><p id="aa90" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc jf hb bi translated">当我们讨论栈的操作时，它们包括下面两个基本操作。</p><pre class="ke kf kg kh fd ll lm ln lo aw lp bi"><span id="04aa" class="lq kj hi lm b fi lr ls l lt lu"> <strong class="lm hj">push()</strong> — Inserting an element to the stack</span><span id="0e61" class="lq kj hi lm b fi lv ls l lt lu"><strong class="lm hj"> pop()</strong> — Removing an element from the stack</span></pre><p id="1778" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated">为了有效地使用堆栈，我们还需要检查堆栈的状态。为此，堆栈中增加了以下功能。</p><pre class="ke kf kg kh fd ll lm ln lo aw lp bi"><span id="d4df" class="lq kj hi lm b fi lr ls l lt lu"><strong class="lm hj">peek()</strong> — get the top element of the stack, without removing the element.</span><span id="3cb5" class="lq kj hi lm b fi lv ls l lt lu"><strong class="lm hj">isFull()</strong> — check if the stack is full</span><span id="4fe8" class="lq kj hi lm b fi lv ls l lt lu"><strong class="lm hj">isEmpty()</strong> — check if the stack is empty</span></pre><h2 id="78fd" class="lq kj hi bd kk mb mc md ko me mf mg ks jr mh mi kw jv mj mk la jz ml mm le mn bi translated">算法</h2><pre class="ke kf kg kh fd ll lm ln lo aw lp bi"><span id="7d5f" class="lq kj hi lm b fi lr ls l lt lu">1. A pointer called <strong class="lm hj">TOP</strong> is used to keep track of the top element in the stack.<br/>2. When initializing, The value of TOP is -1. So that we can check if the stack is empty by comparing<strong class="lm hj"> TOP == -1</strong>.<br/>3. When pushing an element, we <strong class="lm hj">increase the value of TOP</strong> and <strong class="lm hj">place the new element</strong> in the <strong class="lm hj">position pointed to by TOP.<br/></strong>4. On popping an element, we <strong class="lm hj">return the element pointed to by TOP</strong> and <strong class="lm hj">reduce the value of TOP</strong>.<br/>5. Before pushing, we check if the stack is already full.<br/>6. Before popping, we check if the stack is already empty</span></pre></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h1 id="3fca" class="ki kj hi bd kk kl mv kn ko kp mw kr ks kt mx kv kw kx my kz la lb mz ld le lf bi translated"><strong class="ak">用Java实现堆栈</strong></h1><blockquote class="iv"><p id="0b27" class="iw ix hi bd iy iz na nb nc nd ne jf dx translated">尝试自己的堆栈实现，并使用下面的代码检查您的实现。</p></blockquote><figure class="nf ng nh ni nj ij"><div class="bz dy l di"><div class="nk nl l"/></div></figure><h1 id="ee82" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">堆栈错误</h1><p id="3a9b" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc jf hb bi translated">堆栈可能会出现两种问题:</p><h2 id="103f" class="lq kj hi bd kk mb mc md ko me mf mg ks jr mh mi kw jv mj mk la jz ml mm le mn bi translated"><em class="nm"> 1。下溢</em></h2><p id="3ef4" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc jf hb bi translated">当试图弹出空堆栈时。从一个空的集合中删除一些东西是没有意义的。堆栈下溢是一个常见错误——应该使用对<strong class="ji hj"> <em class="nn"> isEmpty </em> </strong>的调用来防止它。</p><h2 id="c0d1" class="lq kj hi bd kk mb mc md ko me mf mg ks jr mh mi kw jv mj mk la jz ml mm le mn bi translated"><em class="nm"> 2。溢出</em></h2><p id="88bf" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc jf hb bi translated">当试图将一个项目压入满栈时。栈的一些实现指定了特定的有限大小。堆栈溢出最常见的原因可能是递归“走得太远了”</p><h1 id="b617" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">堆栈操作的运行时复杂性</h1><p id="bd96" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc jf hb bi translated">对于所有标准的堆栈操作(push、pop、isEmpty、size)，最坏情况下的运行时复杂度可以是O(1)。因为这些操作需要持续的时间。很明显，大小和是一个空常数时间运算。push和pop也是O(1 ),因为它们只处理数据结构的一端——栈顶。</p><h1 id="e339" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">堆栈在问题解决中的应用</h1><p id="4aba" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc jf hb bi translated"><em class="nn">平衡括号</em></p><p id="9da6" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated">我们的代码编辑器使用堆栈来检查我们是否正确地结束了所有的括号，甚至美化代码。下面的代码是一个检查平衡括号的例子。</p><p id="a430" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><em class="nn">回溯</em></p><p id="9c3e" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated">当计算必须以相反的顺序返回时，堆栈特别有用。这在人工智能应用中经常发生:游戏、逻辑程序、定理证明器等。</p><p id="50f6" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><em class="nn">想象走过一个迷宫。每当你有多个移动方向的选项时，按下除其中一个选项之外的所有选项</em></p><p id="00c3" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><em class="nn">扔到堆栈上，然后往你没推的方向走。当你走进一个死胡同时，后退到你的最后一个选项(即弹出堆栈)并从那里继续前进。</em></p><p id="f95e" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><em class="nn">激活记录</em></p><p id="6fdc" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated">每次在程序中调用一个函数时，该函数的所有参数和局部变量都被推送到堆栈中进行存储。当函数退出时，只需将堆栈弹出到函数调用前的位置，就可以回收所有的内存。</p><p id="93ed" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><em class="nn">反一字</em></p><p id="999f" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated">把所有的字母堆成一堆，然后取出来。由于堆栈的后进先出顺序，您将得到逆序的字母。</p><p id="79f3" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><em class="nn">在编译器中</em></p><p id="2182" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated">编译器使用堆栈通过将表达式转换为前缀或后缀形式来计算像2+4/5 *(7–9)这样的表达式的值。</p><p id="9f91" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><em class="nn">在浏览器中</em></p><p id="5e19" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated">浏览器中的后退按钮会将您之前访问过的所有URL保存在一个堆栈中。每次你访问一个新的页面，它都会被添加到堆栈的顶部。当您按下“后退”按钮时，当前URL将从堆栈中删除，并访问以前的URL。</p><h1 id="03d2" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">了解有关Stack ADT的更多信息</strong></h1><p id="c784" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc jf hb bi translated"><a class="ae iu" href="https://www.tutorialspoint.com/data_structures_algorithms/stack_algorithm.htm" rel="noopener ugc nofollow" target="_blank">数据结构和算法—堆栈—教程点</a> t</p><p id="3a4d" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><a class="ae iu" href="https://www.javatpoint.com/data-structure-stack" rel="noopener ugc nofollow" target="_blank"> DS堆栈—Java端口</a> t</p><h1 id="e77c" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">资源</h1><p id="9338" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc jf hb bi translated"><a class="ae iu" href="https://www.studytonight.com/data-structures/stack-data-structure" rel="noopener ugc nofollow" target="_blank">堆栈数据结构| Studytonight </a></p><p id="12ed" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><a class="ae iu" href="https://www.programiz.com/dsa/stack" rel="noopener ugc nofollow" target="_blank">Python、Java和C/c++(programiz.com)的栈数据结构及实现</a></p><p id="4d46" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><a class="ae iu" href="http://pages.cs.wisc.edu/~siff/CS367/Notes/stacks.html" rel="noopener ugc nofollow" target="_blank">CS 367–3—堆栈(wisc.edu)</a></p><p id="a3a6" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated"><a class="ae iu" href="https://www.tutorialspoint.com/data_structures_algorithms/stack_algorithm.htm" rel="noopener ugc nofollow" target="_blank">数据结构和算法—堆栈—教程点</a></p><p id="afa9" class="pw-post-body-paragraph jg jh hi ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc jf hb bi translated">Java程序员必备的6种数据结构</p></div></div>    
</body>
</html>