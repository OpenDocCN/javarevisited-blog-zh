<html>
<head>
<title>How to choose Upper &amp; Lower bounds in Java Generics?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java泛型中如何选择上下界？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/how-to-choose-upper-lower-bounds-in-java-generics-52bfdcfd17c2?source=collection_archive---------1-----------------------#2020-06-18">https://medium.com/javarevisited/how-to-choose-upper-lower-bounds-in-java-generics-52bfdcfd17c2?source=collection_archive---------1-----------------------#2020-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1d42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于缺乏理解，大多数Java开发人员对泛型有一种毫无根据的恐惧(或者我称之为对未知:D的恐惧)。如果偶然，他们克服了恐惧，他们开始害怕上界和下界。这篇博客是我用简单的方式解释这个概念的真诚努力。</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://medium.com/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"><div class="er es jd"><img src="../Images/f8665115216b2bc64a1c9a2087dce9ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IoC0cvxr0nasLRGFkc96Og.jpeg"/></div></a><p class="jl jm et er es jn jo bd b be z dx translated">Java泛型</p></figure><p id="abb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上&amp;下界有什么用？</strong></p><p id="8ed4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些用于放松对变量的限制。</p><p id="9604" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上限通配符(</strong>？扩展类型<strong class="ih hj"> ) </strong></p><p id="6065" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将未知类型限制为<strong class="ih hj">特定类型或子类型</strong>。这可以用下面的例子来解释:</p><p id="449b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设函数可以接受数字及其子类型，样本签名应该是这样的:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="9c90" class="ju jv hi jq b fi jw jx l jy jz">public void myFunction(List&lt;? extends Number&gt; list)<br/>{ /* some implementation */}</span></pre><p id="17b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">下界通配符(</strong>？超级类型。<strong class="ih hj"> ) </strong></p><p id="0e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将未知类型限制为该类型的<strong class="ih hj">特定类型或超类型。这可以用下面的例子来解释:</strong></p><p id="cd30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设函数可以接受整数及其超类型，样本签名应该是这样的:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="e1f8" class="ju jv hi jq b fi jw jx l jy jz">public void myFunction(List&lt;? super Integer&gt; list)<br/>{ /* some implementation */}</span></pre><blockquote class="ka"><p id="9d42" class="kb kc hi bd kd ke kf kg kh ki kj jc dx translated">所以上面的函数接受List <integer> &amp; List <number>，但<strong class="ak">不接受</strong> List &lt; Double &gt;。</number></integer></p></blockquote><p id="4da3" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated"><strong class="ih hj">多重界限</strong></p><p id="92fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kp kq kr jq b">&lt;T extends C &amp; I&gt;</code>表示<em class="ks">调用方</em>可以指定<a class="ae kt" href="https://www.java67.com/2019/07/top-50-java-generics-and-collection-interview-questions.html" rel="noopener ugc nofollow" target="_blank">扩展</a> <code class="du kp kq kr jq b">C</code>和<code class="du kp kq kr jq b">I</code>的任意类型。这可以解释如下:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="65f5" class="ju jv hi jq b fi jw jx l jy jz"><strong class="jq hj">class</strong> Multiple<!-- -->Bound&lt;T <strong class="jq hj">extends</strong> <!-- -->A &amp; B&gt;<br/>{<br/>  <strong class="jq hj">private</strong> <!-- -->T objRef;<br/> <br/>  <strong class="jq hj">public</strong> Multiple<!-- -->Bound(T obj)<br/>  {<br/>    <strong class="jq hj">this</strong>.objRef = obj;<br/>  }<br/> <br/>  <strong class="jq hj">public</strong> <strong class="jq hj">void</strong> <!-- -->run()<br/>  {<br/>    <strong class="jq hj">this</strong>.objRef.<!-- -->execute<!-- -->();<br/>  }<br/>}</span><span id="423b" class="ju jv hi jq b fi ku jx l jy jz"><strong class="jq hj">interface</strong> <!-- -->B<br/>{<br/>  <strong class="jq hj">public</strong> <strong class="jq hj">void</strong> execute<!-- -->();<br/>}</span><span id="7fdf" class="ju jv hi jq b fi ku jx l jy jz"><strong class="jq hj">public class</strong> <!-- -->A <strong class="jq hj">implements</strong> <!-- -->B<br/>{<br/>  <strong class="jq hj">public</strong> <strong class="jq hj">void</strong> <!-- -->execute()<br/>  {<br/>    System.out.println("Inside class A");<br/>  }<br/>}</span><span id="b45d" class="ju jv hi jq b fi ku jx l jy jz"><strong class="jq hj">public</strong> <strong class="jq hj">class</strong> <!-- -->BoundedClass<br/>{<br/>   <strong class="jq hj">public</strong> <strong class="jq hj">static</strong> <strong class="jq hj">void</strong> <!-- -->main(String a[])<br/>   {<br/>     <!-- -->Multiple<!-- -->Bound&lt;A&gt; obj= <strong class="jq hj">new</strong> Multiple<!-- -->Bound&lt;&gt;(<strong class="jq hj">new</strong> <!-- -->A());<br/>     obj.run();<br/>   }<br/>}</span></pre><blockquote class="kv kw kx"><p id="bdf3" class="if ig ks ih b ii ij ik il im in io ip ky ir is it kz iv iw ix la iz ja jb jc hb bi translated">西格尔定律是一句谚语:</p><p id="b268" class="if ig ks ih b ii ij ik il im in io ip ky ir is it kz iv iw ix la iz ja jb jc hb bi translated">“有手表的人知道现在是什么时间。一个有两只表的人永远不确定。”</p></blockquote><h1 id="1880" class="lb jv hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么时候选择什么？</h1><p id="dca5" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">为了决定哪种类型的通配符最适合该条件，让我们首先将传递给方法的参数类型分类为<strong class="ih hj"> in </strong>和<strong class="ih hj"> out </strong>参数。</p><ul class=""><li id="2777" class="md me hi ih b ii ij im in iq mf iu mg iy mh jc mi mj mk ml bi translated"><strong class="ih hj">输入变量</strong>——输入变量向代码提供数据。例如，copy(src，dest)。这里，src充当要复制的数据的变量。</li><li id="8134" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated"><strong class="ih hj">输出变量</strong>——输出变量保存由代码更新的数据。例如，copy(src，dest)。这里dest充当复制了数据的变量。</li></ul><h1 id="117f" class="lb jv hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">通配符指南(Get-Put原则)</h1><ul class=""><li id="b199" class="md me hi ih b ii ly im lz iq mr iu ms iy mt jc mi mj mk ml bi translated"><strong class="ih hj">上限通配符</strong>——如果变量属于类别中的<strong class="ih hj">，使用带通配符的扩展关键字。</strong></li><li id="4c0a" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated"><strong class="ih hj">下限通配符</strong>——如果变量不属于类别，使用带通配符的超级关键字。</li><li id="f32a" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated"><a class="ae kt" href="https://javarevisited.blogspot.com/2012/04/what-is-bounded-and-unbounded-wildcards.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">无界通配符</strong></a>——如果变量可以使用对象类方法访问，则使用无界通配符。</li><li id="adef" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated"><a class="ae kt" href="http://javarevisited.blogspot.sg/2017/04/difference-between-raw-type-and-wild-card-arraylist.html#axzz4rZnBGAiP" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">无通配符</strong></a>——如果代码同时在和<strong class="ih hj"> out </strong>类别中访问变量，则不要使用通配符。</li></ul><h1 id="a6e8" class="lb jv hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="0f34" class="pw-post-body-paragraph if ig hi ih b ii ly ik il im lz io ip iq ma is it iu mb iw ix iy mc ja jb jc hb bi translated">有界通配符在创建灵活的通用API时非常有用。使用有界通配符的最大障碍是确定下界/上界通配符的情况。</p><p id="edba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">get-put原则可用于确定应该使用哪一个。</p></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><p id="ede6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有问题吗？建议？评论？</p></div></div>    
</body>
</html>