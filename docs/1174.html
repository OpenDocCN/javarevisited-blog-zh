<html>
<head>
<title>Hibernate isn’t Object-Oriented, Don’t Force It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hibernate不是面向对象的，不要强迫它</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/hibernate-isnt-object-oriented-don-t-try-to-make-it-oop-631c53253099?source=collection_archive---------3-----------------------#2021-04-22">https://medium.com/javarevisited/hibernate-isnt-object-oriented-don-t-try-to-make-it-oop-631c53253099?source=collection_archive---------3-----------------------#2021-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5f41ddb327bf97684f756e23550d53c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ey9cyDCMRYw9RHdDAXOLlA.jpeg"/></div></div></figure><p id="6e5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用Hibernate/JPA。我喜欢。但是我完全理解那些像这个家伙一样极度讨厌它的人。还有其他人，比如<a class="ae jo" href="https://vladmihalcea.com/" rel="noopener ugc nofollow" target="_blank">弗拉德·米哈尔恰</a>，他在Hibernate方面非常出色，但老实说，只是看了他的一些帖子就让我感到头疼……我们通常选择Hibernate来避免痛苦……</p><p id="16f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为Hibernate有几个核心问题，它们都可以归结为人们对它过于“聪明”。</p><h1 id="614f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">您必须了解并查看SQL</h1><p id="32df" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果您选择Hibernate来避免SQL，那么您就犯了一个大错误。这将是你的性能和可靠性死亡的点。您必须调试SQL，并检查/验证hibernate生成的查询是否有意义。</p><p id="22c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Hibernate是一个有漏洞的抽象。这是故意的。Hibernate希望您了解SQL，这样您就可以充分利用它的功能和性能。这很糟糕，但是完全抽象的选择更糟糕。</p><h1 id="f4e1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">你不能使用正确的面向对象程序设计</h1><p id="1cb2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在我们当前的项目中，一位非常有才华的工程师说服我们使用一种非常面向对象的继承架构，在表中的各种层次结构之间使用复杂的连接语义。我们仍在清理该架构的混乱，并承受连接带来的性能损失。</p><p id="ad01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SQL不是OOP。SQL不擅长连接，使用对象范例可以有效地强制进行大量连接。</p><p id="0fdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更好的方法是提供一个巨大的表和一个包含所有字段的巨大对象。是的，这很难看，但是查询会简单而快速。维护会非常容易。我们仍然可以使用适当的数据传输对象和服务层将所有内容封装到其他层。</p><h1 id="ee81" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">关系是地狱</h1><p id="082a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在hibernate中，让关系在所有情况下都能正常执行和工作是最困难的事情之一。尤其是当你的对象图开始变深的时候。如果你有一个深度对象图，我建议你完全重新考虑它。</p><p id="5c1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个常见的错误是使用懒惰的关系来解决性能问题。可惜，这恰恰隐藏了核心问题。更好的解决方案是尽可能统一对象，并通过简化模式来减少实体的数量。</p><h1 id="588f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">灵活使用模式</h1><p id="4347" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这与我先前的观点有关。减少关系意味着改变模式以匹配简化的对象图。是的，在Hibernate中，您可以将任何模式映射到几乎任何对象图…</p><p id="6ef5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不要。</p><p id="f8e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有这么多边缘案例，不值得。</p><p id="64f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使模式和对象图尽可能简单。用整体式对象构建宽桌子。是的，我知道这很糟糕。这也会让你在以后的道路上免于麻烦。</p><h1 id="0d4c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">尝试不变性</h1><p id="b00b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在我们的数据库中，我们尽可能避免实体突变。实体被创建和删除。很少修改。这解决了人们在事务冲突等方面的许多问题。这可能并不适用于所有情况，但通常情况下，它可以相当好地工作，并解决许多并发问题。</p><h1 id="9a07" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用龙目语或科特林语</h1><p id="9b6b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">一些人经历了一些龙目岛和<a class="ae jo" rel="noopener" href="/javarevisited/top-5-books-to-learn-hibernate-for-java-developers-b2cb4b16ccd6?source=---------14------------------">冬眠</a>的问题，所以小心行事。我在一个项目中使用它(不是全部),它在压力下似乎工作得很好。冗长的节省是美妙的。dto和实体简洁易读。这是一个很好的工具。</p><p id="09d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还没有在我的Hibernate项目中使用过<a class="ae jo" rel="noopener" href="/javarevisited/top-5-courses-to-learn-kotlin-in-2020-dfc3fa7706d8"> Kotlin </a>，但是我的朋友们使用过。移除setter/getter样板文件(正如我们在Java中看到的record特性)的价值是巨大的。</p><h1 id="9e4c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">那么为什么要使用Hibernate呢？</h1><p id="82ac" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">此时，你可能会说很多开发人员都在说的话:为什么不直接使用<a class="ae jo" rel="noopener" href="/hackernoon/top-5-sql-and-database-courses-to-learn-online-48424533ac61"> SQL </a>或者通过像<a class="ae jo" href="https://www.jooq.org" rel="noopener ugc nofollow" target="_blank"> jooq </a>这样的抽象。</p><p id="83cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些都是正确的，但是<a class="ae jo" rel="noopener" href="/javarevisited/8-best-spring-and-hibernate-training-courses-for-java-developers-acf09aa0e244"> Hibernate </a>仍然带来了很多好处:</p><ul class=""><li id="a846" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">它可能不是我们绘图板上的完美OOP模型，但它仍然是一个具有方法和功能的对象。</li><li id="c8a8" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">很容易将其与缓存解决方案集成，并通过注释(事务、隔离等)定义复杂的行为。).</li><li id="629e" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">使用Hibernate时重用代码比手工编写SQL更容易。</li><li id="21ae" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">它是数据库中立的。例如，我们在hsql上调试，但在MySQL上运行生产。</li><li id="3446" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">最后，网上有很多帮助。当你遇到问题时，通常很容易找到解决办法。</li></ul><p id="0d81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你愿意，选择低级SQL路线也是可以的。这不是我大多数项目的发展方向。但是如果你把Hibernate和其他ORM工具相比，它还是很棒的。</p><h1 id="16cd" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="b907" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我认为Hibernate很棒，尽管它不是万灵药。您需要将您对Hibernate的期望与现实保持一致。不要期待面向对象。不要指望浏览SQL。为问题做好准备，和Hibernate一起工作会很愉快。</p></div></div>    
</body>
</html>