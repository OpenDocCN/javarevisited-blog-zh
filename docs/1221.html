<html>
<head>
<title>Threads in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的线程</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/threads-in-java-4666bf0e418c?source=collection_archive---------1-----------------------#2021-05-10">https://medium.com/javarevisited/threads-in-java-4666bf0e418c?source=collection_archive---------1-----------------------#2021-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/106459aeb2eaac1cf363069e1cb88af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8V30ygZYzaVtl6Tq9Y1WUQ.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">蒂姆·莫斯霍尔德在<a class="ae iu" href="https://unsplash.com/s/photos/thread?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="97db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">“看不见的线是最牢固的纽带。”―弗里德里希·尼采</em></p><p id="68b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在了解Java中的线程之前，我们首先需要了解一下<em class="jt">多任务</em>。</p><p id="70f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多任务处理的基本思想是同时做多件事情。但是计算机能同时完成多项任务吗？实际上，不，在操作系统内核中使用像<em class="jt">分时</em>这样的技术可以在任务之间快速切换，甚至不会察觉。为此，现代处理器使用“核心”,它是中央处理器内部的一个处理单元。然而，具有多个处理器的计算机可以进行一定程度的多任务处理。</p><p id="6a27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在计算机中，这种多任务处理可以有两种方法，一种是基于进程的方法，另一种是基于线程的方法。 </p><p id="104b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">什么是基于进程的多任务处理，它实际上提供了运行多个彼此完全独立的进程的能力，例如，一个网络浏览器运行，同时一个音乐播放器应用程序播放音乐。</p><p id="3ad2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于线程的多任务实际上是由多个线程组成的，一个线程是一个进程所拥有的执行的一小部分，所以一个进程可以有多个线程。这些多线程同时执行。处理器中的“核心”负责充分利用线程。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/d58cae1fcc1d45fe45dd4232eae2bc01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*yMCwIEOjti0XSm-f57tAMQ.png"/></div></figure><p id="8652" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不是让我们找到关于Java中线程的详细视图。</p><h1 id="50a8" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Java中的线程是什么？</h1><p id="29fa" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">正如我们所讨论的，线程是执行路径。这可以是程序内部涉及的方法或业务逻辑。为了运行Java，线程<em class="jt">线程调度器</em>需要从CPU分配一部分资源，Java程序并不是运行在计算机上的唯一程序，因此OS线程也将获得优先级，由于这个原因，预测执行顺序是不可能的(如果没有任何标准照常运行)。</p><p id="12dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于预测执行顺序的这种不确定性，程序员不能将一组进程分配到各个线程中并等待结果，因为如果它们之间存在任何依赖关系，那么预期的结果将不会出现。</p><p id="ab65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java的main方法也是一个线程，确切的说是非守护进程。JVM的启动以非守护进程线程的启动开始，并且JVM将在最后一个非守护进程线程执行结束时退出。</p><h1 id="3714" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">线程生命周期</h1><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/9ca96bf8bf43b133c616d895b046f72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9I8EAfCnRXcjk1aGHymaQ.png"/></div></div></figure><p id="0b4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与操作系统上运行的进程一样，线程也有自己的状态，根据时间和优先级，这些线程必须不断地改变它们的状态。</p><p id="2b23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> NEW </strong> —新线程创建但尚未开始的时刻。</p><p id="6dc9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">可运行</strong> —线程处于执行模式。</p><p id="f88b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">阻塞</strong>—线程被阻塞，等待监视器锁被释放。</p><p id="e85a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">等待</strong> —只要线程接收到另一个线程的信号，它就会一直等待。</p><p id="b8d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> TIMED_WAITING </strong> —线程正在等待一段特定的时间</p><p id="4231" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">终止</strong> —线程已经退出。</p><p id="9d7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些线程状态转换不是即时的。<em class="jt">线程调度器</em>需要根据可用性分配CPU时间。</p><h1 id="8aa6" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">创建线程</h1><p id="9911" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">在Java中创建线程主要有两种方法，一种是从<strong class="ix hj"> <em class="jt"> Runnable </em> </strong>接口中的<em class="jt">implements</em></p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="d0f5" class="li ka hi le b fi lj lk l ll lm">public class RunnableThread implements Runnable {<br/>    @Override<br/>    public void run() {<br/>        //functionality to run during thread execution<br/>    }<br/>}</span></pre><p id="38ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一种方法是从<strong class="ix hj"> <em class="jt">线程</em> </strong>类中“<em class="jt">扩展</em>”。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="1be8" class="li ka hi le b fi lj lk l ll lm">public class ExtendedThread extends Thread{<br/>    @Override<br/>    public void run() {<br/>       //functionality to run during thread execution<br/>    }<br/>}</span></pre><p id="2298" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两者看起来是一样的，那么有什么区别呢？用两种不同的方法做同一件事有什么用呢？Java基于面向对象的原则，我们创建的类应该有适当的层次顺序。<br/>举个例子，如果我们正在创建一辆汽车，</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="258a" class="li ka hi le b fi lj lk l ll lm">Vehicle -&gt; Car -&gt; SUV</span></pre><p id="1d07" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个流程会类似于这样，但是万一如果我们要添加一个线程类，它会断开相关类之间的连接，而且也不像c++这样的语言，Java不提供多个继承，在这种情况下，没有办法使用多个父类，那时我们就可以使用接口了。</p><p id="ecac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一个用两种不同方法创建线程的例子。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="f38f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的例子是它从<strong class="ix hj"> <em class="jt">线程</em> </strong>类中<strong class="ix hj"> <em class="jt">扩展了</em> </strong>，并覆盖了<strong class="ix hj"> <em class="jt"> run() </em> </strong>方法来添加要运行的功能。有必要超驰吗？不要！但是创建一个线程的想法是运行一些功能，run方法的责任是保存这些功能，以防万一如果它不覆盖run()方法它什么也不做。</p><p id="81af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看看如何运行它，</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="f63b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单地说，我们从类中创建一个对象，并调用方法“<strong class="ix hj"><em class="jt">”start()”。</em> </strong>好吧，为什么不跑？我们讨论过run的职责是持有运行()的功能。但是线程化是一个复杂的过程，它通过与JVM、OS通信、创建线程、将它们添加到线程池来处理，所有这些都应该被处理。所有这些进程都将使用<strong class="ix hj"><em class="jt">“start()”</em></strong>方法来处理。</p><p id="6992" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我们可以直接调用<em class="jt"> "run()" </em>方法，程序将会正确无误地运行，但是<em class="jt">不会创建单独的线程</em>，它将在主线程上运行。</p><p id="01a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看看通过使用<em class="jt"> Runnable </em>接口来使用另一种方式。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="ab45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在情况开始发生变化，不像Thread类在使用接口时它现在强制开发者覆盖"<strong class="ix hj"><em class="jt">【run()"</em></strong>方法，否则会导致编译器错误。</p><p id="9e41" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当查看实现时，Runnable类实际上是<em class="jt">函数接口</em>(它只包含一个抽象方法)。所以现在没有办法继承由<em class="jt">线程</em>类提供的<em class="jt"> start() </em>方法、属性或其他功能。现在我们来看看。🤔</p><p id="2421" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们必须再次使用Thread类作为使用<em class="jt"> Runnable </em>接口创建的类的实例(对象)的包装类。我们是这样做的。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="abb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过使用线程对象进行包装，现在它可以使用线程操作所需的所有方法。</p><p id="2717" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java为我们提供了不受任何限制地覆盖这些方法的能力，但是这会影响线程的工作方式。当自定义实现正在进行时，在线程类的功能中，最好也引用其父类实现，<em class="jt">(例如——"</em><strong class="ix hj"><em class="jt">super . start()</em></strong><em class="jt">"</em></p><h1 id="a839" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">线程中的优先级</h1><p id="d66c" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">线程的执行顺序无法像预期的那样预测，但是在Java线程中，它为我们提供了一种机制来为线程分配优先级。</p><p id="21c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">线程优先级是基于<em class="jt">值的</em>方法，与数据结构不同，它不是基于索引的。Java定义了线程优先级的范围，</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="a670" class="li ka hi le b fi lj lk l ll lm">public static final int <em class="jt">MIN_PRIORITY </em>= 1;<em class="jt"><br/></em>public static final int <em class="jt">NORM_PRIORITY </em>= 5;<em class="jt"><br/></em>public static final int <em class="jt">MAX_PRIORITY </em>= 10;</span></pre><p id="3c0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是这些值不限于这些范围，它们可以是从1到10的值，小于或大于此范围以外的值会导致<strong class="ix hj"><em class="jt">“IllegalArgumentException”。</em> </strong></p><p id="3b0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">线程的优先级是可继承的，它们使用主线程优先级的值，除非它没有被显式设置。这里有一个例子，</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="8a28" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">螺纹连接</h1><p id="c96f" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">可能会出现这样的情况，两个或多个不同的线程必须等待完成进程的剩余部分，直到其他线程完成。Java为这些类型的场景提供了方法<strong class="ix hj"><em class="jt">【join()】</em></strong>。“Join”方法有不同的实现。</p><ul class=""><li id="0e6b" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated">join() —该方法等待，直到特定的方法完成工作</li><li id="c4e8" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">join(长毫秒)—此方法等待，直到某个时间段</li><li id="1b4f" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated">join(long毫秒，int纳秒)—该方法也等待一段时间，但需要一点精确的时间</li></ul><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="0e49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，它创建了两个Java线程，一个从1数到10，另一个从11数到20。"<em class="jt"> threadTwo </em> " <em class="jt">必须等待</em>直到"<em class="jt"> threadOne </em>"完成，所以联接应该是<em class="jt"> "threadOne.join()"。<br/> </em>输出会是这样的结果，</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es md"><img src="../Images/baf6e8aa996aea0a8367b0f2dc173cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*UVRyzN5-6Q-AKqeFV_HcTA.png"/></div></figure><h1 id="e6c0" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">线程中的操作</h1><p id="0dfc" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">线程有各种各样的其他功能来工作，而不会导致冲突，并具有安全性和分配时间。如果要保持应用程序流畅，这是必要的。Java很少有有价值的操作。</p><h2 id="8e8a" class="li ka hi bd kb me mf mg kf mh mi mj kj jg mk ml kn jk mm mn kr jo mo mp kv mq bi translated">产量</h2><p id="cbdf" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">“yield()”是Thread类中的一个本机静态方法，它应该处理本机库来完成它的工作。<br/><strong class="ix hj"><em class="jt">" thread . yield()"</em></strong>所做的就是在方法被调用的时候，给另一个线程提供它的运行时隙。</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="3aa5" class="li ka hi le b fi lj lk l ll lm">@Override<br/>public void run() {<br/>    for (int i = 0; i &lt; 100; i++) {<br/>        if (i == 66){<br/>            Thread.<em class="jt">yield</em>();<br/>            //When counter reaches 66 give chance to another thread  <br/>        }<br/>        System.<em class="jt">out</em>.println(i);<br/>    }<br/>}</span></pre><h2 id="d3ca" class="li ka hi bd kb me mf mg kf mh mi mj kj jg mk ml kn jk mm mn kr jo mo mp kv mq bi translated">睡眠和中断</h2><p id="29f2" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">“<strong class="ix hj"> <em class="jt"> sleep() </em> </strong>”方法提供了线程等待一定时间的能力，将线程置于<em class="jt"> TIMED_WAITING </em>状态，它有两种定义方式，</p><pre class="jv jw jx jy fd ld le lf lg aw lh bi"><span id="f85d" class="li ka hi le b fi lj lk l ll lm">sleep(long miliseconds)</span><span id="f607" class="li ka hi le b fi mr lk l ll lm">sleep(long miliseconds, int nanoseonds)</span></pre><p id="b9ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而<em class="jt"> interrupt() </em>方法，等到方法进入sleep()并触发方法来中断睡眠，但是中断一个非睡眠的方法不会抛出异常它只是遵循通常的路径。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h1 id="6377" class="jz ka hi bd kb kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw bi translated">参考</h1><p id="fbbc" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">Java线程速成班:<a class="ae iu" href="https://youtube.com/playlist?list=PLD-mYtebG3X99o6vJ3uR5P6UcH3MQSWBH" rel="noopener ugc nofollow" target="_blank">https://youtube.com/playlist?list = PLD-myte BG 3 x 99 o 6 VJ 3 ur 5 p 6 uch 3 mqs wbh</a></p></div></div>    
</body>
</html>