<html>
<head>
<title>Inside the JVM — Part 02 (ClassLoader)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JVM内部—第2部分(类加载器)</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/inside-the-jvm-part-02-classloader-e893edf64c00?source=collection_archive---------2-----------------------#2021-05-02">https://medium.com/javarevisited/inside-the-jvm-part-02-classloader-e893edf64c00?source=collection_archive---------2-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2ae037c63ff19aed7788bb4a6d8c5098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aVoTQt_ylgHY7-qV"/></div></div><p class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@petrebels?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">海燕</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ee8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">“正直是做正确的事，即使没有人看着。”刘易斯</em></p><p id="fc82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们回顾一下JVM，基本上，JVM有三个主要功能，分别是<strong class="ix hj"> <em class="jt">加载</em> </strong>编译后的类文件，<strong class="ix hj"> <em class="jt">存储</em> </strong>它，然后<strong class="ix hj"> <em class="jt">执行</em> </strong>它。为了完成这个过程，JVM有三个独立的组件。</p><p id="b509" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">加载过程由<strong class="ix hj"> <em class="jt">类加载器完成，</em> </strong>存储由<strong class="ix hj"> <em class="jt">内存区</em> </strong>完成，程序执行由<strong class="ix hj"> <em class="jt">执行引擎</em> </strong>处理。现在让我们详细讨论每一个问题。</p><p id="3402" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们来谈谈<strong class="ix hj"> <em class="jt">类加载器。</em> </strong></p><p id="444a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当JVM实例开始运行时，classloader的基本职责是在运行时将编译好的类加载到JVM中。如果类找不到它就会抛出<strong class="ix hj"><em class="jt">ClassNotFoundException</em></strong><em class="jt">。</em><em class="jt"/>最重要的是要知道每一个定制的类加载器都是通过<strong class="ix hj"> <em class="jt">扩展</em></strong><em class="jt">" class loader "</em>类(抽象)来实现的，这些类位于<em class="jt"> "java.lang" </em>包中，而不是Boostrap类加载器(细节见下文)。</p><p id="8bd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个类装入器都应该遵守一些原则。</p><p id="bd0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">可见性原则</strong> —子类装入器可以看到由它们的父类装入器生成的其他类装入器，但是父类装入器看不到它的子类装入器生成的是什么类装入器(祖父母不知道孙子辈😉)</p><p id="3572" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">唯一性原则</strong>——确保一个类只加载一次，并确保子类不会加载其父类已经加载的同一个类。</p><p id="da25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">委托原则</strong> —这遵循一种分层的方法来寻找和加载适当的类当一个请求来加载类(<em class="jt">example class loader . load class(" com . org . pkg ")</em>)时，它将把请求从最低层传递到较高层(应用程序类加载器&gt;扩展类加载器&gt;引导类加载器)来寻找类， 如果在那里没有找到它，那么它将返回到扩展类加载器来查找它在自定义路径中的位置，如果最后应用程序类加载器也失败了，那么如果没有找到，则抛出一个"<strong class="ix hj"><em class="jt">ClassNotFoundException "</em></strong>。</p><p id="937b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">无卸载原则</strong> —已加载的类不能从类加载器中卸载，只能删除并创建一个新的类加载器。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="8f7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JVM中有几种不同的类装入器，它们是</p><h2 id="480b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jg km kn ko jk kp kq kr jo ks kt ku kv bi translated">1.引导类装入器</h2><p id="bc5d" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">为了运行Java程序，必须加载必要的库和核心Java APIs，引导类加载器也称为原始类，负责加载这些类。Boostrap ClassLoader认为是用JRE实现中使用的本机代码编写的JVM的核心部分(<a class="ae iu" rel="noopener" href="/javarevisited/10-best-c-and-c-programming-books-for-beginners-and-experienced-programmers-eb5ee8dbdc5a"> C，C++ </a>)和类加载器的最终父类。</p><h2 id="f6f2" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jg km kn ko jk kp kq kr jo ks kt ku kv bi translated">2.扩展类加载器</h2><p id="0cfa" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">这个类加载器是Boostrap类加载器的子类加载器，负责加载标准类的所有扩展类。</p><h2 id="a487" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jg km kn ko jk kp kq kr jo ks kt ku kv bi translated">3应用程序类加载器</h2><p id="fdb3" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">这也被称为<strong class="ix hj"> <em class="jt">系统类加载器</em> </strong>，以及扩展类加载器的子类，这个负责在编译程序时加载<strong class="ix hj"><em class="jt">class path(-CP)</em></strong>中提到的与应用相关的所有应用级类文件。</p><p id="f8e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">classloader本身由三个子进程组成，分别是<strong class="ix hj"><em class="jt"/></strong><strong class="ix hj"><em class="jt">链接</em></strong><strong class="ix hj"><em class="jt">初始化</em> </strong>。现在让我们来详细讨论其中的每一个。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/89eef4956629099dbf8dfec055d319f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*rjteFPLg2PHsFc3jG1c3Ww.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">类加载器子进程</p></figure><h1 id="51c9" class="lg kc hi bd kd lh li lj kh lk ll lm kl ln lo lp ko lq lr ls kr lt lu lv ku lw bi translated">1.装货</h1><p id="dc14" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">当加载到其中的类第一次从类中读取一些信息时，这些信息是，<br/>完全限定的类名(例如“java.lang.String”)。<br/>直接父类信息。<br/>实例和静态变量，<br/>找出它是类、接口还是枚举。</p><p id="6650" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">得到这些信息后，<em class="jt">第一次运行它的JVM的</em>从<strong class="ix hj"><em class="jt"/></strong>文件<em class="jt"> ("java.lang.Class ")，</em>中创建一个对象，最重要的是这个对象不是使用应用程序中创建的类文件创建的(例如——User，Employee)。</p><pre class="lc ld le lf fd lx ly lz ma aw mb bi"><span id="5c50" class="kb kc hi ly b fi mc md l me mf">Class class = new AdminUser();</span></pre><p id="e01c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并将它放入堆中。</p><h1 id="f717" class="lg kc hi bd kd lh li lj kh lk ll lm kl ln lo lp ko lq lr ls kr lt lu lv ku lw bi translated">2.连接</h1><p id="2cb8" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">链接分为三个子过程，即<strong class="ix hj"> <em class="jt">验证</em> </strong>、<strong class="ix hj"> <em class="jt">准备、</em> </strong>和<strong class="ix hj"> <em class="jt">解析。</em>T11】</strong></p><p id="86ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2.1验证</strong> —该过程确保字节码的安全性，验证过程用于决定给定的类文件是否可以安全执行，以及它是否从其原始形式被改变。在字节码验证器的帮助下，这个过程遵循几个标准，即</p><ul class=""><li id="2f06" class="mg mh hi ix b iy iz jc jd jg mi jk mj jo mk js ml mm mn mo bi translated">检查编译后的类文件是否来自有效的编译器，是否符合JVM规范。</li><li id="8964" class="mg mh hi ix b iy mp jc mq jg mr jk ms jo mt js ml mm mn mo bi translated">检查它是否具有正确的类文件结构和正确的语言格式，是否符合语法规则和其他规则。</li></ul><p id="b7cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果其中任何一个失败，它将抛出<em class="jt"> VerifyException </em>。</p><p id="02f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2.2准备</strong> —如果类有实例级或者静态变量，在这个阶段会提供<a class="ae iu" href="https://chamalwr.medium.com/inside-the-jvm-part-01-90c841abfd81" rel="noopener"> <em class="jt">默认值</em> </a> <em class="jt"> </em>(不是用户指定的值)。</p><p id="38c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2.3解析</strong> —当程序员编写Java程序时，他们使用<em class="jt">符号名称</em>来表示基于应用程序域的对象，例如Payment、Student、Course等类。但是当它到达JVM时，那些没有被JVM识别的或者在机器级别的，在这个阶段，它将搜索方法区域来定位被引用的实体，并且<em class="jt">用引用</em>替换它们，在那里它们实际上驻留在堆中。</p><h1 id="ab15" class="lg kc hi bd kd lh li lj kh lk ll lm kl ln lo lp ko lq lr ls kr lt lu lv ku lw bi translated">3.初始化</h1><p id="18c0" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">作为类加载器的最后一步，它将决定类或静态变量是否有任何活动的使用，如果有任何活动的使用，那么它将进行初始化过程，选择它是否有活动用例的标准很少。</p><ul class=""><li id="19d2" class="mg mh hi ix b iy iz jc jd jg mi jk mj jo mk js ml mm mn mo bi translated">如果使用<em class="jt">【new】</em>关键字(new Student())创建一个类。</li><li id="55a0" class="mg mh hi ix b iy mp jc mq jg mr jk ms jo mt js ml mm mn mo bi translated">调用一个类中的静态方法会将驻留其方法的类视为活动使用。</li><li id="27d5" class="mg mh hi ix b iy mp jc mq jg mr jk ms jo mt js ml mm mn mo bi translated">为静态字段赋值。这里需要注意的重要一点是，如果字段是静态的，那么将决定活动的情况，如果它被定义为<em class="jt">【最终】</em>或<em class="jt">【静态最终】</em>，则不认为它是活动的使用。</li><li id="d3da" class="mg mh hi ix b iy mp jc mq jg mr jk ms jo mt js ml mm mn mo bi translated">如果该类是初始类，这意味着它包含了<em class="jt">" public static void main(String[]args)"</em>方法。</li><li id="907d" class="mg mh hi ix b iy mp jc mq jg mr jk ms jo mt js ml mm mn mo bi translated">举例来说，如果一个类不具有这些属性中的任何一个，但是另一个类具有一个或多个扩展该类的属性，那么父类也被认为是一个活跃的使用，它可以经历初始化</li></ul><pre class="lc ld le lf fd lx ly lz ma aw mb bi"><span id="8bac" class="kb kc hi ly b fi mc md l me mf">public class Student{...} </span><span id="d9ca" class="kb kc hi ly b fi mu md l me mf">public class FullTimeStudent extends Student { ... }</span><span id="6287" class="kb kc hi ly b fi mu md l me mf">public class Main {  <br/>      FullTimeStudent ftStudentGrd = new FullTimeStudent();<br/>}</span><span id="28be" class="kb kc hi ly b fi mu md l me mf">//Both the Student and FullTimeStudent classes considered as active use</span></pre><h2 id="f154" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jg km kn ko jk kp kq kr jo ks kt ku kv bi translated">参考</h2><p id="7c19" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">Java类加载器—<a class="ae iu" href="https://www.youtube.com/watch?v=CQQzYCjNdIw" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=CQQzYCjNdIw</a></p><div class="mv mw ez fb mx my"><a href="https://www.baeldung.com/java-classloaders" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">Java中的类装入器| Baeldung</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">类加载器负责在运行时将Java类动态加载到JVM (Java虚拟机)中…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">www.baeldung.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://www.javatpoint.com/classloader-in-java" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">Java-Java point中的类加载器</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">Java ClassLoader是一个抽象类。它属于一个java.lang包。它从不同的资源加载类…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">www.javatpoint.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm io my"/></div></div></a></div></div></div>    
</body>
</html>