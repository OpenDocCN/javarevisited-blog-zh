<html>
<head>
<title>Step scoped beans in a Spring Batch Job</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring批处理作业中的Step作用域beans</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/step-scoped-beans-in-a-spring-batch-job-570a09184fa5?source=collection_archive---------1-----------------------#2021-04-04">https://medium.com/javarevisited/step-scoped-beans-in-a-spring-batch-job-570a09184fa5?source=collection_archive---------1-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/2295cbff1224ea609e982a49b8d1fa9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*NpECa-pqXGT4HeJNcPfYwQ.jpeg"/></div></figure><p id="cade" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">spring中bean范围的概念使我们能够专注于业务逻辑，而不必担心数据不一致。</p><p id="fd1a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">spring应用程序中beans的生命周期是根据应用程序上下文(@Singleton)、线程(@Prototype)或web感知应用程序的http会话(@Session)、http请求(@Request)或servlet生命周期(@ApplicationScope)、webSocket会话来定义的。</p><p id="15d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">换句话说，用@Singelton注释的bean将在容器初始化(应用程序启动)时创建一次，并在容器终止(应用程序关闭)时销毁。</p><p id="8383" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">类似地，每次有对bean的新请求时，都会创建一个用@prototype注释的bean。用@Session注释的Bean为每个会话创建一次，用@Request注释的bean为每个http请求创建一次。</p><p id="bf4c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以看到，我们有大量的<a class="ae jk" href="https://javarevisited.blogspot.com/2012/05/what-is-bean-scope-in-spring-mvc.html" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> bean作用域</strong> </a>可供选择，以满足每个定制应用程序的需求。我们有关于web应用程序的特定范围，我们有关于应用程序上下文的范围。</p><p id="9163" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">到目前为止一切顺利。但是在spring批处理作业的情况下，上述范围只能在一定程度上使用。由于跳批作业由多个步骤组成，因此除了上述范围之外，根据一个步骤来定义beans是很自然和实际的。</p><p id="e677" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">幸运的是，<strong class="io hj"> Spring定义了另外两个作用域，即step作用域和job作用域</strong>，帮助我们定义生命周期分别与job和step生命周期相关联的beans。</p><h2 id="1848" class="jl jm hi bd jn jo jp jq jr js jt ju jv ix jw jx jy jb jz ka kb jf kc kd ke kf bi translated"><strong class="ak">步进范围</strong></h2><p id="0a06" class="pw-post-body-paragraph im in hi io b ip kg ir is it kh iv iw ix ki iz ja jb kj jd je jf kk jh ji jj hb bi translated">步骤范围内的bean的生命周期与步骤的生命周期相关，即bean分别在步骤开始和结束时创建和销毁。</p><p id="2cac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">用于声明步骤范围bean的注释是@StepScope</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/67bc5dd4695bfb79aa3a9e5ccf771ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*NJ5-NrmuwluUJ-5wDQExjA.png"/></div></figure><p id="4084" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们并行执行步骤时，步骤范围特别有用，因为隔离bean的状态变得非常重要。否则，多个线程会同时修改bean的状态，导致它不一致。</p><p id="c16e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在下面的示例中，我们配置了一个SpringBatch作业，其中每个步骤都执行相同的操作，即从数据库中读取数据，对数据进行一些转换，然后将其写入文件。</p><p id="b3c9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里的想法是从<a class="ae jk" rel="noopener" href="/hackernoon/top-5-sql-and-database-courses-to-learn-online-48424533ac61">数据库</a>中读取数据，对其进行处理并将其移动到文件中。一旦它被成功处理并写入文件，我们就从数据库中删除所有数据。</p><p id="70d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上述顺序在各个步骤中是不变的，唯一的区别是每个步骤读取的数据库(每个步骤一个db配置),然后从中删除所有数据。</p><p id="a6c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这项工作包含三个步骤步骤1，步骤2，步骤3。步骤1和2被配置为并行运行，而步骤3在步骤1和2完成执行后执行。</p><figure class="km kn ko kp fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/08/top-5-courses-to-learn-spring-mvc-for.html"><div class="ab fe cl kq"><img src="../Images/f12804c4c90c7265d2cfabf905c0051e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*O80dbLGlPv-qKKo7FXe4Cw.png"/></div></a></figure><p id="295e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">读取、处理、写入部分由步骤处理，但是额外的数据删除方面呢？</p><p id="b136" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个通用操作，必须在每个步骤执行完毕后执行。</p><p id="2379" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Spring为我们提供了一种叫做step listener的东西，它能做到这一点。当侦听器注册到一个步骤时，在该步骤成功运行之后，在进入下一个步骤之前，框架会调用它。</p><figure class="km kn ko kp fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/04/best-reactive-spring-and-webflux-courses-for-java-developers.html#axzz6qnblZnVj"><div class="er es kr"><img src="../Images/3f80802a61491375daa1746ec4efd6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*6gpfi_dG-pRb4U4439T9XA.png"/></div></a></figure><p id="102b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们已经定义了一个通用的step listener类，它将处理流程中的数据删除部分。</p><p id="41f1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它在构造函数中接受dbname、dbUserName等参数，然后在步骤完成后框架调用监听器的afterStep方法时删除数据库中的所有数据。</p><p id="da94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">定义一个通用监听器使我们能够在每个步骤中使用相同的监听器类。我们只需要确保每一步都使用三个不同配置的不同实例</p><figure class="km kn ko kp fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/02/difference-between-contextconfiguration-and-springapplicationConfiguration-annotations-in-spring-boot-testing.html"><div class="er es ks"><img src="../Images/0c83a7f021955e1833a3f02554114bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*tPdYzVbyZTPvgDbmSGeE8A.png"/></div></a></figure><p id="b25f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们需要监听器存在于步骤的生命周期中，并且对于每个步骤都有不同的配置。这只能通过使用步骤范围来实现。</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/b66e255dd73d35c88d57ed5974f495a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*I0OCJ2mWHZt7HvplBlEUOA.png"/></div></figure><p id="33e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">StepScope将确保我们隔离每个步骤的侦听器的处理，而且一旦步骤完成执行，侦听器实例就不再存在，从而避免任何内存泄漏。</p><p id="5001" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> Stepscope还为我们提供了</strong>的能力</p><p id="eede" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">通过步骤执行上下文和步骤执行监听器在步骤之间传递信息</strong></p><p id="5603" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">通过用占位符对参数进行注释来执行参数的后期绑定</strong></p><p id="3a3b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">考虑下面的场景，其中每个都需要将它处理的记录数传递给下一个连续步骤。我们有三步第一步，第二步，第三步。步骤1应该将它处理的记录总数传递给步骤2，依此类推。</p><figure class="km kn ko kp fd ij er es paragraph-image"><a href="https://medium.com/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25"><div class="er es kt"><img src="../Images/464637d23c9163d7f4fddf0da005018d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*EG-3ItRVOk2u_XIAX6aL3g.png"/></div></a></figure><p id="9d31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们必须将计数信息从一个步骤传递到另一个步骤时，问题就出现了。这就是stepexecutionListener再次发挥作用的地方。</p><p id="cc71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如上所述，当侦听器向某个步骤注册时，一旦该步骤完成执行，侦听器的afterStep方法就会被调用。Listener有两个方法BeforeStep和AfterStep，分别在步骤开始执行之前和完成执行之后调用。</p><p id="19ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，侦听器通过在步骤之间不间断地存储计数信息来帮助我们弥合步骤之间的差距。</p><p id="d131" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，这些步骤只需确保在终止之前将这些信息传递给侦听器。我们如何将这些数据从步骤传递给监听器？</p><p id="b434" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">幸运的是，我们有一个叫做<code class="du ku kv kw kx b">stepExecutionContext </code>的东西，它通常包含与该步骤相关的上下文信息。每个步骤的编写器在stepExecutionContext中设置计数值，侦听器从上下文中检索它。</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/27876ec25b10de6537485533a5a2df47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*J-GGfK0LlZ_gW1oMFdm4NQ.png"/></div></figure><p id="5448" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们使用一个占位符来自动填充计数变量。最初，该值为0，步骤1的编写器将刚刚处理的数字添加到该值中。因此，如果步骤1读取了10条记录，计数将更新为10。(0+10)</p><p id="a8bc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">占位符允许我们检索前面所有步骤处理的记录的数量。占位符在运行时通过从stepExecutionContext中检索计数值来解析。</p><p id="325d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，stepExecutionContext的生命周期与一个步骤相关联。步骤1的stepExecutionContext中保存的内容在步骤2的stepExecutionContext中不可见。</p><p id="46ba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您一定已经注意到，这次我们的侦听器不是单步执行，而是作业。这意味着每次作业调用只创建一个侦听器实例。因此，同一个侦听器实例在一个作业的所有步骤中共享。</p><p id="5550" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们利用这一点间歇地将当前计数存储在侦听器中，并在步骤之间传递它。</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/dccadf6f2ca27e7d938b78170e19c497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*XqtTeBdBsRm690TwyLqcUQ.png"/></div></figure><p id="0584" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在退出步骤之前，我们从stepExecutionContext中检索计数(通过侦听器中的AfterStep方法),并更新stepExecutionListener的currentCount以反映到目前为止处理的记录总数。</p><p id="99da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们之前提到过，在step1开始处理之前，初始计数值被设置为0。但是谁来设定呢？这是在侦听器的beforeStep方法中完成的，该方法检查当前步骤是否是第一步，如果是，则将其设置为0。</p><p id="972a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是【step scope如何帮助我们不仅定义beans的生命周期，还允许我们跨步骤传递数据</p><p id="66c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">页（page的缩写）你可以在这里找到一个例子<a class="ae jk" href="https://github.com/SafinaAh/SpringBatchExamples" rel="noopener ugc nofollow" target="_blank">https://github.com/SafinaAh/SpringBatchExamples</a>。这并不包含本文中讨论的所有内容，但是当我能挤出一些时间来整合这里讨论的所有内容时，将会进行更新。</p></div></div>    
</body>
</html>