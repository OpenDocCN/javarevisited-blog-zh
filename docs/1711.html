<html>
<head>
<title>Mapstruct — Bean Mapping framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Mapstruct — Bean映射框架</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/mapstruct-bean-mapping-framework-7955ac60a746?source=collection_archive---------1-----------------------#2021-11-08">https://medium.com/javarevisited/mapstruct-bean-mapping-framework-7955ac60a746?source=collection_archive---------1-----------------------#2021-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://www.java67.com/2016/09/map-reduce-example-java8.html"><div class="er es if"><img src="../Images/12af3c085070f8ae24c2c4bc4fc09541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQcMkk-OO_C4JdwcIJ9DiQ.jpeg"/></div></a></figure><p id="e591" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你有没有面对过Java中属性(Bean)映射的枯燥任务？你曾经需要编写服务POJO到d to转换的代码吗？您需要为映射API准备一个设计吗？</p><blockquote class="jk jl jm"><p id="2d39" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">MapStruct是满足上述需求的正确解决方案。</p></blockquote><p id="43ba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">MapStruct是一个代码生成器，它基于配置方法的约定，极大地简化了Java bean类型之间映射的实现。</p><p id="64a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将讨论不同的场景及其实现和示例。</p><h1 id="b88f" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">指数</strong></h1><ul class=""><li id="8fee" class="kp kq hi io b ip kr it ks ix kt jb ku jf kv jj kw kx ky kz bi translated">为什么是MapStruct？</li><li id="f50e" class="kp kq hi io b ip la it lb ix lc jb ld jf le jj kw kx ky kz bi translated">如何实施？</li><li id="f72b" class="kp kq hi io b ip la it lb ix lc jb ld jf le jj kw kx ky kz bi translated">例子—</li></ul><ol class=""><li id="3863" class="kp kq hi io b ip iq it iu ix lf jb lg jf lh jj li kx ky kz bi translated">精确名称映射(基本)</li><li id="7073" class="kp kq hi io b ip la it lb ix lc jb ld jf le jj li kx ky kz bi translated">不同的名称映射</li><li id="54cb" class="kp kq hi io b ip la it lb ix lc jb ld jf le jj li kx ky kz bi translated">自定义对象映射</li><li id="be0b" class="kp kq hi io b ip la it lb ix lc jb ld jf le jj li kx ky kz bi translated">映射的自定义方法</li><li id="f503" class="kp kq hi io b ip la it lb ix lc jb ld jf le jj li kx ky kz bi translated">集合映射</li><li id="0e69" class="kp kq hi io b ip la it lb ix lc jb ld jf le jj li kx ky kz bi translated">附加对象映射</li><li id="c4f2" class="kp kq hi io b ip la it lb ix lc jb ld jf le jj li kx ky kz bi translated">@BeforeMapping和@AfterMapping批注</li></ol></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h2 id="1414" class="lq js hi bd jt lr ls lt jx lu lv lw kb ix lx ly kf jb lz ma kj jf mb mc kn md bi translated">那么让我们开始吧。</h2><h1 id="c5cd" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">为什么是MapStruct？</h1><p id="1a3a" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">多层应用程序通常需要不同对象模型(例如实体和dto)之间的映射。编写这样的映射代码是一项乏味且容易出错的任务。MapStruct旨在通过尽可能自动化来简化这项工作。</p><p id="b510" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与其他映射框架相比，MapStruct在编译时生成bean映射，这确保了高性能，允许快速的开发人员反馈和彻底的错误检查。</p><h1 id="0598" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">如何实施？</h1><p id="30b3" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">MapStruct是一个注释处理器，它被插入到Java编译器中，可以在命令行构建中使用(Maven、Gradle等)。)以及您首选的IDE中。</p><p id="72ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您需要在编译器插件中添加下面的依赖项和注释标签</p><h2 id="f5ba" class="lq js hi bd jt lr ls lt jx lu lv lw kb ix lx ly kf jb lz ma kj jf mb mc kn md bi translated">pom.xml</h2><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="a2a8" class="lq js hi mm b fi mq mr l ms mt">&lt;properties&gt;<br/> &lt;org.mapstruct.version&gt;1.4.2.Final&lt;/org.mapstruct.version&gt;<br/>&lt;/properties&gt;</span><span id="619b" class="lq js hi mm b fi mu mr l ms mt">&lt;dependency&gt;<br/>   &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;<br/>   &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;<br/>   &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span><span id="3ce5" class="lq js hi mm b fi mu mr l ms mt">&lt;plugin&gt;<br/> &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br/> &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br/> &lt;version&gt;3.8.1&lt;/version&gt;<br/> &lt;configuration&gt;<br/>  &lt;source&gt;1.8&lt;/source&gt; &lt;!-- depending on your project --&gt;<br/>  &lt;target&gt;1.8&lt;/target&gt; &lt;!-- depending on your project --&gt;<br/>  <strong class="mm hj">&lt;annotationProcessorPaths&gt;<br/>   &lt;path&gt;<br/>    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;<br/>    &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;<br/>    &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;<br/>   &lt;/path&gt;<br/>  &lt;/annotationProcessorPaths&gt;</strong><br/> &lt;/configuration&gt;<br/>&lt;/plugin&gt;</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="74cf" class="jr js hi bd jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko bi translated">1.精确名称映射(基本)</h1><p id="094b" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">这里我们的任务是从模型层检索<strong class="io hj">电路</strong>对象，并通过创建<strong class="io hj">电路到</strong>类将其传递给持久层。所以我们将简单的<strong class="io hj">电路</strong>类映射到<strong class="io hj">电路到</strong>类。</p><p id="d406" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">Circuit.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="3e49" class="lq js hi mm b fi mq mr l ms mt">@Data<br/>public class Circuit{<br/> private int id;<br/> private String name;<br/>}</span></pre><p id="a64e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">CircuitDto.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="7ea9" class="lq js hi mm b fi mq mr l ms mt">@Data<br/>public class CircuitDto {<br/> private int id;<br/> private String name;<br/>}</span></pre><p id="61f5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为此，我们将创建一个映射器接口。</p><p id="3c95" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">CircuitMapper.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="54b6" class="lq js hi mm b fi mq mr l ms mt">@Mapper(componentModel = "spring")<br/>public interface CircuitMapper {<br/> CircuitDto toDto(Circuit circuit);<br/>}</span></pre><p id="50a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">@Mapper <em class="jn"> → MapStruct的注释创建并生成映射实现</em></p><p id="998f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jn"> componentModel = "spring" →在spring项目中生成bean，这样我们可以很容易地将这个bean注释为autowire。</em></p><p id="1e7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为两个类有相同的属性名，我们不需要为它写任何显式的映射。Mapstruct将包括这两个字段的映射。</p><p id="fec8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了测试这个—</p><p id="4cc1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">CircuitMapperTest.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="4871" class="lq js hi mm b fi mq mr l ms mt">@Autowired<br/>CircuitMapper circuitMapper;<br/><br/>@Test<br/>public void testCircuitDtoMapping(){<br/>    Circuit circuit = new Circuit(123, "transportBearer123");<br/>    CircuitDto circuitDto = circuitMapper.toDto(circuit);<br/>    assertEquals(circuit.getId(), circuitDto.getId());<br/>    assertEquals(circuit.getName(), circuitDto.getName());<br/>}</span></pre><h1 id="f795" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak"> 2。不同的名称映射</strong></h1><p id="117b" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">现在让我们在两个beans中都包含不同的名称。</p><p id="b6ad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">Circuit.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="2df7" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class Circuit{<br/> private int id;<br/> private String name;<br/> private long circuitTypeId;<br/>}</span></pre><p id="fe7b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">CircuitDto.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="ab24" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class CircuitDto {<br/> private int id;<br/> private String name;<br/> private long circuit2circuitType;<br/>}</span></pre><p id="9981" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，映射器将无法自动映射它。为了实现这一点，我们只需简单地提到如下的映射。</p><p id="3014" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">CircuitMapper.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="100f" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Mapper" rel="noopener ugc nofollow" target="_blank">@Mapper</a>(componentModel = "spring")<br/>public interface CircuitMapper {<br/> <a class="ae na" href="http://twitter.com/Mapping" rel="noopener ugc nofollow" target="_blank">@Mapping</a>(source = "circuitTypeId", target = "circuit2circuitType")<br/> CircuitDto toDto(Circuit circuit);<br/>}</span></pre><h1 id="2a50" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">3.自定义对象映射</h1><p id="7c06" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">让我们继续上面的例子，Circuit有它自己的子对象(Port ),我们需要映射它。</p><p id="9ea2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">源类</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="9ef3" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class Circuit{<br/> private int id;<br/> private String name;<br/> private long circuitTypeId;<br/> private Port port;<br/>}</span><span id="8e00" class="lq js hi mm b fi mu mr l ms mt">public class Port{<br/> private int id;<br/> private String name;<br/>}</span></pre><p id="eeec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">目标班级</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="b92f" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class CircuitDto {<br/> private int id;<br/> private String name;<br/> private long circuit2circuitType;<br/> private PortDto portDto;<br/>}</span><span id="6153" class="lq js hi mm b fi mu mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class PortDto{<br/> private int id;<br/> private String name;<br/>}</span></pre><p id="7323" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要进行子类映射，我们必须创建一个单独的映射器，如Circuit，然后像uses = {PortMapper.class}一样导入它。</p><p id="7c7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">映射器接口</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="3f7b" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Mapper" rel="noopener ugc nofollow" target="_blank">@Mapper</a>(componentModel = "spring")<br/>public interface PortMapper {<br/> PortDto toDto(Port port);<br/>}</span><span id="3306" class="lq js hi mm b fi mu mr l ms mt"><a class="ae na" href="http://twitter.com/Mapper" rel="noopener ugc nofollow" target="_blank">@Mapper</a>(componentModel = "spring",<br/>  uses = {PortMapper.class})<br/>public interface CircuitMapper {</span><span id="0758" class="lq js hi mm b fi mu mr l ms mt"><a class="ae na" href="http://twitter.com/Mapping" rel="noopener ugc nofollow" target="_blank">@Mapping</a>(source = "circuitTypeId", target = "circuit2circuitType")<br/> CircuitDto toDto(Circuit circuit);<br/>}</span></pre><h1 id="1d3e" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">4.映射的自定义方法</h1><p id="0708" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">如果对于某个属性，我们需要自定义逻辑来映射值。我们还可以编写一个自定义的映射方法。</p><p id="836c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，在源Circuit类中，我们有一个子电路列表，而在目标CircuitDto类中，我们只需要一个子电路计数。</p><p id="9996" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">Circuit.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="3ae8" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class Circuit{<br/> private int id;<br/> private String name;<br/> private List&lt;Circuit&gt; childCircuits;<br/>}</span></pre><p id="c42a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">CircuitDto.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="ef31" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class CircuitDto {<br/> private int id;<br/> private String name;<br/> private int noOfChildCirtcuits;<br/>}</span></pre><p id="707d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们必须编写我们的自定义方法来计算子电路的大小。因此，我们可以用@named Autowire编写我们的自定义方法。这可以由映射字段中的<em class="jn"> qualifiedByName </em>提供。</p><p id="fa09" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">CircuitMapper.java</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="6f96" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Mapper" rel="noopener ugc nofollow" target="_blank">@Mapper</a>(componentModel = "spring")<br/>public interface CircuitMapper {</span><span id="4e82" class="lq js hi mm b fi mu mr l ms mt"><a class="ae na" href="http://twitter.com/Mapping" rel="noopener ugc nofollow" target="_blank">@Mapping</a>(<br/>         source = "childCircuits", <br/>         target = "noOfChildCirtcuits", <br/>         qualifiedByName = "countChildCircuits")<br/> CircuitDto toDto(Circuit circuit);<br/> <br/> <br/>  <a class="ae na" href="http://twitter.com/Named" rel="noopener ugc nofollow" target="_blank">@Named</a>("countChildCircuits")<br/>   default int getChildCircuits(List&lt;Circuit&gt; childCircuits) {<br/>      if(childCircuits == null) {<br/>         return 0;<br/>      }<br/>      return childCircuits.size();<br/>   }<br/>   <br/>}</span></pre><h1 id="aac8" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">5.集合映射</h1><p id="6a1d" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">假设我们有一个这样的属性集合，我们只是想将它映射到目标类中。例如，我们在电路类的源中有一个端口列表，我们希望将它映射到目标类中的PortDto列表。</p><p id="0c4e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">源类</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="31e8" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class Circuit{<br/> private int id;<br/> private String name;<br/> private long circuitTypeId;<br/> private List&lt;Port&gt; port;<br/>}</span><span id="0756" class="lq js hi mm b fi mu mr l ms mt">public class Port{<br/> private int id;<br/> private String name;<br/>}</span></pre><p id="6af0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">目标类别</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="4944" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class CircuitDto {<br/> private int id;<br/> private String name;<br/> private long circuit2circuitType;<br/> private List&lt;PortDto&gt; portDto;<br/>}</span><span id="fc71" class="lq js hi mm b fi mu mr l ms mt"><a class="ae na" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class PortDto{<br/> private int id;<br/> private String name;<br/>}</span></pre><p id="4b27" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要进行此列表映射，我们可以简单地在PortMapper.class中定义此列表映射，如下所示。</p><p id="88ea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">映射器接口</strong></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="4630" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Mapper" rel="noopener ugc nofollow" target="_blank">@Mapper</a>(componentModel = "spring")<br/>public interface PortMapper {<br/> PortDto toDto(Port port);<br/> <br/>  List&lt;PortDto&gt; toPortDtoList(List&lt;Port&gt; ports);<br/>}</span><span id="1919" class="lq js hi mm b fi mu mr l ms mt"><a class="ae na" href="http://twitter.com/Mapper" rel="noopener ugc nofollow" target="_blank">@Mapper</a>(componentModel = "spring",<br/>  uses = {PortMapper.class})<br/>public interface CircuitMapper {</span><span id="bab7" class="lq js hi mm b fi mu mr l ms mt"><a class="ae na" href="http://twitter.com/Mapping" rel="noopener ugc nofollow" target="_blank">@Mapping</a>(source = "circuitTypeId", target = "circuit2circuitType")<br/> CircuitDto toDto(Circuit circuit);<br/>}</span></pre><h1 id="441a" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">6.附加对象映射</h1><p id="57fe" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">为了迎合这种特殊处理，MapStruct还在映射字段中提供了一些特殊的属性。</p><p id="c040" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，我们希望在目标类中映射固定值。像在目标CircuitDto类中一样，我们希望映射具有固定值“Circuit”的字段类型。</p><p id="dd0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以像下面这样直接映射它。</p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="8e79" class="lq js hi mm b fi mq mr l ms mt">@Mapping(target = "type", constant = "Circuit")</span></pre><p id="4b07" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">更多的特殊属性，可以去查阅MapStrcut的官方文档。</p><p id="e8ae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">7。@BeforeMapping和@AfterMapping注释</p><p id="9077" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有两个非常重要的注释非常有助于在开头或结尾迎合特殊要求。</p><p id="4dc5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">@BeforeMapping —在我们开始映射之前，如果我们想要添加一些验证或属性/集合创建。</p><p id="e87d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">@AfterMapping —在映射之后，如果我们想对目标类做最后的修改，我们可以把它作为这个方法的一部分来做。</p><p id="3381" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，在下面的代码片段中，我们已经在@BeforeMapping中初始化了列表<circuits>,并且基于子电路的计数，我们已经在@AfterMapping中设置了isChildCircuitAvailable布尔标志</circuits></p><pre class="mh mi mj mk fd ml mm mn mo aw mp bi"><span id="b7f0" class="lq js hi mm b fi mq mr l ms mt"><a class="ae na" href="http://twitter.com/Mapper" rel="noopener ugc nofollow" target="_blank">@Mapper</a>(componentModel = "spring",<br/>  uses = {PortMapper.class})<br/>public interface CircuitMapper {</span><span id="8521" class="lq js hi mm b fi mu mr l ms mt"><a class="ae na" href="http://twitter.com/BeforeMapping" rel="noopener ugc nofollow" target="_blank">@BeforeMapping</a><br/>    default void setChildCircuitList(Circuit circuit) {<br/>  if(circuit.getChildCircuits == null){<br/>   circuit.setChildCircuits( new ArrayList&lt;Circuit&gt;());<br/>  }<br/> }</span><span id="9141" class="lq js hi mm b fi mu mr l ms mt"><a class="ae na" href="http://twitter.com/Mapping" rel="noopener ugc nofollow" target="_blank">@Mapping</a>(source = "circuitTypeId", target = "circuit2circuitType")<br/> CircuitDto toDto(Circuit circuit);<br/> <br/> <a class="ae na" href="http://twitter.com/AfterMapping" rel="noopener ugc nofollow" target="_blank">@AfterMapping</a><br/> default void setisChildCircuitsAvailable(CircuitDto circuitDto) {<br/>  if(circuitDto.getNoOfChildCirtcuits &gt;0){<br/>   circuitDto.isChildCircuitsAvailable(true);<br/>  }<br/> } <br/>}</span></pre><h1 id="8d61" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结论</h1><p id="d655" class="pw-post-body-paragraph im in hi io b ip kr ir is it ks iv iw ix me iz ja jb mf jd je jf mg jh ji jj hb bi translated">本文描述了如何利用Mapstruct库以一种安全而优雅的方式显著减少我们的样板代码。</p><p id="20e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如在例子中看到的，Mapstruct提供了大量的功能和配置，允许我们以一种简单快速的方式创建从基本到复杂的映射器。</p><p id="ad43" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要了解更多关于MapStruct的信息，你可以点击下面的链接。</p><p id="4085" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢阅读。享受…！！！😊😊</p><blockquote class="jk jl jm"><p id="e31a" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">官网—<a class="ae na" href="https://mapstruct.org/" rel="noopener ugc nofollow" target="_blank">https://mapstruct.org/</a></p><p id="a969" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">安装指南—【https://mapstruct.org/documentation/installation/ T2】</p><p id="16e1" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">参考指南—【https://mapstruct.org/documentation/reference-guide/ T4】</p><p id="03be" class="im in jn io b ip iq ir is it iu iv iw jo iy iz ja jp jc jd je jq jg jh ji jj hb bi translated">例子—<a class="ae na" href="https://github.com/mapstruct/mapstruct-examples" rel="noopener ugc nofollow" target="_blank">https://github.com/mapstruct/mapstruct-examples</a></p></blockquote></div></div>    
</body>
</html>