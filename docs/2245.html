<html>
<head>
<title>Sieve of Eratosthenes in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">爪哇厄拉多塞筛</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/sieve-of-eratosthenes-in-java-3556dcea37e2?source=collection_archive---------0-----------------------#2022-07-13">https://medium.com/javarevisited/sieve-of-eratosthenes-in-java-3556dcea37e2?source=collection_archive---------0-----------------------#2022-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/05/sieve-of-Eratosthenes-algorithm-to-generate-prime-numbers-in-java.html"><div class="er es hg"><img src="../Images/1df9eabbf52d60660fdbc4af5e950275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f82-3jUNWsc3ylPIqokFhQ.png"/></div></a><p class="hn ho et er es hp hq bd b be z dx translated">爪哇厄拉多塞筛</p></figure><div class=""/><p id="5b2f" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们熟悉素数的特征，并在我们的学术生涯中使用过。一个<a class="ae jp" href="https://www.youtube.com/watch?v=BHPrHvDooL4" rel="noopener ugc nofollow" target="_blank">质数</a>是一个只能被一整除或者只能被自身整除的质数。现在，假设我们需要汇编一个1到任意给定n之间的所有素数的列表。</p><p id="8412" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">下一步是确定<a class="ae jp" href="http://www.java67.com/2014/01/how-to-check-if-given-number-is-prime.html" rel="noopener ugc nofollow" target="_blank">每个数字是否是质数</a>。如果我们被要求为同样的事情编写一个计算机程序，那么对每个数字遵循同样的程序将是低效的。</p><p id="9da0" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">事实上，筛选算法就是答案。没错，解决方案就是筛子算法。那么在这篇文章中，我们将了解什么是厄拉多塞之筛？它是如何工作的？以及如何在Java中实现厄拉多塞的<a class="ae jp" href="https://www.interviewbit.com/blog/sieve-of-eratosthenes/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hu">筛子</strong> </a>。</p><h1 id="25f4" class="jq jr ht bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">厄拉多塞的筛子是什么？</strong></h1><p id="76f0" class="pw-post-body-paragraph ir is ht it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hb bi translated">厄拉多塞的筛子是一个用来寻找质数的简单筛子。它是由希腊数学家厄拉多塞在公元前2世纪发明的。筛子是一个简单的筛子，它确定一个数是否是质数。筛子的工作原理是将数字除以2，并将结果与素数表进行比较。如果数字是质数<a class="ae jp" href="http://javarevisited.blogspot.sg/2012/04/java-program-to-print-prime-numbers-in.html#axzz5E2uHdG3w" rel="noopener ugc nofollow" target="_blank"/>，它将被添加到质数表中。如果它不是质数，它就被丢弃。使用表格，这有助于消除任何数n之间的所有非质数。这有助于降低计算机程序的时间复杂性，并广泛用于密码学。让我们借助问题陈述来理解它的工作原理。</p><p id="1ed0" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">问题陈述:</strong>要求你打印所有小于等于给定数n的质数。</p><p id="b41b" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">根据上面的问题陈述，可以获得的打印质数的第一个解决方案是—从1到n迭代。检查每个数字，如果是质数，则打印。否则，转到下一个号码，再次执行相同的步骤。</p><p id="e724" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">例:</strong>求1到10之间的质数。</p><p id="bd2c" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">解决方案:</strong>考虑下图进行解释。</p><figure class="ku kv kw kx fd hk er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/07/top-50-java-programs-from-coding-Interviews.html"><div class="er es kt"><img src="../Images/e873133c517dc0aad64e48b8071e598b.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*ymXW82LRuIP_ffa_u55jbQ.png"/></div></a></figure><p id="211a" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在上图中，我们可以看到，对于每个数字，我们需要检查它是否是一个质数，然后将它打印出来。否则跳过。现在的问题是，我们如何确定<a class="ae jp" href="https://www.java67.com/2018/06/data-structure-and-algorithm-interview-questions-programmers.html" rel="noopener ugc nofollow" target="_blank">是否是质数？</a>我们需要从每个数字遍历到1，并检查它是否能被任何数字整除。如果是，那么它不是质数，否则，它是质数。所以这个方法的算法是-</p><p id="49c2" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">算法- </strong></p><ol class=""><li id="8544" class="ky kz ht it b iu iv iy iz jc la jg lb jk lc jo ld le lf lg bi translated">开始吧。</li><li id="e3cc" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">从1到n重复数字<strong class="it hu">‘I’</strong></li><li id="acd0" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">从<strong class="it hu">‘I-1’</strong>到2迭代<strong class="it hu">‘j’</strong>。</li><li id="9c21" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">如果<strong class="it hu">‘I’</strong>能被<strong class="it hu">‘j’</strong>整除，则终止迭代。</li><li id="a095" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">如果<strong class="it hu">‘I’</strong>不能被<strong class="it hu">‘j’</strong>整除，则继续下一次迭代。</li><li id="c11e" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">如果内部迭代没有找到任何可以被<strong class="it hu">‘I’</strong>整除的数，那么打印这个数。因为它是质数。</li><li id="bffa" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">否则，继续迭代。</li><li id="87b0" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">停下来。</li></ol><h2 id="fd1f" class="lm jr ht bd js ln lo lp jw lq lr ls ka jc lt lu ke jg lv lw ki jk lx ly km lz bi translated"><strong class="ak"> Java程序进行如下处理</strong></h2><figure class="ku kv kw kx fd hk"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="19d6" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">输入:</strong>十</p><p id="ecb5" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">输出:</strong> 1 2 3 5 7</p><p id="cd2b" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">解释:</strong>外部循环遍历从1到输入数n的每个元素。然后内部循环从当前数-1运行到1，检查当前数可以除其下的任何数。如果可以，则不打印。所以它通过标记变量来终止循环。当内部循环终止时，检查变量是否被修改。如果没有修改，那么这意味着它是质数。所以把那个数字打印出来。并继续下一次迭代。</p><p id="d63c" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">上述算法分析:</strong>对于从1到n的每一个数，我们需要运行一个从元素到1的循环。所以渐近方程会是— [n * (n-1) / 2]。也就是<strong class="it hu"> O(n2) </strong>。并且不需要额外的空间，所以空间复杂度将是常数。</p><p id="d806" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们可以看到<a class="ae jp" rel="noopener" href="/javarevisited/10-data-structure-algorithms-and-programming-courses-to-crack-any-coding-interview-e1c50b30b927">算法</a>花费了大量的时间来打印元素。因此，我们可以避免对每个第I个元素从它本身到它的一半进行不必要的检查。因为没有一个数能被整除。</p><p id="d492" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">举个例子:</strong>对于数字25检查它是否是质数，从12到25没有任何数字可以除尽。因此，我们可以通过从(<strong class="it hu"> i/2 </strong>到<strong class="it hu"> 1) </strong>遍历内部循环来避免这种情况。这节省了一些计算时间。但是渐近时间是一样的。所以这个算法也可以不被认为是最好的。</p><p id="6c35" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以这就是Sieve算法帮助高效找到素数的地方。</p><p id="9d15" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">厄拉多塞算法的<a class="ae jp" href="https://javarevisited.blogspot.com/2015/05/sieve-of-Eratosthenes-algorithm-to-generate-prime-numbers-in-java.html" rel="noopener ugc nofollow" target="_blank">筛子通过管理一个表并消除所有非素数的元素来解决这个问题。</a></p><p id="ac72" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">sieve算法的思想是创建一个从1到n的表，并开始迭代它。并将特定元素的所有倍数标记为假，因为它不可能是质数。这个迭代一直持续到数字n。</p><p id="9b21" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们借助一个例子来清楚地理解这一点——考虑从1到30的数字。我们需要打印这些之间的质数。</p><ul class=""><li id="0f18" class="ky kz ht it b iu iv iy iz jc la jg lb jk lc jo mc le lf lg bi translated">筛选算法的第一步是——创建一个从1到30的表格。</li></ul><figure class="ku kv kw kx fd hk er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/06/top-programming-interview-questions.html"><div class="er es md"><img src="../Images/a3fef68aed4601d46cade75cd989b334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*VXzuFw52WZwt8547li9R6Q.png"/></div></a></figure><ul class=""><li id="712b" class="ky kz ht it b iu iv iy iz jc la jg lb jk lc jo mc le lf lg bi translated">然后下一步是从2到n遍历未标记的数字表，对于每个元素，取消其倍数的标记。</li></ul><p id="2c1c" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">下一个</strong> <strong class="it hu">无标记数字2 - </strong></p><figure class="ku kv kw kx fd hk er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/07/top-5-websites-to-learn-coding-in-java.html"><div class="er es me"><img src="../Images/bd6c80a475effc0a0e144716cb7ffba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*M3oG8HQRItk6nPW_d0My8Q.png"/></div></a></figure><p id="dd22" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">下一个</strong> <strong class="it hu">未标记的数字3 - </strong></p><figure class="ku kv kw kx fd hk er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/03/top-dynamic-programming-problems-for-coding-interviews.html"><div class="er es md"><img src="../Images/6d237162746db4b0057e0bf12f9bb459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*vnjuJQWFjdAjErQMBBjgSw.png"/></div></a></figure><p id="2a4e" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">下一个未标记的数字5 - </strong></p><figure class="ku kv kw kx fd hk er es paragraph-image"><a href="https://www.java67.com/2018/05/top-75-programming-interview-questions-answers.html"><div class="er es mf"><img src="../Images/a2e67b265707f2d7664f9b9080abb6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*8_qIjheY3PHxE_APj-loQg.png"/></div></a></figure><p id="8f6f" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">下一个未标记的数字是</strong> 7 11 13 17 …全部执行后，表格将-</p><figure class="ku kv kw kx fd hk er es paragraph-image"><a href="https://www.java67.com/2013/01/10-programming-questions-and-exercises.html"><div class="er es mg"><img src="../Images/afb284008def7822ad48c8b61ca26227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*Df0Qf06zHnJPx6r9PquOTw.png"/></div></a></figure><p id="0704" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以表中剩余的元素将是质数。这些是在寻找质数的筛选算法中要遵循的步骤。</p><p id="4167" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">所以厄拉多塞算法的筛子是——</strong></p><ol class=""><li id="e91a" class="ky kz ht it b iu iv iy iz jc la jg lb jk lc jo ld le lf lg bi translated">开始吧。</li><li id="3df0" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">创建一个长度为n+1的布尔数组。</li><li id="759a" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">从2到n开始循环。</li><li id="d0ad" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">如果元素被标记，则从当前元素的下一个倍数到n开始一个循环，并取消所有当前数的倍数的标记。</li><li id="fc3c" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">否则，继续下一次迭代。</li><li id="8a4f" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">打印所有仍然被标记的数字，因为它们是质数。</li><li id="3b1c" class="ky kz ht it b iu lh iy li jc lj jg lk jk ll jo ld le lf lg bi translated">停下来。</li></ol><h2 id="12af" class="lm jr ht bd js ln lo lp jw lq lr ls ka jc lt lu ke jg lv lw ki jk lx ly km lz bi translated"><strong class="ak">厄拉多塞筛子的Java程序- </strong></h2><figure class="ku kv kw kx fd hk"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="295a" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">输入:</strong> 100</p><p id="a293" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">产量:2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97</p><p id="0a28" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">解释:</strong>我们遵循的是我们在算法中定义的东西。我们创建了一个由布尔值<a class="ae jp" href="https://www.java67.com/2018/03/java-convert-string-to-boolean.html" rel="noopener ugc nofollow" target="_blank">和</a>组成的表格，然后对所有的值进行了初始标记。然后我们开始一个循环，检查表中的当前值是否仍然被标记。如果这个数仍然被标记，那么它将是一个质数。所以把它打印出来，去掉它的所有倍数。</p><p id="1bdc" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hu">算法分析— </strong>先来了解一下外循环中每个数字的步骤，以及嵌套循环执行了多少次。</p><p id="c2e9" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">最初，当i == 2时，内部循环发现它被标记，所以它将执行内部循环n/2次。那么对于i == 3，就是n/3次。对于i == 5，就是n/5次，以此类推。所以如果我们试图用泰勒级数来证明这一点——[n++⅓+⅕+…]。那么我们得到的时间复杂度是<strong class="it hu"> O(log (log n))。这对于n个不同的值执行。所以总的时间复杂度将是<strong class="it hu"> O( n * log(log n))。</strong></strong></p><p id="6939" class="pw-post-body-paragraph ir is ht it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们必须维护非质数的非标表格<strong class="it hu">。</strong>表格可以包含n个空格。所以空间复杂度会是<strong class="it hu"> O(n) </strong>。</p><h1 id="fcef" class="jq jr ht bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">结论</strong></h1><p id="b9cd" class="pw-post-body-paragraph ir is ht it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hb bi translated">厄拉多塞的筛子是帮助获得从1到n的最优质数的技术。它使用列表法来找到它。希腊数学家和科学家厄拉多塞在大约2300年前创造了它。在这篇博客中，我们已经了解了常规问题的基本方面，以及sieve算法如何通过java实现来优化解决这个问题。</p><div class="hh hi ez fb hj mh"><a rel="noopener follow" target="_blank" href="/javarevisited/two-sum-coding-problem-how-to-find-all-pairs-which-adds-to-a-given-sum-in-an-array-in-java-a396be0f308d"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hu fi z dy mm ea eb mn ed ef hs bi translated">如何在Java中找到一个数组中所有和与给定数字相加的对</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">大家好，如果你一直在解决数据结构和算法问题，或者已经完成了几个编码…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">medium.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv hl mh"/></div></div></a></div><div class="hh hi ez fb hj mh"><a rel="noopener follow" target="_blank" href="/javarevisited/20-array-coding-problems-and-questions-from-programming-interviews-869b475b9121"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hu fi z dy mm ea eb mn ed ef hs bi translated">20多个数组编码问题和来自编程访谈的问题</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">大家好，数组是最基本的数据结构，它将元素存储在连续的内存位置。它…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">medium.com</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv hl mh"/></div></div></a></div><div class="hh hi ez fb hj mh"><a rel="noopener follow" target="_blank" href="/javarevisited/20-binary-tree-algorithms-problems-from-coding-interviews-c5e5a384df30"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hu fi z dy mm ea eb mn ed ef hs bi translated">来自编程访谈的20多个二叉树编码问题</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">大家好，我已经分享了很多关于编程面试的资源，比如书籍、课程和一些…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">medium.com</p></div></div><div class="mq l"><div class="mx l ms mt mu mq mv hl mh"/></div></div></a></div></div></div>    
</body>
</html>