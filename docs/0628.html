<html>
<head>
<title>How to Solve Super Egg Drop Problem with Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用动态规划解决超级落蛋问题</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/super-egg-drop-problem-ac42a4b4b09a?source=collection_archive---------1-----------------------#2020-08-06">https://medium.com/javarevisited/super-egg-drop-problem-ac42a4b4b09a?source=collection_archive---------1-----------------------#2020-08-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="9dc3" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">找出鸡蛋掉落的最少次数，从而知道鸡蛋不会从建筑物的哪一层打破。</p></blockquote><h1 id="0ded" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">问题描述</h1><figure class="kg kh ki kj fd kk er es paragraph-image"><a href="https://medium.com/javarevisited/20-array-coding-problems-and-questions-from-programming-interviews-869b475b9121"><div class="er es kf"><img src="../Images/cbfdcae371b7841674830bf8535347de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*n10o4GdNHxmqNIxMZybD9w.png"/></div></a><p class="kn ko et er es kp kq bd b be z dx translated">由<a class="ae kr" href="https://www.flaticon.com/authors/freepik" rel="noopener ugc nofollow" target="_blank"> FreePik </a></p></figure><p id="70d3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">有<strong class="il hj"> E蛋(=允许蛋碎)</strong>，一栋有<strong class="il hj"> F </strong> <strong class="il hj">楼层</strong>[<strong class="il hj">1≥F】</strong><strong class="il hj"/>特殊楼层<strong class="il hj">S</strong>[<strong class="il hj">0≤S≤F】-</strong>任何掉在高于S <strong class="il hj"> </strong>楼层的未碎蛋都会碎，掉在该楼层或该楼层以下的蛋不会碎。</p><p id="c42b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">给定一个未打破的鸡蛋可以从任何楼层掉下，为了在最坏的情况下找到S <strong class="il hj"> </strong>，需要<strong class="il hj">的<strong class="il hj">鸡蛋掉D[1≤D≤F】</strong>的最少次数是多少？</strong></p><p id="5997" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">输入1: E =1，F=1 |输出1: D=1 <br/>输入2: E =1，F=2 |输出2: D=2 <br/>输入3: E =1，F=7 |输出3: D=7 <br/>输入4: E =2，F=7 |输出4: D=4 <br/>输入5: E =3，F=7 |输出5: D=3</p><h2 id="2fd8" class="kv ji hi bd jj kw kx ky jn kz la lb jr ks lc ld jv kt le lf jz ku lg lh kd li bi translated">常见混淆点:</h2><ul class=""><li id="b26f" class="lj lk hi il b im ll iq lm ks ln kt lo ku lp jg lq lr ls lt bi translated">什么是“最坏的情况”？这意味着只有当从上到下的搜索范围用尽时，鸡蛋才会打破。</li><li id="b6c7" class="lj lk hi il b im lu iq lv ks lw kt lx ku ly jg lq lr ls lt bi translated">特殊地板范围内的“地板0”是多少？把它当成一个不允许掉蛋但可以借鉴的地下室。例如:S=0如果鸡蛋在1楼打破，这意味着任何高于0楼的跌落都会导致打破。</li></ul><h1 id="2a4a" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">🍳解决方法</h1><h2 id="d949" class="kv ji hi bd jj kw kx ky jn kz la lb jr ks lc ld jv kt le lf jz ku lg lh kd li bi translated">线性搜索</h2><p id="dbdd" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it ks lz iw ix kt ma ja jb ku mb je jf jg hb bi translated">拿一个鸡蛋到第一层，开始一层一层往下扔，直到它破了或者我们超过了顶层。最坏的情况是遍历所有楼层[O(F)]来求S=F。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><a href="https://hackernoon.com/10-data-structure-algorithms-books-every-programmer-should-read-d50487313127"><div class="er es mc"><img src="../Images/e8f78df74514bd220f0d55720d2f5a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfFj4OjmjpziC6DFhd4kAA.png"/></div></a><p class="kn ko et er es kp kq bd b be z dx translated">建筑物中的线性搜索</p></figure><p id="0a3e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">不幸的是，这种算法将不起作用，因为我们必须找到找到S所需的最小<strong class="il hj">蛋滴数</strong>，这在几种情况下将小于S。</p><h2 id="372f" class="kv ji hi bd jj kw kx ky jn kz la lb jr ks lc ld jv kt le lf jz ku lg lh kd li bi translated"><strong class="ak">改良的二分搜索法</strong></h2><p id="da0b" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it ks lz iw ix kt ma ja jb ku mb je jf jg hb bi translated">一只典型的二分搜索法会给我们带来蛋液。这里我们将在一个范围内(从底层到顶层)从中层反复做一次鸡蛋掉落，检查是否打碎。在下图中，您可以看到第一次迭代中建筑物的底部=1，顶部=7，中部=4。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><a href="https://medium.com/javarevisited/top-10-free-data-structure-and-algorithms-courses-for-beginners-best-of-lot-ad807cc55f7a?source=collection_home---4------0-----------------------"><div class="er es mh"><img src="../Images/611bca0d4a8e4f13194b3586f62dae29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsELkfNPZ_zt4XNmVfrjYA.png"/></div></a><p class="kn ko et er es kp kq bd b be z dx translated">建筑中的二分搜索法</p></figure><p id="ed84" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">如果鸡蛋在第4层打破，那么这一层在S层之上，因为鸡蛋会在S层之上的所有层打破，所以底部保持为1，而顶部变为中间-1=4 -1=3。如果鸡蛋没有在第4层打破，那么这一层就在S层以下，因为鸡蛋不会在S层以下的任何一层打破。所以顶部保持为7，而底部变为中间+1=4 +1=5。范围改变后，我们不断重复这一过程，直到找到S。最坏的情况是通过Log2(F)层，找到S=F或S=0。</p><p id="693c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">这在一个有<strong class="il hj">无限鸡蛋(=鸡蛋打破)</strong>的世界中非常有效，但在有鸡蛋打破限制的情况下效率会低得多。在上面的场景中，如果第一个鸡蛋从第四层打破，然后第二个鸡蛋也从第二层打破，会怎么样？因为没有剩余的鸡蛋来继续算法，所以不可能找到S=1还是S=0。为了实现这一点，我们可以将第二个鸡蛋带到底部(第一层)并进行线性搜索，而不是将第二个鸡蛋放在第二层，每次向上一层。</p><p id="eefb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">即使做了这样的修改，想象一个有1000层和2个鸡蛋的情况，我们最终将通过500层，在这种情况下是F/2 ~ O(F)。我们能做得更好吗？</p><h2 id="f02e" class="kv ji hi bd jj kw kx ky jn kz la lb jr ks lc ld jv kt le lf jz ku lg lh kd li bi translated">O(ExF)复杂性</h2><p id="1e97" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it ks lz iw ix kt ma ja jb ku mb je jf jg hb bi translated"><strong class="il hj">两个鸡蛋打破</strong></p><p id="e037" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">现在让我们再来看看F层有2个鸡蛋限制的问题，以及修改过的<a class="ae kr" rel="noopener" href="/javarevisited/binary-search-in-java-algorithm-eca288cb9bc2?source=extreme_sidebar----d3a191ac6ed-----0-1----------------------">二分搜索法算法</a>，我们学会了理解算法的基本主题。</p><p id="c059" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">假设我们已经知道需要执行<strong class="il hj"> X </strong>落蛋来找到s，给定这些约束，第一个蛋必须落在楼层X <strong class="il hj">(直接跳到X)</strong>。这是必要的，以保持最后的蛋滴数等于X。</p><p id="0341" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">当第一个鸡蛋打破时，我们从第一层的第二个鸡蛋开始线性搜索。</p><pre class="kg kh ki kj fd mi mg mj mk aw ml bi"><span id="75d7" class="kv ji hi mg b fi mm mn l mo mp">X =   1 (drop at floor X with first egg) <br/>    + X-1 (drops from floor 1 to floor X-1 with second egg)</span></pre><p id="4f60" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">当第一个鸡蛋在X层没有打破的时候，我们可以向上跳X-1，然后把它掉在地板上(X+(X-1))=2X-1。如果第一个鸡蛋在第二次下落时破裂，那么我们从X+1开始线性搜索，否则我们继续向上跳。</p><pre class="kg kh ki kj fd mi mg mj mk aw ml bi"><span id="a050" class="kv ji hi mg b fi mm mn l mo mp">X =    1 (drop at floor X with first egg) <br/>     + 1 (drop at floor 2X-1 with first egg)<br/>     + X-2 (drops from floor X+1 to floor 2X-2 with second egg)</span></pre><p id="cf42" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">我们每跳一次就减少一次，直到只剩下一层楼。概括地说，对于2个鸡蛋，在最坏的情况下，跳跃的总和应该大于或等于楼层数，如下所示:</p><pre class="kg kh ki kj fd mi mg mj mk aw ml bi"><span id="14c1" class="kv ji hi mg b fi mm mn l mo mp">X + (X-1) + (X-2) + … + 2 + 1 &gt;= F</span></pre><p id="add5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated"><strong class="il hj">限制E蛋打破</strong></p><p id="480d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">在深入研究实际算法之前，让我们回顾一些事情:</p><ol class=""><li id="800e" class="lj lk hi il b im in iq ir ks mq kt mr ku ms jg mt lr ls lt bi translated">建筑物的总层数= <br/>当前楼层<br/> +当前鸡蛋破裂时探索的楼层(底部到当前-1) <br/> +当前鸡蛋未破裂时探索的楼层(当前+1到顶部)</li><li id="49ba" class="lj lk hi il b im lu iq lv ks lw kt lx ku ly jg mt lr ls lt bi translated">在蛋破裂的约束下，有可能从若干楼层发现蛋掉落，反之亦然(根据等式)。</li></ol><p id="e34a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">我们有一个二维矩阵<strong class="il hj"> floors </strong>是D x E，而<strong class="il hj"> floors[d][e] </strong>是我们可以找到S的层数，其中允许蛋掉落<strong class="il hj"> d </strong>和<strong class="il hj">T22】蛋打破<strong class="il hj"> e </strong>(基本上是蛋的数量)。</strong></p><pre class="kg kh ki kj fd mi mg mj mk aw ml bi"><span id="c128" class="kv ji hi mg b fi mm mn l mo mp">floors[d][e] =   1 (new floor against new egg drop)<br/>               + floors[d-1][e-1] <br/>                 (floors with 1 less egg drop and 1 less egg break)<br/>               + floors[d-1][e] <br/>                 (floors with 1 less egg drop)</span></pre><p id="7156" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">floors[d][e]是我们能找到的有d个鸡蛋下落和e个鸡蛋破裂的楼层数。当我们丢下一个新蛋时，如果蛋破了，那么S在当前楼层之下，否则它在当前楼层之上。总楼层数是三个值的总和:</p><ul class=""><li id="0106" class="lj lk hi il b im in iq ir ks mq kt mr ku ms jg lq lr ls lt bi translated"><strong class="il hj">当前+朝向底部的楼层数</strong> : 1 +楼层数[d-1][e-1]是我们可以从底部到达的总楼层数，假设鸡蛋在新的下落中破碎。</li><li id="e9c2" class="lj lk hi il b im lu iq lv ks lw kt lx ku ly jg lq lr ls lt bi translated"><strong class="il hj">朝向顶层的楼层数</strong>:楼层数【d-1】【e】是我们从新楼层到顶层可以到达的楼层数。</li></ul><p id="310e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated"><strong class="il hj">代号</strong></p><pre class="kg kh ki kj fd mi mg mj mk aw ml bi"><span id="671c" class="kv ji hi mg b fi mm mn l mo mp"># Language: Java<br/># Time Complexity: O(ExF) because of the nested loop.</span><span id="76c2" class="kv ji hi mg b fi mu mn l mo mp">public int superEggDrop(int E, int F) {<br/>        <br/>        int[][] floors = new int[F+1][E+1];<br/>        <br/>        for (int d=1; d&lt;=F; d++) {<br/>            for (int e=1; e&lt;=E; e++) {<br/>                <br/>                floors[d][e] = 1 <br/>                    + floors[d-1][e-1] <br/>                    + floors[d-1][e];<br/>                <br/>                if (floors[d][e] &gt;= F) {<br/>                    return d;<br/>                }<br/>            }<br/>        }<br/>        <br/>        return -1;<br/>}</span></pre><p id="8726" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">让我们详细讨论一个例子；对于D=4和E=2，楼层数为10。楼层矩阵的可视化(比代码计算的维度更多)如下:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><a href="https://medium.com/javarevisited/7-best-courses-to-learn-data-structure-and-algorithms-d5379ae2588?source=---------18------------------"><div class="er es mv"><img src="../Images/3c2133f1f72a74e422b9fc27f836a6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTkBYbGhGwaEaGcx-LT7Lw.png"/></div></a><p class="kn ko et er es kp kq bd b be z dx translated">地板矩阵7x7</p></figure><p id="6b44" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">请注意E=1列值如何用于楼层上的线性搜索，因为只允许1个鸡蛋打破，而E=2列值遵循两个鸡蛋打破部分中描述的逻辑。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><a href="https://medium.com/hackernoon/10-data-structure-algorithms-and-programming-courses-to-crack-any-coding-interview-e1c50b30b927?source=user_profile---------8-----------------------"><div class="er es mw"><img src="../Images/a770d5307fc896d463e67ed05e8e336d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*8pWzcxZ2Xo3dCZi2eJeeIQ.png"/></div></a><p class="kn ko et er es kp kq bd b be z dx translated">楼层(4、2层)</p></figure><p id="5be8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">算法步骤是:</p><p id="5df0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">第一步:在地板上扔鸡蛋=地板(3，1)+1=3+1=4。我们还剩3滴鸡蛋。如果中断，<a class="ae kr" href="https://javarevisited.blogspot.com/2020/01/how-to-implement-linear-or-sequential-search-in-java.html#axzz6VYKcmyZz" rel="noopener ugc nofollow" target="_blank">从第1层到第3层线性搜索</a>，否则转到步骤2。</p><p id="486c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">第二步:把鸡蛋扔在地板上= 4+(4–1)= 4+3 = 7。我们还剩两滴鸡蛋。如果中断，从第5层到第6层进行线性搜索，否则转到第3步。</p><p id="560d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">第三步:把鸡蛋扔在地板上= 7+(4–2)= 9。我们还剩一滴鸡蛋。如果打破了，把鸡蛋扔在第8层，否则扔在第9层。</p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="717a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">如果你觉得这篇文章有用，请帮助我接触更多的开发学习者！</p><p id="7de4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">通过“鼓掌”来展示一些❤👏在页面的左边距(在桌面上)或底部(在手机上)。通过连续点击，您可以这样做多达50次！</p><h1 id="8cbc" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">阿努姆·马利克</h1><p id="84cd" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it ks lz iw ix kt ma ja jb ku mb je jf jg hb bi translated"><a class="ae kr" href="https://www.linkedin.com/in/anumsarmadmalik/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kr" href="https://twitter.com/anumsarmadmalik" rel="noopener ugc nofollow" target="_blank">Twitter</a></p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><h2 id="4612" class="kv ji hi bd jj kw kx ky jn kz la lb jr ks lc ld jv kt le lf jz ku lg lh kd li bi translated">特别感谢…</h2><p id="75cd" class="pw-post-body-paragraph ii ij hi il b im ll io ip iq lm is it ks lz iw ix kt ma ja jb ku mb je jf jg hb bi translated">【1】<a class="ae kr" href="https://leetcode.com/problems/super-egg-drop/discuss/443089/Simplest-Python-DP-Solution-with-Detailed-Explanation-99Time-100Mem" rel="noopener ugc nofollow" target="_blank">最简单——Python DP解决方案详解</a><br/>【2】<a class="ae kr" href="https://labuladong.gitbook.io/algo-en/i.-dynamic-programming/throwingeggsinhighbuildings" rel="noopener ugc nofollow" target="_blank">经典DP超级彩蛋</a><br/>【3】<a class="ae kr" href="http://datagenetics.com/blog/july22012/index.html" rel="noopener ugc nofollow" target="_blank">两个彩蛋问题</a><br/>【4】<a class="ae kr" href="https://leetcode.com/problems/super-egg-drop/" rel="noopener ugc nofollow" target="_blank">887。超级蛋蛋滴</a></p><p id="2f8a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ks iv iw ix kt iz ja jb ku jd je jf jg hb bi translated">您可能喜欢的其他<strong class="il hj">数据结构和算法文章</strong>:</p><div class="ne nf ez fb ng nh"><a rel="noopener follow" target="_blank" href="/hackernoon/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">50+数据结构和算法程序员面试问题</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">有很多计算机科学毕业生和程序员申请编程、编码和软件…</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kl nh"/></div></div></a></div><div class="ne nf ez fb ng nh"><a rel="noopener follow" target="_blank" href="/javarevisited/top-10-data-structure-and-algorithms-courses-for-java-developers-25161ee2edc0"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">面向Java开发人员的10大数据结构和算法课程</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">这些是学习Java中数据结构和算法的最好的在线课程，包含免费和付费…</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">medium.com</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv kl nh"/></div></div></a></div><div class="ne nf ez fb ng nh"><a rel="noopener follow" target="_blank" href="/javarevisited/top-21-string-programming-interview-questions-for-beginners-and-experienced-developers-56037048de45"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">面向初学者和有经验的开发人员的21个字符串编程面试问题</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">除了数组、二叉树和链表数据结构，字符串是编程工作中的另一个热门话题…</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">medium.com</p></div></div><div class="nq l"><div class="nx l ns nt nu nq nv kl nh"/></div></div></a></div></div></div>    
</body>
</html>