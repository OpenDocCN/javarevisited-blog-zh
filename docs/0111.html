<html>
<head>
<title>(REST API using Spring Boot) Part-2 Adding Model, Service, Controller, and Dao Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(使用Spring Boot的REST API)第2部分添加模型、服务、控制器和Dao实现</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/rest-api-using-spring-boot-part-2-adding-model-service-controller-and-dao-implementation-697284b4ff38?source=collection_archive---------1-----------------------#2019-08-17">https://medium.com/javarevisited/rest-api-using-spring-boot-part-2-adding-model-service-controller-and-dao-implementation-697284b4ff38?source=collection_archive---------1-----------------------#2019-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/13c1e64a53efa4dcd608480bd471c44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0XiWYIpc3Fd8NokC4wL4Q.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">用户流量</p></figure><p id="b58b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文讨论了模型、服务、数据访问对象(DAO)和控制器的实现。在<a class="ae js" rel="noopener" href="/javarevisited/rest-api-using-spring-boot-part-1-setting-up-and-creating-basic-controller-9699330df64f?source=friends_link&amp;sk=02dbff036a521ee9adaab275711a31fa">第一部分</a>的续篇中，讨论了建立<a class="ae js" href="http://www.java67.com/2019/01/top-5-spring-boot-annotations-java-programmers-should-know.html" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>项目和编写基本控制器的步骤。</p><p id="176c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">控制器是与外界交互的接口。它处理传入的HTTP请求并将响应发送回调用者。基于传入的请求URL和HTTP动词(GET/POST/PUT/PATCH/DELETE)，API决定执行哪个控制器和动作方法，例如GET()方法将处理HTTP GET请求，POST()方法将处理HTTP POST请求，PUT()方法将处理HTTP PUT请求，DELETE()方法将处理上述Web API的HTTP DELETE请求。服务是定义应用程序业务逻辑的工具。DAO或数据访问对象用于直接与数据库交互。</p><h1 id="0069" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">添加到application.properties</h1><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8b46" class="la ju hi kw b fi lb lc l ld le">spring.jpa.hibernate.ddl-auto=update<br/>spring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:3306/all_transactions<br/>spring.datasource.username=****<br/>spring.datasource.password=****<br/>spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect</span></pre><h1 id="af9b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">编写接口和模型类</h1><h2 id="10c9" class="la ju hi bd jv lf lg lh jz li lj lk kd jf ll lm kh jj ln lo kl jn lp lq kp lr bi translated"><strong class="ak">模特班</strong></h2><p id="9283" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">在我的例子中，模型类是用于事务的，它将id、类型、电子邮件和日期作为它的属性。让我们在IntelliJ类中声明这些。</p><p id="cc92" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">@ Table(name = " Transaction ")</strong>'用于在MySQL数据库中创建一个名为Transaction的表。<strong class="iw hj">@ generated value(strategy = generation type。<em class="lx"> AUTO) </em> </strong> <em class="lx"> ' </em>用于每当增加新交易时自动生成id。这意味着每当创建一个事务时，id将自动增加1。<strong class="iw hj"> @Column(name= "id") </strong>'用于在数据库的交易表中创建一个具有特定名称' id '的列。为每个指定的属性编写Setters和getters方法。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d73d" class="la ju hi kw b fi lb lc l ld le"><strong class="kw hj">import </strong>javax.persistence.*;</span><span id="395b" class="la ju hi kw b fi ly lc l ld le">@Entity<br/>@Table(name = "Transaction")<br/>public class Transaction {<br/><br/>    @Id<br/>    @GeneratedValue(strategy=GenerationType.<em class="lx">AUTO</em>)<br/>    @Column(name="id")<br/>    private Integer id;<br/><br/>    @Column(name="type")<br/>    private String type;<br/><br/>    @Column(name="email")<br/>    private String email;<br/><br/>    @Column(name="date")<br/>    private String date;<br/><br/>    public Transaction(){<br/><br/>    }<br/><br/>    public Transaction(Integer id, String type, String email, String date) {<br/>        this.id=id;<br/>        this.type = type;<br/>        this.email = email;<br/>        this.date = date;<br/>    }<br/><br/>    public int getId() {<br/>        return id;<br/>    }<br/><br/>    public void setId(int id) {<br/>        this.id = id;<br/>    }<br/><br/>    public String getType() {<br/>        return type;<br/>    }<br/><br/>    public void setType(String type) {<br/>        this.type = type;<br/>    }<br/><br/>    public String getEmail() {<br/>        return email;<br/>    }<br/><br/>    public void setEmail(String email) {<br/>        this.email = email;<br/>    }<br/><br/>    public String getDate() {<br/>        return date;<br/>    }<br/><br/>    public void setDate(String date) {<br/>        this.date = date;<br/>    }<br/><br/>}</span></pre><h2 id="3c0a" class="la ju hi bd jv lf lg lh jz li lj lk kd jf ll lm kh jj ln lo kl jn lp lq kp lr bi translated">服务接口</h2><p id="7940" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">服务将具有保存交易、获取所有交易、通过id获取交易、筛选交易和删除交易的功能。保存交易功能将用于更新现有交易和创建新交易。我们将为服务创建另一个包，其中我们将添加<a class="ae js" href="https://javarevisited.blogspot.com/2018/01/what-is-functional-interface-in-java-8.html" rel="noopener ugc nofollow" target="_blank">接口</a>及其实现。</p><p id="80a3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果交易的电子邮件id在黑名单中，并且交易是在过去30天内进行的，则筛选交易应返回“已拒绝”。在所有其他情况下，它应该返回“接受”。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="204f" class="la ju hi kw b fi lb lc l ld le">public interface TransactionService {<br/><br/>    public List&lt;Transaction&gt; findAllTransactions();<br/><br/>    public String screenTransactionById(int theId);<br/><br/>    public Transaction findTransactionById(int theId);<br/><br/>    public Transaction saveTransaction(Transaction theTransaction);<br/><br/>    public int deleteTransactionById(int theId);<br/><br/>}</span></pre><h2 id="67f7" class="la ju hi bd jv lf lg lh jz li lj lk kd jf ll lm kh jj ln lo kl jn lp lq kp lr bi translated">DAO接口</h2><p id="e3be" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">DAO将具有与服务类似的功能，即从数据库中获取所有交易，通过id从数据库中获取交易，在数据库中添加交易和在数据库中删除交易。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="bb6a" class="la ju hi kw b fi lb lc l ld le">public interface TransactionDAO {<br/><br/>    List&lt;Transaction&gt; getAllTransactions();<br/><br/>    Transaction findTransactionById(int theId);<br/><br/>    Transaction saveTransaction(Transaction theTransaction);<br/><br/>    void deleteTransactionById(int theId);<br/><br/>}</span></pre><h2 id="c9f9" class="la ju hi bd jv lf lg lh jz li lj lk kd jf ll lm kh jj ln lo kl jn lp lq kp lr bi translated">DAO实现类</h2><p id="7077" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">DAO实现类将与数据库交互。本例中使用MySql 作为数据库。DAO接口的所有方法都在这个类中被重写。</p><p id="52e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们用<strong class="iw hj"> @Autowired </strong>注释一个类，Spring会自动解析这个实例，并把它注入到声明它的类中。因此，我们不需要自己获得singleton实例。如果一个类是<a class="ae js" href="https://javarevisited.blogspot.com/2014/05/double-checked-locking-on-singleton-in-java.html" rel="noopener ugc nofollow" target="_blank">单例</a>，那么在整个应用程序生命周期中，这个类只能有一个实例。</p><p id="6ffc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> Spring Repository </strong>非常接近于<a class="ae js" href="https://www.journaldev.com/16813/dao-design-pattern" rel="noopener ugc nofollow" target="_blank"> DAO </a>模式，其中DAO类负责提供数据库表上的CRUD操作。<strong class="iw hj"> '@Repository' </strong>注释用于将类声明为由spring framework自动检测的存储库对象。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="930a" class="la ju hi kw b fi lb lc l ld le"><strong class="kw hj">import </strong>org.hibernate.query.Query;<br/><strong class="kw hj">import </strong>org.springframework.beans.factory.annotation.Autowired;<br/><strong class="kw hj">import </strong>org.springframework.stereotype.Repository;<br/><strong class="kw hj">import </strong>javax.persistence.EntityManager;<br/><strong class="kw hj">import </strong>java.util.List;</span><span id="cf03" class="la ju hi kw b fi ly lc l ld le">@Repository<br/>public class TransactionDAOJpaImpl implements TransactionDAO {<br/><br/>    private EntityManager entityManager;<br/><br/>    @Autowired<br/>    public TransactionDAOJpaImpl(EntityManager entityManager){<br/>        this.entityManager = entityManager;<br/><br/>    }<br/>    <br/>   //get all the transactions from the database<br/>    @Override<br/>    public List&lt;Transaction&gt; getAllTransactions() {<br/>        Query theQuery= (Query) entityManager.createQuery("from Transaction");<br/>        List&lt;Transaction&gt; transactions = theQuery.getResultList();<br/><br/>        return transactions;<br/>    }<br/><br/>    //return the transaction by giving id as input<br/>    @Override<br/>    public Transaction findTransactionById(int theId) {<br/>        Transaction theTransaction = entityManager.find(Transaction.class,theId);<br/>        return theTransaction;<br/>    }<br/><br/>    //add the transaction to the database<br/>    @Override<br/>    public Transaction saveTransaction(Transaction theTransaction) {<br/>        Transaction dbTransaction = entityManager.merge(theTransaction);<br/>        theTransaction.setId(dbTransaction.getId());<br/>        return theTransaction;<br/>    }<br/><br/>    //delete the transaction from the database using transaction id<br/>    @Override<br/>    public void deleteTransactionById(int theId) {<br/>        Query theQuery = (Query) entityManager.createQuery("delete from Transaction where id=:transactionId");<br/>        theQuery.setParameter("transactionId", theId);<br/>        theQuery.executeUpdate();<br/>    }<br/>}</span></pre><p id="d896" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦定义了映射，<strong class="iw hj">实体管理器</strong>就可以管理您的实体。实体管理器处理与数据库的所有交互。</p><h2 id="89f0" class="la ju hi bd jv lf lg lh jz li lj lk kd jf ll lm kh jj ln lo kl jn lp lq kp lr bi translated">服务实现类</h2><p id="ea29" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">服务接口中声明的所有方法都在该类中被覆盖。</p><p id="f757" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> '@Transactional' </strong>注释本身定义了单个数据库事务的范围。数据库事务发生在一个<em class="lx">持久上下文</em>的范围内。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5b19" class="la ju hi kw b fi lb lc l ld le"><strong class="kw hj">import </strong>org.springframework.beans.factory.annotation.Autowired;<br/><strong class="kw hj">import </strong>org.springframework.beans.factory.annotation.Qualifier;<br/><strong class="kw hj">import </strong>org.springframework.stereotype.Service;<br/><strong class="kw hj">import </strong>org.springframework.transaction.annotation.Transactional;<br/><br/><strong class="kw hj">import </strong>java.text.SimpleDateFormat;<br/><strong class="kw hj">import </strong>java.time.LocalDate;<br/><strong class="kw hj">import </strong>java.util.Arrays;<br/><strong class="kw hj">import </strong>java.util.List;<br/><br/><strong class="kw hj">import static </strong>java.time.temporal.ChronoUnit.<strong class="kw hj"><em class="lx">DAYS</em></strong>;</span><span id="e4bb" class="la ju hi kw b fi ly lc l ld le">@Service<br/>public class TransactionServiceImpl implements TransactionService {<br/><br/>    TransactionDAO transactionDAO;<br/>    private static final String[] <em class="lx">blackListEmails </em>= new String[] {"blacklist1@gmail.com","blacklist2@gmail.com","blacklist3@gmail.com","blacklist4@gmail.com"};<br/><br/>    @Autowired<br/>    public TransactionServiceImpl(@Qualifier("transactionDAOJpaImpl") TransactionDAO theTransactionDao){<br/>        transactionDAO = theTransactionDao;<br/>    }<br/><br/>    @Override<br/>    @Transactional<br/>    public List&lt;Transaction&gt; findAllTransactions() {<br/>        return transactionDAO.getAllTransactions();<br/>    }<br/><br/>    @Override<br/>    @Transactional<br/>    public String screenTransactionById(int theId) {<br/>        Transaction theTransaction=transactionDAO.findTransactionById(theId);<br/>        String dateInString = theTransaction.getDate();<br/>        LocalDate localDate = LocalDate.<em class="lx">parse</em>(dateInString);<br/>        LocalDate today = LocalDate.<em class="lx">now</em>();<br/><br/>        long difference=<em class="lx">DAYS</em>.between(localDate, today);<br/>        boolean isInBlackList = Arrays.<em class="lx">asList</em>(<em class="lx">blackListEmails</em>).contains(theTransaction.getEmail());<br/><br/>        //return Reject if the email id is in blacklist and the transaction has been made in the last 30 days, otherwise return accept<br/>        if(isInBlackList &amp;&amp; difference&lt;30) {<br/>            return "REJECT";<br/>        }<br/>        else {<br/>            return "ACCEPT";<br/>        }<br/><br/>    }<br/><br/>    @Override<br/>    @Transactional<br/>    public Transaction findTransactionById(int theId) {<br/>        return transactionDAO.findTransactionById(theId);<br/>    }<br/><br/>    @Override<br/>    @Transactional<br/>    public Transaction saveTransaction(Transaction theTransaction) {<br/>        return transactionDAO.saveTransaction(theTransaction);<br/>    }<br/><br/>    @Override<br/>    @Transactional<br/>    public int deleteTransactionById(int theId) {<br/>        transactionDAO.deleteTransactionById(theId);<br/>        return theId;<br/>    }<br/>}</span></pre><h2 id="7feb" class="la ju hi bd jv lf lg lh jz li lj lk kd jf ll lm kh jj ln lo kl jn lp lq kp lr bi translated">控制器类别</h2><p id="bb99" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">Spring Boot <a class="ae js" href="http://www.java67.com/2019/01/top-5-spring-boot-annotations-java-programmers-should-know.html" rel="noopener ugc nofollow" target="_blank">注解</a>用于处理不同的HTTP请求类型</p><ul class=""><li id="1d6e" class="lz ma hi iw b ix iy jb jc jf mb jj mc jn md jr me mf mg mh bi translated">@RequestMapping —用于处理任何请求类型</li><li id="6f48" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">@GetMapping —获取请求</li><li id="0f5f" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">@PostMapping —发布请求</li><li id="2bc3" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">@PutMapping —上传请求</li><li id="acc2" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">@PatchMapping —修补请求</li><li id="76cc" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">@DeleteMapping —删除请求</li></ul><p id="3a3d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">路径变量是请求URL中的变量，用“<a class="ae js" href="https://javarevisited.blogspot.com/2017/10/differences-between-requestparam-and-pathvariable-annotations-spring-mvc.html#axzz5jtleVQXB" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">@ path variable</strong></a>”标注。</p><p id="e7b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">POST、PUT和DELETE请求可以包含一个名为“<strong class="iw hj"> @RequestBody </strong>”的有效负载。有效载荷包含可以存储或更新的数据。有效载荷通常是<a class="ae js" href="https://javarevisited.blogspot.com/2013/02/how-to-convert-json-string-to-java-object-jackson-example-tutorial.html" rel="noopener ugc nofollow" target="_blank"> JSON格式</a></p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="03d8" class="la ju hi kw b fi lb lc l ld le"><strong class="kw hj">import </strong>org.springframework.beans.factory.annotation.Autowired;<br/><strong class="kw hj">import </strong>org.springframework.http.HttpStatus;<br/><strong class="kw hj">import </strong>org.springframework.http.ResponseEntity;<br/><strong class="kw hj">import </strong>org.springframework.web.bind.annotation.*;<br/><br/><strong class="kw hj">import </strong>java.util.List;</span><span id="4b1d" class="la ju hi kw b fi ly lc l ld le">@RestController<br/>@RequestMapping(path="/demo")<br/>public class TransactionRestController {<br/><br/>    private TransactionService transactionService;<br/><br/>    @Autowired<br/>    public TransactionRestController(TransactionService thetransactionservice){<br/>        transactionService = thetransactionservice;<br/><br/>    }<br/><br/>    //For getting all the transactions<br/>    @RequestMapping(value = "/transactions", method= RequestMethod.<em class="lx">GET</em>)<br/>    public ResponseEntity&lt;List&lt;Transaction&gt;&gt; findAll(){<br/>        System.<em class="lx">out</em>.println(transactionService.findAllTransactions().size());<br/>        return new ResponseEntity&lt;List&lt;Transaction&gt;&gt;(transactionService.findAllTransactions(), HttpStatus.<em class="lx">OK</em>);<br/><br/>    }<br/><br/>    //For getting whether the transaction with a given id is rejected or accepted<br/>    @RequestMapping(value = "/transactions/{transactionId}", method = RequestMethod.<em class="lx">GET</em>)<br/>    public String screenTransaction(@PathVariable int transactionId)  {<br/>        String theTransaction = transactionService.screenTransactionById(transactionId);<br/><br/>        return theTransaction;<br/>    }<br/><br/>    //For adding a transaction<br/>    @RequestMapping(value = "/transactions", method = RequestMethod.<em class="lx">POST</em>)<br/>    public Transaction addTransaction(@RequestBody Transaction theTransaction){<br/><br/>        return (transactionService.saveTransaction(theTransaction));<br/>    }<br/><br/>    //For updating a transaction<br/>    @RequestMapping(value = "/transactions", method = RequestMethod.<em class="lx">PUT</em>)<br/>    public Transaction updateTransaction(@RequestBody Transaction theTransaction){<br/>        Transaction transaction = transactionService.findTransactionById(theTransaction.getId());<br/>        if (transaction == null) {<br/>            throw new RuntimeException("Transaction to update doesn't exist");<br/>        }<br/>        return (transactionService.saveTransaction(theTransaction));<br/>    }<br/><br/>    //For deleting a transaction<br/>    @RequestMapping(value = "/transactions/{transactionId}", method = RequestMethod.<em class="lx">DELETE</em>)<br/>    public String deleteTransaction(@PathVariable int transactionId){<br/>        Transaction tempTransaction = transactionService.findTransactionById(transactionId);<br/>        if(tempTransaction == null){<br/>            throw new RuntimeException("Transaction Id not found");<br/>        }<br/>        transactionService.deleteTransactionById(transactionId);<br/>        return "deleted transaction id " + transactionId;<br/><br/>    }<br/>}</span></pre><p id="5363" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在你可以在Postman<a class="ae js" href="http://localhost:8080/demo/transactions." rel="noopener ugc nofollow" target="_blank">T5【http://localhost:8080/demo/transactions</a><em class="lx">，</em>screen transactions在URL<a class="ae js" href="http://localhost:8080/demo/transactions/{transactionId}" rel="noopener ugc nofollow" target="_blank"><em class="lx">http://localhost:8080/demo/transactions/{ transaction id }</em></a><em class="lx"/>中选择get，就可以得到所有的交易。您可以在URL<em class="lx"/><a class="ae js" href="http://localhost:8080/demo/transactions." rel="noopener ugc nofollow" target="_blank"><em class="lx">http://localhost:8080/demo/transactions</em></a><em class="lx"/>中添加交易，并在URL<a class="ae js" href="http://localhost:8080/demo/transactions." rel="noopener ugc nofollow" target="_blank"><em class="lx">http://localhost:8080/demo/transactions</em></a><em class="lx"/>中选择发布和更新交易，然后选择PUT <em class="lx">。</em>您也可以通过转到<a class="ae js" href="http://localhost:8080/demo/transactions/{transactionId}" rel="noopener ugc nofollow" target="_blank"><em class="lx">http://localhost:8080/demo/transactions/{ transaction id }</em></a><em class="lx"/>并选择删除来删除交易。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="823d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你想更多地了解Spring Boot，这里有一些有用的资源，如供进一步阅读的书籍和课程:</p><ol class=""><li id="db6b" class="lz ma hi iw b ix iy jb jc jf mb jj mc jn md jr mu mf mg mh bi translated"><a class="ae js" href="http://www.java67.com/2017/11/top-5-free-core-spring-mvc-courses-learn-online.html" rel="noopener ugc nofollow" target="_blank">学习春天和Spring Boot的5门免费课程</a></li><li id="c3d0" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr mu mf mg mh bi translated"><a class="ae js" href="http://javarevisited.blogspot.sg/2018/05/10-tips-to-become-better-java-developer.html" rel="noopener ugc nofollow" target="_blank">成为更好的Java开发人员的10个技巧</a></li><li id="d050" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr mu mf mg mh bi translated"><a class="ae js" href="http://www.java67.com/2017/12/top-5-spring-security-online-training-courses.html" rel="noopener ugc nofollow" target="_blank"> 5门春季安全课程在线学习</a></li><li id="1966" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr mu mf mg mh bi translated"><a class="ae js" href="http://javarevisited.blogspot.sg/2018/01/how-to-learn-spring-core-spring-mvc-boot-security-framework.html#axzz55IgfKjy8" rel="noopener ugc nofollow" target="_blank">学习Spring Boot和春云的3种方法</a></li><li id="62c9" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr mu mf mg mh bi translated"><a class="ae js" href="https://javarevisited.blogspot.sg/2018/05/top-5-courses-to-learn-spring-boot-in.html" rel="noopener ugc nofollow" target="_blank">初学者学习Spring Boot的5门课程</a></li><li id="a294" class="lz ma hi iw b ix mi jb mj jf mk jj ml jn mm jr mu mf mg mh bi translated"><a class="ae js" href="https://javarevisited.blogspot.com/2018/06/top-6-spring-framework-online-courses-Java-programmers.html" rel="noopener ugc nofollow" target="_blank">深入学习Spring框架的前5门课程</a></li></ol><p id="66ba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="lx">请继续关注第3部分，讨论为编写的代码编写单元测试。</em> </strong></p><div class="mv mw ez fb mx my"><a rel="noopener follow" target="_blank" href="/javarevisited/10-free-spring-boot-tutorials-and-courses-for-java-developers-53dfe084587e"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">面向Java开发人员的10个免费Spring Boot课程和教程</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">大家好，作为一个Java博客的作者和Java开发人员，很多人问我关于课程和书籍的问题…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">medium.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm io my"/></div></div></a></div></div></div>    
</body>
</html>