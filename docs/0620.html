<html>
<head>
<title>JMS -SimpleMessageListenerContainer Vs DefaultMessageListenerContainer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JMS-SimpleMessageListenerContainer Vs DefaultMessageListenerContainer</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/jms-simplemessagelistenercontainer-vs-defaultmessagelistenercontainer-940415bef558?source=collection_archive---------1-----------------------#2020-08-02">https://medium.com/javarevisited/jms-simplemessagelistenercontainer-vs-defaultmessagelistenercontainer-940415bef558?source=collection_archive---------1-----------------------#2020-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8d42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring提供了一个JMS集成框架，简化了对<a class="ae jd" href="https://en.wikipedia.org/wiki/Java_Message_Service" rel="noopener ugc nofollow" target="_blank"> JMS </a> API的使用。消息监听器是JMS应用程序的一部分。为了异步接收JMS消息，<a class="ae jd" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25"> Spring </a>提供了创建<strong class="ih hj">消息驱动POJO</strong>(MDP)的解决方案。</p><p id="d84e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring MessageListenerContainer允许我们在没有EJB容器的情况下注册MessageListeners。它用于异步接收消息。它是Pojo和消息传递提供者之间的中介。它从队列中轮询消息，并将其提供给侦听器。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/05/top-16-jms-java-messaging-service-interview-questions-answers.html"><div class="er es je"><img src="../Images/5aed53c77552749df292fa066af551cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*1JWkrEHdJMTHpwFB.jpeg"/></div></a></figure><p id="413b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring打包的两个标准JMS MessageListenerContainer是:<strong class="ih hj">DefaultMessageListenerContainer(DMLC)和SimpleMessageListenerContainer(SMLC)</strong></p><p id="7b9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两种容器的细节和方法可在<a class="ae jd" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jms/listener/MessageListenerContainer.html" rel="noopener ugc nofollow" target="_blank">这里</a>查看。我特别要写的是创建JMS应用程序时面临的差异和问题。</p><p id="b64c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<strong class="ih hj">SimpleMessageListenerContainer</strong>使用推的方法时，<strong class="ih hj">DefaultMessageListenerContainer</strong>使用拉的方法，这意味着它在一个无限循环中接收消息。</p><p id="b791" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SMLC是消息侦听器容器的最简单形式。它创建固定数量的JMS会话来调用侦听器，并且不允许任何运行时需求。它的主要优点是低复杂性和对JMS提供者的最低要求。</p><p id="dc8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然SMLC易于使用，并且是本机JMS的首选，而且如果JMS提供者能够很好地处理线程管理和连接恢复，那么它也有一些缺点。</p><p id="dcb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别是在您的<a class="ae jd" href="https://javarevisited.blogspot.com/2014/03/top-10-websphere-mq-series-interview-questions-answers-active-rabbit.html" rel="noopener ugc nofollow" target="_blank">队列/主题</a>与您的监听器不在同一个服务器上，或者与JMS提供者的连接频繁失败的情况下，线程管理将是SMLC的主要问题，因为一旦您的监听器启动，线程数量超过该服务器的<a class="ae jd" href="https://www.linuxtechi.com/set-ulimit-file-descriptors-limit-linux-servers/" rel="noopener ugc nofollow" target="_blank"> ulimit </a>，线程管理就会继续创建不必要的线程，因为<a class="ae jd" rel="noopener" href="/javarevisited/7-best-linux-courses-for-developers-cloud-engineers-and-devops-in-2021-7415314087e1"> Linux </a>有每个用户允许的最大进程限制，这可能会导致应用程序出错(<strong class="ih hj">无法创建新的本机线程:内存不足问题</strong>)。</p><p id="6b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将需要重新启动应用程序来终止所有线程，这将背离使用MessageListenerContainer连续监听消息的整体目的。</p><p id="a356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述问题的解决方案是在这种情况下应该使用DMLC，这也是许多环境中更值得推荐的方法。它不使用/阻止JMS提供者线程。它还能优雅地处理连接失败。</p><p id="9b33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了深入一点，我有一个带有JMS实现的应用程序。最初，在JMS提供者托管在本地服务器上之前，SMLC运行得很好。</p><p id="09c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后来的提供者被转移到<a class="ae jd" rel="noopener" href="/javarevisited/how-to-prepare-for-aws-solution-architect-associate-certification-saa-c01-saa-c02-exam-in-2021-a6e7e7e771fc"> AWS设置</a>并进行一些常见的连接重置，这开始导致线程问题。在我将我的<strong class="ih hj">SimpleMessageListenerContainer</strong>替换为<strong class="ih hj">DefaultMessageListenerContainer之后，这个问题得到了解决。</strong></p><p id="00b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们看了看Spring提供的两种不同的JMS侦听器及其用法。希望你觉得有用。</p><p id="821c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢！</p></div></div>    
</body>
</html>