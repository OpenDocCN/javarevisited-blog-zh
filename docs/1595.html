<html>
<head>
<title>Clean code — Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净的代码-类</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/clean-code-classes-dae3cb44eb90?source=collection_archive---------2-----------------------#2021-09-27">https://medium.com/javarevisited/clean-code-classes-dae3cb44eb90?source=collection_archive---------2-----------------------#2021-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8b4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我正在读第二遍，罗伯特·c·马丁又叫<em class="je">鲍勃叔叔</em>的伟大著作<a class="ae jd" rel="noopener" href="/javarevisited/clean-code-a-must-read-coding-book-for-programmers-9dc80494d27c"> <strong class="ih hj">干净的代码</strong> </a>，我认为写下它试图传达给我们的最重要的想法是个好主意。今天，我将重点讨论第十章。</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><figure class="jn jo jp jq fd jr er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/10/clean-code-by-uncle-bob-book-review.html"><div class="er es jm"><img src="../Images/31c6cc1f9167feb140af587c77dcb948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*RVqbvKSIDHGdYoEiiwH9hw.png"/></div></a></figure><p id="6eba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们喜欢保持变量和效用函数的私密性，但并不热衷于此。有时我们需要保护一个变量或效用函数，以便它可以被测试访问。</p><p id="088b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我们来说，测试规则。如果同一个包中的一个测试需要调用一个函数或者访问一个变量，我们会把它设为<a class="ae jd" href="https://javarevisited.blogspot.com/2012/10/difference-between-private-protected-public-package-access-java.html#axzz6j8KhisSX" rel="noopener ugc nofollow" target="_blank">保护</a>或者<a class="ae jd" href="http://www.java67.com/2012/12/what-is-public-private-protected-package-default-private-access-modifier-java.html" rel="noopener ugc nofollow" target="_blank">包作用域</a>。然而，我们将首先寻找一种保持隐私的方法。放松封装永远是最后的手段。</p><h2 id="521d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak">班级要小！</strong></h2><p id="0b6d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在设计类时，较小是首要原则。和函数一样，我们最直接的问题总是“有多小？”</p><p id="6c57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于函数，我们通过计算物理线来测量大小。对于类，我们使用不同的度量。我们算<em class="je">责任</em>。</p><p id="c04d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个类的名字应该描述它履行什么职责。事实上，命名可能是帮助确定班级规模的第一种方式。如果我们不能为一个类获得一个简洁的名字，那么它可能太大了。</p><p id="24aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类名越模糊，就越有可能有太多的责任。例如，包含像<em class="je">服务</em>或<em class="je">经理</em>或<em class="je">超级</em>这样的含糊其词的类名通常暗示了责任的不幸聚合。</p><p id="819e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还应该能够用25个左右的单词写一篇简短的课堂描述，不要使用“如果”、“和”、“或”、“但是”这样的词。</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="033e" class="ku jv hi bd jw kv kw kx ka ky kz la ke lb lc ld kh le lf lg kk lh li lj kn lk bi translated">单一责任原则</h1><p id="f704" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">SRP声明一个类或模块应该有且只有一个改变的理由。这个原则给了我们责任的定义和班级规模的指导方针。类应该有一个责任，一个改变的理由(试图识别责任通常有助于我们在代码中识别和创建更好的抽象)。</p><p id="f2f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望我们的系统由许多小类组成，而不是几个大类。每个小类都封装了一个单独的责任，有一个改变的理由，并与其他一些人合作来实现期望的系统行为。</p><h2 id="3066" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">内聚力</h2><p id="8e14" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">类应该有少量的实例变量。一个类的每个方法都应该操作一个或多个这样的变量。一般来说，一个方法操纵的变量越多，这个方法对它的类就越有凝聚力。一个类中的每一个变量都被每一个方法使用，这个类就是最大内聚的。</p><p id="1dde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，创建这样的最大内聚类既不可取也不可能，另一方面，我们希望内聚性高。当内聚性很高时，意味着类的方法和变量是相互依赖的，作为一个逻辑整体挂在一起。</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h2 id="29b9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">结论</h2><p id="8e65" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">需求会改变，因此代码也会改变。我们在OO 101中了解到，有包含实现细节的具体类，也有仅代表概念的抽象类。</p><p id="2f2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当具体细节发生变化时，依赖于具体细节的客户端类将面临风险。我们可以引入接口和抽象类来帮助隔离这些细节的影响。</p><p id="e995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住，对具体细节的依赖给测试我们的系统带来了挑战。如果一个系统解耦到可以用这种方式测试。，它也将更加灵活，并促进更多的重用。</p></div></div>    
</body>
</html>