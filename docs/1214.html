<html>
<head>
<title>Java - Ordering Thread Executions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java -排序线程执行</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-ordering-thread-executions-8ac8bb764144?source=collection_archive---------1-----------------------#2021-05-06">https://medium.com/javarevisited/java-ordering-thread-executions-8ac8bb764144?source=collection_archive---------1-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/de259ffb1f88ba3e0d9fd8e20401d00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-zcdRB0QlKrbZXxIN3_Xw.png"/></div></div></figure><p id="1c91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将讨论如何给不同的线程排序，让它们按照我们希望的顺序运行。当然，有传统的方法来确保秩序，但我想给你展示一种优雅的方法，叫做<strong class="is hj"> CompletableFuture </strong>，它是在<a class="ae jo" rel="noopener" href="/hackernoon/top-5-java-8-courses-to-learn-online-2db57d9dfb8d"> Java 8 </a>中引入的。</p><h2 id="38bf" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak"> 1-什么是CompletableFuture？</strong></h2><p id="9d11" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">CompletableFuture是一种新的执行线程的方式，正如你现在看到的，使用起来非常简单。让我们看看如何用它来执行一个线程。首先，我们创建一个可运行的类。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="7db5" class="jp jq hi ku b fi ky kz l la lb">public class TextDownloader implements Runnable {<br/><br/>    @Override<br/>    public void run() {<br/>        // Download text from server<br/>        System.<em class="lc">out</em>.println("I am downloading the file containing text to a directory");<br/>        try {<br/>            Thread.<em class="lc">sleep</em>(2000); // for simulating download wait time<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</span></pre><p id="4627" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du ld le lf ku b">TextDownloader </code>课上，我正在模拟下载操作，这需要一些时间来完成。当然，我们希望在一个单独的线程中运行下载操作，如下所示。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="e69e" class="jp jq hi ku b fi ky kz l la lb">CompletableFuture<br/>        .<em class="lc">runAsync</em>(new TextDownloader());</span></pre><p id="b339" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看多轻松好看！现在让我们添加另一个部分，并处理下载的文本。当我们下载完文本(作为文件)后，我们将它保存到文件系统中的某个位置，以便以后处理。这是关键部分，我们需要确保下载阶段已经完成，以便我们可以在以后访问它进行处理。这是处理器类</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="b5cd" class="jp jq hi ku b fi ky kz l la lb">public class TextProcessor implements Runnable {<br/><br/>    @Override<br/>    public void run() {<br/>        // Process downloaded text<br/>        System.<em class="lc">out</em>.println("I am taking the text from the location and processing the text");<br/>    }<br/>}</span></pre><p id="60db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们按如下方式运行它们，以确保有序</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="9613" class="jp jq hi ku b fi ky kz l la lb">CompletableFuture<br/>        .<em class="lc">runAsync</em>(new TextDownloader())<br/>        .thenRunAsync(new TextProcessor());</span></pre><p id="8069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lc">然后RunAsync </em>方法确保通过<em class="lc"> runAsync </em>执行的线程完成，然后运行给它的线程。在上面的例子中，我们假设第二个线程已经知道第一个<a class="ae jo" href="https://javarevisited.blogspot.com/2014/07/top-50-java-multithreading-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank">线程</a>将下载的文件放在文件系统中的什么地方。但是如果没有呢？让我们看看供应商如何处理它。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="4b82" class="jp jq hi ku b fi ky kz l la lb">public class TextDownloader2 implements Supplier&lt;String&gt; {<br/><br/>    @Override<br/>    public String get() {<br/>        System.<em class="lc">out</em>.println("I am downloading the file containing text to a directory");<br/>        try {<br/>            Thread.<em class="lc">sleep</em>(2000); // for simulating download wait time<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>        return "pathToDownloadedFile";<br/>    }<br/>}</span></pre><p id="10a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面，你可以看到一个文本下载器的更新版本。不同之处在于，现在它实现了一个供应商接口，该接口的get方法返回值。我们可以将返回值传递给处理器类，这样它就知道在哪里可以找到下载的文件。更新的文本处理器类现在正在实现消费者接口，以消费供应商提供的输出。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="5a4a" class="jp jq hi ku b fi ky kz l la lb">public class TextProcessor2 implements Consumer&lt;String&gt; {<br/><br/>    @Override<br/>    public void accept(String s) {<br/>        // Process downloaded text<br/>        System.<em class="lc">out</em>.println("I am taking the text from the location and processing the text");<br/>        System.<em class="lc">out</em>.println("Path: " + s);<br/>    }<br/>}</span></pre><p id="c3cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以及我们如何一起使用它们</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="32c4" class="jp jq hi ku b fi ky kz l la lb">CompletableFuture<br/>        .<em class="lc">supplyAsync</em>(new TextDownloader2())<br/>        .thenAccept(new TextProcessor2());</span></pre><p id="86d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您也可以直接在<em class="lc">接受</em>中提供您的逻辑，如下所示</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="7e8c" class="jp jq hi ku b fi ky kz l la lb">CompletableFuture<br/>        .<em class="lc">supplyAsync</em>(new TextDownloader2())<br/>        .thenAccept(path -&gt; {<br/>            // some logic<br/>        });</span></pre><p id="9a99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">CompletableFuture类中有不同的方法可供您使用，例如<em class="lc">thenacceptsync</em>或<em class="lc">theapply</em>，但我现在不想让文章变得更长。</p><p id="dd2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程中，我谈到了排序线程执行。我希望你喜欢它。</p><div class="lg lh ez fb li lj"><a href="https://github.com/kurular4/medium-java/tree/master/completable-future" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hj fi z dy lo ea eb lp ed ef hh bi translated">中级java/completable-master kurula 4的未来/中级Java</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">关于Java的文章中的代码。在GitHub上创建一个帐户，为kurura 4/medium-Java开发做贡献。</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">github.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx io lj"/></div></div></a></div></div></div>    
</body>
</html>