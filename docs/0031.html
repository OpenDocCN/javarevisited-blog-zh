<html>
<head>
<title>Interview Question: Reversing an Immutable List in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试问题:在 Java 中反转不可变列表</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/interview-question-reversing-an-immutable-list-in-java-57a891a521c5?source=collection_archive---------0-----------------------#2018-11-19">https://medium.com/javarevisited/interview-question-reversing-an-immutable-list-in-java-57a891a521c5?source=collection_archive---------0-----------------------#2018-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7307ee3e7823e63aa2671e0214073207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7f0mFDI-SC-WIcFsbKyiaw.jpeg"/></div></div></figure><p id="936a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在最近的一系列 Java 访谈中，我准备了一个关于如何反转不可变列表的问题。我发现对大多数候选人来说，这个问题并不那么简单。因此，我决定分享它。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="828f" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">问题</h1><p id="b035" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">我们必须实现以下接口来反转输入列表:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="c1e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">预期结果的一个例子是:</p><pre class="ky kz la lb fd le lf lg lh aw li bi"><span id="cc96" class="lj jw hi lf b fi lk ll l lm ln">Input: 1, 2, 3<br/>Output: 3, 2, 1</span></pre><p id="acc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">唯一的约束是输入<code class="du lo lp lq lf b">list</code>是<strong class="is hj">不可变的。</strong></p><p id="5081" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当前的实现如下:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><blockquote class="lr"><p id="86c2" class="ls lt hi bd lu lv lw lx ly lz ma jn dx translated">这个解决方案将产生预期的结果。然而，从性能角度来看，问题很少。你能认出他们吗？</p><p id="e556" class="ls lt hi bd lu lv mb mc md me mf jn dx translated">你会用不同的方式实现它吗？</p></blockquote><p id="e6b4" class="pw-post-body-paragraph iq ir hi is b it mg iv iw ix mh iz ja jb mi jd je jf mj jh ji jj mk jl jm jn hb bi translated">我们考虑访问输入列表的给定索引是在一个常数时间内完成的。</p><p id="860e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为基础，在 Oracle JDK 9 和带有 1M 元素的英特尔酷睿 i7–7700(3.6 GHz)上运行此函数会产生以下响应时间:</p><pre class="ky kz la lb fd le lf lg lh aw li bi"><span id="5a8c" class="lj jw hi lf b fi lk ll l lm ln">problem          avgt     403.000 us/op</span></pre><h1 id="ed48" class="jv jw hi bd jx jy ml ka kb kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks bi translated">可能的解决方案</h1><h2 id="9c82" class="lj jw hi bd jx mq mr ms kb mt mu mv kf jb mw mx kj jf my mz kn jj na nb kr nc bi translated">迭代模式</h2><p id="388d" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">首先，我们来检查一下在输入列表上迭代的方式。众所周知，对于经典的 for 有不同的替代方案。</p><p id="78b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 Java 5 中，使用 for-each 循环:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="2e81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">真的更快吗？在<a class="ae nd" href="https://www.java67.com/2018/01/effective-java-3rd-edition-by-joshua-bloch-must-read-book-for-java-develoeprs.html" rel="noopener ugc nofollow" target="_blank">有效的 Java </a>中，约书亚·布洛克说:</p><blockquote class="ne nf ng"><p id="35f0" class="iq ir nh is b it iu iv iw ix iy iz ja ni jc jd je nj jg jh ji nk jk jl jm jn hb bi translated">for-each 循环]在某些情况下可能比普通的 for 循环提供一点性能优势，因为它只计算一次数组索引的限制。虽然您可以手工完成这项工作，但程序员并不总是这样做。</p></blockquote><p id="9c89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，如果我们已经预先计算了列表大小(就像我们在最初的实现中所做的那样)，那么与传统的 for 应该没有任何区别。</p><p id="5705" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java 8 的另一个选项是使用<a class="ae nd" href="https://javarevisited.blogspot.com/2015/03/parsing-large-json-files-using-jackson.html" rel="noopener ugc nofollow" target="_blank">流 API </a>:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="ae5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，这不会提供任何主要的性能优势。使用 for-each 和 stream 解决方案运行基准测试得到了大致相同的结果:</p><pre class="ky kz la lb fd le lf lg lh aw li bi"><span id="6cf7" class="lj jw hi lf b fi lk ll l lm ln">problem          avgt     403.000 us/op<br/><strong class="lf hj">for-each         avgt     403.000 us/op<br/>stream           avgt     403.000 us/op</strong></span></pre><h2 id="38ea" class="lj jw hi bd jx mq mr ms kb mt mu mv kf jb mw mx kj jf my mz kn jj na nb kr nc bi translated">数组列表分配</h2><p id="9940" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">一个<code class="du lo lp lq lf b">ArrayList</code>是一个可调整大小的数组实现。在底层，它管理一个<strong class="is hj">容量</strong>，它是用来存储元素的数组的大小。</p><p id="f8f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个<code class="du lo lp lq lf b">ArrayList</code>实施都有一个增长策略，该策略可能因 JDK 而异(例如，一旦阵列满了，就将容量乘以 50%)。</p><p id="e193" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想摆脱这种动态增长，我们可以用给定的<strong class="is hj">初始容量</strong>初始化<code class="du lo lp lq lf b">ArrayList</code>。这是可能的，因为我们已经知道输出列表的大小。</p><p id="5ca0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是这样完成的:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="0770" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看看结果:</p><pre class="ky kz la lb fd le lf lg lh aw li bi"><span id="f1fe" class="lj jw hi lf b fi lk ll l lm ln">problem          avgt     403.000 us/op<br/><strong class="lf hj">initial-capacity avgt     403.000 us/op</strong></span></pre><p id="ca35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么都没有改变。我们该如何解释呢？</p><p id="f0e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最有可能的是，JIT 编译器所做的运行时优化导致人们认为丢失这个初始容量并不那么重要。如果我们禁用预热阶段，我们会注意到两个测试之间的响应时间差要重要得多。</p><h2 id="4435" class="lj jw hi bd jx mq mr ms kb mt mu mv kf jb mw mx kj jf my mz kn jj na nb kr nc bi translated">元素转移</h2><p id="9ae3" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">让我们仔细看看我们在生成的<code class="du lo lp lq lf b">ArrayList</code>中插入元素的方式:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="d5e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个简单表达式的时间复杂度是<strong class="is hj">线性</strong>，不是常数。事实上，在一个<code class="du lo lp lq lf b">ArrayList</code>的零位置插入一个元素需要将所有元素向右移动。</p><p id="01e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是<strong class="is hj">实施的主要问题</strong>。那么有哪些不同的选择呢？</p><p id="b00a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一种选择是使用具有恒定时间的数据结构在位置 0 插入元素。在 Java 中，我们可以使用<code class="du lo lp lq lf b">LinkedList</code>,因为它管理第一个元素上的指针。</p><p id="7690" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用方法<code class="du lo lp lq lf b">addFirst()</code>在第一个位置插入:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="9738" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这次有什么重大改进吗？</p><pre class="ky kz la lb fd le lf lg lh aw li bi"><span id="520d" class="lj jw hi lf b fi lk ll l lm ln">problem          avgt     403.000 us/op<br/><strong class="lf hj">linked-list      avgt         541 us/op</strong></span></pre><p id="809c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好多了。🍾</p><p id="5de0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二种选择是保留一个<code class="du lo lp lq lf b">ArrayList</code>结构，并将元素插入到末尾(这一次，以恒定的时间复杂度进行管理)。</p><p id="c2cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们必须以相反的顺序迭代，如下所示:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><pre class="ky kz la lb fd le lf lg lh aw li bi"><span id="e382" class="lj jw hi lf b fi lk ll l lm ln">problem          avgt     403.000 us/op<br/>linked-list      avgt         541 us/op<strong class="lf hj"><br/>insert-last-pos  avgt         281 us/op</strong></span></pre><p id="afbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">响应时间甚至比使用<code class="du lo lp lq lf b">LinkedList</code>解决方案还要短。</p><p id="5c48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，由于动态内存分配(每个元素都包装在一个节点对象中)，使用<code class="du lo lp lq lf b">LinkedList</code>会增加一点开销。所以，如果我们已经知道了结构的大小，那么使用像<code class="du lo lp lq lf b">ArrayList</code>这样的结构显然更快。</p><h2 id="3b5e" class="lj jw hi bd jx mq mr ms kb mt mu mv kf jb mw mx kj jf my mz kn jj na nb kr nc bi translated">内部数组复制</h2><p id="1e77" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated"><code class="du lo lp lq lf b">ArrayList</code>背靠一个阵。如果我们试图复制这个内部数组，并对这个副本进行就地反转，会怎么样呢？</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="d362" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lo lp lq lf b">swap()</code>函数简单地交换给定数组中的两个索引。</p><p id="e8d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有性能提升吗？</p><pre class="ky kz la lb fd le lf lg lh aw li bi"><span id="171d" class="lj jw hi lf b fi lk ll l lm ln">problem          avgt     403.000 us/op<br/>linked-list      avgt         541 us/op<strong class="lf hj"><br/></strong>insert-last-pos  avgt         281 us/op<strong class="lf hj"><br/>copy-swap-array  avgt         254 us/op</strong></span></pre><p id="6d1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有趣的是，这个解决方案甚至比前几个更快。有一些可能的解释:</p><ul class=""><li id="8161" class="nl nm hi is b it iu ix iy jb nn jf no jj np jn nq nr ns nt bi translated">数组副本由<code class="du lo lp lq lf b">System.arraycopy()</code>管理，这是一个本地的优化函数</li><li id="05df" class="nl nm hi is b it nu ix nv jb nw jf nx jj ny jn nq nr ns nt bi translated">代码对 CPU 缓存更加友好</li></ul><h2 id="9cc1" class="lj jw hi bd jx mq mr ms kb mt mu mv kf jb mw mx kj jf my mz kn jj na nb kr nc bi translated">视角</h2><p id="f872" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">最后一种解决方案依赖于输入列表是不可变的这一事实。因此，我们可以通过创建我们自己的<code class="du lo lp lq lf b">AbstractList</code>在这个列表上创建一个视图:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="4a72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，在这种情况下，比较<code class="du lo lp lq lf b">reverseList()</code>基准并不那么有趣，因为输出列表是延迟构建的:</p><pre class="ky kz la lb fd le lf lg lh aw li bi"><span id="f606" class="lj jw hi lf b fi lk ll l lm ln">problem          avgt     403.000 us/op<br/>linked-list      avgt         541 us/op<strong class="lf hj"><br/></strong>insert-last-pos  avgt         281 us/op<strong class="lf hj"><br/></strong>copy-swap-array  avgt         254 us/op<strong class="lf hj"><br/>view             avgt       0,002 us/op</strong></span></pre><p id="047a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们需要处理<code class="du lo lp lq lf b">list.size() - 1 - index</code>时，调用<code class="du lo lp lq lf b">get()</code>会有很小的开销。在现实生活中，可能值得考虑如何使用这个列表。如果访问非常频繁，也许复制一份是最好的解决方案。</p><p id="d63b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后要提一件事。一些人倾向于强调函数式编程和不变性将<strong class="is hj">总是</strong>对应用程序的性能产生负面影响。这种说法不能一概而论。</p><p id="9ffb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，在我们的例子中，最佳解决方案依赖于问题本身的<strong class="is hj">约束</strong>。</p><p id="aceb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">进一步学习</strong> <br/> <a class="ae nd" href="http://www.java67.com/2017/06/10-books-to-prepare-technical-coding-job-interviews.html" rel="noopener ugc nofollow" target="_blank"> 10 本书准备技术编程/编码求职面试</a> <br/> <a class="ae nd" href="http://www.java67.com/2015/09/top-10-algorithm-books-every-programmer-read-learn.html" rel="noopener ugc nofollow" target="_blank"> 10 本算法书每个程序员都应该读的</a><br/><a class="ae nd" href="http://javarevisited.blogspot.sg/2016/05/5-free-data-structure-and-algorithm-books-in-java.html#axzz4uXETWjmV" rel="noopener ugc nofollow" target="_blank">Java 开发人员的前 5 本数据结构和算法书</a> <br/> <a class="ae nd" href="https://www.java67.com/2019/07/top-10-online-courses-to-learn-data-structure-and-algorithms-in-java.html" rel="noopener ugc nofollow" target="_blank">从 0 到 1:Java 中的数据结构&amp;算法</a> <br/> <a class="ae nd" href="https://click.linksynergy.com/fs-bin/click?id=JVFxdTr9V80&amp;subid=0&amp;offerid=323058.1&amp;type=10&amp;tmpid=14538&amp;RD_PARM1=https%3A%2F%2Fwww.udemy.com%2Fdata-structure-and-algorithms-analysis%2F" rel="noopener ugc nofollow" target="_blank">数据结构和算法分析— —求职面试</a> <br/> <a class="ae nd" href="https://dev.to/javinpaul/top-20-string-coding-problems-from-programming-job-interviews-493m" rel="noopener ugc nofollow" target="_blank"> 20+面试中基于字符串的编码问题</a><a class="ae nd" href="https://dev.to/javinpaul/top-20-string-coding-problems-from-programming-job-interviews-493m" rel="noopener ugc nofollow" target="_blank"/></p><div class="nz oa ez fb ob oc"><a rel="noopener follow" target="_blank" href="/javarevisited/top-21-string-programming-interview-questions-for-beginners-and-experienced-developers-56037048de45"><div class="od ab dw"><div class="oe ab of cl cj og"><h2 class="bd hj fi z dy oh ea eb oi ed ef hh bi translated">面向初学者和有经验的开发人员的 21 个字符串编程面试问题</h2><div class="oj l"><h3 class="bd b fi z dy oh ea eb oi ed ef dx translated">除了数组、二叉树和链表数据结构，字符串是编程工作中的另一个热门话题…</h3></div><div class="ok l"><p class="bd b fp z dy oh ea eb oi ed ef dx translated">medium.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq io oc"/></div></div></a></div><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es or"><img src="../Images/b6578984dc018c44134738b9e16e76e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ni3QlYv1zjIZfJkxFYTzmA.png"/></div></div></figure><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es os"><img src="../Images/ec9b9710329661db6caf375f69308521.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*8kh8D7Gu7uPHxI0aaqGrZA.png"/></div><p class="ot ou et er es ov ow bd b be z dx translated">在 Twitter 上关注我<a class="ae nd" href="https://twitter.com/teivah" rel="noopener ugc nofollow" target="_blank"> @teivah </a></p></figure></div></div>    
</body>
</html>