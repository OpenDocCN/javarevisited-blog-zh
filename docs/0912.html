<html>
<head>
<title>Facade Design pattern for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的立面设计模式</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/facade-design-pattern-for-beginners-7dde0612d069?source=collection_archive---------1-----------------------#2021-01-10">https://medium.com/javarevisited/facade-design-pattern-for-beginners-7dde0612d069?source=collection_archive---------1-----------------------#2021-01-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f46889811b97a7eae32e71cba53d9b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-yfPkXYrZED73Wz3b-Ysow.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@ymwang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">王运明</a>在<a class="ae iu" href="https://unsplash.com/s/photos/dog-leash?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="22a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">立面设计模式是结构设计模式的子类型之一。它用于向客户展示最小的实现，也是以客户能够理解的简单方式。</p><p id="9cc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Facade提供了一个客户端可以用来访问系统的接口。业务逻辑的复杂性可能隐藏在接口的背后。</p><p id="6d1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">让我们直接进入主题，看看如何实现外观设计模式:</strong></p><p id="328f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑一个需求，我们必须生成不同的报告，这些报告的数据存储在不同的ORM上，比如MYSQL和DB2。因此，在生成报告时，我们必须首先建立一个连接，并从数据库中获取数据。一旦数据被填充，我们就可以将数据发送给生成报告的方法。</p><p id="a44b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们将创建一个接口，并定义可以在所有地方使用的公共方法。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b905" class="kc kd hi jy b fi ke kf l kg kh">public interface Reports {<br/>    public void getDataForReports(String reportType);<br/>    public void generateReport();<br/>}</span></pre><p id="8373" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将考虑两种类型的报告:客户报告和订单报告。CustomerReport类可以这样定义。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e3fb" class="kc kd hi jy b fi ke kf l kg kh">public class CustomerReport implements Reports {<br/><br/>    @Override<br/>    public void getDataForReports(String reportType) {<br/>        <em class="ki">// BusinessLogic for getting the data for Customer Report<br/>    </em>}<br/><br/>    @Override<br/>    public void generateReport() {<br/>        <em class="ki">// Business Logic for generating report;<br/>    </em>}<br/>}</span></pre><p id="d8fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">订单报告应该这样定义。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="6b60" class="kc kd hi jy b fi ke kf l kg kh">public class OrderReports implements Reports{<br/><br/>    @Override<br/>    public void getDataForReports(String reportType) {<br/>        <em class="ki">// BusinessLogic for getting the data for Customer Report<br/>    </em>}<br/><br/>    @Override<br/>    public void generateReport() {<br/>        <em class="ki">// Business Logic for generating report;<br/>    </em>}<br/>}</span></pre><p id="0e82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来是ReportsGenerator类，它将充当门面。这个类将隐藏数据获取和生成报告的实际实现。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="01e7" class="kc kd hi jy b fi ke kf l kg kh">public class ReportsGenerator {<br/>    public static String generateReport(String reportType) {<br/>        switch(reportType) {<br/>            case "Customer":<br/>                Reports customerReport = new CustomerReport();<br/>                customerReport.getDataForReports(reportType);<br/>                customerReport.generateReport();<br/>                return reportType + "generated successfully!";<br/><br/>            case "OrderReport":<br/>                Reports orderReport = new OrderReports();<br/>                orderReport.getDataForReports(reportType);<br/>                orderReport.generateReport();<br/>                return reportType + "generated successfully!";<br/>        }<br/>        return "Invalid Report Type, Please select the correct one!";<br/>    }<br/>}</span></pre><p id="3fcc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们设计ApiHandler类，它将依次调用ReportsGenerator类的<code class="du kj kk kl jy b">generateReport()</code>方法。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="d6e1" class="kc kd hi jy b fi ke kf l kg kh">public class ApiHandler {<br/>    public static void main(String[] args) {<br/>        System.<em class="ki">out</em>.println(ReportsGenerator.<em class="ki">generateReport</em>("Customer"));<br/>        System.<em class="ki">out</em>.println(ReportsGenerator.<em class="ki">generateReport</em>("Order"));<br/>    }<br/>}</span></pre><h2 id="75b9" class="kc kd hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">什么时候使用外观设计模式？</h2><p id="5a8f" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">当我们有一个复杂的业务逻辑，并且我们必须只向客户公开简化的API时，应该使用Facade。</p><h2 id="fe9a" class="kc kd hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">立面设计模式的优势:</h2><ul class=""><li id="fbae" class="lk ll hi ix b iy lf jc lg jg lm jk ln jo lo js lp lq lr ls bi translated">我们可以将复杂的系统逻辑从客户端分离出来。</li><li id="da6b" class="lk ll hi ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">包装复杂的系统逻辑是使用外观设计模式实现的。</li></ul><h2 id="61c3" class="kc kd hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">立面设计模式的缺点:</h2><ul class=""><li id="bc51" class="lk ll hi ix b iy lf jc lg jg lm jk ln jo lo js lp lq lr ls bi translated">从长远来看，Facade类可能会成为超级类。</li><li id="f9a4" class="lk ll hi ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">由于Facade，增加了额外的抽象层次。</li></ul></div></div>    
</body>
</html>