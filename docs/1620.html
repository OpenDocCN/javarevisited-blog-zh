<html>
<head>
<title>First steps with RabbitMQ and Spring boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RabbitMQ和Spring boot的第一步</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/first-steps-with-rabbitmq-and-spring-boot-81d293554703?source=collection_archive---------0-----------------------#2021-10-06">https://medium.com/javarevisited/first-steps-with-rabbitmq-and-spring-boot-81d293554703?source=collection_archive---------0-----------------------#2021-10-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f772214ca1e63464b10f0f7c83422f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*jfEQdefRoDDdodiz.png"/></div></figure><p id="a86f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我打算给出一个例子，展示如何使用RabbitMQ、Java和Spring Boot在队列中发布和使用消息。<br/>在开始编程之前，我们必须澄清一些要点:</p><p id="f2c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">什么是RabbitMQ？</strong></p><p id="f5e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">RabbitMQ是一个开源的消息服务器，它利用了AMQP(高级消息队列协议)协议。Rabbit与许多编程语言兼容，允许您简单可靠地处理消息流量。值得一提的是，它还具有原生管理界面，并且是跨平台的。</p><p id="0dd8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">我们将如何在本地使用它？</strong></p><p id="bf0c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本地使用rabbit有两种选择:安装或使用docker容器。在这个例子中，我们将使用<a class="ae jk" rel="noopener" href="/javarevisited/top-5-free-courses-to-learn-docker-for-beginners-best-of-lot-b2b1ad2b98ad?source=collection_home---4------2-----------------------"> docker </a>。</p><p id="6c24" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">运行本教程的先决条件(带链接):</p><ul class=""><li id="f68e" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><a class="ae jk" href="https://www.oracle.com/java/technologies/downloads/" rel="noopener ugc nofollow" target="_blank"> jdk已安装</a>；</li><li id="7aab" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> docker已安装</a>；</li><li id="65cc" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://www.jetbrains.com/pt-br/idea/download/#section=windows" rel="noopener ugc nofollow" target="_blank"> Intellij或Eclipse已安装</a>；</li></ul><h2 id="689d" class="jz ka hi bd kb kc kd ke kf kg kh ki kj ix kk kl km jb kn ko kp jf kq kr ks kt bi translated">开始排队</h2><p id="b103" class="pw-post-body-paragraph im in hi io b ip ku ir is it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj hb bi translated">RabbitMQ自己的网站显示:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/98aac81034406fa4bacb0cbe9ed787ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8z8oGszvu8Vb3fiY.png"/></div></figure><p id="cbf3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们使用这个命令，并在提示符下运行它:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/46714e67948fbbba77050999d30e19d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gzrWvEVuO4Ge2Oud.png"/></div></figure><p id="45be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最终结果看起来像这样:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/195e57f31ac06db1b1258d22914b58ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rLo484rewRtBxgqe.png"/></div></figure><p id="f947" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">兔子在工作。如果你愿意，看看桌面docker上的容器，这个应该出现在这里:</p><figure class="la lb lc ld fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2014/03/top-10-websphere-mq-series-interview-questions-answers-active-rabbit.html"><div class="er es le"><img src="../Images/de7a8d5610f02844beb2da833727cf48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/0*vwCcaiqENrN1pgjl.png"/></div></a></figure><p id="03d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我所说的，有一个接口，默认情况下可以通过端口15672访问，所以访问<a class="ae jk" href="http://localhost:15672/" rel="noopener ugc nofollow" target="_blank">http://localhost:15672/</a>就有可能访问它。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es kz"><img src="../Images/cf2a67f4be48de2bb232c80e6ae968d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gxBzKzs4759FxwgW.png"/></div></div></figure><p id="3336" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">登录时，我们将使用guest作为用户名，guest作为密码。这是兔子的概览屏幕:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/e45b70ca9f0abd3e3b9c72d3d85207c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eLpeG4zzmI5Fub1m.png"/></div></figure><p id="1744" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一步是创建我们将在示例中使用的队列。但是放松点，不难。让我们单击“队列”，然后单击“添加新队列”:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/2ce7aac23e2385a3985056f019293060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iwM3iOvDhC-29g3X.png"/></div></figure><p id="63d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">完成后，让我们填充这个队列的数据(我只输入了名称，其余的都是默认的):</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/70988a5c2b2e93a51a85a1ca8ebe3618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LncCYPIaAloV3JhW.png"/></div></figure><p id="8b35" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我的队列的名称将是一个测试，在创建之后，我们可以在queues页面上看到它:</p><figure class="la lb lc ld fd ij er es paragraph-image"><a href="https://medium.com/javarevisited/top-10-free-courses-to-learn-maven-jenkins-and-docker-for-java-developers-51fa7a1e66f6"><div class="er es kz"><img src="../Images/975856296ffe8d01c549f046775a8699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7FsqQJBm0jVZNrZl.png"/></div></a></figure><h2 id="8bcb" class="jz ka hi bd kb kc kd ke kf kg kh ki kj ix kk kl km jb kn ko kp jf kq kr ks kt bi translated">创建消费者:</h2><p id="704d" class="pw-post-body-paragraph im in hi io b ip ku ir is it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj hb bi translated">在一个有<a class="ae jk" rel="noopener" href="/javarevisited/6-best-maven-courses-for-beginners-in-2020-23ea3cba89"> maven </a>的Spring Boot项目中，让我们放入下面的依赖关系:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="0933" class="jz ka hi lk b fi lo lp l lq lr">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="b803" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">事实上，我们只需要第一个，但是拥有用于运行单元测试、集成测试等的测试工具总是好的。</p><p id="6ebd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">maven下载完依赖项后，我们将编写代码。<br/>这是负责创建消费者的类:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="a3a9" class="jz ka hi lk b fi lo lp l lq lr">import org.springframework.amqp.rabbit.annotation.RabbitListener;<br/>import org.springframework.messaging.handler.annotation.Payload;<br/>import org.springframework.stereotype.Component;<br/><br/><br/>@Component<br/>public class QueueConsumer {<br/><br/>    @RabbitListener(queues = {"${queue.name}"})<br/>    public void receive(@Payload String fileBody) {<br/>        System.<em class="ls">out</em>.println("Message " + fileBody);<br/>    }<br/><br/>}</span></pre><p id="9480" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不要惊讶，只是这个代码。在application.properties中，我们将配置以下属性:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="8464" class="jz ka hi lk b fi lo lp l lq lr">spring.rabbitmq.host=localhost<br/>spring.rabbitmq.port=5672<br/>spring.rabbitmq.username=guest<br/>spring.rabbitmq.password=guest<br/><br/>queue.name=teste</span></pre><p id="1234" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，主类接收@/EnableRabbit注释，如下所示:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="4f6b" class="jz ka hi lk b fi lo lp l lq lr">import org.springframework.amqp.rabbit.annotation.EnableRabbit;<br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/><br/>@EnableRabbit<br/>@SpringBootApplication<br/>public class AppApplication {<br/><br/>   public static void main(String[] args) {<br/>      SpringApplication.<em class="ls">run</em>(AppApplication.class, args);<br/>   }<br/><br/>}</span></pre><p id="8b00" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个注释也可以放在配置类中，没问题。在这个例子中，我并没有为此创建一个类。</p><p id="848f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在只要启动应用程序，在它已经启动之后，让我们回到兔子的队列屏幕并咨询这个消费者。为此，请单击队列名称:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/2135bcd3172c9a393b80952b5e731369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YHta0MjKEINwUGt_.png"/></div></figure><p id="77f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将显示以下画面:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/2b4815714cb159f05082e86634281692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rqXJgTMJ9rwygp5T.png"/></div></figure><p id="b148" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">看看那里的消费者，它是连接的。让我们发送一条短信:<br/>点击“发布消息”</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/98780778cfd7333e0ade7d380c53372b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J5U7v7NHaH7Dz1_D.png"/></div></figure><p id="902c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在ide控制台中，我们可以看到我们留在类中的system.out.println:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lt"><img src="../Images/57d155d9558542555ae5af672c5805ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QP3M_EiklOb9HJGP.png"/></div></div></figure><p id="7f71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">消费在起作用，公布吧。</p><h2 id="0606" class="jz ka hi bd kb kc kd ke kf kg kh ki kj ix kk kl km jb kn ko kp jf kq kr ks kt bi translated">创建发布者</h2><p id="3909" class="pw-post-body-paragraph im in hi io b ip ku ir is it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj hb bi translated">第一步是放置依赖项并填充application.properties，就像在消费者中所做的那样。我就不重复了，因为完全是一回事。</p><p id="8280" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们必须创建一个配置类:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="4e40" class="jz ka hi lk b fi lo lp l lq lr">import org.springframework.amqp.core.Queue;<br/>import org.springframework.beans.factory.annotation.Value;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.context.annotation.Configuration;<br/><br/>@Configuration<br/>public class SenderConfig {<br/><br/>    @Value("${queue.name}")<br/>    private String message;<br/><br/>    @Bean<br/>    public Queue queue() {<br/>        return new Queue(message, true);<br/>    }<br/><br/>}</span></pre><p id="b27a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该类创建一个队列bean，用于发送消息。<br/>就在一个实际发送消息的类之后:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="a801" class="jz ka hi lk b fi lo lp l lq lr">import org.springframework.amqp.core.Queue;<br/>import org.springframework.amqp.rabbit.core.RabbitTemplate;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.stereotype.Component;<br/><br/>@Component<br/>public class QueueSender {<br/><br/>    @Autowired<br/>    private RabbitTemplate rabbitTemplate;<br/><br/>    @Autowired<br/>    private Queue queue;<br/><br/>    public void send(String order) {<br/>        rabbitTemplate.convertAndSend(this.queue.getName(), order);<br/>    }<br/>}</span></pre><p id="2d09" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">并且在主类中还必须使用<a class="ae jk" href="http://twitter.com/EnableRabbit" rel="noopener ugc nofollow" target="_blank"> @EnableRabbit </a>注释:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="794d" class="jz ka hi lk b fi lo lp l lq lr">import org.springframework.amqp.rabbit.annotation.EnableRabbit;<br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/><br/>@EnableRabbit<br/>@SpringBootApplication<br/>public class AppApplication {<br/><br/>   public static void main(String[] args) {<br/>      SpringApplication.<em class="ls">run</em>(AppApplication.class, args);<br/>   }<br/><br/>}</span></pre><p id="0362" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了便于测试，我创建了一个带有<a class="ae jk" href="https://javarevisited.blogspot.com/2016/04/what-is-purpose-of-http-request-types-in-RESTful-web-service.html" rel="noopener ugc nofollow" target="_blank"> rest GET方法</a>的控制器来开始发送消息:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="764e" class="jz ka hi lk b fi lo lp l lq lr">import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/><br/>@RestController<br/>@RequestMapping("/teste")<br/>public class TesteController {<br/><br/>    @Autowired<br/>    private QueueSender queueSender;<br/><br/>    @GetMapping<br/>    public String send(){<br/>        queueSender.send("test message");<br/>        return "ok. done";<br/>    }<br/><br/>}</span></pre><p id="abb8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">完成后，让我们启动应用程序并在浏览器中打开该url:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/876ddf2569f41fa8b309b6c73b4118fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/0*VjQW3Lflcyfkf-Ka.png"/></div></figure><p id="7a7d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">结果如上图所示。在使用者端，消息被接收并处理:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lt"><img src="../Images/bf5639d397d343b96032f5972dc44907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GUqGdP9wHxbEeu3M.png"/></div></div></figure><p id="0b7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">到目前为止的要点是:我们将一些东西直接发送到队列，但是使用rabbitmq，建议将它发送到一个交换，然后这个交换发送到队列。</p><p id="f2c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">看起来像这样:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/addb32a0af8cb0b958d153966282500f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/0*QS-Y_6Iexfm8HfPR.png"/></div></figure><h2 id="c1f3" class="jz ka hi bd kb kc kd ke kf kg kh ki kj ix kk kl km jb kn ko kp jf kq kr ks kt bi translated">交换类型:</h2><ul class=""><li id="fbd7" class="jl jm hi io b ip ku it kv ix lw jb lx jf ly jj jq jr js jt bi translated"><strong class="io hj"> Direct </strong>:将消息传递给与之相连的队列，允许使用路由关键字。</li><li id="ddec" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">扇出(Fanout):这种类型主要用作广播，所有感兴趣的人都会接收到未经任何过滤的消息。路由关键字不支持。</li><li id="65ff" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><strong class="io hj">主题</strong>:它看起来像是前两者的混合，它允许发送到几个队列，也允许使用路由关键字，能够根据路由关键字中发送的值绑定消息。</li></ul><p id="a6ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">什么是路由关键字？</strong></p><p id="697e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">路由密钥</strong>:与消息一起发送的密钥，交换机用它来决定消息的路由位置。</p><p id="e98e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们做个交易吧？步骤非常简单:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/d2411af83ff63919de7f553f914c9e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SwpOR9U9XDJ_zf-7.png"/></div></figure><p id="c199" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们放一个路由键并将其绑定到一个队列。这也很简单:只需单击所创建的交易所的名称，并填写字段，如下例所示:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/8cd444cd3e3de0b1b0c87cb02b9c44c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zno0Ijx0gU21p2Up.png"/></div></figure><p id="6a2d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后只需点击绑定，你就完成了:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/9e4cceba6e458eb02e5d70df0523c96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/0*e3gKcF4Km5Cw6t03.png"/></div></figure><p id="8876" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在是时候编写一个代码，在交易所上发布一条消息，在那里创建的消费者会收到这条消息。</p><p id="48fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一件事是为rabbitmq创建一个配置类:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="3fed" class="jz ka hi lk b fi lo lp l lq lr">@Configuration<br/>public class RabbitMQConfig {<br/><br/>    @Bean<br/>    public ConnectionFactory connectionFactory() {<br/>        CachingConnectionFactory connectionFactory = new CachingConnectionFactory("localhost");<br/>        connectionFactory.setUsername("guest");<br/>        connectionFactory.setPassword("guest");<br/>        return connectionFactory;<br/>    }<br/><br/>    @Bean<br/>    public Queue testeQueue() {<br/>        return new Queue("teste", true);<br/>    }<br/><br/>    @Bean<br/>    DirectExchange exchange() {<br/>        return new DirectExchange("direct-exchange");<br/>    }<br/><br/>    @Bean<br/>    Binding testeBinding(Queue testeQueue, DirectExchange exchange) {<br/>        return BindingBuilder.<em class="ls">bind</em>(testeQueue).to(exchange).with("teste-routing-key");<br/>    }<br/>}</span></pre><p id="5d7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，在这个类中，我定义了一个队列、一个交换和队列的交换绑定。</p><p id="fc9b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">之后，我创建了一个控制器，以便于测试:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="8e99" class="jz ka hi lk b fi lo lp l lq lr">@RestController<br/>@RequestMapping("/teste")<br/>public class TesteController {<br/><br/>    public TesteController(RabbitTemplate queueSender) {<br/>        this.queueSender = queueSender;<br/>    }<br/><br/>    private final RabbitTemplate queueSender;<br/><br/>    @GetMapping<br/>    public String send() throws JsonProcessingException {<br/>        queueSender.convertAndSend("teste-exchange", "routing-key-teste", "test message");<br/>        return "ok. done";</span><span id="354e" class="jz ka hi lk b fi ma lp l lq lr">    }<br/>}</span></pre><p id="15b4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">瞧，当发送消息时，它将在监听队列的类中被接收，队列是我们在本文开始时创建的。</p><p id="2c75" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">放置标题:</strong></p><p id="aa76" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有一个更重要的细节:我们可以在发送的邮件中指定标题，如果你打开这个例子:</p><pre class="la lb lc ld fd lj lk ll lm aw ln bi"><span id="e4da" class="jz ka hi lk b fi lo lp l lq lr">import org.springframework.amqp.core.AmqpTemplate;<br/>import org.springframework.amqp.core.Message;<br/>import org.springframework.amqp.core.MessageProperties;<br/>import org.springframework.web.bind.annotation.GetMapping;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RestController;<br/></span><span id="706e" class="jz ka hi lk b fi ma lp l lq lr">@RestController<br/>@RequestMapping("/teste")<br/>public class TesteController {<br/><br/>    public TesteController(RabbitTemplate queueSender) {<br/>        this.queueSender = queueSender;<br/>    }<br/><br/>    private final RabbitTemplate queueSender;<br/><br/>    @GetMapping<br/>    public String send() throws JsonProcessingException {<br/><br/>        String mensagem = "test message";<br/><br/>        MessageProperties messageProperties = new MessageProperties();<br/>        messageProperties.setHeader("ultima", "sim");<br/>        Message message = new Message(mensagem.getBytes(), messageProperties);<br/><br/>        queueSender.convertAndSend("teste-exchange", "routing-key-teste", message);<br/>        return "ok. done";<br/>    }<br/><br/>}</span></pre><p id="4442" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不要觉得这个代码代码很丑呵呵，这只是一个概念证明。</p><p id="8de7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在监听器中，我们可以看到这个标题:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/d5ca71c1f09bf8e091e7d5ca434aea05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JP_OnvQovALCnjOW.png"/></div></figure><p id="479b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望能有所帮助。</p><p id="1fc9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这段代码在这里:【https://github.com/mmarcosab/rabbitmq-example T2】</p></div></div>    
</body>
</html>