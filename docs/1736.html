<html>
<head>
<title>How to introspect and find conceptual symmetry between classes in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Java中自省并发现类之间的概念对称性</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/how-to-introspect-and-find-conceptual-symmetry-between-classes-in-java-696999b7eeda?source=collection_archive---------3-----------------------#2021-11-15">https://medium.com/javarevisited/how-to-introspect-and-find-conceptual-symmetry-between-classes-in-java-696999b7eeda?source=collection_archive---------3-----------------------#2021-11-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2ae2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">演示用Eclipse集合构建的实用程序类<code class="du jd je jf jg b">ClassComparer</code>。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/4442c4038c1fdef94797078a39b30119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V1mbPbNwl92ux4JM"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated"><a class="ae jx" href="https://unsplash.com/@throughjackseyes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰克·弗伦奇</a>在<a class="ae jx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="807b" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">富API的挑战</h1><p id="6a93" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">丰富的API可能很棒。通过提供许多有用的通用行为，它们可以显著减少代码的重复。有时，类的不同实现具有相似的丰富的方法签名集。Java中的一些类在概念上是等价的，即使它们不共享定义该行为的公共父抽象。</p><p id="f2e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题是，作为人类，我们有时需要帮助来确定和理解概念上相同的类之间的细微差别。解析和比较Java源文件或Javadoc中长达数百行的文本既费力又容易出错。有时候我们会错过一些东西。电脑可以帮助我们，所以我们可以识别和理解模式。</p><p id="d812" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jx" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse Collections </a>是一个库，它的主要设计目标是在其API中提供良好的对称性。考虑到Eclipse集合API的规模，这个目标非常难以实现。Eclipse Collections API在过去18年中发展如此之快，我需要一些帮助来完全理解它。</p><h1 id="6fb8" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用于比较类的解决方案</h1><p id="83e0" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">几年前，我在一个实用程序类中编写了一些代码，用于比较两个类中的方法签名。该实用程序利用Java中可用的方法来自省类，以及Eclipse集合中可用的数据结构和算法来比较这些方法。</p><p id="4449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我写的比较类的实用程序没有什么特别令人惊奇的地方。我在以前的博客中分享过早期版本的源代码(链接到最后)。直到最近，当我不得不将代码复制到我当前的Eclipse Collections项目并修改它以便比较<code class="du jd je jf jg b">IntIterable</code>和<code class="du jd je jf jg b">RichIterable</code>时，我才决定将它包含在Eclipse Collections <code class="du jd je jf jg b">eclipse-collections-testutils</code>模块中是有用的，这样我就可以很容易地在任何需要比较丰富API的项目中使用它。</p><p id="e837" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该实用程序执行以下操作:</p><ul class=""><li id="621b" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">使用<code class="du jd je jf jg b">getMethods</code>读取每个<code class="du jd je jf jg b">Class</code>的方法</li><li id="5fc6" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">可选地使用<code class="du jd je jf jg b">getParameters</code>读取每个<code class="du jd je jf jg b">Method</code>的参数</li><li id="30c7" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">可以选择包含每个方法的返回类型</li><li id="ccd6" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">将每个方法的一个<code class="du jd je jf jg b">String</code>添加到两个<code class="du jd je jf jg b">MutableSortedSet</code>实例之一</li><li id="371e" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">计算两组方法的交集</li><li id="2de9" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">计算两组方法在两个方向上的差异</li><li id="4c6a" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">输出按字母顺序排序的方法，并按其首字母进行分组</li></ul><p id="93b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在名为<code class="du jd je jf jg b">ClassComparer</code>的实用程序类中还有一些其他有用的方法，但这是它的主要目的。</p><h2 id="fe52" class="lp jz hi bd ka lq lr ls ke lt lu lv ki iq lw lx km iu ly lz kq iy ma mb ku mc bi translated">保持简单</h2><p id="c940" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">该实用程序在两个类的方法签名之间创建一个等效的维恩图。聪明的地方在于，如果有的话，实用程序类将允许您在方法签名比较中可选地包括参数类型和返回类型。通过排除参数类型和返回类型，我们能够通过简单地比较方法名来确定两个类是否具有良好的概念对称性。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es md"><img src="../Images/f950330dddc5b2ae70dad7d53f93d56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLDII9cDuTqBqqZv8IHbrw.png"/></div></div></figure><h1 id="f43e" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">简单的比较</h1><p id="5f8b" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">作为比较的第一个例子，我将比较<code class="du jd je jf jg b">StringBuffer</code>和<code class="du jd je jf jg b">StringBuilder</code>。注意:我在本地Eclipse Collections项目中使用了这段代码，该项目目前使用的是Java 8。<code class="du jd je jf jg b">StringBuilder</code>是作为Java 5中<code class="du jd je jf jg b">StringBuffer</code>的替代物引入的，所以我们希望它们有相同的方法签名。从概念上讲，它们是相同的。当我们更深入地挖掘细节时，我们会发现它们有微妙的区别。</p><p id="6b8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是比较这两个类所需的代码，不包括参数类型或返回类型。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es me"><img src="../Images/765b3956a641e8211849c5ed45c37d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6fH0bDwDnur2jAdGHQutA.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">比较StringBuffer.class和StringBuilder.class</p></figure><p id="e829" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个特定的方法将进行比较，并输出一个文本版本的<code class="du jd je jf jg b">StringBuffer</code>和<code class="du jd je jf jg b">StringBuilder</code>类的交集和双向差。因为我使用了默认的构造函数，所以方法参数类型和返回类型被排除在比较之外。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mf"><img src="../Images/29ff8dc3d52dcfddd453a051cd6af222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgecasL9iO7Zplddw6WBlg.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">StringBuffer和StringBuilder的交集和差异的输出</p></figure><p id="e2c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们比较在方法中包含参数时的输出。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mg"><img src="../Images/9e13e7ba4e678ba9480c9fcb519e2202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STxC72TDYJs02TtKeWuzWA.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">将第一个标志设置为true可以包含方法参数类型</p></figure><p id="2f1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是包含方法参数的输出。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mh"><img src="../Images/b8a7c0a7c306ef8d2203c556b3f20706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9zg041q3V4QrNcGO4jm4g.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">使用参数类型比较StringBuffer和StringBuilder的输出</p></figure><p id="1cc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些类看起来还是一样的。因此，让我们通过将<code class="du jd je jf jg b">ClassComparer</code>构造函数中的第二个标志设置为<code class="du jd je jf jg b">true</code>来包含返回类型。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mi"><img src="../Images/1af98a8dd0fd577461b0f465228a666c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuORGbD7QtzXJbml_YT7og.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">将第二个标志设置为true可以包含方法返回类型</p></figure><p id="083a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在输出看起来大不相同了。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mj"><img src="../Images/d28b33f361695c6cf7f71a1b5e96974e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wxWgLMEh7ewx92BUCxkEfQ.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">使用参数和返回类型比较StringBuffer和StringBuilder的输出</p></figure><p id="e3f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多方法签名要么返回<code class="du jd je jf jg b">StringBuffer</code>要么返回<code class="du jd je jf jg b">StringBuilder</code>。两者都有一个名为<code class="du jd je jf jg b">AbstractStringBuilder</code>的父抽象，它定义了许多类似<code class="du jd je jf jg b">append</code>的方法，这些方法从两个子类中调用，并被覆盖以返回特定的返回类型。这就是为什么方法的数量在双向差异中显著增长。</p><h1 id="1cfc" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">一个实验性的Swing UI</h1><p id="916d" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">我决定构建一个快速原型Swing UI来显示<code class="du jd je jf jg b">ClassComparer</code>的交集和差异。Swing UI在快速比较差异方面更好，因为它使用三窗格列表视图，这或多或少模拟了维恩图，只是没有重叠的圆圈。</p><p id="3557" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是比较上面两个类的Swing UI的样子。</p><h2 id="058a" class="lp jz hi bd ka lq lr ls ke lt lu lv ki iq lw lx km iu ly lz kq iy ma mb ku mc bi translated">排除参数和返回类型</h2><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mk"><img src="../Images/19fc0ea3b3091839a55de5a43947b94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3mP02F50maMLk8KuLYbrw.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">Swing UI比较StringBuffer和StringBuilder，不包括参数和返回类型</p></figure><h2 id="37b5" class="lp jz hi bd ka lq lr ls ke lt lu lv ki iq lw lx km iu ly lz kq iy ma mb ku mc bi translated">包括参数类型</h2><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ml"><img src="../Images/8f0d6ea524211f1f2c5bd19b8ad3d426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDnGem03FMppe5AMAY98xQ.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">Swing UI比较StringBuffer和StringBuilder，仅包括参数类型</p></figure><h2 id="de46" class="lp jz hi bd ka lq lr ls ke lt lu lv ki iq lw lx km iu ly lz kq iy ma mb ku mc bi translated">包括参数和返回类型</h2><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mm"><img src="../Images/3e2baf1de54b6e4e76b82799d984a8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3HjQuILjHaWGMBHwwssqw.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">Swing UI比较StringBuffer和StringBuilder，包括参数和返回类型</p></figure><h1 id="fb91" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在Eclipse集合API中寻找不对称性</h1><p id="cbaf" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">为了说明在Eclipse集合上工作的开发人员如何使用这个实用程序来发现在改善对称性方面需要完成的潜在工作，我将比较一个原始集合接口和它在对象端的对等接口。</p><h2 id="61de" class="lp jz hi bd ka lq lr ls ke lt lu lv ki iq lw lx km iu ly lz kq iy ma mb ku mc bi translated"><code class="du jd je jf jg b">IntIterable</code>与<code class="du jd je jf jg b">RichIterable</code></h2><p id="7354" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">首先，让我们从纯概念的角度比较一下<code class="du jd je jf jg b">IntIterable</code>和<code class="du jd je jf jg b">RichIterable</code>的方法签名。我们可以通过在<code class="du jd je jf jg b">ClassComparer</code>上使用不带参数的构造函数来做到这一点。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mn"><img src="../Images/947236bec454d910e691c1f7bae08e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTetQqeqVimQ72JIFawFXw.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">比较不可改变的和可丰富的接口</p></figure><p id="8577" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出显示了基元集合父类型和对象集合父类型之间一些有趣的差异，甚至在概念级别。概念对称是我们在Eclipse集合中最关心的问题。显然，我们在这一领域有很多工作要做。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mo"><img src="../Images/b7e8343781586e70e567550fa3c1d61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sDZW9sMjM-D5thM3jbv18g.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">比较不可更改接口和可丰富接口的输出</p></figure><p id="9521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实验性的Swing UI中查看相同的输出，可以看到文本输出的一个优点，即按照方法的首字母对方法进行分组。在文本输出中不需要滚动，在三窗格Swing UI中，所有方法都不适合屏幕，所以需要滚动。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mp"><img src="../Images/0399f62b6e829b70d56c786bc3d78cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sr-_DLNSDwUs86KHhaVsJQ.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">Swing UI比较了不可改变和可丰富</p></figure><p id="8a94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看当我们在比较中向方法添加参数类型和返回类型时，文本输出会发生什么。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mq"><img src="../Images/1bdfd735fc5e88ad8fe5979995d6b310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SYixWbvTqpwZQTvF97EM1w.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">输出的第1部分比较了不可改变和可丰富，包括参数和返回类型</p></figure><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mr"><img src="../Images/802c6df50620520f07fbddfc7bdb27f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmMbPtU4KiWAhq_rX6M-xg.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">输出的第2部分比较了不可改变和可丰富，包括参数和返回类型</p></figure><p id="7515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，在Eclipse集合<code class="du jd je jf jg b">RichIterable</code>和<code class="du jd je jf jg b">IntIterable</code>接口中有相当多的方法被重载。使用不带方法参数和返回类型的概念视图隐藏了这些细节。这个细节很重要，所以两种观点都有价值。</p><p id="4560" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是Swing UI在这个更大的比较中的样子。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ms"><img src="../Images/6e1a70dc8eaba154461555957d1367b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FS_A-VgYWZTQRIqEL6khkQ.png"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated">Swing UI比较了不可改变和可丰富，包括参数和返回类型</p></figure><p id="983f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Swing UI对于这种特殊的比较可能更有用，因为在这两种情况下都需要滚动。</p><h1 id="2d14" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">敬请期待</h1><p id="d549" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated"><code class="du jd je jf jg b">ClassComparer</code>的代码将在即将发布的Eclipse Collections 11.0版本中提供。它位于<code class="du jd je jf jg b">eclipse-collections-testutils</code>模块中。如果您想查看代码，现在可以在下面链接的Eclipse Collections repo中找到。</p><div class="mt mu ez fb mv mw"><a href="https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections-testutils/src/main/java/org/eclipse/collections/impl/test/ClassComparer.java" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">主eclipse/eclipse-collections上的eclipse-collections/class comparer . Java</h2><div class="nd l"><h3 class="bd b fi z dy nb ea eb nc ed ef dx translated">Eclipse Collections是一个面向Java的集合框架，具有优化的数据结构和丰富的、功能性的…</h3></div><div class="ne l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">github.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk jr mw"/></div></div></a></div><p id="aa4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的博客中有一个旧版本的代码，这是我第一次开始探索如何更容易理解富API之间的差异。</p><div class="mt mu ez fb mv mw"><a rel="noopener follow" target="_blank" href="/oracledevs/graduating-from-minimal-to-rich-java-apis-c50192c8322f"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">从最简到丰富的Java APIs</h2><div class="nd l"><h3 class="bd b fi z dy nb ea eb nc ed ef dx translated">将简单易学与减少代码重复相结合，以提高生产率。</h3></div><div class="ne l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">medium.com</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk jr mw"/></div></div></a></div><p id="3dae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经使用了<code class="du jd je jf jg b">ClassComparer</code>工具来生成这个博客中的所有例子。Swing UI代码是一个单独类的一部分，还没有包含在Eclipse集合中。我需要与其他Eclipse集合提交者讨论包含swing代码的可能性。Eclipse Collections <code class="du jd je jf jg b">eclipse-collections-testutils</code>模块包含任何UI代码是独一无二的，所以我不能对它的到来做出任何承诺。现在，这里是实验性Swing UI代码的要点。</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="nm nn l"/></div></figure><p id="8270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你觉得这很有用。感谢阅读！</p><p id="c5fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="no">我是</em><a class="ae jx" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="no">Eclipse Collections</em></a><em class="no">OSS项目在</em><a class="ae jx" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="no">Eclipse Foundation</em></a><em class="no">的项目负责人。</em> <a class="ae jx" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="no">月食收藏</em> </a> <em class="no">是开投</em> <a class="ae jx" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="no">投稿</em> </a> <em class="no">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p><p id="6a3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能想探索的其他Java资源文章</p><div class="mt mu ez fb mv mw"><a rel="noopener follow" target="_blank" href="/javarevisited/the-java-programmer-roadmap-f9db163ef2c2"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">2021年Java程序员路线图</h2><div class="nd l"><h3 class="bd b fi z dy nb ea eb nc ed ef dx translated">2021年成为Java开发人员的图解指南，包含相关课程的链接</h3></div><div class="ne l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">medium.com</p></div></div><div class="nf l"><div class="np l nh ni nj nf nk jr mw"/></div></div></a></div><div class="mt mu ez fb mv mw"><a rel="noopener follow" target="_blank" href="/javarevisited/11-advanced-core-java-online-courses-to-join-in-2021-46011661257a"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">2021年将加入11门高级核心Java在线课程</h2><div class="nd l"><h3 class="bd b fi z dy nb ea eb nc ed ef dx translated">这些是核心java开发人员学习多线程、集合、JVM等技能的最佳在线课程</h3></div><div class="ne l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">medium.com</p></div></div><div class="nf l"><div class="nq l nh ni nj nf nk jr mw"/></div></div></a></div><div class="mt mu ez fb mv mw"><a rel="noopener follow" target="_blank" href="/javarevisited/7-best-webflux-and-reactive-spring-boot-courses-for-java-programmers-33b7c6fa8995"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">面向Java程序员的7门最佳WebFlux和反应式Spring Boot课程</h2><div class="nd l"><h3 class="bd b fi z dy nb ea eb nc ed ef dx translated">我最喜欢的课程2021年学习Java中的反应式编程使用WebFlux、RxJava和反应式Spring Boot来自…</h3></div><div class="ne l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">medium.com</p></div></div><div class="nf l"><div class="nr l nh ni nj nf nk jr mw"/></div></div></a></div></div></div>    
</body>
</html>