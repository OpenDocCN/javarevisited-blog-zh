<html>
<head>
<title>How to print nodes of a binary search tree in sorted order?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何按排序顺序打印二叉查找树的节点？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/how-to-print-nodes-of-a-binary-search-tree-in-sorted-order-8a4e52eb8856?source=collection_archive---------0-----------------------#2020-04-02">https://medium.com/javarevisited/how-to-print-nodes-of-a-binary-search-tree-in-sorted-order-8a4e52eb8856?source=collection_archive---------0-----------------------#2020-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://www.educative.io/collection/5668639101419520/5671464854355968?affiliate_id=5073518643380224"><div class="er es if"><img src="../Images/19481b9b72aa54fb935e33b8bafa5bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nC8Km4HNs8YTsisy.png"/></div></a><p class="im in et er es io ip bd b be z dx translated"><a class="ae iq" href="https://www.educative.io/collection/5668639101419520/5671464854355968?affiliate_id=5073518643380224" rel="noopener ugc nofollow" target="_blank">寻找编码面试:编码问题的模式</a></p></figure><p id="f80b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">大家好，最近在一次电话Java采访中，我的一位读者被问到关于<strong class="it hj">如何按顺序打印一个二叉查找树的所有节点。不幸的是，他不知道<a class="ae iq" href="https://javarevisited.blogspot.com/2016/08/inorder-traversal-of-binary-tree-in-java-recursion-iteration-example.html" rel="noopener ugc nofollow" target="_blank">可以用来打印排序后的节点，他在采访后问我。</a></strong></p><p id="cfb7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">以前我已经分享过<a class="ae iq" rel="noopener" href="/javarevisited/7-best-courses-to-learn-data-structure-and-algorithms-d5379ae2588?source=---------18------------------"> <strong class="it hj">最佳数据结构课程</strong> </a>和<a class="ae iq" rel="noopener" href="/hackernoon/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0">数据结构面试题</a>，今天我就来教大家一些有趣又有用的二叉树算法，叫做InOrer遍历。我们还将看到使用Java编程语言的实现。</p><p id="702d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">有序</strong>遍历是遍历二叉树数据结构的三种流行方式之一，另外两种是<a class="ae iq" href="http://www.java67.com/2016/07/binary-tree-preorder-traversal-in-java-without-recursion.html" rel="noopener ugc nofollow" target="_blank">前序</a>和<a class="ae iq" href="http://www.java67.com/2016/10/binary-tree-post-order-traversal-in.html" rel="noopener ugc nofollow" target="_blank">后序</a>。在有序遍历算法中，首先浏览左边的子树，然后是根，最后是右边子树上的节点。</p><p id="14e4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">您从根节点开始遍历，然后转到左侧节点，然后再次转到左侧节点，直到到达一个叶节点。在那个时间点，您打印节点的值或标记它被访问过，并移到右边的子树。继续相同的算法，直到访问了二叉树的所有节点。</p><p id="b50f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">InOrder遍历也称为<strong class="it hj">左节点右</strong>或<strong class="it hj">左根右</strong>遍历或<strong class="it hj"> LNR </strong>遍历算法。</p><p id="8ee1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">类似于<a class="ae iq" href="http://www.java67.com/2016/07/how-to-implement-preorder-traversal-of-binary-tree-in-java.html" rel="noopener ugc nofollow" target="_blank">预排序算法</a>，它也是深度优先算法，因为它在探索兄弟之前探索二叉树的深度。因为它是基本的二叉树算法之一，所以在<a class="ae iq" href="https://codeburst.io/100-coding-interview-questions-for-programmers-b1cf74885fb7" rel="noopener" target="_blank">编程面试</a>中很受欢迎。</p><div class="jp jq ez fb jr js"><a href="https://codeburst.io/100-coding-interview-questions-for-programmers-b1cf74885fb7" rel="noopener follow" target="_blank"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hj fi z dy jx ea eb jy ed ef hh bi translated">程序员的100+编码面试问题</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">解决这些常见的编码问题，以便在下一次编程工作面试中表现出色。</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">codeburst.io</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ik js"/></div></div></a></div><p id="d9c3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这些遍历算法也是学习更高级的<a class="ae iq" rel="noopener" href="/javarevisited/20-binary-tree-algorithms-problems-from-coding-interviews-c5e5a384df30">二叉树算法</a>的基础，因此每个程序员都应该学习、理解并知道如何实现顺序和其他遍历算法。</p><p id="3880" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在Java或任何编程语言中实现inOrder遍历算法的最简单方法是使用<a class="ae iq" href="https://javarevisited.blogspot.com/2016/03/how-to-reverse-arraylist-in-java-using-recursion.html" rel="noopener ugc nofollow" target="_blank">递归</a>。由于二叉树是一种递归数据结构，递归是解决基于树的问题的自然选择。BinaryTree类中的方法实现了使用递归遍历二叉树的逻辑。</p><p id="a87f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">从采访的角度来看，InOrder遍历是非常重要的，因为它也打印了一个排序顺序为的二叉查找树的节点，但前提是给定的树是一个<a class="ae iq" href="http://javarevisited.blogspot.com/2015/10/how-to-implement-binary-search-tree-in-java-example.html" rel="noopener ugc nofollow" target="_blank">二叉查找树</a>。</p><p id="15ee" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果你还记得，在BST中，左子树中节点的值低于根，右子树上节点的值高于根。按顺序遍历的字面意思是按顺序，也就是说，节点是按顺序或排序后的顺序打印的。</p><p id="043e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">顺便说一下，尽管这三种算法(前序、按序和后序)是流行的二叉树遍历算法，但它们不是唯一的。你也有其他广度优先的方法来遍历二叉树，比如层次顺序遍历(参见<a class="ae iq" href="https://click.linksynergy.com/fs-bin/click?id=JVFxdTr9V80&amp;subid=0&amp;offerid=323058.1&amp;type=10&amp;tmpid=14538&amp;RD_PARM1=https%3A%2F%2Fwww.udemy.com%2Fdata-structures-and-algorithms-deep-dive-using-java%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">数据结构和算法:深度挖掘</strong> </a>)。</p><figure class="km kn ko kp fd ij er es paragraph-image"><a href="https://click.linksynergy.com/fs-bin/click?id=JVFxdTr9V80&amp;subid=0&amp;offerid=323058.1&amp;type=10&amp;tmpid=14538&amp;RD_PARM1=https%3A%2F%2Fwww.udemy.com%2Fdata-structures-and-algorithms-deep-dive-using-java%2F"><div class="er es kl"><img src="../Images/7741275d5d6a83ada2e1583de319cd2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*n8CuaH5abqg7_ez3.png"/></div></a></figure><h1 id="8aa4" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">实现二叉树有序遍历的递归算法</h1><p id="6d0f" class="pw-post-body-paragraph ir is hi it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hb bi translated">顺序遍历的递归算法非常简单。你只需要按照你想要访问树的顺序调用BinaryTree类的inOrder()方法。最重要的是包含基本情况，这是任何递归算法的关键。</p><p id="1a48" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">例如，在这个问题中，基本情况是您到达了叶节点，没有更多的节点要探索，在那个时间点递归开始减速。下面是使用有序遍历遍历二叉树的具体步骤:</p><ol class=""><li id="6e2c" class="lt lu hi it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb bi translated">访问左侧节点</li><li id="ff6e" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb bi translated">打印根的值</li><li id="cf95" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb bi translated">访问正确的节点，下面是在Java中使用递归实现该算法的示例代码:</li></ol><pre class="km kn ko kp fd mh kk mi mj aw mk bi"><span id="ef03" class="ml kr hi kk b fi mm mn l mo mp">private void inOrder(TreeNode node) {<br/>    if (node == null) {<br/>      return;<br/>    }</span><span id="7a50" class="ml kr hi kk b fi mq mn l mo mp">    inOrder(node.left);<br/>    System.out.printf("%s ", node.data);<br/>    inOrder(node.right);<br/>}</span></pre><p id="dd27" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">类似于<a class="ae iq" href="http://javarevisited.blogspot.com/2016/07/binary-tree-preorder-traversal-in-java-using-recursion-iteration-example.html" rel="noopener ugc nofollow" target="_blank">最后一个例子</a>中的preOrder()方法，还有另一个<code class="du kh ki kj kk b">inOrder()</code>方法，它将inorder遍历公开，并调用这个私有方法来实际执行InOrder遍历。</p><p id="4837" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这是编写接受输入的递归方法的标准方式，它使得客户端调用该方法更容易。</p><pre class="km kn ko kp fd mh kk mi mj aw mk bi"><span id="79e8" class="ml kr hi kk b fi mm mn l mo mp">public void inOrder() {<br/>    inOrder(root);<br/>}</span></pre><p id="7d4e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">你可以看到我们从root开始，然后用<code class="du kh ki kj kk b">node.left</code>递归调用<code class="du kh ki kj kk b">inOrder() </code>方法，这意味着我们在左子树上向下，直到我们点击<code class="du kh ki kj kk b">node == null</code>，这意味着最后一个节点是一个<a class="ae iq" href="https://www.java67.com/2020/02/top-40-binary-tree-interview-questions.html" rel="noopener ugc nofollow" target="_blank">叶节点</a>。</p><p id="05e3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">此时，<code class="du kh ki kj kk b">inOrder()</code>方法将返回并执行下一行，打印node.data。之后，这又是一个对node.right的递归<code class="du kh ki kj kk b">inOrder()</code>调用，这将再次启动相同的过程。</p><p id="9418" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">您也可以查看Pluralsight上的<a class="ae iq" href="https://pluralsight.pxf.io/c/1193463/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fads-part1" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">数据结构和算法第一部分和第二部分</strong> </a>课程，了解更多关于算法以及如何设计自己的算法。</p><figure class="km kn ko kp fd ij er es paragraph-image"><a href="https://pluralsight.pxf.io/c/1193463/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fads-part1"><div class="er es mr"><img src="../Images/3a60ecc399c1cbd62f407a4853dc50f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*PVlQyAs3nGIsT_Jb.jpg"/></div></a></figure><p id="6ce8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">顺便说一句，你需要一个Pluralsight会员才能参加这个课程，费用大约是每月29美元或者每年<a class="ae iq" href="https://pluralsight.pxf.io/c/1193463/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Fpricing" rel="noopener ugc nofollow" target="_blank">299美元</a>(节省14%)。我有一个，我也建议所有开发人员都有这个计划，因为<a class="ms mt ge" href="https://medium.com/u/50a6c7ef7431?source=post_page-----8a4e52eb8856--------------------------------" rel="noopener" target="_blank"> Pluralsight </a>就像软件开发人员的网飞。</p><p id="5d07" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">它有5000多门高质量的课程，涵盖所有最新的主题。因为我们程序员每天都要学习新的东西，所以299美元的投资是不错的。</p><p id="101c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">顺便说一下，它还提供了10天的免费试用，没有任何义务，允许您观看200小时的内容。注册那个<a class="ae iq" href="http://pluralsight.pxf.io/c/1193463/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Flearn" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> 10天免费试用</strong> </a>，就可以免费观看这些课程。</p><div class="jp jq ez fb jr js"><a href="https://pluralsight.pxf.io/c/1193463/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Flearn" rel="noopener  ugc nofollow" target="_blank"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hj fi z dy jx ea eb jy ed ef hh bi translated">个人技术技能|多视角</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">培养你在职业生涯中更快发展所需的技术技能。掌握最新的技术与数以千计的…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">pluralsight.pxf.io</p></div></div><div class="kb l"><div class="mu l kd ke kf kb kg ik js"/></div></div></a></div></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><h1 id="1392" class="kq kr hi bd ks kt nc kv kw kx nd kz la lb ne ld le lf nf lh li lj ng ll lm ln bi translated">Java中二叉树的有序遍历</h1><p id="6bf4" class="pw-post-body-paragraph ir is hi it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hb bi translated">下面是我们在Java中对inorder遍历算法的完整解决方案。这个程序使用一个<a class="ae iq" href="https://javarevisited.blogspot.com/2016/12/how-to-count-number-of-leaf-nodes-in-java-recursive-iterative-algorithm.html" rel="noopener ugc nofollow" target="_blank">递归算法</a>来打印一个二叉树的所有节点的值。</p><p id="c050" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">正如我之前告诉你的，在有序遍历期间，首先打印左子树的值，然后是根和右子树。如果你对迭代算法感兴趣，可以进一步查看这个<a class="ae iq" href="http://javarevisited.blogspot.com/2016/08/inorder-traversal-of-binary-tree-in-java-recursion-iteration-example.html" rel="noopener ugc nofollow" target="_blank">教程</a>实现无递归的顺序遍历。</p><pre class="km kn ko kp fd mh kk mi mj aw mk bi"><span id="f7b3" class="ml kr hi kk b fi mm mn l mo mp">import java.util.Stack;</span><span id="5e2e" class="ml kr hi kk b fi mq mn l mo mp">/*<br/> * Java Program to traverse a binary search tree<br/> * using inorder traversal without recursion <br/> * and print all nodes in sorted order<br/> * In InOrder traversal first left node is visited, followed by root<br/> * and right node.<br/> *<br/> * input:<br/> *      40<br/> *     /\<br/> *    20   50<br/> *   / \    \<br/> *  10  30   60<br/> * /   /  \<br/> * 5  67  78<br/> *<br/> * output: 5 10 20 30 40 50 60 67 78<br/> */</span><span id="bb82" class="ml kr hi kk b fi mq mn l mo mp">public class Main {</span><span id="25ee" class="ml kr hi kk b fi mq mn l mo mp">  public static void main(String[] args) throws Exception {</span><span id="9237" class="ml kr hi kk b fi mq mn l mo mp">    // construct the binary tree given in question<br/>    BinaryTree bt = BinaryTree.create();</span><span id="d3be" class="ml kr hi kk b fi mq mn l mo mp">    // traversing binary tree using InOrder traversal using recursion<br/>    System.out<br/>        .println("printing nodes of binary tree on InOrder using recursion");</span><span id="f736" class="ml kr hi kk b fi mq mn l mo mp">    bt.inOrder();<br/>  }</span><span id="eb99" class="ml kr hi kk b fi mq mn l mo mp">}</span><span id="b1c7" class="ml kr hi kk b fi mq mn l mo mp">class BinaryTree {<br/>  static class TreeNode {<br/>    String data;<br/>    TreeNode left, right;</span><span id="13b0" class="ml kr hi kk b fi mq mn l mo mp">    TreeNode(String value) {<br/>      this.data = value;<br/>      left = right = null;<br/>    }</span><span id="619a" class="ml kr hi kk b fi mq mn l mo mp">  }</span><span id="9cd4" class="ml kr hi kk b fi mq mn l mo mp">  // root of binary tree<br/>  TreeNode root;</span><span id="b40c" class="ml kr hi kk b fi mq mn l mo mp">  /**<br/>   * traverse the binary tree on InOrder traversal algorithm<br/>   */<br/>  public void inOrder() {<br/>    inOrder(root);<br/>  }</span><span id="2005" class="ml kr hi kk b fi mq mn l mo mp">  private void inOrder(TreeNode node) {<br/>    if (node == null) {<br/>      return;<br/>    }</span><span id="3a41" class="ml kr hi kk b fi mq mn l mo mp">    inOrder(node.left);<br/>    System.out.printf("%s ", node.data);<br/>    inOrder(node.right);<br/>  }</span><span id="e1b7" class="ml kr hi kk b fi mq mn l mo mp">  /**<br/>   * Java method to create binary tree with test data<br/>   *<br/>   * @return a sample binary tree for testing<br/>   */<br/>  public static BinaryTree create() {<br/>    BinaryTree tree = new BinaryTree();<br/>    TreeNode root = new TreeNode("40");<br/>    tree.root = root;<br/>    tree.root.left = new TreeNode("20");<br/>    tree.root.left.left = new TreeNode("10");<br/>    tree.root.left.left.left = new TreeNode("5");</span><span id="7caf" class="ml kr hi kk b fi mq mn l mo mp">    tree.root.left.right = new TreeNode("30");<br/>    tree.root.right = new TreeNode("50");<br/>    tree.root.right.right = new TreeNode("60");<br/>    tree.root.left.right.left = new TreeNode("67");<br/>    tree.root.left.right.right = new TreeNode("78");</span><span id="c96b" class="ml kr hi kk b fi mq mn l mo mp">    return tree;<br/>  }</span><span id="e068" class="ml kr hi kk b fi mq mn l mo mp">}</span></pre><p id="3b51" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">输出</strong> <br/> <code class="du kh ki kj kk b"> printing nodes of the binary tree on InOrder using recursion</code> <br/> <code class="du kh ki kj kk b"> 5 10 20 30 67 78 40 50 60</code></p><p id="f15e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这就是关于<strong class="it hj">如何使用递归</strong>在Java中实现二叉树的有序遍历。你可以看到代码非常类似于前序遍历，唯一的区别是我们递归调用方法的顺序。在这种情况下，我们首先调用<code class="du kh ki kj kk b">inOrder(node.left)</code>，然后打印节点的值。</p><p id="e2a7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">值得记住的是，按顺序遍历是一种深度优先算法，如果给定的二叉树是一个二叉查找树，则按排序顺序打印树节点。</p><p id="d4c6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在本文的下一部分，我将分享无递归的有序遍历，同时，您可以尝试练习以下数据结构和二叉树问题。</p><p id="634d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">进一步学习</strong> <br/> <a class="ae iq" href="https://click.linksynergy.com/fs-bin/click?id=JVFxdTr9V80&amp;subid=0&amp;offerid=323058.1&amp;type=10&amp;tmpid=14538&amp;RD_PARM1=https%3A%2F%2Fwww.udemy.com%2Fdata-structures-and-algorithms-deep-dive-using-java%2F" rel="noopener ugc nofollow" target="_blank">数据结构和算法:深度挖掘使用Java </a> <br/> <a class="ae iq" href="https://pluralsight.pxf.io/c/1193463/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fads-part1" rel="noopener ugc nofollow" target="_blank">算法和数据结构—第一部分和第二部分</a><br/><a class="ae iq" href="https://learning.javaspecialists.eu/courses/data-structures?affcode=92815_johrd7r8" rel="noopener ugc nofollow" target="_blank">Java 9中的数据结构由亨氏Kabutz </a> <br/> <a class="ae iq" href="http://www.amazon.com/Cracking-Coding-Interview-6th-Edition/dp/0984782850/?tag=javamysqlanta-20" rel="noopener ugc nofollow" target="_blank">破解编码面试— 189题及解答</a> <br/> <a class="ae iq" href="http://www.java67.com/2018/06/data-structure-and-algorithm-interview-questions-programmers.html" rel="noopener ugc nofollow" target="_blank"> 100+数据结构和算法题给程序员的</a> <br/> <a class="ae iq" href="http://www.java67.com/2018/05/top-75-programming-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank"> 75+编程和编码面试题</a> <br/> <a class="ae iq" href="https://www.educative.io/collection/5668639101419520/5671464854355968?affiliate_id=5073518643380224" rel="noopener ugc nofollow" target="_blank"/></p><p id="d090" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">面向Java程序员的其他<strong class="it hj">数据结构和算法教程</strong></p><ul class=""><li id="3511" class="lt lu hi it b iu iv iy iz jc lv jg lw jk lx jo nh lz ma mb bi translated">每个程序员都应该读的10本算法书(<a class="ae iq" href="http://www.java67.com/2015/09/top-10-algorithm-books-every-programmer-read-learn.html" rel="noopener ugc nofollow" target="_blank">列举</a>)</li><li id="3865" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">如何用Java实现快速排序算法？(<a class="ae iq" href="http://javarevisited.blogspot.com/2014/08/quicksort-sorting-algorithm-in-java-in-place-example.html" rel="noopener ugc nofollow" target="_blank">解</a>)</li><li id="6b33" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">用Java学习数据结构和算法的5本书？(<a class="ae iq" href="http://javarevisited.blogspot.com/2015/07/5-data-structure-and-algorithm-books-best-must-read.html" rel="noopener ugc nofollow" target="_blank">书籍</a>)</li><li id="adf7" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">如何用Java实现一个二分搜索法算法？(<a class="ae iq" href="http://www.java67.com/2016/05/java-program-to-perform-binary-search-without-recursion.html" rel="noopener ugc nofollow" target="_blank">解</a></li><li id="288b" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">如何在一个和等于给定一个数的整数数组上找到所有对？(<a class="ae iq" href="http://javarevisited.blogspot.sg/2014/08/how-to-find-all-pairs-in-array-of-integers-whose-sum-equal-given-number-java.html" rel="noopener ugc nofollow" target="_blank">解</a></li><li id="247b" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">如何在Java中原地反转数组？(<a class="ae iq" href="http://www.java67.com/2016/01/java-program-to-reverse-array-in-place.html" rel="noopener ugc nofollow" target="_blank">解</a>)</li><li id="a94a" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">如何在Java中不使用递归来反转一个链表？(<a class="ae iq" href="http://www.java67.com/2016/07/how-to-reverse-singly-linked-list-in-java-example.html" rel="noopener ugc nofollow" target="_blank">解</a>)</li><li id="2f1a" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">如何在Java中实现插入排序？(<a class="ae iq" href="http://www.java67.com/2014/09/insertion-sort-in-java-with-example.html" rel="noopener ugc nofollow" target="_blank">解</a>)</li><li id="056c" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">如何在1到100的数组中找到缺失的数字？(<a class="ae iq" href="http://javarevisited.blogspot.sg/2014/11/how-to-find-missing-number-on-integer-array-java.html" rel="noopener ugc nofollow" target="_blank">解决方案</a>)</li><li id="e210" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">如何在Java中求单链表的长度？(<a class="ae iq" href="http://javarevisited.blogspot.sg/2016/05/how-do-you-find-length-of-singly-linked.html" rel="noopener ugc nofollow" target="_blank">解决方案</a>)</li><li id="c432" class="lt lu hi it b iu mc iy md jc me jg mf jk mg jo nh lz ma mb bi translated">15个常见的数据结构与算法面试问题(<a class="ae iq" href="http://javarevisited.blogspot.com/2015/07/5-data-structure-and-algorithm-books-best-must-read.html" rel="noopener ugc nofollow" target="_blank">列举</a>)</li></ul><p id="a690" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果你有什么建议可以让这个算法变得更好，欢迎提出来。面试官喜欢那些提出自己的算法或者对流行算法有所触动的人。</p><p id="b0dd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> P.S. </strong> —如果你不介意从免费资源中学习，那么你也可以看看我为Java开发人员提供的<a class="ae iq" href="https://javarevisited.blogspot.com/2018/01/top-5-free-data-structure-and-algorithm-courses-java--c-programmers.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">免费数据结构和算法课程</strong> </a>列表。</p><div class="jp jq ez fb jr js"><a rel="noopener follow" target="_blank" href="/javarevisited/top-10-free-data-structure-and-algorithms-courses-for-beginners-best-of-lot-ad807cc55f7a"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hj fi z dy jx ea eb jy ed ef hh bi translated">面向初学者的10大免费数据结构和算法课程——最好的</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">算法和数据结构是计算机科学的两个最基本和最重要的课题，是计算机科学的基础</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="ni l kd ke kf kb kg ik js"/></div></div></a></div><div class="jp jq ez fb jr js"><a rel="noopener follow" target="_blank" href="/javarevisited/10-best-books-for-data-structure-and-algorithms-for-beginners-in-java-c-c-and-python-5e3d9b478eb1"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hj fi z dy jx ea eb jy ed ef hh bi translated">Java、C/C++和Python初学者的10本最佳数据结构和算法书籍</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">算法是语言不可知的，任何称职的程序员都应该能够将它们转换成他们自己的代码…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="nj l kd ke kf kb kg ik js"/></div></div></a></div><blockquote class="nk nl nm"><p id="044f" class="ir is nn it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hb bi translated">如果你不是媒体成员，我强烈推荐你加入媒体，阅读不同领域伟大作家的精彩故事。你可以<strong class="it hj">在这里加入介质</strong><a class="ae iq" rel="noopener" href="/@somasharma_81597/membership"><strong class="it hj"/></a></p></blockquote></div></div>    
</body>
</html>