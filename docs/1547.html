<html>
<head>
<title>GCP- How to achieve High-Performance Synchronous Pull with Pub/Sub and Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP-如何通过发布/订阅和Spring Boot实现高性能同步拉取</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/gcp-how-to-achieve-high-performance-synchronous-pull-with-pub-sub-and-spring-boot-12cb220c4d65?source=collection_archive---------0-----------------------#2021-09-10">https://medium.com/javarevisited/gcp-how-to-achieve-high-performance-synchronous-pull-with-pub-sub-and-spring-boot-12cb220c4d65?source=collection_archive---------0-----------------------#2021-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5edb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GCP发布插曲</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4699b6979aac1eb3a00879e41ff18043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPrhk7WL9vXJ6ksXioa8ZQ.jpeg"/></div></div></figure><h1 id="2ab4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍</h1><p id="f604" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">谷歌云平台(<a class="ae ks" rel="noopener" href="/javarevisited/5-best-courses-to-learn-google-cloud-platform-gcp-in-2021-169093a3771a"> GCP </a>)提供了一套云计算服务，运行在谷歌内部用于终端用户产品的相同基础设施上。</p><p id="7a7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了增强事件驱动系统和流分析的消息传递和接收能力，<a class="ae ks" href="https://javarevisited.blogspot.com/2019/07/top-5-google-cloud-platform-gcp-courses-certifications-online.html#axzz6iNNhKZui" rel="noopener ugc nofollow" target="_blank"> GCP </a>提供了发布/订阅服务。它提供了可扩展的、有序的消息传递，具有拉和推模式、自动扩展和自动供应，以及许多其他很酷的功能。欲了解更多信息，请访问<a class="ae ks" href="https://cloud.google.com/pubsub" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="8154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于订阅发布/订阅主题，google cloud提供了两种订阅模式。首先是<a class="ae ks" href="https://cloud.google.com/pubsub/docs/pull#streamingpull" rel="noopener ugc nofollow" target="_blank">流拉</a>，如果您需要高吞吐量/速度，并且没有太多的处理接收到的消息，这是非常好的。</p><p id="9bdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后是<a class="ae ks" href="https://cloud.google.com/pubsub/docs/pull#synchronous_pull" rel="noopener ugc nofollow" target="_blank">同步拉取</a>，这比“流拉取”慢得多，但如果您有一些处理逻辑，需要对消息数量进行限制，准确地说，每个拉取请求有1000条消息，这就更好、更合适了。在本文中，我将介绍一种方法，使这个选项<em class="la">非常快</em>，同时仍然享受它带来的好处。</p><h1 id="8f30" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用例</h1><p id="e35d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我在爱马仕的团队主要与信息和经纪人打交道，我们总是把他们从A地转移到B地，或者从任何地方转移到任何地方。不久前，我接了一个任务，我们需要在消息所在的发布/订阅中的主题之间建立一个连接，并将它们移动到我们的ActiveMQ代理。</p><p id="139a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这项任务最重要的验收标准是速度要快，不低于每小时1000万条消息。</p><p id="760c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着发布/订阅中的消息只有在成功提交给我们的ActiveMQ代理时才能被确认。所以我必须从Pub/Sub中提取消息，将它们发送给代理，成功提交这个事务，然后确认消息。</p><h1 id="74e8" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设计</h1><p id="4a64" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">所以我前面提到过，同步Pub/Sub的每个Pull请求不能检索1000条以上的消息。因此，它会很慢，不会满足我的标准。幸运的是，这些文件提到了以下几点:</p><blockquote class="lb lc ld"><p id="9bfe" class="if ig la ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated">请注意，要实现同步拉的低消息传递延迟，有许多同时未完成的拉请求是很重要的。随着主题吞吐量的增加，需要更多的拉请求。</p></blockquote><p id="682f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的关键词是同步PRs。因此，我决定设计这个任务，并利用<a class="ae ks" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html" rel="noopener ugc nofollow" target="_blank"> ThreadPoolExecutor </a>来拥有我想要的尽可能多的并发PRs。</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/04/difference-between-atomic-volatile-and-synchronized-in-java-multi-threading.html"><div class="er es lh"><img src="../Images/8df282b9edbd67006e25540d9aaacad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UywAgOJ-JXlCCqADlE4FGw.jpeg"/></div></a><p class="li lj et er es lk ll bd b be z dx translated">线程池执行器图</p></figure><p id="9c9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线程池执行器允许您定义一个线程池。这些线程坐在那里等待工作(任务)，然后您开始向池提交任务。然后这个<a class="ae ks" href="https://javarevisited.blogspot.sg/2013/07/how-to-create-thread-pools-in-java-executors-framework-example-tutorial.html#ixzz5EAhFySdA" rel="noopener ugc nofollow" target="_blank">池</a>中的一个自由线程将从池中弹出一个任务并开始处理它。这个设置最酷的一点是，所有这些都已经为您配置好了，您只需要两行代码来设置这样的需求，请看这个例子。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h1 id="85b9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">履行</h1><p id="0b11" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">有了executor服务，我将订阅代码放在一个<strong class="ih hj">任务</strong>中，这个任务只是一个实现那个<a class="ae ks" href="https://www.java67.com/2016/01/7-differences-between-extends-thread-vs-implements-Runnable-java.html" rel="noopener ugc nofollow" target="_blank"> Runnable </a>接口的类。差不多就是这样。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="acef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它只是创建一个订阅者，并开始从Pub/Sub获取，完成后关闭订阅者。关闭步骤对于确保没有泄漏非常重要。</p><p id="7d25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要从Pub/Sub中提取，您需要类似以下的内容:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="e9e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是为了将订阅逻辑设计到任务中，其中每个任务都是一个到发布/订阅的PR。剩下的只是开始把这些任务提交给线程池执行器，开始拉。</p><p id="22db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的设置达到了每小时3000万条消息，这真的很酷。</p><h1 id="2d61" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">多线程的注意事项</h1><p id="3e5c" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">了解您的系统的限制以利用这样的设置是很重要的。因此，一个CPU内核一次大约可以运行一个线程(如果没有激活超线程),因此，如果您有一个pod(您最终将在其中部署您的应用),它在一个内核上运行，而您配置了一个有10个线程的线程池，这将是一种资源浪费，基本上没有任何意义。</p><p id="b28a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样重要的是要知道，更多的线程并不一定意味着更快的速度，大多数时候瓶颈在其他地方。例如，在我们的例子中，一个人可能发现性能有点慢，他/她想要优化它。因此，他将尝试同时执行20个任务(20个线程)，这意味着大约20K条消息将同时发送到ActiveMQ代理。</p><p id="bc4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这可以在发布/订阅端工作，但对于ActiveMQ来说，处理这样的负载可能是个问题。在这种情况下，优化测量应用在了错误的部分。一本关于这类主题的好书以及更多的书将会成为Java性能的权威指南。</p><div class="lo lp ez fb lq lr"><a href="https://javarevisited.blogspot.com/2018/07/top-5-java-performance-tuning-books-for.html" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab dw"><div class="lt ab lu cl cj lv"><h2 class="bd hj fi z dy lw ea eb lx ed ef hh bi translated">面向有经验程序员的5大Java性能调优书籍——最好的，必读</h2><div class="ly l"><h3 class="bd b fi z dy lw ea eb lx ed ef dx translated">您可能会想，为什么Java开发人员要读一本关于性能调优的书呢？当我第一次面对这个问题的时候…</h3></div><div class="lz l"><p class="bd b fp z dy lw ea eb lx ed ef dx translated">javarevisited.blogspot.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf jn lr"/></div></div></a></div><p id="8e5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="la">随意分享你对文章和内容的想法，如果觉得有趣或者有用，就鼓掌分享。</em> </strong></p></div></div>    
</body>
</html>