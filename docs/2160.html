<html>
<head>
<title>Dynamic Programming Approach for Pairwise DNA Sequence Alignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两两DNA序列比对的动态规划方法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/dynamic-programming-approach-for-pairwise-dna-sequence-alignment-c3e98ec35576?source=collection_archive---------2-----------------------#2022-06-03">https://medium.com/javarevisited/dynamic-programming-approach-for-pairwise-dna-sequence-alignment-c3e98ec35576?source=collection_archive---------2-----------------------#2022-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="c9c9" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">生物信息学</h2><div class=""/><div class=""><h2 id="8980" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">两个DNA序列有多相似？如何使用BioPython执行DNA成对序列比对:Python库</h2></div><p id="3acc" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">大家好😃你好吗，you❓Hope你过得很好。这一集我们将学习成对DNA序列比对。让我们毫不迟疑地深入到上下文中。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/5d48817e807302e8a27ec0999a05982f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ih-AXmU1HTMOth-V"/></div></div><p class="ko kp et er es kq kr bd b be z dx translated"><a class="ae ks" href="https://unsplash.com/@5tep5?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山大·波波夫</a>在<a class="ae ks" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="687a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">首先，学习一些基本定义，以便轻松理解这一集。</p><ul class=""><li id="3662" class="kt ku hi ji b jj jk jm jn jp kv jt kw jx kx kb ky kz la lb bi translated"><strong class="ji hs"/>—序列比对是根据两个DNA或蛋白质序列内容表示的相似性来排列它们的方法。</li><li id="16ec" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated"><strong class="ji hs">成对序列比对</strong>:成对序列比对是一种仅比较两个序列的序列比对方法。该过程需要确定两个序列之间的最佳比对，基于它们的相似性或不相似性分配分数，并确定相似性或不相似性的分数。</li></ul><h1 id="391c" class="lh li hi bd lj lk ll lm ln lo lp lq lr ix ls iy lt ja lu jb lv jd lw je lx ly bi translated">得分</h1><p id="03e3" class="pw-post-body-paragraph jg jh hi ji b jj lz is jl jm ma iv jo jp mb jr js jt mc jv jw jx md jz ka kb hb bi translated">评分主要考虑三个方面。</p><ul class=""><li id="33cd" class="kt ku hi ji b jj jk jm jn jp kv jt kw jx kx kb ky kz la lb bi translated"><strong class="ji hs">匹配值</strong> —匹配两个序列中的字符</li><li id="2e6f" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated"><strong class="ji hs">不匹配值</strong> —两个序列中不匹配的字符</li><li id="df34" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated"><strong class="ji hs">空位罚分</strong> —将一个字符与一个空格匹配</li></ul><p id="95ab" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">为了便于理解上述三个概念，下面给你一张图片。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><a href="https://www.java67.com/2019/01/5-free-courses-to-learn-machine-and-deep-learning-in-2019.html"><div class="er es me"><img src="../Images/4ee2993345b0804bff95dafed75bcf90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FskXwbVY5G2DsLXy.jpg"/></div></a><p class="ko kp et er es kq kr bd b be z dx translated"><a class="ae ks" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fslideplayer.com%2Fslide%2F5698114%2F&amp;psig=AOvVaw0bzeLBJbndRVn8CYYbjjYt&amp;ust=1653933140005000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCPD23aKjhfgCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><blockquote class="mf mg mh"><p id="d94b" class="jg jh mi ji b jj jk is jl jm jn iv jo mj jq jr js mk ju jv jw ml jy jz ka kb hb bi translated">让我们以下面的例子来学习评分方法</p></blockquote><figure class="kd ke kf kg fd kh er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/08/top-5-courses-to-learn-deep-learning.html"><div class="er es mm"><img src="../Images/e6b4371f6b0f265af18a48bea4e4dcb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L2W1v6VXcC7uM1Oe.png"/></div></a></figure><p id="fc39" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">匹配:24，替换:4，插入/缺失:5</p><p id="e57e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> <em class="mi">基于距离计分</em> </strong></p><ul class=""><li id="2594" class="kt ku hi ji b jj jk jm jn jp kv jt kw jx kx kb ky kz la lb bi translated">该评分将给出两个序列的不同之处。</li><li id="00e6" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated">匹配:0，替换:1，插入/删除:2</li><li id="d634" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated">距离= 24*0 + 4*1 + 5*2 = 14</li></ul><p id="0718" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> <em class="mi">相似度基础评分</em> </strong></p><ul class=""><li id="b2ad" class="kt ku hi ji b jj jk jm jn jp kv jt kw jx kx kb ky kz la lb bi translated">该评分将给出两个序列是如何相似的。</li><li id="e873" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated">匹配:1，替换:0，插入/删除:-1.5</li><li id="d622" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated">相似度:24 * 1+4 * 0+5 *(1.5)= 16.5</li></ul><p id="efe3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">比对距离/相似性可用于估计两个DNA或蛋白质序列之间的生物学差异/相似性。现在，你知道了序列比对和成对序列比对。让我们学习两两序列比对的类型。</p><blockquote class="mn"><p id="c7dc" class="mo mp hi bd mq mr ms mt mu mv mw kb dx translated"><em class="mx">全局比对(Needleman-Wunsch算法)</em></p><p id="7c8a" class="mo mp hi bd mq mr ms mt mu mv mw kb dx translated"><em class="mx">局部对齐(史密斯-沃特曼算法)</em></p><p id="c5da" class="mo mp hi bd mq mr ms mt mu mv mw kb dx translated"><em class="mx">自由端对齐</em></p></blockquote><ul class=""><li id="52d8" class="kt ku hi ji b jj my jm mz jp na jt nb jx nc kb ky kz la lb bi translated"><strong class="ji hs">全局比对:</strong>两个序列的整个长度被认为是计算最佳相似性值。插入空格以匹配序列长度。</li><li id="737b" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated"><strong class="ji hs">局部比对:</strong>考虑两个序列的子序列，寻找相似度的最优值。</li><li id="a51c" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated"><strong class="ji hs">无末端比对:</strong>当这些子序列中至少有一个是原始序列的前缀，一个是后缀时，子序列之间的最佳比对。所以序列不需要在同一个地方开始和结束。</li></ul><p id="b2c2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">使用Needleman-Wunsch算法计算全局比对，而使用Smith-Waterman算法计算局部比对。</strong></p><blockquote class="mf mg mh"><p id="11c0" class="jg jh mi ji b jj jk is jl jm jn iv jo mj jq jr js mk ju jv jw ml jy jz ka kb hb bi translated"><strong class="ji hs">用于全局比对的Needleman-Wunsch算法</strong></p></blockquote><ul class=""><li id="66c4" class="kt ku hi ji b jj jk jm jn jp kv jt kw jx kx kb ky kz la lb bi translated">needle man–Wunsch算法是一种用于生物信息学的蛋白质或核苷酸序列比对算法。这是第一次使用动态编程进行生物序列比较。Saul B. Needleman和Christian D. Wunsch创建了该算法，并于1970年发表。该方法将一个主要问题分解为一系列较小的问题，然后使用较小问题的解决方案来发现较大问题的最佳解决方案(这被称为<a class="ae ks" rel="noopener" href="/javarevisited/6-best-dynamic-programming-courses-for-coding-interviews-14744060923c">动态编程</a>，要了解有关动态编程的更多信息，请访问<strong class="ji hs"> </strong> <a class="ae ks" rel="noopener" href="/javarevisited/what-is-dynamic-programming-e3e1c2eb0621"> <strong class="ji hs">此处</strong> </a>)。全局比对技术和最佳匹配算法是它的其他名称。为了获得最佳的全局比对，needle man–Wunsch算法仍然被广泛使用。该算法的目标是找到所有具有最佳分数的潜在比对。</li><li id="02d2" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated">观看下面的视频，了解如何使用Needleman-Wunch算法执行全局比对。</li></ul><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="9907" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">这里有一个使用Needleman-Wunch算法</strong> <a class="ae ks" href="http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Needleman-Wunsch" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hs">进行全局比对的可视化工具</strong> </a> <strong class="ji hs">。下图显示了一个可视化示例。</strong></p><figure class="kd ke kf kg fd kh er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/08/top-10-coursera-certifications-to-learn-Data-Science-Visualization-and-Data-Analysis.html"><div class="er es kc"><img src="../Images/dd5bdb6f80b40892f52306f4d92b8be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HS2F3WvoV04Cz4dg.png"/></div></a><p class="ko kp et er es kq kr bd b be z dx translated">图片作者来自:<a class="ae ks" href="http://rna.informatik.uni-freiburg.de/" rel="noopener ugc nofollow" target="_blank">http://rna.informatik.uni-freiburg.de/</a></p></figure><blockquote class="mf mg mh"><p id="0f84" class="jg jh mi ji b jj jk is jl jm jn iv jo mj jq jr js mk ju jv jw ml jy jz ka kb hb bi translated"><strong class="ji hs">局部对准的史密斯-沃特曼算法</strong></p></blockquote><ul class=""><li id="5e54" class="kt ku hi ji b jj jk jm jn jp kv jt kw jx kx kb ky kz la lb bi translated">Smith-Waterman方法通过进行局部序列比对来确定两串核酸或蛋白质序列之间的可比较区域。Smith-Waterman算法分析所有可能长度的片段，并优化相似性度量，而不是查看整个序列。坦普尔·f·史密斯和迈克尔·s·沃特曼于1981年首次提出了这一方法。Smith-Waterman是一种动态规划算法，就像needle man–Wunsch方法一样，它是该方法的变体。结果，它具有确保为所使用的评分系统找到最佳局部比对的理想品质。</li><li id="0ca5" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated">观看下面的视频，了解如何使用Smith-Waterman算法执行局部对齐。</li></ul><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="nf ne l"/></div></figure><p id="476c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">这里有一个使用史密斯-沃特曼算法</strong><a class="ae ks" href="http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman" rel="noopener ugc nofollow" target="_blank"><strong class="ji hs"/></a><strong class="ji hs">进行局部比对的可视化工具。下图显示了一个可视化示例。</strong></p><figure class="kd ke kf kg fd kh er es paragraph-image"><a href="https://www.java67.com/2020/07/top-5-data-visualization-tools-every.html"><div class="er es kc"><img src="../Images/a04f9f476d3af5b3501398f1d7a21c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*umax5dG3BAG5WwTY.png"/></div></a><p class="ko kp et er es kq kr bd b be z dx translated">图片作者来自:<a class="ae ks" href="http://rna.informatik.uni-freiburg.de/" rel="noopener ugc nofollow" target="_blank">http://rna.informatik.uni-freiburg.de/</a></p></figure><h1 id="cfe9" class="lh li hi bd lj lk ll lm ln lo lp lq lr ix ls iy lt ja lu jb lv jd lw je lx ly bi translated">用于生物计算的BioPython库</h1><ul class=""><li id="1df8" class="kt ku hi ji b jj lz jm ma jp ng jt nh jx ni kb ky kz la lb bi translated">我们已经了解了这些全局和局部比对是如何进行的。然而，当序列太长时，我们无法做到这一点。因此，使用程序寻找最佳比对是最有效的方法。</li><li id="2f4c" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated">BioPython是一个基于Python的库。它有许多生物信息学相关的实现。我们可以直接使用它们，而不用太担心实现。你可以在这里了解更多关于biopython库<a class="ae ks" href="https://biopython.org/" rel="noopener ugc nofollow" target="_blank">的信息。</a></li></ul><blockquote class="mn"><p id="c698" class="mo mp hi bd mq mr nj nk nl nm nn kb dx translated"><em class="mx"> Biopython是由一个国际开发团队用</em><a class="ae ks" rel="noopener" href="/javarevisited/10-free-python-tutorials-and-courses-from-google-microsoft-and-coursera-for-beginners-96b9ad20b4e6"><em class="mx">Python</em></a><em class="mx">编写的一套免费可用的生物计算工具。这是一个分布式的合作项目，旨在开发Python库和应用程序，以满足当前和未来生物信息学工作的需求。源代码可以在</em> <a class="ae ks" href="https://github.com/biopython/biopython/blob/master/LICENSE.rst" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> Biopython许可</em> </a> <em class="mx">下获得，这是非常自由的，并且与世界上几乎所有的许可都兼容——bio python网站</em></p></blockquote><figure class="np nq nr ns nt kh er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/09/5-websites-to-learn-python-for-free.html"><div class="er es no"><img src="../Images/c37b5f0e0cb1b33e9bd8cf8d405b5e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*4JgWXAOqQPd2R_Pd.png"/></div></a><p class="ko kp et er es kq kr bd b be z dx translated">来源:<a class="ae ks" href="https://biopython.org/" rel="noopener ugc nofollow" target="_blank">https://biopython.org/</a></p></figure><p id="a460" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">让我们看看如何使用这个Bio Python库进行成对序列比对</strong></p><ul class=""><li id="622a" class="kt ku hi ji b jj jk jm jn jp kv jt kw jx kx kb ky kz la lb bi translated"><strong class="ji hs"> <em class="mi">注意，根据评分矩阵，这些比对可能会有所不同。</em> </strong></li><li id="dda6" class="kt ku hi ji b jj lc jm ld jp le jt lf jx lg kb ky kz la lb bi translated"><em class="mi">让我们看看如何在下面的BioPython中全局对齐两个序列。</em></li></ul><pre class="kd ke kf kg fd nu nv nw nx aw ny bi"><span id="0054" class="nz li hi nv b fi oa ob l oc od">from Bio import Align</span><span id="de59" class="nz li hi nv b fi oe ob l oc od">aligner = Align.PairwiseAligner()<br/>aligner.match_score = 2.0<br/>aligner.mismatch_score = -1.0<br/>aligner.gap_score = -1</span><span id="6ed3" class="nz li hi nv b fi oe ob l oc od">alignments = aligner.align("ACGCTG","CATGT")<br/>score = aligner.score("ACGCTG","CATGT")</span><span id="1e28" class="nz li hi nv b fi oe ob l oc od">for alignment in alignments:<br/>    print(alignment)<br/>print(score)</span></pre><p id="7f6b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">上面代码的输出如下所示。下面给出了匹配方式和最佳匹配分数。我们可以使用上述工具的全球比对问题的结果来验证这一点。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><a href="https://www.java67.com/2018/10/top-10-data-science-and-machine-learning-courses.html"><div class="er es of"><img src="../Images/5b5a42d75ca96159b8050a6cc5c8a2fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iXmNsQ_6XMC4BfJz.png"/></div></a><p class="ko kp et er es kq kr bd b be z dx translated">作者图片:全球对齐</p></figure><ul class=""><li id="bc1d" class="kt ku hi ji b jj jk jm jn jp kv jt kw jx kx kb ky kz la lb bi translated"><em class="mi">让我们看看如何在下面的BioPython中局部对齐两个序列。</em></li></ul><pre class="kd ke kf kg fd nu nv nw nx aw ny bi"><span id="e542" class="nz li hi nv b fi oa ob l oc od">from Bio import Align</span><span id="7a55" class="nz li hi nv b fi oe ob l oc od">aligner = Align.PairwiseAligner()<br/>aligner.mode="local"<br/>aligner.match_score = 1.0<br/>aligner.mismatch_score = -1.0<br/>aligner.gap_score = -2</span><span id="f24f" class="nz li hi nv b fi oe ob l oc od">alignments = aligner.align("AATCG","AACG")<br/>score = aligner.score("AATCG","AACG")</span><span id="f022" class="nz li hi nv b fi oe ob l oc od">for alignment in alignments:<br/>     print(alignment)<br/>print(score)</span></pre><p id="1f6c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">上面代码的输出如下所示。下面给出了匹配方式和最佳匹配分数。我们可以使用上述工具的局部对齐问题的结果来验证这一点。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/08/top-10-coursera-courses-and-certification-for-artificial-intelligence-and-machine-learning.html#axzz6oh08Cv8w"><div class="er es kc"><img src="../Images/a1af4d02011f8b837fa50ae81f950157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GYbSZ69hvRswL-uD.png"/></div></a><p class="ko kp et er es kq kr bd b be z dx translated">作者图片:局部对齐</p></figure><p id="7e28" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我相信你学到了生物信息学中关于序列比对和成对序列比对的一些关键点。如果您有任何问题或任何澄清，不要犹豫，通过回复部分与我联系。感谢您花费宝贵的时间阅读本博客，我相信这将激励您继续阅读我的其他博客<a class="ae ks" href="https://sthenusan.medium.com/" rel="noopener"> <strong class="ji hs"> <em class="mi">这里</em> </strong> </a> <em class="mi">。</em></p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/a55ab834543dd403102de1805ddf20ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NaHWHfdciUye6jMN"/></div></div><p class="ko kp et er es kq kr bd b be z dx translated">照片由<a class="ae ks" href="https://unsplash.com/@cmhedger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Courtney hedge</a>在<a class="ae ks" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="cedc" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><em class="mi">喜欢这篇文章吗？成为</em> <a class="ae ks" href="https://sthenusan.medium.com/membership" rel="noopener"> <strong class="ji hs"> <em class="mi">中等会员</em> </strong> </a> <em class="mi">继续学习没有任何限制。如果你使用上面的链接，我会收到你的一部分会员费，不需要你额外付费。提前感谢。</em></p></div></div>    
</body>
</html>