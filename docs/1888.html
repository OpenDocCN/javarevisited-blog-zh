<html>
<head>
<title>Interview questions on Object-Oriented Programming and JAVA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程和JAVA的面试问题</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/interview-questions-on-object-oriented-programming-and-java-41b027d93ddb?source=collection_archive---------0-----------------------#2022-01-21">https://medium.com/javarevisited/interview-questions-on-object-oriented-programming-and-java-41b027d93ddb?source=collection_archive---------0-----------------------#2022-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="c9c0" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">面试经验和指南—第二部分</h2><div class=""/><div class=""><h2 id="0ba4" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">面向对象和JAVA的面试准备</h2></div><p id="cb10" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">大家好，今天我将分享oop和JAVA的相关概念，作为我软件工程师职位面试准备系列的一部分。这是该系列的第二部分。如果你错过了第一部分，点击 <a class="ae kd" rel="noopener" href="/geekculture/interview-preparation-kid-for-software-engineer-1380f6fcbae9"> <em class="kc">这里</em> </a> <em class="kc">。下一篇关于数据库相关面试问题可用</em> <a class="ae kd" href="https://faun.pub/interview-questions-on-database-concepts-d480defce050" rel="noopener ugc nofollow" target="_blank"> <em class="kc">此处</em> </a> <em class="kc">。不再拖延，让我们进入今天的话题。</em></p><figure class="kf kg kh ki fd kj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/05/object-oriented-programming-questions-answers.html#axzz6vwZEctyQ"><div class="er es ke"><img src="../Images/97c617a380cd04de20b02f0aacf8ccbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*27N841h4tvLGZktM"/></div></a><p class="km kn et er es ko kp bd b be z dx translated">照片由<a class="ae kd" href="https://unsplash.com/@wocintechchat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜@ wocintechchat.com</a>在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b11c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">OOP是一个非常基础的概念，不仅是软件工程师，软件开发相关人员也需要了解它。面向对象编程问题也是任何面试官的必答问题。oop中有四个主要概念。我将在下面解释其中的一些问题和答案。要了解更多关于OOP的基础知识，请访问<a class="ae kd" rel="noopener" href="/codex/object-oriented-programming-in-five-minutes-d54b96c906d">这里</a>。我在下面的问答中给出了所有的主要话题。</p><ol class=""><li id="6652" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kv kw kx ky bi translated">用真实世界的例子解释基本的OOP概念。</li></ol><ul class=""><li id="0c53" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">有四个基本的oop概念。它们是继承、抽象、封装和多态。</li><li id="3af9" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs">继承</strong>是指继承子类中的父类方法和字段。让我们考虑狗和动物类。狗是动物类的一个子类。因此，例如狗继承动物的<em class="kc">吃()</em>的方法。</li><li id="87ef" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs">抽象</strong>就是隐藏实现细节。我们只说做了什么，但隐瞒了如何做。例如:当我们使用ATM时，我们只需点击取现，但我们不知道具体是如何操作的。它是抽象的。</li><li id="54e8" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs">封装</strong>意为数据隐藏。在内部隐藏与类相关的数据。封装是通过设置私有属性并提供访问这些变量的setters和getters来实现的。我们可以想象一个医用胶囊，它用一个包装来隐藏内部。所以我们不知道它的成分。</li><li id="4471" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs">多态性</strong>是指一个对象采取多种形式。<strong class="ji hs"> </strong>在JAVA中，每个对象都是多态的，因为每个对象都是Java对象类的子对象。例如，狗既是一种动物，也是一只狗。就是多态性。父类引用用于创建子类对象。那也是多态性。</li></ul><p id="151b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 2。为什么我们需要使用oop？</strong></p><ul class=""><li id="b709" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">OOP概念是编程中最古老的概念之一。Java和Python是面向对象的语言。当我们使用oop时，有很多优点。我们可以避免代码冗余，管理变更，管理复杂性和代码重用支持。</li></ul><p id="19ba" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 3。封装在编程中有什么好处？</strong></p><ul class=""><li id="1756" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">更改类内部不会影响类外部的任何代码。</li><li id="569b" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">管理变化更容易。更改实现不会反映到使用它们的客户机上。</li></ul><p id="8ccd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 4。Java是如何实现多态性的？</strong></p><ul class=""><li id="90eb" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">Java多态性已经通过<strong class="ji hs">运行时多态性</strong>和<strong class="ji hs">编译时多态性</strong>实现。</li><li id="b5fe" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs">运行时多态性</strong>也被称为方法<strong class="ji hs">覆盖</strong>。在方法重写中，两个不同类中的两个方法的方法名和签名是相同的，但实现会不同。JVM将决定在运行时运行哪个方法。我们不能用static关键字覆盖一个类。最终类不能被覆盖。</li><li id="6204" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs">编译时多态性</strong>也被称为方法<strong class="ji hs">重载</strong>。这里使用了相同的方法名，但是参数不同。重载方法在同一个类中。JVM在编译时而不是运行时决定这一点。</li></ul><p id="6e80" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 5。Java中实现抽象有哪些不同的方式？</strong></p><ul class=""><li id="8364" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">使用<strong class="ji hs">抽象类</strong>和<strong class="ji hs">接口</strong>。</li><li id="9723" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">该接口给出了100%的抽象，而我们甚至可以在抽象类中定义具体的方法。</li><li id="f0b5" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">我们只能在接口中定义使用final和static修饰符。但是final，不是final，静态和非静态成员都可以在抽象类中定义。</li><li id="66ab" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">我们不能从抽象类中初始化对象。</li><li id="aeeb" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">基于我们的目的，我们可以选择以上其中之一。如果我们计划使用多个继承，我们可以选择接口。但是如果我们想要子类之间的一些共同特征，我们可以使用抽象类。</li></ul><p id="a9c2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 6。oop中的造型是什么？</strong></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/aa193f643c85392045ccb19fc50331f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-FshL0KoybBDh1b3"/></div></div><p class="km kn et er es ko kp bd b be z dx translated">照片由<a class="ae kd" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><ul class=""><li id="b3b5" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">强制转换意味着将对象类型转换为超类或子类。</li><li id="d6a4" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">将一个对象的类型转换成它的超类叫做<strong class="ji hs">向上转换</strong>。</li><li id="fd08" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">将一个对象的类型转换成它的子类叫做<strong class="ji hs">向下转换</strong>。</li><li id="76f2" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">下面的代码段是<strong class="ji hs">向上抛掷</strong>和<strong class="ji hs">向下抛掷的例子。你也可以用其他例子。这里狗是动物的一个子类。</strong></li></ul><pre class="kf kg kh ki fd lk ll lm ln aw lo bi"><span id="039b" class="lp lq hi ll b fi lr ls l lt lu"><strong class="ll hs">#Upcasting</strong><br/>Dog d = new Dog();      <br/>Animal a = (Animal)d;</span><span id="c4e0" class="lp lq hi ll b fi lv ls l lt lu"><strong class="ll hs">#Downcasting</strong><br/>Animal animal = new Animal();<br/>Dog sampleDog = (Dog) animal;</span></pre><p id="4e1a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 7。oop中的内聚和耦合是什么意思？</strong></p><ul class=""><li id="ef27" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">内聚性描述了一个类的成员为了中心目标而紧密合作的程度。凝聚力一定要强。定义良好的抽象会产生强大的凝聚力。</li><li id="3b36" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">耦合意味着一个类与另一个类的关系有多紧密。耦合必须保持较低。无论如何，模块之间相互依赖很小。所有的类和方法必须与其他类有小的直接可见的和灵活的关系。但是一个模块必须容易被其他模块使用。</li></ul><p id="b4b4" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 8。抽象和封装的区别？</strong></p><ul class=""><li id="288b" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">在抽象中，使用抽象类和接口隐藏了实现的复杂性。在封装中，数据是使用getters和setters方法隐藏的。</li><li id="a2dc" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">抽象是隐藏不想要的实现信息的方法。而封装是一种将数据隐藏在单个实体或单元中的方法，同时也是一种保护信息不受外界影响的方法。</li></ul><p id="e1dd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 9。什么是功能接口和标记接口？</strong></p><ul class=""><li id="7d64" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">只有一个抽象方法的接口称为函数接口。他们一次只能演示一种功能。一个函数接口可以有任意多的默认方法。<strong class="ji hs"> Runnable </strong>和<strong class="ji hs"> Comparable </strong>是功能接口的例子。</li><li id="be67" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">这是一个空白接口(没有字段或方法)。可串行化的和可克隆的是标记接口的例子。所有这些界面都是空的。它主要用于向java编译器说明对象的类型。</li></ul><p id="1e85" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">10。线程在Java中是如何实现的？</p><p id="516f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">线程是一个轻量级的进程。java中有两种实现线程的方法。</p><ol class=""><li id="1b12" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kv kw kx ky bi translated">通过扩展线程类并重写</li><li id="22d3" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kv kw kx ky bi translated">通过实现Runnable接口。</li></ol><p id="5f74" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">任何其实例由线程运行的类都应该实现Runnable接口或thread类。只有一个名为的抽象方法在runnable接口中运行。它被用作一根线。我们在扩展Thread类的时候不能扩展任何其他类，即使我们需要。当我们为线程实现一个Runnable接口时，我们可以为我们的类节省空间。这样我们就可以在未来或现在扩展任何其他类。</p><p id="841b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">10。什么是Java垃圾收集器？它是如何工作的？</p><p id="99a2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">垃圾收集是在运行时自动回收未使用的内存的过程。换句话说，这是一种在JAVA中清除不需要的项目的方法。垃圾收集器从堆内存中清除未被引用的对象，从而提高java内存的效率。作为程序员，<br/> <strong class="ji hs">我们不需要做任何额外的事情</strong>，因为垃圾收集器(JVM的一部分)已经为我们做了。</p><p id="14f9" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 11。Final，Finally和Finalize有什么区别？</strong></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lw"><img src="../Images/60da0690535b4e65d469c1e9189c8de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xHyEL7x4iHtbjwH0"/></div></div><p class="km kn et er es ko kp bd b be z dx translated">斯蒂芬·以赛亚在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><ul class=""><li id="0ba1" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated"><strong class="ji hs"> Final: </strong>在Java中，Final是保留关键字。该关键字可用于变量、方法和类。在Java中，final关键字有不同的含义，这取决于它是用于引用变量、类还是方法。如果一个最终变量被初始化，它就不能被改变。最终类不能被继承。当我们将一个方法声明为final时，我们表明我们将不能重写该方法。</li><li id="fb4e" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs"> Finally: </strong> Finally也是Java的保留术语。当与try/catch块结合使用时，finally关键字确保即使抛出异常，部分代码也能运行。在try和catch块之后，但在控制返回其原点之前，将执行finally块。最后，Finally块的目的是释放资源。也就是说，我们在try块中打开的任何资源，比如网络连接和数据库连接，都必须关闭，这样我们才不会丢失资源。因此，这些资源必须在finally块中关闭。</li><li id="461c" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs"> Finalize: </strong>这是垃圾收集器在删除或销毁适合垃圾收集的对象之前调用的一种方法，用于进行清理。清除操作需要取消分配或关闭与该项关联的资源，如数据库连接和网络连接。</li></ul><p id="861d" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 12。解释Java中的异常处理？</strong></p><ul class=""><li id="772c" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">在程序执行过程中发生的扰乱程序正常指令流的事件称为异常。</li><li id="c65f" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">Java Throwable类是所有类型的Java异常和错误的根类。JVM只抛出这个类的实例对象。</li><li id="15f8" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">错误是不可恢复的，而异常可以被处理以维持程序的正常运行。</li><li id="db25" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">java中的异常和错误是有层次的。请参考下图进一步了解。</li></ul><figure class="kf kg kh ki fd kj er es paragraph-image"><a href="https://www.java67.com/2015/12/top-30-oops-concept-interview-questions-answers-java.html"><div class="er es lx"><img src="../Images/0ee92f6a5c002fe782be3af2eddd201e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*s2560S1lFVDs_6-4K_1HjA.png"/></div></a><p class="km kn et er es ko kp bd b be z dx translated"><a class="ae kd" href="https://www.geeksforgeeks.org/exceptions-in-java/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/exceptions-in-java/</a></p></figure><ul class=""><li id="acb9" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated">检查的异常在编译时处理，而未检查的异常在运行时处理。</li><li id="c663" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">我们也可以根据自己的需要用java设计自定义异常。这就是所谓的定制异常处理。</li><li id="8bb2" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">有时可能会出现这样的情况，块的一部分可能会导致一个异常，而整个块本身可能会导致另一个异常。我们甚至可以使用嵌套的try-catch块来处理程序中的多个异常。</li></ul><p id="9e0c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs"> 13。在Java中比较throw和throws</strong></p><ul class=""><li id="afaa" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated"><strong class="ji hs"> Throw </strong>可以通过Throw关键字在Java中显式抛出检查过的或未检查的异常。<strong class="ji hs">抛出</strong>用于声明异常。它向程序员提供了可能发生异常的信息。</li><li id="6cc4" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs"> throw </strong>后面是一个实例，而<strong class="ji hs"> Throws </strong>后面是一个类。</li><li id="7eec" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated"><strong class="ji hs">抛出</strong>用于方法内部，而<strong class="ji hs">抛出</strong>用于方法签名。</li><li id="4d8e" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">您不能使用<strong class="ji hs"> Throw </strong>抛出多个异常，但是我们可以使用<strong class="ji hs"> Throws </strong>声明多个异常。</li></ul><p id="fea4" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">14。什么是Java栈和堆内存管理比较和对比？</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ly"><img src="../Images/362e822475283b9782f2bb9aad216701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*NX2PYzGZ8TE4qrAfQ64jZw.png"/></div><p class="km kn et er es ko kp bd b be z dx translated"><a class="ae kd" href="https://www.javatpoint.com/stack-vs-heap-java" rel="noopener ugc nofollow" target="_blank">https://www.javatpoint.com/stack-vs-heap-java</a></p></figure><ul class=""><li id="3acd" class="kq kr hi ji b jj jk jm jn jp ks jt kt jx ku kb kz kw kx ky bi translated"><strong class="ji hs">栈</strong>内存中包含有短暂生命周期的项目，比如对象方法、变量、引用变量。<strong class="ji hs">堆</strong>内存保存Java运行时环境(JRE)类和对象。</li><li id="ebf6" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">在<strong class="ji hs">堆栈</strong>内存中，只有所有者线程可以看到变量。变量暴露给<strong class="ji hs">堆</strong>内存中的所有线程。</li><li id="5270" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">如果<strong class="ji hs">栈</strong>的大小超过了限制，JVM就会抛出<strong class="ji hs">stackoverflowererror</strong>。增加堆栈大小以避免此问题。如果JVM无法在<strong class="ji hs">堆</strong>内存空间中构造一个新对象，它将抛出一个<strong class="ji hs"> OutOfMemoryError </strong>。</li><li id="809c" class="kq kr hi ji b jj la jm lb jp lc jt ld jx le kb kz kw kx ky bi translated">因为每个线程都有自己的<strong class="ji hs">堆栈</strong>，所以堆栈是线程安全的。因为<strong class="ji hs">堆</strong>不是线程安全的，适当的代码同步是必不可少的。</li></ul></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="d82e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我相信你已经理解了上面讨论的所有与Java和OOP相关的问题。如果您有任何问题或任何澄清，不要犹豫，通过回复部分与我联系。感谢你花宝贵的时间阅读这篇博客，我相信这会激励你继续阅读其他关于面对面试的博客。</p><p id="823b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">喜欢这篇文章吗？成为 <a class="ae kd" href="https://sthenusan.medium.com/membership" rel="noopener"> <em class="kc">中等会员</em> </a> <em class="kc">继续无限制学习。如果你使用上面的链接，我会收到你的一部分会员费，不需要你额外付费。提前感谢。</em></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mg"><img src="../Images/d4fe9f466b99fa8e3e6baed636e68499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LQb01HToFY8OJ10Q"/></div></div><p class="km kn et er es ko kp bd b be z dx translated">由<a class="ae kd" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div></div>    
</body>
</html>