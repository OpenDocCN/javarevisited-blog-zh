<html>
<head>
<title>Improve Scalability Using Factory Method Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工厂方法设计模式提高可伸缩性</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/improve-scalability-using-factory-method-design-pattern-4c6a166f0c0?source=collection_archive---------2-----------------------#2022-03-07">https://medium.com/javarevisited/improve-scalability-using-factory-method-design-pattern-4c6a166f0c0?source=collection_archive---------2-----------------------#2022-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b760" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">工厂模式使我们的代码更加健壮，耦合度更低，并且高度可伸缩。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/bad629c48d0ac66e09a056df16139c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CG6gbcR5Pad7s3fH"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">弗拉德·库特波夫在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e816" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">工厂设计模式是一种创造性的设计模式，也称为虚拟构造器。它委托对象创建，并为在超类中创建对象和改变子类提供接口，而不影响现有的客户端实现。它通过消除将特定于应用程序的类绑定到代码中的需要，促进了<strong class="jq hj">松耦合</strong>。</p><blockquote class="kk kl km"><p id="8bbb" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated"><strong class="jq hj">耦合</strong>意味着一个类与另一个类的关系有多紧密。耦合必须保持较低。无论如何，模块之间相互依赖很小。所有的类和方法必须与其他类有小的直接可见的和灵活的关系。但是一个模块必须容易被其他模块使用。</p></blockquote><p id="a4b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="http://javarevisited.blogspot.sg/2013/01/difference-between-factory-and-abstract-factory-design-pattern-java.html" rel="noopener ugc nofollow" target="_blank">工厂模式</a>从客户端代码中移除实际实现类的实例化。代码只与生成的接口或抽象类交互，因此它将与实现该接口或扩展该<a class="ae jn" href="https://javarevisited.blogspot.com/2013/05/difference-between-abstract-class-vs-interface-java-when-prefer-over-design-oops.html" rel="noopener ugc nofollow" target="_blank">抽象类</a>的任何类一起工作。它将客户端代码从具体的类中分离出来，您需要通过允许子类选择要创建的对象类型并改变将要创建的对象类型来进行实例化。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="0dda" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated"><strong class="ak">何时使用？</strong></h2><p id="9a41" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated"><em class="kn"> 1。当您事先不知道代码应该处理的对象的确切类型和依赖关系时，请使用</em> <a class="ae jn" href="https://javarevisited.blogspot.com/2011/12/factory-design-pattern-java-example.html#axzz7CAMs6DOi" rel="noopener ugc nofollow" target="_blank"> <em class="kn">工厂方法</em> </a> <em class="kn">。</em></p><p id="fb98" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kn"> 2。当您希望在不破坏初始客户端实现的情况下扩展其内部组件时，请使用工厂方法。</em></p><p id="dc94" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kn"> 3。当您希望通过重用现有对象而不是每次都重新生成它们来节省系统资源时，请使用工厂方法。</em></p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="2b8f" class="ly kz hi bd la lz ma mb le mc md me li io mf ip ll ir mg is lo iu mh iv lr mi bi translated"><strong class="ak">现实世界系统设计类比</strong></h1><h1 id="5f02" class="ly kz hi bd la lz mj mb le mc mk me li io ml ip ll ir mm is lo iu mn iv lr mi bi translated">问题</h1><p id="914f" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">我认为我们的应用程序有3种类型的数据，它们是按用途分类的。应用程序应该根据情况支持不同类型的数据连接。从设计角度来看，每次都创建一个<a class="ae jn" href="https://javarevisited.blogspot.com/2012/06/jdbc-database-connection-pool-in-spring.html#axzz6ggCCT42g" rel="noopener ugc nofollow" target="_blank">数据连接</a>是不明智的。它使样板代码和紧密耦合。我们的示例中使用了以下数据类型。</p><p id="8d48" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">热数据</strong>——频繁访问的数据。存储在内存缓存存储中。</p><p id="0b66" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">暖数据</strong> -访问频率较低。存储在数据库中。</p><h1 id="0efc" class="ly kz hi bd la lz mj mb le mc mk me li io ml ip ll ir mm is lo iu mn iv lr mi bi translated">解决办法</h1><p id="e3ee" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">如果我们应用了工厂设计模式，那么我们只需要从客户端代码传递一个参数。然后工厂开始发挥作用，它知道哪种类型的数据连接实例应该返回给我们。</p><p id="ffbb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编写客户机源只是为了给出数据观点。客户请求来自抽象类的工厂请求。<a class="ae jn" href="https://www.java67.com/2014/06/why-abstract-class-is-important-in-java.html" rel="noopener ugc nofollow" target="_blank">抽象类</a>给出选择的对象。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-java-design-pattern-courses-for-developers.html"><div class="er es mo"><img src="../Images/9ffab1546803d2b17db13a85eedea6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zt1WT2sKvRLb8RD4r5xAMw.png"/></div></a><p class="jj jk et er es jl jm bd b be z dx translated">类图</p></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="7102" class="ly kz hi bd la lz ma mb le mc md me li io mf ip ll ir mg is lo iu mh iv lr mi bi translated">履行</h1><ol class=""><li id="ea03" class="mp mq hi jq b jr lt ju lu jx mr kb ms kf mt kj mu mv mw mx bi translated">创建一个抽象类。</li></ol><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="ef3d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2.创建扩展同一抽象类的具体类。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="2a7d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">3.创建一个工厂，根据给定的信息生成具体类的对象。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="4225" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">4.演示-通过传递类型等信息，使用工厂获取具体类的对象。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="a9b1" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated">工厂设计模式的优势</h2><ol class=""><li id="fa02" class="mp mq hi jq b jr lt ju lu jx mr kb ms kf mt kj mu mv mw mx bi translated">工厂设计模式为接口提供了一种接近<a class="ae jn" rel="noopener" href="/javarevisited/10-oop-design-principles-you-can-learn-in-2020-f7370cccdd31">代码的方法，而不是实现</a>。</li><li id="68cd" class="mp mq hi jq b jr na ju nb jx nc kb nd kf ne kj mu mv mw mx bi translated">工厂模式从客户端代码中移除了实际实现类的实例化。工厂模式使我们的代码更加健壮，耦合性更低，易于扩展。例如，我们可以很容易地改变<code class="du nf ng nh ni b">HotData </code>类的实现，因为客户端程序不知道这一点。</li><li id="c3de" class="mp mq hi jq b jr na ju nb jx nc kb nd kf ne kj mu mv mw mx bi translated">工厂模式通过继承在实现和客户端类之间提供了抽象。</li></ol></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="13b2" class="ly kz hi bd la lz ma mb le mc md me li io mf ip ll ir mg is lo iu mh iv lr mi bi translated">包装东西</h1><p id="7a49" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">最后，我希望您清楚工厂方法设计模式及其适用性。本文试图巩固工厂方法的大多数常见设计方法。</p><p id="eae6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你愿意学习我写的其他设计模式，</p><div class="nj nk ez fb nl nm"><a href="https://susithrj.medium.com/demystifying-singleton-design-pattern-in-java-96887744d40a" rel="noopener follow" target="_blank"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hj fi z dy nr ea eb ns ed ef hh bi translated">揭开Java中单例设计模式的神秘面纱</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">本文讨论了单件模式，许多人认为这是最常用的设计模式。</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">susithrj.medium.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jh nm"/></div></div></a></div><div class="nj nk ez fb nl nm"><a rel="noopener follow" target="_blank" href="/javarevisited/toned-down-code-complexity-using-facade-design-pattern-6f21d1e762d"><div class="nn ab dw"><div class="no ab np cl cj nq"><h2 class="bd hj fi z dy nr ea eb ns ed ef hh bi translated">使用外观设计模式降低代码复杂性</h2><div class="nt l"><h3 class="bd b fi z dy nr ea eb ns ed ef dx translated">给出一个“表面/正面”使得代码简单明了，易于理解。</h3></div><div class="nu l"><p class="bd b fp z dy nr ea eb ns ed ef dx translated">medium.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa jh nm"/></div></div></a></div></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="150d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果有什么我说得不对的地方，欢迎在下面评论！。<em class="kn">如果你喜欢这篇文章，点击👏下面这样更多的人可以看到它！请务必在</em><a class="ae jn" rel="noopener" href="/@susithrj"><strong class="jq hj"><em class="kn">Medium</em></strong></a><strong class="jq hj"><em class="kn"/></strong><em class="kn">或</em> <a class="ae jn" href="https://susithrj.wordpress.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="kn">我的博客</em></strong></a><strong class="jq hj"><em class="kn"/></strong><em class="kn">上关注我，以便在有新文章发表时获得更新。</em></p><p id="60da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kn">快乐编码！👌</em></p></div></div>    
</body>
</html>