<html>
<head>
<title>Binary Search Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法树</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/binary-search-trees-cab4b53953fa?source=collection_archive---------3-----------------------#2021-08-19">https://medium.com/javarevisited/binary-search-trees-cab4b53953fa?source=collection_archive---------3-----------------------#2021-08-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="edc6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">二分搜索法树简介</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5b6d3015a7ba8c63384e1b9954a31428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*REUb6TO7jkUMRpN5BUcRKQ.png"/></div></div></figure><p id="b60c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">关于树形数据结构，你想了解什么？</strong></p><p id="7ad4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">二叉查找树是一种非常通用的数据结构，在插入、移除和搜索元素时速度更快。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kf"><img src="../Images/1c1c96c79cbfc8b56501b709b1bbef5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRmo0PmlpeXF-IJnwAZ9mA.png"/></div></div><p class="kg kh et er es ki kj bd b be z dx translated">树形结构</p></figure><p id="816b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如您在图中看到的，只能有一个根节点，所有其他节点都是通过使用根节点来访问的。c是F和G节点的父节点，它们被认为是子节点。这些节点可以有<strong class="jl hj">两个子节点，但不能超过两个子节点。</strong>一些节点可以不存在被认为是叶节点的子节点。</p><p id="939c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">二叉树的属性是什么？</strong></p><ul class=""><li id="f6b9" class="kk kl hi jl b jm jn jp jq js km jw kn ka ko ke kp kq kr ks bi translated">节点的左子树只包含键小于节点键的节点。</li><li id="0f65" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">节点的右边子树只包含大于该节点键的键。</li><li id="5989" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">左子树和右子树都必须是二叉查找树。</li></ul><p id="dab2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">二叉树有哪些应用？</strong></p><p id="ddb0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae ky" rel="noopener" href="/javarevisited/20-binary-tree-algorithms-problems-from-coding-interviews-c5e5a384df30">二叉树</a>主要用于搜索和排序计算，因为它们允许数据分层存储。插入、删除和遍历是可以在二叉树上执行的一些最频繁的操作。</p><p id="0439" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">有什么好处？</strong></p><ul class=""><li id="cb8a" class="kk kl hi jl b jm jn jp jq js km jw kn ka ko ke kp kq kr ks bi translated">对分层数据存储方法的极好补充。</li><li id="03af" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">应反映所提供的数据集中存在的结构联系。</li><li id="4de3" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">与<a class="ae ky" rel="noopener" href="/javarevisited/top-20-linked-list-coding-problems-from-technical-interviews-90b64d2df093">链表</a>和<a class="ae ky" rel="noopener" href="/javarevisited/20-array-coding-problems-and-questions-from-programming-interviews-869b475b9121?source=---------15------------------">数组</a>相比，插入和删除更快。</li><li id="d59c" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">存储和传输数据的通用方法。</li><li id="ccef" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">它可以存储大量的节点。</li></ul><p id="a97a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">如何实现二叉树？</strong></p><p id="bd97" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将使用一个辅助的<em class="kz">节点</em>类来存储<em class="kz"> int </em>值。并保存对每个孩子的引用:</p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="c22e" class="lf lg hi lb b fi lh li l lj lk">class <strong class="lb hj">Node</strong> {<br/>    int value;<br/>    Node leftChild;<br/>    Node rightChild;</span><span id="6fb9" class="lf lg hi lb b fi ll li l lj lk">    Node(int value) {<br/>        this.value = value;<br/>        rightChild = null;<br/>        leftChild = null;<br/>    }<br/>}</span></pre><p id="c03c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后我们将添加树的开始节点，通常称为<em class="kz">根:</em></p><pre class="iy iz ja jb fd la lb lc ld aw le bi"><span id="df0d" class="lf lg hi lb b fi lh li l lj lk">public class <strong class="lb hj">BinaryTree</strong> {</span><span id="a140" class="lf lg hi lb b fi ll li l lj lk">    Node root;</span><span id="31d8" class="lf lg hi lb b fi ll li l lj lk">    // ...<br/>}</span></pre><p id="dfcb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">有哪些基本操作？</strong></p><ul class=""><li id="cb9d" class="kk kl hi jl b jm jn jp jq js km jw kn ka ko ke kp kq kr ks bi translated">搜索</li><li id="9faa" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated">插入</li><li id="6d43" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated"><a class="ae ky" href="https://javarevisited.blogspot.com/2016/07/binary-tree-preorder-traversal-in-java-using-recursion-iteration-example.html#axzz6dXsEfLvJ" rel="noopener ugc nofollow" target="_blank">前序遍历</a></li><li id="3db9" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated"><a class="ae ky" href="https://javarevisited.blogspot.com/2016/08/inorder-traversal-of-binary-tree-in-java-recursion-iteration-example.html" rel="noopener ugc nofollow" target="_blank">按序遍历</a></li><li id="1b88" class="kk kl hi jl b jm kt jp ku js kv jw kw ka kx ke kp kq kr ks bi translated"><a class="ae ky" href="https://javarevisited.blogspot.com/2016/10/post-order-binary-tree-traversal-in-java-iteration-recursion.html#axzz5ghwj3kuU" rel="noopener ugc nofollow" target="_blank">后序遍历</a></li></ul><p id="8a89" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">什么是二叉查找树？</strong></p><p id="8d95" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae ky" href="https://javarevisited.blogspot.com/2015/10/how-to-implement-binary-search-tree-in-java-example.html#axzz6dXsEfLvJ" rel="noopener ugc nofollow" target="_blank">二叉查找树</a>，在计算机科学中也称为有序或排序二叉树，是一种有根二叉树数据结构，其中每个内部节点存储一个大于该节点左子树中所有关键字但小于该节点右子树中所有关键字的关键字。</p><p id="29df" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">二叉树和二叉查找树有什么区别？</p><p id="ab49" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae ky" href="https://www.java67.com/2020/02/top-40-binary-tree-interview-questions.html" rel="noopener ugc nofollow" target="_blank">二叉树</a>是一种简单的结构，具有简单的约束，即任何父节点都不能有两个以上的子节点，但是二叉查找树是二叉树的一个版本，它遵循节点应该被排序的特定顺序。</p><p id="b11c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我的下一篇文章中，我希望解释二叉树的这些基本操作。如此快乐的编码！！</p><div class="lm ln ez fb lo lp"><a rel="noopener follow" target="_blank" href="/javarevisited/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">50大数据结构和算法程序员面试问题</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">有很多计算机科学毕业生和程序员申请编程、编码和软件…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">medium.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md jh lp"/></div></div></a></div><div class="lm ln ez fb lo lp"><a rel="noopener follow" target="_blank" href="/hackernoon/10-data-structure-algorithms-and-programming-courses-to-crack-any-coding-interview-e1c50b30b927"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">15门数据结构、算法和编程课程，破解任何编码面试</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">许多初级开发人员梦想在大型科技公司工作，但是，说实话，获得你的…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">medium.com</p></div></div><div class="ly l"><div class="me l ma mb mc ly md jh lp"/></div></div></a></div></div></div>    
</body>
</html>