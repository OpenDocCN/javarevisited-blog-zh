<html>
<head>
<title>Timing attack by Genetic algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于遗传算法的定时攻击</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/timing-attack-by-genetic-algorithm-b93a4357cd43?source=collection_archive---------2-----------------------#2021-05-18">https://medium.com/javarevisited/timing-attack-by-genetic-algorithm-b93a4357cd43?source=collection_archive---------2-----------------------#2021-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fcc15bf72ce947b963c9382192a2a3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7jD-5dF5bdUX8N0Rkdxxw.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">格尔德·奥特曼-皮查拜</p></figure><p id="1d30" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇短文中，我们展示了如何使用<strong class="iw hj">遗传算法</strong>来模拟<strong class="iw hj">定时攻击</strong>。我们并不打算严肃对待潜在的真实用例；该演示主要是由设计遗传算法和探索一个不太为人知，但有趣的系统漏洞的乐趣所驱动的。</p><p id="9fa9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">(准备好香草Java吧！)</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="ae77" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">定时攻击</h1><p id="bc38" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">密码验证是许多系统的共同特征。除了每一个加密问题，最基本的想法是比较两个字符串是否相等。下面是一个简单的例子:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/ed247daa0363bb482cbb950346c51146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*tLDTQqo1r6UrctNK6bcmug.png"/></div><p class="iq ir et er es is it bd b be z dx translated">一个基本的密码检查器</p></figure><p id="da80" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当然，在一个真实的系统中，你会比较散列值，但是让我们保持简单。我们想做的是破解这个对象，找回密码。</p><p id="59f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由我们的CredentialCheck对象引发的<a class="ae lh" href="https://javarevisited.blogspot.com/2012/02/how-to-encode-decode-string-in-java.html#axzz54LFhfNxy" rel="noopener ugc nofollow" target="_blank">字符串</a>上的拓扑以如下方式对字符串前景进行聚类:</p><ul class=""><li id="4afc" class="li lj hi iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated">单个字符串(除了<code class="du lr ls lt lu b">S</code>)和<code class="du lr ls lt lu b">SECRET PASSWOR</code>一样低，因为它们都没有正确的大小</li><li id="e53b" class="li lj hi iw b ix lv jb lw jf lx jj ly jn lz jr ln lo lp lq bi translated"><code class="du lr ls lt lu b">S</code>并不比<code class="du lr ls lt lu b">SICRET PASSWORD</code>差，因为他们都在第一次角色检查后失败了</li><li id="d284" class="li lj hi iw b ix lv jb lw jf lx jj ly jn lz jr ln lo lp lq bi translated"><code class="du lr ls lt lu b">SECRET HEJEOPO</code>比<code class="du lr ls lt lu b">SICRET PASSWORD</code>好6倍左右</li></ul><p id="db8f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以此类推……从CredentialCheck对象的角度来看，这个<em class="ma">也适用于</em>，并且给出了一个系统<strong class="iw hj">容易受到计时攻击</strong>的完美例子。考虑到尽可能快地返回将是富有成效的，我们不提供常数时间算法。<strong class="iw hj">根据输入的测试字符串，系统采取或多或少的操作来完成其任务</strong>。这是关于实际真实密码的间接信息。</p><p id="d5ae" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从攻击者的角度来看，我们实际上无法访问操作计数。计时攻击的思想是当攻击者设法<strong class="iw hj"> <em class="ma">测量执行</em> </strong>检查所需的时间，并从该测量中获益以猜测关于密码的信息。这种攻击可以通过一个简单的桥来执行:</p><figure class="ld le lf lg fd ij er es paragraph-image"><a href="http://javarevisited.blogspot.sg/2012/03/why-character-array-is-better-than.html#axzz4pEKHfj36"><div class="er es mb"><img src="../Images/0eeb3e23def1c58a136480e5b29cc170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*eBVnERQlbWV5lGnifBCFOA.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">CredentialCheck的包装器，用于计算运行时间</p></figure><h2 id="69ca" class="mc ka hi bd kb md me mf kf mg mh mi kj jf mj mk kn jj ml mm kr jn mn mo kv mp bi translated">野蛮力量的第一次审判</h2><p id="501b" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">使用经过的时间来度量是计时攻击背后的基本思想，但是会带来更多的度量差异！下面的强力测试，我们对1.000.000次试验的平均执行时间进行了说明:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/c09f5d2d4c365179bf2a23e60428e80f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzPP_TH-y-QgY8vebL9zZg.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">暴力攻击:由于运行时噪音导致的主要故障</p></figure><p id="38fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们获得的最佳候选是AXBQCPTNOEHSTNND，它与我们的密码没有任何共同之处。这个算法的时间长度大约是1.000.000*26*16 (~2 ⁹)。对平均长度为1000的16个字符串的每种组合进行强力运算将会得到1000*26，因此比2⁸⁵运算多一点。</p><p id="a3b1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，暴力战略是一个重大失败。然而，我们的系统并不安全…</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="c63e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">遗传算法</h1><p id="320d" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">我们的MeasuredCredentialCheck给了我们一个测试函数，这个函数测量一个字符串对象的好坏:分数越低，字符串越好；并且仅对于秘密密码达到最小值。</p><p id="b6f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们认为字符串是由char数组驱动的带有遗传DNA的生物对象。为了黑自己，我们要实现一个进化(遗传)算法。这个想法是创造一群生物串，并在其上模拟生物进化。</p><p id="3df1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个生物链在测试中获得的分数赋予了它繁殖的能力。生物链的繁殖被称为<em class="ma">交换</em>。在复制我们的字符串后，我们还将<em class="ma">突变</em>他们的DNA，给种群带来生物多样性。</p><p id="e7f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们还可以执行许多不同的额外进化操作:复制最好的竞争对手，杀死最差的竞争对手，创建种群孤岛并实现迁移，等等……交叉和突变本身的定义是相当自由的。</p><p id="4622" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">无论我们做什么选择，在设计遗传算法时都应该记住一些基本原则:</p><ul class=""><li id="b4c5" class="li lj hi iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated">生物多样性真的很重要:减轻突变的影响不一定是个好主意。</li><li id="0577" class="li lj hi iw b ix lv jb lw jf lx jj ly jn lz jr ln lo lp lq bi translated">繁殖应该小心进行:过多的繁殖可能会减慢学习过程，因为在进化过程中给了糟糕的竞争者太多的效率。</li><li id="d643" class="li lj hi iw b ix lv jb lw jf lx jj ly jn lz jr ln lo lp lq bi translated">应该特别注意种群灭绝。首先，保持人口数量不变是个好主意。</li></ul><p id="3423" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过连续几代的计算，我们希望全球趋势收敛到一个最优配置，并有望破解密码！</p><h2 id="67f6" class="mc ka hi bd kb md me mf kf mg mh mi kj jf mj mk kn jj ml mm kr jn mn mo kv mp bi translated">我们的遗传算法的一般方案</h2><p id="7ac2" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">对于我们的遗传算法设计，我们将保持事情简单。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/d3a10bd125d0650b42c089a72f0f470f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fl_AlHLsOFBVQheRlP6pag.png"/></div></div></figure><p id="d623" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如您可能看到的(我希望如此，因为我投入了巨大的精力使代码不像普通Java那样冗长！)，给定一个假定按效率排序的字符串总体(最好的先排序)，下一个总体被设计为</p><ul class=""><li id="31a1" class="li lj hi iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated">前几名候选人(根据某些配置百分比)</li><li id="74c5" class="li lj hi iw b ix lv jb lw jf lx jj ly jn lz jr ln lo lp lq bi translated">变异和交叉的个体</li><li id="bdc9" class="li lj hi iw b ix lv jb lw jf lx jj ly jn lz jr ln lo lp lq bi translated">截断以获得总人口规模。</li></ul><p id="89c2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第一个条件确保在结果群体中找到最高的候选人。这是为了提高一点进程(我们风扇调整！).交叉和突变并不是每次都发生:NaturalSelection对象随机操作它们。当它做某事时，它根据以下代数规则来做:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/3f692fb52ee67fe17084ead6d490dea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*s-bdHCB4AMocbTq2tagjLQ.png"/></div><p class="iq ir et er es is it bd b be z dx translated">我们的交叉和变异算子</p></figure><p id="57e1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">再说一次，我认为在代码中投入足够多的爱可以让它变得非常清楚:突变在字符串DNA中随机抽取一些字符，并随机修改它们。<code class="du lr ls lt lu b">(a,b)</code>的交叉取<code class="du lr ls lt lu b">a</code>的第一段，并相应地用它替换<code class="du lr ls lt lu b">b</code>的第一个元素。我们选择了这个交叉，因为我们怀疑(哼哼哼)CredentialCheck对象是按原样编码的(例如，我们从github窃取了信息)。</p><p id="96b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">既然我们知道了自然选择是如何运作的，我们就可以设计我们的进化计划了:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/ed9ebf33f062ba6cff16e0e663dc5524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*Ys7mjDnJQP_b7Fgyo_QmLw.png"/></div><p class="iq ir et er es is it bd b be z dx translated">人口进化计划</p></figure><p id="5482" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同样，我认为这里发生的事情应该是清楚的:给定一个初始随机群体，我们评估它(第0代)并开始进化过程:计算下一代，如果找到完美的东西就停止，或者等待超时。</p><h2 id="33e9" class="mc ka hi bd kb md me mf kf mg mh mi kj jf mj mk kn jj ml mm kr jn mn mo kv mp bi translated">结果呢</h2><p id="bd72" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">结果挺有意思的。攻击测试如下进行:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/01d38a17e891dbf71ec4542a1cdd803e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QePWdwoXNircds9Ma44lw.png"/></div></div></figure><p id="cc4e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们从一个很小的群体(2⁹ = 512)开始，每个字符串的大小在1到19之间，包括1和19。因此，总人口数为9728 (~2)。攻击经过的时间仅供参考。</p><p id="bfd4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">遗传算法的成本大致由<code class="du lr ls lt lu b">O(n log(n) * m)</code>给出，其中<code class="du lr ls lt lu b">n</code>是种群规模，<code class="du lr ls lt lu b">m</code>是迭代次数。在这里，1.000美元约为2 ⁹，但我们将看到最佳价格在200美元左右。不用说，我们没有优化我们的设计(例如，测试长度小于8的密码不是很有用)。</p><p id="e66a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">运行该算法会得到以下结果:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/0cf4be8026764d400db9e2a9a95cec08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18CPxq7fRb1UbUvc-itSSw.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">第一代攻击测试</p></figure><p id="3b58" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如你所见，开始相当复杂和缓慢。在红色部分，我们发现了两代最佳竞争对手(！)都是很短的字符串。在绿色部分，我们发现了两代“SEC”前缀已经出现在最佳竞争对手中的产品。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/6b96d85cd358d593117230f8881912f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGafHQLajdFQtVGGoCcPZw.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">最后几代，就在达到最优之前</p></figure><p id="f90b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">大约1.2秒后，我们在第190代达到了最佳配置(多次运行该算法可能会放弃大约100代！).在红色部分，我们发现了Java虚拟机有趣的噪声行为。正如你所看到的，这几代的最佳竞争者就像一个单独的字符串一样糟糕！</p><p id="ffe9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们认为这是由于我们测量的极端随机性。有趣的是，尽管那些表现不好但仍然表现最好的人和其他人的比例相同，但总的模式很快恢复到接近秘密通道的状态。</p><p id="11e3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们认为，与暴力相比，这一过程的遗传本质使得静态正确的模式在DNA中得以传递，即使有些世代运气不佳。</p><p id="5476" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">事实上，在一段时间后，我们可以注意到最优竞争者的百分比增加了20%左右。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/5474e3204c44e436ac735fcb77d433e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebX0FVnu4SvTsFfFWZk1Rw.png"/></div></div></figure><p id="a305" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">出于信息目的，这里是另一个运行的几何信息，根据Levenshtein-distance:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es my"><img src="../Images/0afa460b976d290d6af1bbaa40f76002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*yCtO3yOZBWgBwUxvQZhz9A.png"/></div></figure><h2 id="5eef" class="mc ka hi bd kb md me mf kf mg mh mi kj jf mj mk kn jj ml mm kr jn mn mo kv mp bi translated">防止计时攻击</h2><p id="5edd" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">好了，现在我们成功地黑了自己，我们如何保护？嗯，通常很难保护系统免受计时攻击，因为编译器和运行时都可能使用快速结束指令。它也可能来自处理器中的算术运算和相关的东西。</p><p id="be2b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第一步可能是加重CredentialCheck对象的重量，使其以常量指令计数结束:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/cdb14a1ce15da14a9edaab19fb87335d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9_ALhga01IoWOzmPPoz2w.png"/></div></div><p class="iq ir et er es is it bd b be z dx translated">凭证检查的常量指令版本</p></figure><p id="5fe0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个服务上运行我们的算法是行不通的:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es na"><img src="../Images/f3f4de23c14cbdd78fcfa251dd2b8e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*bFdeY_nnIhbvNV_bSHCQFg.png"/></div><p class="iq ir et er es is it bd b be z dx translated">遗传算法对“受保护”版本的悲惨失败</p></figure><p id="5ddb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这意味着我们安全了吗？我不知道。但也许我们比以前更安全了！</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="0d83" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">最后的话</h1><p id="cdc0" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">下面是我如何花了一些时间，用遗传算法的方法模拟时间攻击的乐趣。虽然这个设置并不完美，但我希望它能激发您对这个或那个主题的好奇心，并让您享受阅读Java代码的乐趣。</p><p id="4b12" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你想知道事物是如何设计的，可以在我的github(<a class="ae lh" href="https://github.com/Judekeyser/genetictimingattack" rel="noopener ugc nofollow" target="_blank">/Jude keyser/geneticitimingattack</a>)上免费获得代码。</p><p id="65a3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢任何建设性的反馈。</p><p id="31b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">干杯！</p></div></div>    
</body>
</html>