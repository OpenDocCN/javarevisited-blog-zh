<html>
<head>
<title>Hibernate — a silver bullet for Java Persistence (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">hibernate——Java持久性的银弹(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/hibernate-a-silver-bullet-for-java-persistence-part-1-14799751f525?source=collection_archive---------7-----------------------#2019-08-29">https://medium.com/javarevisited/hibernate-a-silver-bullet-for-java-persistence-part-1-14799751f525?source=collection_archive---------7-----------------------#2019-08-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="b850" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">关于职业选手有一场长期的辩论。和缺点。JPA或Hibernate的。(在本文中，我将交替使用这些术语)。一些作者声称JPA拿走了对SQL的控制。他们说，由于Hibernate作为一种工具，不能100%执行所需的“数据库任务”，用户迟早会遇到问题。他们解决这个问题的方法是…不使用JPA！</p></blockquote><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/889c3f96d7fa57d0de04fc5f0d97b3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sg0cu9PqDSYEuRZn"/></div></div><p class="jt ju et er es jv jw bd b be z dx translated"><a class="ae jx" href="https://unsplash.com/@bradbarmore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布拉德·巴摩尔</a>在<a class="ae jx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">太空望远镜</a>上拍摄的照片</p></figure><p id="a57c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jy iv iw ix jz iz ja jb ka jd je jf jg hb bi translated">在本系列中，我将展示Hibernate的出色之处。当达到极限时，应使用<strong class="il hj">互补</strong>工具。</p><p id="6b99" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jy iv iw ix jz iz ja jb ka jd je jf jg hb bi translated">简而言之，如果我一年去几次徒步旅行，我不会烧伤我的车。因为否则我每天早上都要徒步去我的办公室！</p><h1 id="300e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Hibernate最擅长什么？</h1><ul class=""><li id="2a0d" class="kz la hi il b im lb iq lc jy ld jz le ka lf jg lg lh li lj bi translated"><strong class="il hj"> ORM </strong>。地图。因为我们用Java编程，所以我们想使用对象。我们想要类型安全和智能感知。</li><li id="e59d" class="kz la hi il b im lk iq ll jy lm jz ln ka lo jg lg lh li lj bi translated">对象检索和持久化。我们可以很容易地通过这些变化<strong class="il hj">找到()</strong>和<strong class="il hj">持久化()</strong>后面的对象层次。</li></ul><h1 id="22c8" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">【Hibernate在哪些方面表现不佳？</h1><p id="a6ee" class="pw-post-body-paragraph ii ij hi il b im lb io ip iq lc is it jy lp iw ix jz lq ja jb ka lr je jf jg hb bi translated"><strong class="il hj">查询</strong>。实际上有一种JPA语言——JPQL，它允许我们编写一些<em class="ik">查询。我个人不喜欢它。因为这个“<em class="ik">一些</em>”并且因为我需要写一个字符串。我失去了Java编译器。所以，让我们寻找一个补充工具！</em></p><ul class=""><li id="8571" class="kz la hi il b im in iq ir jy ls jz lt ka lu jg lg lh li lj bi translated"><a class="ae jx" href="https://docs.spring.io/spring-data/jpa/docs/2.1.9.RELEASE/reference/html/#repositories.query-methods.query-creation" rel="noopener ugc nofollow" target="_blank">JPA repository</a>，它根据方法名构造查询。对于在实体上构建约束查询来说，这既简单又有用。</li></ul><p id="926f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jy iv iw ix jz iz ja jb ka jd je jf jg hb bi translated">Hibernate的基本<strong class="il hj"> find() </strong>和<strong class="il hj"> persist() </strong>与JPA Repositories相结合，通常可以满足70–80%(如果不是更多)的应用程序数据库需求。并且做得非常干净和高效。</p><p id="4688" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jy iv iw ix jz iz ja jb ka jd je jf jg hb bi translated">还剩下什么？<strong class="il hj"> <em class="ik">复杂的</em> </strong>查询。我们要委托给数据库的业务逻辑。我们通常会向数据库管理员咨询的事情。从业务角度来看，这可能是最重要的东西，但它并不超过我们数据库需求的20-30%。</p><p id="63d8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jy iv iw ix jz iz ja jb ka jd je jf jg hb bi translated">那么，对于剩下的20–30%，您准备好放弃其他70%的简单性了吗？我不推荐。相反，让我们选择一个工具来补充和提供缺失的功能。</p><h1 id="d6d4" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">流利的初级专业人员</h1><p id="fa66" class="pw-post-body-paragraph ii ij hi il b im lb io ip iq lc is it jy lp iw ix jz lq ja jb ka lr je jf jg hb bi translated"><a class="ae jx" href="https://github.com/streamx-co/FluentJPA" rel="noopener ugc nofollow" target="_blank"> FluentJPA </a>让我们用Java编写SQL，使用JPA模型定义的实体(映射)。它允许使用Java语言，具有类型安全、智能感知、重构和其他IDE特性。有了它，您可以满足其余的数据库需求。让我们看几个例子:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="lv lw l"/></div><p class="jt ju et er es jv jw bd b be z dx translated">带有外部参数的简单查询的完整流程</p></figure><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="lv lw l"/></div><p class="jt ju et er es jv jw bd b be z dx translated">用Java编写的带有JPA实体的子查询</p></figure><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="lv lw l"/></div><p class="jt ju et er es jv jw bd b be z dx translated">相关子查询(第8行)</p></figure><p id="9d37" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jy iv iw ix jz iz ja jb ka jd je jf jg hb bi translated">你可以用<a class="ae jx" href="https://github.com/streamx-co/FluentJPA" rel="noopener ugc nofollow" target="_blank"> FluentJPA </a>做任何事情都没有限制。但最重要的是，您可以为每项任务选择最好的工具，而不会损害可维护性、功能或性能！</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lx"><img src="../Images/42f37e3d83d65125410540b4d5efe9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTdW1UlIOcx34QD_yuIOsA.jpeg"/></div></div></figure></div></div>    
</body>
</html>