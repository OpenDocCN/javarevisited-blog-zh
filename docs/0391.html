<html>
<head>
<title>Factory Pattern For Test Automation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试自动化的工厂模式</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/factory-pattern-for-test-automation-828b09499dab?source=collection_archive---------1-----------------------#2020-04-20">https://medium.com/javarevisited/factory-pattern-for-test-automation-828b09499dab?source=collection_archive---------1-----------------------#2020-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ea2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们应该知道什么是/为什么是设计模式(请参考链接以获得更多理解——待定)。我们应该知道什么是工厂模式，什么时候使用工厂模式。</p><p id="e59f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工厂模式是Java 中最常用的设计模式之一。这种类型的设计模式属于创建模式，因为这种模式提供了创建对象的最佳方式之一。</p><p id="0e76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="http://javarevisited.blogspot.sg/2011/12/factory-design-pattern-java-example.html#axzz51cvxH5kW" rel="noopener ugc nofollow" target="_blank">工厂模式</a>中，我们创建一个对象，而不将创建逻辑暴露给客户端，并引用新创建的对象返回给客户端，使用或者在接口中指定并由子类实现，或者在基类中实现并可选地由派生类覆盖(使用公共接口)。</p><p id="a2ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么工厂模式是-</p><ol class=""><li id="b3b6" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">工厂类防止客户端代码的耦合。</li><li id="b165" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">初始化保存在一个地方，而不是有多个新的MyObject()调用，满足了不重复自己(DRY)的原则。</li><li id="2e99" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">对象的新版本可以很容易地从工厂方法中返回。派生类必须满足Liskov替换原则。</li><li id="53c4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">工厂设计模式提供了一种为接口而不是实现编码的方法。</li><li id="2ab8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">工厂模式通过继承提供了实现和客户端类之间的抽象。</li></ol><p id="507d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们写一些代码来理解它。</p><p id="1981" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">演示—实时</strong></p><p id="eba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个例子很容易理解工厂模式的行为，</p><div class="js jt ju jv fd ab cb"><figure class="jw jx jy jz ka kb kc paragraph-image"><a href="http://javarevisited.blogspot.sg/2013/01/difference-between-factory-and-abstract-factory-design-pattern-java.html"><img src="../Images/22f5f05cc59fe22b991120d0e73dc57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*sPH3ZNJdQWwha0lAwl5_SQ.jpeg"/></a></figure><figure class="jw jx kf jz ka kb kc paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><img src="../Images/3a9cfc7ae0b24a59d64c37673a2d2b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*hfZZ0-Kw9z7kybrPHwDccg.jpeg"/></div><p class="kk kl et er es km kn bd b be z dx ko di kp kq translated">货币具体类、工厂类和工厂客户代码</p></figure></div><h2 id="7ede" class="kr ks hi bd kt ku kv kw kx ky kz la lb iq lc ld le iu lf lg lh iy li lj lk ll bi translated"><strong class="ak">演示—用于测试目的</strong></h2><figure class="js jt ju jv fd jx er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-java-design-pattern-courses-for-developers.html"><div class="er es lm"><img src="../Images/f2efa79f078845965aa00f8ece3dc5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7dfQ9sOJrw6x_0-Hlg86Xg.jpeg"/></div></a><p class="kk kl et er es km kn bd b be z dx translated">Chrome/Firefox/Safari/IE驱动程序的具体类实现了这个WebDriver接口，我们可以通过WebDriver接口引用ChromeDriver/FirefoxDriver等，而无需对代码做太多修改</p></figure><p id="09fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用带有测试类的工厂模式</p><figure class="js jt ju jv fd jx er es paragraph-image"><a href="https://www.java67.com/2012/09/top-10-java-design-pattern-interview-question-answer.html"><div class="er es lm"><img src="../Images/11c8291c87d08de80ca6d8fa044ef574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKKTFAvCvU5fs1Ww9PDByA.jpeg"/></div></a></figure><p id="689a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看工厂是如何与我们的示例集成的。作为用户，测试类不应该真正关心驱动程序实际上是如何创建的。它需要的只是一个WebDriver实例来执行给定的测试用例。因此，我们提出了自己的抽象类“DriverManager ”,测试类可以使用它来获取驱动程序实例，并在测试中使用它们。</p><p id="6335" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看具体的实现示例-</p><figure class="js jt ju jv fd jx"><div class="bz dy l di"><div class="ln lo l"/></div><p class="kk kl et er es km kn bd b be z dx translated"><a class="ae jd" href="https://gist.github.com/preelakmali/876a0481209dcc7b1b758ed177a43adf" rel="noopener ugc nofollow" target="_blank">DriverManager.java</a></p></figure><figure class="js jt ju jv fd jx"><div class="bz dy l di"><div class="ln lo l"/></div><p class="kk kl et er es km kn bd b be z dx translated"><a class="ae jd" href="https://gist.github.com/preelakmali/df7c8e8e873fe95a4d02a1bf5cfe7da6" rel="noopener ugc nofollow" target="_blank"> ChromeDriverManger.js </a></p></figure><figure class="js jt ju jv fd jx"><div class="bz dy l di"><div class="ln lo l"/></div><p class="kk kl et er es km kn bd b be z dx translated">DriverType.java<a class="ae jd" href="https://gist.github.com/preelakmali/a1955a1d4fb29030ac3ec634238be465" rel="noopener ugc nofollow" target="_blank"/></p></figure><figure class="js jt ju jv fd jx"><div class="bz dy l di"><div class="ln lo l"/></div><p class="kk kl et er es km kn bd b be z dx translated">【DriverManagerFactory.java T4】</p></figure><figure class="js jt ju jv fd jx"><div class="bz dy l di"><div class="ln lo l"/></div><p class="kk kl et er es km kn bd b be z dx translated"><a class="ae jd" href="https://gist.github.com/preelakmali/d1661a6bfd24566e17a2a2a1543a4d44" rel="noopener ugc nofollow" target="_blank">FactoryPatternTest.java</a></p></figure><figure class="js jt ju jv fd jx er es paragraph-image"><div class="er es lp"><img src="../Images/ad8d92b0e7cb22830b84099553bd3be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*Xi6nZNuv58WPIOXlS8HWgw.png"/></div><p class="kk kl et er es km kn bd b be z dx translated">输出</p></figure><p id="5ac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用<a class="ae jd" href="https://javarevisited.blogspot.com/2012/06/20-design-pattern-and-software-design.html" rel="noopener ugc nofollow" target="_blank">工厂模式</a>，我们对测试类完全隐藏了浏览器/服务实例的创建逻辑。如果我们得到一个添加新浏览器的新需求，比如说PhantomJS，应该没什么大不了。我们只需要创建一个扩展DriverManager的PhantomJSDriverManager。</p><p id="8311" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这篇文章会有所帮助，您的疑问请尽管问:)</p></div></div>    
</body>
</html>