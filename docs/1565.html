<html>
<head>
<title>Spring Core: Including Aspect-Oriented Programming in your skills</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Core:在你的技能中包含面向方面编程</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-core-including-aspect-oriented-programming-in-your-skills-2c37eaa75c2a?source=collection_archive---------1-----------------------#2021-09-16">https://medium.com/javarevisited/spring-core-including-aspect-oriented-programming-in-your-skills-2c37eaa75c2a?source=collection_archive---------1-----------------------#2021-09-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="666a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">理解Spring如何在幕后工作——第三章</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/dc33bf2f81bd822f4483d14bdcb95cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOebYKVhG2Rv6p6CvxfUSw.png"/></div></div></figure><p id="b550" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在前两章中，我们介绍了所有你需要知道的Spring核心基础知识，探索了IoC是如何工作的，以及依赖注入背后的所有科学。如果你错过了这个，看看第一章和第二章的<a class="ae kf" rel="noopener" href="/javarevisited/spring-core-ioc-and-container-c01608b527a1">。</a></p><p id="d828" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">本章将从Spring Core的角度介绍面向方面的编程范式，解释它是如何工作的，并使用案例来应用它。</p><h1 id="24e8" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">AOP和代理</h1><p id="5b17" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">让我们开始定义AOP的缩写:</p><blockquote class="ld"><p id="6253" class="le lf hi bd lg lh li lj lk ll lm ke dx translated"><em class="ln">面向方面编程</em> ( <a class="ae kf" href="https://javarevisited.blogspot.com/2021/03/spring-aop-interview-questions-answers.html#axzz6t8XhPyPu" rel="noopener ugc nofollow" target="_blank"> AOP </a>)通过提供另一种思考程序结构的方式来补充面向对象编程(OOP)。在OOP中模块化的关键单元是类，而在AOP中模块化的单元是方面。方面支持关注点的模块化，比如跨越多种类型和对象的事务管理。—春季文档。</p></blockquote><p id="ffa7" class="pw-post-body-paragraph jj jk hi jl b jm lo ij jo jp lp im jr js lq ju jv jw lr jy jz ka ls kc kd ke hb bi translated">将其翻译成一种更常见的语言，我们可以将AOP定义为我们日常工作的补充，有助于解决<em class="lt">横切</em>关注用例及事务管理。正如我们常说的，有了榜样，一切都会变得更好:</p><p id="8cc8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">假设您已经有了自己的<a class="ae kf" href="https://www.java67.com/2019/10/spring-helloworld-example-in-Java-eclipse.html" rel="noopener ugc nofollow" target="_blank"> Spring应用程序</a>并正在运行。您有一些服务、存储库，为了向您的服务添加一些监控，您开始添加日志。例如，您的方法结构将如下所示:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="e21f" class="lz kh hi lv b fi ma mb l mc md">void serviceMethodA(String param) {<br/>  log.info("Starting method A with param: ", param);<br/>  // Business code<br/>  ...<br/>}</span></pre><p id="e0f5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">同样，您的其他服务方法看起来也非常相似:</p><pre class="iy iz ja jb fd lu lv lw lx aw ly bi"><span id="3c7f" class="lz kh hi lv b fi ma mb l mc md">void serviceMethodB() {<br/>  log.info("Starting method B");<br/>  // Business code<br/>  ...<br/>}</span></pre><p id="fea0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我需要你注意一件事:现在每个方法都有两个职责。</p><ul class=""><li id="592d" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated"><a class="ae kf" href="https://javarevisited.blogspot.com/2011/05/top-10-tips-on-logging-in-java.html" rel="noopener ugc nofollow" target="_blank">测井</a></li><li id="dcb5" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">执行业务操作</li></ul><p id="5ea8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所有的业务操作都是(或者应该是)独立的，对于每个方法都是唯一的，但是日志记录适用于所有方法，没有任何改变。记录器的目标只是提供关于方法内部发生了什么的信息，而不干扰方法执行本身，并在所有应用程序中复制。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/how-to-fix-exception-in-thread-main.html"><div class="er es ms"><img src="../Images/23dea57f60166ee7f3b9d94006fadb67.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*4Bn4CAISblwaTb3JI0fq5g.png"/></div></a></figure><p id="460f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如您所见，日志是我们所有服务中重复使用的相同方法。通常，在<a class="ae kf" rel="noopener" href="/javarevisited/7-best-online-courses-to-learn-object-oriented-design-pattern-in-java-749b6399af59">面向对象设计</a>中，你习惯于在垂直视图中看到类。这意味着，开始读取类，方法，并垂直组织代码。现在，当您将所有的服务类放在一起时，是时候横向查看它了。在这里，我们将找到我们的<strong class="jl hj">交叉关注点</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/08/5-object-oriented-programming-and-design-courses-for-Java-programmers.html#axzz6fvDCikIM"><div class="er es mt"><img src="../Images/f93968a4f01e26d0d224c0e63c2d538d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*SNnFD1wFACxujzEDOrXLaw.png"/></div></a></figure><p id="ea2c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">日志记录是最常见的例子，但是还可能有其他例子，比如警告一些外部服务、将数据保存到数据库、缓存等等。让我们保持简单，使用日志示例。现在我们已经确定了我们的横切用例，现在，把日志记录的东西从我们的方法中分离出来不是很好吗？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2020/04/how-to-send-logger-messages-to-syslog-using-log4j-java-linux.html"><div class="er es mu"><img src="../Images/26c2d1741995a5e325cea76749cbc231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*DM8iQ8-NXKii9je8h21Geg.png"/></div></a></figure><p id="be2c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这种方法有两个主要好处:</p><ul class=""><li id="ff6d" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated">日志责任分离</li><li id="1136" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">所有方法现在只有业务代码，易于阅读和维护。</li></ul><p id="2b4e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是AOP的基础。你的系统的另一个观点，在这里你开始将横向交叉的案例隔离到类中，以截取你的业务类。这就是我们所说的<code class="du mv mw mx lv b">Aspect</code>。</p><p id="5b39" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我们的项目中，我们有两种实现AOP的选择:</p><ul class=""><li id="f729" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated">AspectJ:一种完整的AOP语言，在字节码级别实现方面。</li><li id="ddf2" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">Spring AOP:与AOP集成的Java框架。</li></ul><p id="77a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">可以想象，我们将使用第二个选项。</p><h2 id="2411" class="lz kh hi bd ki my mz na km nb nc nd kq js ne nf ks jw ng nh ku ka ni nj kw nk bi translated">关于AOP的一些基本概念</h2><p id="ecd9" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">你需要熟悉以下表达方式:</p><ul class=""><li id="001e" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated"><strong class="jl hj">连接点</strong>:程序执行的具体点。</li><li id="f060" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><strong class="jl hj">点切割</strong>:分组一个或多个连接点的表达式。</li><li id="21d4" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><strong class="jl hj">建议</strong>:要在某个连接点执行的代码</li><li id="e9a7" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><strong class="jl hj">方面</strong>:封装连接点和通知的模块。</li><li id="2d4a" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><strong class="jl hj">编织</strong>:方面和业务代码的结合。</li></ul><p id="b952" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们看看这些元素在Java类中是如何表示的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="b0c3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里要注意两点:</p><ul class=""><li id="cb19" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated">切入点。用表达式<code class="du mv mw mx lv b">execution(void set*(*))</code>表示。</li><li id="09eb" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><code class="du mv mw mx lv b">@Before</code>的建议。这意味着<code class="du mv mw mx lv b">trackMethod()</code>将在业务方法代码之前执行。</li></ul><p id="4011" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">切入点表达式在开始时可能很难理解，所以让我们更详细地解释一下:</p><ul class=""><li id="4da0" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated"><code class="du mv mw mx lv b">execution(&lt;method-pattern&gt;)</code>语句定义了切入点。</li><li id="f13c" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">方法模式工作如下:<code class="du mv mw mx lv b">designator (returnType +package + class + method (params)</code></li><li id="fab7" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">您可以使用逻辑操作符如<code class="du mv mw mx lv b">||</code>或<code class="du mv mw mx lv b"> &amp;&amp;</code>或<code class="du mv mw mx lv b">!</code>在同一个通知中链接更多的切入点</li></ul><p id="7c19" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，看这个例子，我们可以识别切入点部分:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nn"><img src="../Images/b3a3229978796dbf0556b8b380949837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*6Q4h3hW2BToJiaNjDPdqlw.png"/></div><p class="no np et er es nq nr bd b be z dx translated">切入点部分详细信息</p></figure><p id="32f6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">翻译成人类语言就是:执行所有从<strong class="jl hj"> set </strong>开始的<strong class="jl hj"> void </strong>方法，只接受一个参数。</p><p id="0ca4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有一系列规则来编写切入点表达式，你可以在本文中找到关于它的更多细节和一些更复杂的例子<a class="ae kf" href="https://www.baeldung.com/spring-aop-pointcut-tutorial" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="adfd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">开始的时候听起来可能有点棘手，但是通过一些练习，你会很快掌握所有这些概念。继续读我的朋友！</p><h2 id="280b" class="lz kh hi bd ki my mz na km nb nc nd kq js ne nf ks jw ng nh ku ka ni nj kw nk bi translated">方法代理</h2><p id="c04a" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">现在，让我们看看建议注释。我们已经说过<code class="du mv mw mx lv b">@Before</code>通知意味着<code class="du mv mw mx lv b">trackMethod()</code>将在切入点中定义的被拦截的方法之前执行。让我们用图表来表示它:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ns"><img src="../Images/14f5796a270c8fe98c5d69864693afc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*vUMdZWI_VWxrqM5FPh2xxQ.png"/></div><p class="no np et er es nq nr bd b be z dx translated">建议前的图表</p></figure><p id="71f4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">代理？是的。下面是Spring AOP背后的所有秘密。我们之前说过，Spring不是魔法，我们来解释一下代理是如何工作的。</p><p id="d03f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如您已经知道的，一旦创建了Spring上下文，Spring就会扫描所有标记为<code class="du mv mw mx lv b">@Bean</code>、<code class="du mv mw mx lv b"><a class="ae kf" href="https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html" rel="noopener ugc nofollow" target="_blank">@Component</a></code>等的类。对于<code class="du mv mw mx lv b">@Aspect</code>，Spring将采用不同的方法。</p><ul class=""><li id="5229" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated">Spring将基于截取的类创建一个代理类。比如我们在拦截<code class="du mv mw mx lv b">ServiceA</code>，Spring就会创建<code class="du mv mw mx lv b">ServiceAProxy</code>。这个类只在Spring上下文中创建，我们无法看到或操作它。</li><li id="a82d" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">一旦代理被创建，<a class="ae kf" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring </a>将拦截所有使用代理的方法调用。一旦执行了方面方法，代理将返回到原来的方法。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/06/top-6-spring-framework-online-courses-Java-programmers.html"><div class="er es nt"><img src="../Images/a83b326840936a023dcc1bcd9dec761e.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*MHoIxnFi0JUrMiEqYD9Ljg.png"/></div></a><p class="no np et er es nq nr bd b be z dx translated">代理过程的表示</p></figure><p id="f5dd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如您所看到的，代理根据给定的通知编排调用方面方法和目标方法之间的所有过程。我们有4种类型的建议:</p><ul class=""><li id="1012" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated"><code class="du mv mw mx lv b">Before</code>:目标方法执行前。</li><li id="b13f" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><code class="du mv mw mx lv b">After</code>:方法执行后，无论成功与否。</li><li id="e5a1" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><code class="du mv mw mx lv b">AfterThrowing</code>:异常抛出后触发。</li><li id="b361" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><code class="du mv mw mx lv b">AfterReturning</code>:当执行方法成功完成，我们得到了想要的输出。</li><li id="397b" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">最强大的，让我们完全控制所有目标方法的生命周期。</li></ul><p id="9560" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">举个例子，让我们用图表展示一下around建议是如何工作的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2017/11/top-5-free-core-spring-mvc-courses-learn-online.html"><div class="er es nu"><img src="../Images/4f438c153d3e586a7af1e9a4a9e6dd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*KIV7JoWJTk6Y2Wby0t1_3g.png"/></div></a><p class="no np et er es nq nr bd b be z dx translated">代表建议的图表</p></figure><p id="95ee" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">作为实践，您可以开始为<code class="du mv mw mx lv b">@After</code>、<code class="du mv mw mx lv b">@AfterThrowing</code>和<code class="du mv mw mx lv b">@AfterReturning</code>建议创建图表，以便更好地理解它。</p><p id="a53a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">关于Spring AOP你需要知道的就这些吗？当然不是，这里我们只从零开始解释了AOP是如何在幕后工作的，但是可以肯定的是，您现在已经有了理解更高级主题的基本概念，例如:</p><ul class=""><li id="cf32" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated"><a class="ae kf" href="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch08s06.html" rel="noopener ugc nofollow" target="_blank">代理机制:动态JDK vs CGLib </a></li><li id="8b6d" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><a class="ae kf" href="https://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html#aop-aspectj-support" rel="noopener ugc nofollow" target="_blank"> AspectJ支持</a></li><li id="072b" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><a class="ae kf" href="https://www.baeldung.com/spring-aop-get-advised-method-info" rel="noopener ugc nofollow" target="_blank">使用Spring AOP获取方法信息</a></li></ul></div><div class="ab cl nv nw gp nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="hb hc hd he hf"><p id="49d0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们已经完成了我将在这个月发布的Spring Core系列的第三章。如果你觉得有用，请关注我，继续关注下一篇:</p><ul class=""><li id="cbb3" class="me mf hi jl b jm jn jp jq js mg jw mh ka mi ke mj mk ml mm bi translated"><a class="ae kf" rel="noopener" href="/javarevisited/spring-core-ioc-and-container-c01608b527a1">弹簧芯:IoC和容器</a></li><li id="9bad" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><a class="ae kf" rel="noopener" href="/javarevisited/spring-core-all-you-need-to-know-about-dependency-injection-2048d80340af"> Spring Core:关于依赖注入你需要知道的一切</a></li><li id="6cb9" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated">Spring Core:在您的技能中包含面向方面的编程</li><li id="395e" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><a class="ae kf" rel="noopener" href="/javarevisited/spring-core-managing-transactions-effectively-781bba6c47e8"> Spring Core:有效管理事务</a></li><li id="16d8" class="me mf hi jl b jm mn jp mo js mp jw mq ka mr ke mj mk ml mm bi translated"><a class="ae kf" rel="noopener" href="/javarevisited/spring-core-using-rest-and-spring-mvc-cef35acbec8e"> Spring Core:使用REST和Spring MVC </a></li></ul><p id="f4fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">还有，不要犹豫，把你的疑惑贴出来。我非常乐意在这个奇妙的旅程中帮助你。</p></div></div>    
</body>
</html>