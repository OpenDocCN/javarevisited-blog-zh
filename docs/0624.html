<html>
<head>
<title>MO’s Algorithm — Range Queries Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">莫算法——范围查询变得简单</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/mos-algorithm-range-queries-made-easy-6c35047369ca?source=collection_archive---------1-----------------------#2020-08-04">https://medium.com/javarevisited/mos-algorithm-range-queries-made-easy-6c35047369ca?source=collection_archive---------1-----------------------#2020-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="759a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一种解决离线范围查询问题的有效方法😏</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/1b2436603985b3208d050da92444e524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qdwC_wo4s55v1POC"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">阿里安·达尔维什在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0ab1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">莫氏算法</strong>又名<strong class="jq hj">平方根分解</strong>，一种非常高效简单的解决<strong class="jq hj">范围查询问题的技术(RQP)。</strong>为了让莫的算法工作，<strong class="jq hj"/>必须<strong class="jq hj">离线</strong>。在本帖中，我们将了解RQP、离线RPQ、求解RQP的简单方法以及使用莫算法的有效方法。</p><h2 id="d888" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">什么是范围查询问题？</h2><p id="7736" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">给你一个序列<strong class="jq hj"><em class="lk"/></strong><strong class="jq hj"><em class="lk"/></strong>n个值<strong class="jq hj"><em class="lk">【a₁】、【A₃】、…【aₙ】</em></strong>。你也被给予<strong class="jq hj"> <em class="lk"> Q </em> </strong>的查询。在每次查询中，会给你两个值<strong class="jq hj"> <em class="lk"> l </em> </strong>和<strong class="jq hj"> <em class="lk"> r </em> </strong>。你的任务是对子序列<strong class="jq hj"> <em class="lk">、Aₗ、…、Aᵣ₋₁、Aᵣ </em> </strong>中的元素执行函数<strong class="jq hj"> <em class="lk"> f(l，r) </em> </strong></p><h2 id="52fb" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">什么是离线查询问题？</h2><p id="d376" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">如果满足以下条件，则RQP处于离线状态</p><ol class=""><li id="dd48" class="ll lm hi jq b jr js ju jv jx ln kb lo kf lp kj lq lr ls lt bi translated">所有的查询都是预先知道的。</li><li id="ae74" class="ll lm hi jq b jr lu ju lv jx lw kb lx kf ly kj lq lr ls lt bi translated">给定序列上没有更新操作。</li></ol><h2 id="8a7e" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">问题陈述</h2><p id="01f7" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">给你一个序列<strong class="jq hj"> <em class="lk">一个</em> </strong>的<strong class="jq hj"> <em class="lk"> N个</em> </strong>的值<strong class="jq hj"> <em class="lk"> A₁、A₂、A₃、…、Aₙ.</em> </strong>你也给出了<strong class="jq hj"> <em class="lk"> Q </em> </strong>的查询。每个查询会有两个值<strong class="jq hj"> <em class="lk"> l </em> </strong>和<em class="lk"> r </em> 。你的任务是找出范围<strong class="jq hj"> <em class="lk"> Aₗ，Aₗ₊₁，…，Aᵣ₋₁，Aᵣ </em> </strong>中的元音数</p><h2 id="da07" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">天真的方法</h2><p id="25a5" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">一个简单的方法是，对每个查询<strong class="jq hj"> <em class="lk"> (l，r) </em> </strong>从<strong class="jq hj"/>迭代到<strong class="jq hj"> <em class="lk"> r </em> </strong>，找出范围内元音的个数。下面给出了一个示例代码片段。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/0ca2d4917405df27f7b23697e8f241ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H1JtY21YG3RJCU3Gh_Y2Qw.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">朴素方法的Java代码片段</p></figure><p id="b5a3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">时间复杂度<br/> </strong>上述代码的时间复杂度为<strong class="jq hj"> <em class="lk"> O(N*Q) </em> </strong>其中<strong class="jq hj"> N =序列中元素的数量</strong>和<strong class="jq hj"> Q =查询的数量。</strong></p><h2 id="abd3" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">莫算法</h2><p id="a641" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">莫的算法遵循两个简单的步骤来提高解决方案的效率</p><ol class=""><li id="cac7" class="ll lm hi jq b jr js ju jv jx ln kb lo kf lp kj lq lr ls lt bi translated">将序列分成<strong class="jq hj"> <em class="lk"> √N </em> </strong> <em class="lk">块。</em></li><li id="ca85" class="ll lm hi jq b jr lu ju lv jx lw kb lx kf ly kj lq lr ls lt bi translated">重新排列所有查询，使查询<strong class="jq hj"> <em class="lk"> (l₁，r₁) </em> </strong>在<strong class="jq hj"> <em class="lk"> (l₂，r₂) </em> </strong>之前，如果</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/69391f741b2826f7d4a805afa519ac14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DaAl5I8twjmBmZfhv5V7Dg.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">莫的订单条件</p></figure><p id="7439" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过以上述方式重新排列查询，我们倾向于在处理另一个块的查询之前处理一个块的所有查询，从而最小化指针移动<strong class="jq hj"> <em class="lk"> i </em> </strong>和<strong class="jq hj"> <em class="lk"> j. </em> </strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/41103d95ca0525803fe74bd9a20f810f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMkKdkExxAAE71E4jknLEw.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">样本序列</p></figure><p id="70d3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们有一个大小为12的字母序列。现在我们应用第一步，在我们的序列中计算块大小</p><p id="9e7f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="lk"> BLOCK_SIZE = √12 ≈ 3，</em> </strong>所以，我们把我们的序列分成3个大小为4的块。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/a4062126abc869cb3c61ef33433df665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLuaBh8f7HFMpGnm78vWdw.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">序列分为√N个块</p></figure><p id="7b90" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在考虑给我们以下查询<strong class="jq hj"> <em class="lk"> (4，9)，(3，7)，(2，8)，(0，5)，(7，10)，(1，11) </em> </strong></p><p id="6b4c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下一步是根据<strong class="jq hj">生产订单安排上述查询。</strong>下面给出了排序逻辑的java代码片段</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/5355a80564cca46b85f0fef5dcfbe729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pzCGpvAV30ooI8Dt8QwkDQ.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">Soring逻辑的代码片段</p></figure><p id="a16e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，查询将重新排列为<strong class="jq hj"> <em class="lk"> (0，5)，(2，8)，(1，11)，(3，7)，(4，9)，(7，10) </em> </strong></p><p id="87a7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们按照新的顺序处理查询</p><ol class=""><li id="2805" class="ll lm hi jq b jr js ju jv jx ln kb lo kf lp kj lq lr ls lt bi translated">最初，<strong class="jq hj"> <em class="lk"> i </em> </strong>，<strong class="jq hj"> <em class="lk"> j </em> </strong>，<strong class="jq hj"> <em class="lk"> vowelsCount </em> </strong>会被设置为<strong class="jq hj"> <em class="lk"> 0 </em> </strong>。</li><li id="ea8f" class="ll lm hi jq b jr lu ju lv jx lw kb lx kf ly kj lq lr ls lt bi translated">整个想法基于两个观察</li></ol><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="0183" class="kk kl hi mf b fi mj mk l ml mm">a. While <strong class="mf hj">incrementing</strong> <strong class="mf hj"><em class="lk">i </em></strong>we are excluding <strong class="mf hj"><em class="lk">A[i]</em></strong> from our range and while <strong class="mf hj">decrementing <em class="lk">i</em></strong> we are including <strong class="mf hj"><em class="lk">A[i]</em></strong> in our range.<br/>b. While <strong class="mf hj">incrementing <em class="lk">j </em></strong>we are including <strong class="mf hj"><em class="lk">A[j]</em></strong> from our range and while <strong class="mf hj">decrementing <em class="lk">j</em></strong> we are including <strong class="mf hj"><em class="lk">A[j]</em></strong> in our range.</span></pre><p id="bf76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">3.第一个查询是<strong class="jq hj"> <em class="lk"> (0，5) </em> </strong>。<strong class="jq hj"> <em class="lk">我</em> </strong>在正确的位置。所以，我们增加<strong class="jq hj"> <em class="lk"> j </em> </strong>直到达到<strong class="jq hj"> <em class="lk"> 5 </em> </strong>。在递增<strong class="jq hj"> <em class="lk"> j </em> </strong>的同时如果出现在<strong class="jq hj"><em class="lk">A【j】</em></strong>的字母是元音我们递增<strong class="jq hj"> <em class="lk"> vowelsCount </em> </strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/3acf41982644072b9060d72985410352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_gck9PvS5_1X4nfH9wFCmA.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">处理查询(0，5)</p></figure><p id="c9f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">4.下一个查询是<strong class="jq hj"><em class="lk">【2，8】</em></strong>。目前，<strong class="jq hj">T5、I、</strong>j分别处于<strong class="jq hj"> <em class="lk"> 0 </em> </strong>和<strong class="jq hj"> <em class="lk"> 5 </em> </strong>位置。因此我们递增<strong class="jq hj"> <em class="lk"> j </em> </strong>直到它到达<strong class="jq hj"> <em class="lk"> 8 </em> </strong>并且递增<strong class="jq hj"> <em class="lk"> i </em> </strong>直到它到达索引<strong class="jq hj"> 2 </strong>。当递增<strong class="jq hj"> <em class="lk"> j </em> </strong>时，如果<strong class="jq hj"><em class="lk">【j】</em></strong>处的字母是元音，我们递增<strong class="jq hj"><em class="lk">【vowelsCount】，</em> </strong>并且当递增<strong class="jq hj"> <em class="lk"> i </em> </strong>时，如果<strong class="jq hj"> <em class="lk">处的字母A【I】</em></strong>是元音，我们递减<strong class="jq hj"> <em class="lk"> vowelsCount </em> </strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/930cda4ac2072d4d1c1d59d866d9feed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXlGRHPY4ndbrpk7jSihZA.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">过程查询(2，8)</p></figure><p id="ab91" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">5.接下来的查询是<strong class="jq hj"> <em class="lk"> (1，11) </em> </strong>。目前，<strong class="jq hj"><em class="lk">I</em></strong><strong class="jq hj"><em class="lk">j</em></strong>分别在位<strong class="jq hj"> <em class="lk"> 2 </em> </strong>和<strong class="jq hj"> <em class="lk"> 8 </em> </strong>。所以我们增加<strong class="jq hj"> <em class="lk"> j </em> </strong>直到它到达<strong class="jq hj"> <em class="lk"> 11 </em> </strong>并且减少<strong class="jq hj"> <em class="lk"> i </em> </strong>直到它到达索引<strong class="jq hj"> 1 </strong>。当递减<strong class="jq hj"> <em class="lk"> i时，我们递增vowelsCount </em> </strong>并且当递增j时，我们递增<strong class="jq hj"> <em class="lk"> vowelsCount </em> </strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/fbb2d82aebf55cb6ea19de4e90572a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_PREUnry2uy1TVKITGfAw.png"/></div></div></figure><p id="972b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">6.同样，我们可以根据剩余的查询调整指针<strong class="jq hj"> <em class="lk"> i </em> </strong>和<strong class="jq hj"> j </strong>。剩下的步骤如下图所示</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/b7fb155aac84d46363e8d9c988436f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zEiIvMCPrpbjRXLQzoSq5A.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">过程查询(3，7)</p></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/6a26e37b1670157645aa3eab68e8f15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICUuP_1XVn8O8b64if2gvQ.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">过程查询(4，9)</p></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/0416a5809e1ea770250f0c893b50e62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uuLBv6k3bSWMJCdO_HhIhQ.png"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">过程查询(7，10)</p></figure><p id="5057" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦处理完所有的查询，我们就可以按照给定的查询顺序打印结果。</p><p id="d19b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">时间复杂度<br/> </strong>对于每个查询，有两次移动，一次是指针<strong class="jq hj"> <em class="lk"> i </em> </strong>和指针<strong class="jq hj"> <em class="lk"> j </em> </strong></p><p id="77f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">指针的移动<em class="lk"> i </em> <br/> </strong>所有的查询都是按照<strong class="jq hj"> <em class="lk"> l </em> </strong>值按块分组的方式进行排序的。因此，在处理完当前块中的所有查询之前，我们不会移动到下一个块。所以，<strong class="jq hj"> <em class="lk"> i </em>的</strong>运动对于每次查询都会是<strong class="jq hj"> <em class="lk"> O(√N) </em> </strong>。所以对于Q查询，复杂度将是<strong class="jq hj"> <em class="lk"> O(Q * √N) </em> </strong></p><p id="0cac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">指针的移动<em class="lk"> j </em> <br/> </strong>所有查询按照<strong class="jq hj"> <em class="lk"> r </em>的升序排序。</strong>所以，对于给定的块<strong class="jq hj"> <em class="lk"> j </em> </strong>将一直递增。因此，<strong class="jq hj"> <em class="lk"> j </em> </strong> <em class="lk"> </em>对于每个块<strong class="jq hj">可以一直行进到<strong class="jq hj"> <em class="lk"> N </em> </strong>。</strong>所以复杂度会是<strong class="jq hj"> <em class="lk"> O(N * √N) </em> </strong></p><p id="c580" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以，整体复杂度会是<strong class="jq hj"><em class="lk">O(Q *√N)+O(N *√N)= O((N+Q)*√N)</em></strong></p><h2 id="cd41" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">结论</h2><p id="2a79" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">莫的算法在竞技编程中会很有用。你可以在<a class="ae jn" href="https://www.codechef.com/tags/problems/mos-algorithm" rel="noopener ugc nofollow" target="_blank"> codechef </a>，SPOJ，codeforces等上面找到莫算法的练习题。其中一个著名的问题是<strong class="jq hj">DQUERY</strong>from<strong class="jq hj">SPOJ</strong></p><div class="mn mo ez fb mp mq"><a href="https://www.spoj.com/problems/DQUERY/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hj fi z dy mv ea eb mw ed ef hh bi translated">SPOJ.com问题查询</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">đọcđềđẹp hơn ở: https://code forces . com/group/flvn 1 sc 504/contest/274490/problem/o给定n个数序列a 1，a…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">www.spoj.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne jh mq"/></div></div></a></div><p id="28af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可以在下面的Github网址中找到上述问题的解决方案</p><div class="mn mo ez fb mp mq"><a href="https://github.com/ganeshkumarm1/DSAlgo/tree/master/src/com/dsalgo/Algorithms/MOAlgorithm/DistinctVowels" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hj fi z dy mv ea eb mw ed ef hh bi translated">ganeshkumarm1/DSAlgo</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">在GitHub上创建一个帐户，为ganeshkumarm1/DSAlgo开发做出贡献。</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">github.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne jh mq"/></div></div></a></div><h1 id="0449" class="ng kl hi bd km nh ni nj kq nk nl nm ku io nn ip kx ir no is la iu np iv ld nq bi translated">谢谢你🤘</h1><p id="0c94" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">要了解我的更多信息，请访问<a class="ae jn" href="https://www.ganeshkumarm.me" rel="noopener ugc nofollow" target="_blank"> ganeshkumarm.me </a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.buymeacoffee.com/ganeshkumarm"><div class="er es nr"><img src="../Images/7872e0c329bda2a22946abd0c827b89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*6TcLwitXBT9FyyFxUxV5fg.png"/></div></a></figure></div></div>    
</body>
</html>