<html>
<head>
<title>What is the scope of a variable in Java? Let’s deep dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中变量的作用域是什么？让我们深潜吧</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/what-is-the-scope-of-a-variable-in-java-lets-deep-dive-c2a9ca566d1?source=collection_archive---------2-----------------------#2021-08-20">https://medium.com/javarevisited/what-is-the-scope-of-a-variable-in-java-lets-deep-dive-c2a9ca566d1?source=collection_archive---------2-----------------------#2021-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6817" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">详细了解方法范围、块范围和所有其他概念</h2></div><blockquote class="ix"><p id="88f1" class="iy iz hi bd ja jb jc jd je jf jg jh dx translated">你遇到过变量没有初始化或者已经初始化的错误吗？</p><p id="9bba" class="iy iz hi bd ja jb ji jj jk jl jm jh dx translated">您是否对已经存在的变量名何时何地可以重复使用以及何处不可以重复使用感到困惑？</p></blockquote><p id="db34" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh jh hb bi translated">如果其中一个问题的答案是<strong class="jp hj"> <em class="ki">是的</em> </strong>，那么继续阅读，让你的概念变得清晰，这样你就不会遇到任何与<strong class="jp hj"> JAVA </strong>中的作用域相关的问题，即使发生了，你的调试也会容易得多。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kj"><img src="../Images/1883976b7d4ec9194d97ec2ac843d14a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bIh8CkbU3ij2_IvT"/></div></div><p class="kv kw et er es kx ky bd b be z dx translated">照片由<a class="ae kz" href="https://unsplash.com/@tirzavandijk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tirza van Dijk </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="7e87" class="la lb hi bd lc ld le lf lg lh li lj lk io ll ip lm ir ln is lo iu lp iv lq lr bi translated">什么是可变范围？</h1><p id="d7ed" class="pw-post-body-paragraph jn jo hi jp b jq ls ij js jt lt im jv jw lu jy jz ka lv kc kd ke lw kg kh jh hb bi translated">简单来说，变量作用域就是<strong class="jp hj">区域</strong>，在其中可以访问、更改/修改/更新某个特定的变量。</p><p id="8397" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">在<strong class="jp hj"> Java </strong>中，<strong class="jp hj">区域</strong>可以认为仅仅是被<strong class="jp hj"> <em class="ki">花括号</em> </strong>包围的区域或区块。</p><pre class="kk kl km kn fd mc md me mf aw mg bi"><span id="c421" class="mh lb hi md b fi mi mj l mk ml">public static void func () {<br/>    int a = 5;<br/>    a = a + 10;<br/>    System.out.println(a);<br/>}   </span></pre><p id="47a1" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">在上面的代码片段中，<strong class="jp hj">变量</strong>在名为<code class="du mm mn mo md b"><strong class="jp hj">func</strong></code>的方法中被声明和初始化。因此，变量<code class="du mm mn mo md b"><strong class="jp hj">a</strong></code>的范围是这个特定方法<code class="du mm mn mo md b"><strong class="jp hj">func</strong></code>内的<strong class="jp hj"> ONLY </strong>，区域是被<strong class="jp hj">花括号</strong>包围的区域。</p><blockquote class="mp mq mr"><p id="2b07" class="jn jo ki jp b jq lx ij js jt ly im jv ms lz jy jz mt ma kc kd mu mb kg kh jh hb bi translated"><strong class="jp hj">注:- </strong>变量的<strong class="jp hj">值</strong>只有<strong class="jp hj">在被初始化后才能被访问，或者说已经被赋值。否则，将抛出一个<a class="ae kz" href="https://www.java67.com/2016/07/how-to-fix-variable-might-not-have-been-initialized-error-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hj">错误</strong>，说明变量已声明，但<strong class="jp hj">未初始化</strong> </a>。</strong></p></blockquote><p id="3c9d" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">现在，我们已经大致了解了变量的作用域，让我们来关注在处理多个方法时变量的作用域是如何定义的。</p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><h1 id="3066" class="la lb hi bd lc ld nc lf lg lh nd lj lk io ne ip lm ir nf is lo iu ng iv lq lr bi translated">JAVA中的方法范围</h1><p id="e5f5" class="pw-post-body-paragraph jn jo hi jp b jq ls ij js jt lt im jv jw lu jy jz ka lv kc kd ke lw kg kh jh hb bi translated">在跳到作用域之前，值得一提的一件重要事情是在<strong class="jp hj"> <em class="ki"> Java </em> </strong>中没有<strong class="jp hj">传递引用</strong>。Java中唯一存在的在函数调用时将实参值传递给参数的方法就是<a class="ae kz" href="https://javarevisited.blogspot.com/2012/12/does-java-pass-by-value-or-pass-by-reference.html" rel="noopener ugc nofollow" target="_blank">通过值 </a>传递<strong class="jp hj">。</strong></p><p id="7d5e" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">现在，当处理属于一个特定类的多个方法时，请始终记住:-</p><blockquote class="ix"><p id="c3f7" class="iy iz hi bd ja jb ji jj jk jl jm jh dx translated">无论在方法体中声明和初始化了什么变量，都只能在这个特定的方法中访问。</p></blockquote><p id="f1c2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh jh hb bi translated">任何在该特定方法之外或任何其他方法中声明的同名变量都是完全不同的，与该方法中包含的变量没有任何关系。</p><pre class="kk kl km kn fd mc md me mf aw mg bi"><span id="51e2" class="mh lb hi md b fi mi mj l mk ml">public class Example1 {<br/>    public static void main (String [] Args) {<br/>        int num = 45; // Same name num Case 1<br/>        int a = 5;<br/>        int b = 10;<br/>        func1();<br/>        func2();<br/>        System.out.println("num inside main method is " + num);<br/>        System.out.println("a in main method is " + a);<br/>        System.out.println("b in main method is " + b);<br/>        c = 35; // ERROR Case 2<br/>        d = 55; // ERROR<br/>    }</span><span id="2135" class="mh lb hi md b fi nh mj l mk ml">    public static void func1 () {<br/>        int num = 30;<br/>        int c = 15;<br/>        a = 74; //ERROR<br/>        System.out.println("num inside func1 is " + num);<br/>        System.out.println("c in func1 is " + c);<br/>    }</span><span id="417f" class="mh lb hi md b fi nh mj l mk ml">public static void func2 () {<br/>        int num = 37;<br/>        int d = 26;<br/>        b = 58; //ERROR<br/>        System.out.println("num inside func2 is " + num);<br/>        System.out.println("d in func1 is " + d);<br/>    }</span></pre><p id="a3ee" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">现在，删除所有突出显示为错误的行后，生成的输出如下所示</p><pre class="kk kl km kn fd mc md me mf aw mg bi"><span id="c9b5" class="mh lb hi md b fi mi mj l mk ml">OUTPUT<br/>num inside func1 is 30<br/>c in func1 is 15<br/>num inside func2 is 37<br/>d in func2 id 26<br/>num inside main method is 45<br/>a in main method is 5<br/>b in main method is 10</span></pre><h2 id="8230" class="mh lb hi bd lc ni nj nk lg nl nm nn lk jw no np lm ka nq nr lo ke ns nt lq nu bi translated">了解错误的原因和num:-</h2><p id="8870" class="pw-post-body-paragraph jn jo hi jp b jq ls ij js jt lt im jv jw lu jy jz ka lv kc kd ke lw kg kh jh hb bi translated"><strong class="jp hj">理解错误:- </strong>在main方法内部声明的<strong class="jp hj">变量</strong>即<code class="du mm mn mo md b"><strong class="jp hj">a</strong></code>和<code class="du mm mn mo md b"><strong class="jp hj">b</strong></code>只能在main方法内部访问和修改。<a class="ae kz" rel="noopener" href="/javarevisited/5-tips-and-4-books-to-learn-java-programming-from-scratch-cbca21befed1"> Java </a>找不到主方法外的变量<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">a</em></strong></code>和<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">b</em></strong></code> <strong class="jp hj">，会抛出一个错误，声明变量是<strong class="jp hj">而不是</strong>声明的。</strong></p><p id="8b67" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">所以我们<strong class="jp hj">既不能给<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">func1</em></strong></code> <strong class="jp hj">中的<em class="ki">变量</em> <code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">a</em></strong></code>赋值，也不能给<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">func2</em></strong></code> <strong class="jp hj"> <em class="ki">中的</em></strong>变量<em class="ki"/><code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">b</em></strong></code>赋值。 </strong>但是我们可以在<strong class="jp hj"> <em class="ki"> main </em> </strong> <em class="ki">方法</em>中访问<code class="du mm mn mo md b"><strong class="jp hj">a</strong></code>和<code class="du mm mn mo md b"><strong class="jp hj">b</strong></code>，就在变量被初始化的那一行之后。</strong></p><p id="7334" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">相同的逻辑和概念适用于所有其他错误。在<code class="du mm mn mo md b"><strong class="jp hj">func1</strong></code>内声明和初始化的Like变量<code class="du mm mn mo md b"><strong class="jp hj">c</strong></code>不能在<code class="du mm mn mo md b"><strong class="jp hj">func2</strong></code>内访问或修改或赋值。</p><p id="2924" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated"><strong class="jp hj">变量的变化值</strong> <code class="du mm mn mo md b"><strong class="jp hj">num</strong></code> <strong class="jp hj"> :- </strong>我们可以看到，名为<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">num</em></strong></code>的变量在所有三个方法中都被声明和初始化了，令人惊讶的是没有抛出任何错误。而且一个变量<code class="du mm mn mo md b"><strong class="jp hj">num</strong></code>对应的<strong class="jp hj">输出</strong>在所有的<em class="ki">三种</em> <strong class="jp hj"> <em class="ki">方法</em> </strong>中是完全不同的！！</p><blockquote class="ix"><p id="4ce0" class="iy iz hi bd ja jb ji jj jk jl jm jh dx translated">这是因为所有的变量<code class="du mm mn mo md b">num</code>虽然名称相同，但完全不同，它们之间没有共同的联系，各自有不同的作用域。</p></blockquote><p id="ff5e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh jh hb bi translated">如前所述，Java <strong class="jp hj">无法</strong>找到其作用域之外的变量。它认为好像从未创建过具有该名称的变量。因此，在名为<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">func1</em></strong></code>的<em class="ki">方法</em>中声明一个变量<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">num</em></strong></code>就像创建一个全新的变量，并且这个变量<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">num</em></strong></code>的范围仅限于<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">func1</em></strong></code> <strong class="jp hj">中的</strong>。</p><p id="79c6" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">我们已经触及了与方法作用域相关的所有要点，现在让我们把注意力集中在块作用域上。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es nv"><img src="../Images/e2798740ba08d29f79a723df12428fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oHSWGnpAml8GTJl9"/></div></div><p class="kv kw et er es kx ky bd b be z dx translated">照片由<a class="ae kz" href="https://unsplash.com/@tracycodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">特雷西·亚当斯</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="0a4e" class="la lb hi bd lc ld le lf lg lh li lj lk io ll ip lm ir ln is lo iu lp iv lq lr bi translated">块范围</h1><p id="8895" class="pw-post-body-paragraph jn jo hi jp b jq ls ij js jt lt im jv jw lu jy jz ka lv kc kd ke lw kg kh jh hb bi translated">在讨论作用域之前，让我们定义一下块的含义。</p><p id="a3b1" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">块只是一对花括号中的一部分。它可以在任何方法体中。让我们用一个例子来了解更多。</p><pre class="kk kl km kn fd mc md me mf aw mg bi"><span id="701b" class="mh lb hi md b fi mi mj l mk ml">public class BlockScope {<br/>    public static void main (String [] args) {<br/>        int outsideBlock = 15;<br/>        outsideBlock += 25;<br/>        {<br/>            int insideBlock = 4;<br/>            insideBlock += 14;<br/>            int outsideBlock = 35; // ERROR Case-1<br/>            outsideBlock = 47; // Case-2<br/>            System.out.println("insideBlock value inside the block  is " + insideBlock);<br/>            System.out.println("outsideBlock value updated inside the block is " + outsideBlock);<br/>        }<br/>        insideBlock = 7; // ERROR Case-3<br/>        outsideBlock += 4; // Case-4<br/>        int insideBlock = 14; // Case-5<br/>        System.out.println("insideBlock value outside the block is " + insideBlock);<br/>        System.out.println("outsideBlock value outside the block is " + outsideBlock);<br/>}</span></pre><p id="8997" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">从上面的代码片段中删除所有突出显示为错误的行，我们得到如下输出</p><pre class="kk kl km kn fd mc md me mf aw mg bi"><span id="e4e3" class="mh lb hi md b fi mi mj l mk ml">OUTPUT :-<br/>insideBlock value inside the block is 18<br/>outsideBlock value updated inside the block is 47<br/>insideBlock value outside the block is 14<br/>outsideBlock value outside the block is 51</span></pre><p id="e06d" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">现在，深入了解代码中发生了什么，变量<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">insideBlock</em></strong></code>和<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">outsideBlock</em></strong></code>的范围是什么，让我们用一行代码来理解这个概念，并深入了解块内和块外变量的范围发生了什么。</p><blockquote class="ix"><p id="e9a3" class="iy iz hi bd ja jb ji jj jk jl jm jh dx translated">在块内声明和初始化的任何变量只能在块内访问和修改/更新。但是，在块外声明的变量也可以在块内访问和修改。</p></blockquote><p id="d981" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh jh hb bi translated">另外，在访问在块外声明和初始化的变量时，要记住的一件重要事情是:-</p><blockquote class="mp mq mr"><p id="1747" class="jn jo ki jp b jq lx ij js jt ly im jv ms lz jy jz mt ma kc kd mu mb kg kh jh hb bi translated">即使我们可以访问在块外初始化的原始变量，但是我们<strong class="jp hj">不能</strong>声明和初始化一个完全<strong class="jp hj">新的</strong>变量<strong class="jp hj">在</strong>块内，其<strong class="jp hj">名称与块外</strong>的<strong class="jp hj">名称相同。</strong></p></blockquote><p id="1f83" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">现在，让我们一个一个地分析每个案例，以获得一个更清晰的画面</p><ul class=""><li id="882a" class="nw nx hi jp b jq lx jt ly jw ny ka nz ke oa jh ob oc od oe bi translated"><strong class="jp hj">情况1 :- </strong>变量<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">outsideBlock</em></strong></code>已经在块外定义并初始化。所以我们不能在块中声明和初始化一个同名的新变量<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">outsideBlock</em></strong></code>。</li><li id="3fa2" class="nw nx hi jp b jq of jt og jw oh ka oi ke oj jh ob oc od oe bi translated"><strong class="jp hj">案例二:- </strong>变量<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">outsideBlock</em></strong></code>的<strong class="jp hj">范围</strong>是<code class="du mm mn mo md b"><strong class="jp hj">main</strong></code> <strong class="jp hj"> <em class="ki">方法</em> </strong>内的<strong class="jp hj">整个</strong> <strong class="jp hj"> <em class="ki">区域</em> </strong>。因此，一旦变量被初始化，就可以从main方法内部的任何地方访问和修改/更新。甚至从<strong class="jp hj"><em class="ki"/></strong><em class="ki">内的</em>块作为块也被放置在<a class="ae kz" href="http://javarevisited.blogspot.sg/2011/12/main-public-static-java-void-method-why.html#axzz4uMEUqg5v" rel="noopener ugc nofollow" target="_blank">主方法</a>的<strong class="jp hj">体</strong>内。</li><li id="569d" class="nw nx hi jp b jq of jt og jw oh ka oi ke oj jh ob oc od oe bi translated"><strong class="jp hj">情况3:- </strong>变量<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">insideBlock</em></strong></code>的范围只限定在块内。因此，每当我们试图访问块外的变量时，Java找不到任何具有该特定名称的变量，并抛出一个错误，声明变量未声明。</li><li id="05df" class="nw nx hi jp b jq of jt og jw oh ka oi ke oj jh ob oc od oe bi translated"><strong class="jp hj">案例4:- </strong>与案例3有关联。Java找不到名为<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">insideBlock</em></strong></code>的变量，并且认为好像不存在具有该名称的变量。所以，现在如果我们声明并初始化一个新的变量，并给它一个名字<code class="du mm mn mo md b"><strong class="jp hj"><em class="ki">insideBlock</em></strong></code>，Java会把它当作一个新声明并初始化的变量，只不过这个变量与程序块中的变量没有预先的联系。</li></ul><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es ok"><img src="../Images/ce3d84e68d8397179605682ebcf3aaf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DxpV-1vNArVn-cPY"/></div></div><p class="kv kw et er es kx ky bd b be z dx translated">照片由<a class="ae kz" href="https://unsplash.com/@leunesmedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米歇尔·勒恩斯</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="9f22" class="la lb hi bd lc ld le lf lg lh li lj lk io ll ip lm ir ln is lo iu lp iv lq lr bi translated">循环范围</h1><p id="ebd0" class="pw-post-body-paragraph jn jo hi jp b jq ls ij js jt lt im jv jw lu jy jz ka lv kc kd ke lw kg kh jh hb bi translated">这几乎和上一个一样。同样，在循环内部声明和初始化的变量的作用域仅限于循环体内部，不能在循环外部访问或修改。</p><p id="1dcd" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">类似地，像块范围一样，先前在循环外部声明和初始化的变量也可以在循环体内被访问和修改。</p><p id="0d41" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">但是在循环内部声明和初始化的新变量，或者甚至是在开始指定条件的地方，<strong class="jp hj">不能与已经在循环外部声明和初始化的变量同名。</strong></p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><p id="0171" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">那些已经读完整篇文章并读到这里的人，恭喜你们！！</p><p id="823d" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">您刚刚学习并掌握了与变量范围相关的所有概念，现在已经完全了解了如何处理和调试围绕该主题的所有错误。</p><p id="d26a" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh jh hb bi translated">与JAVA和其他编程语言的核心概念相关的新博客/文章将会比预期来得更快！！你也可以分享你希望我在即将到来的博客/文章中涉及的话题。</p></div></div>    
</body>
</html>