<html>
<head>
<title>Strategy Pattern in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的策略模式</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/strategy-pattern-in-java-6e97304bf5e5?source=collection_archive---------1-----------------------#2022-11-19">https://medium.com/javarevisited/strategy-pattern-in-java-6e97304bf5e5?source=collection_archive---------1-----------------------#2022-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4cfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是战略模式？</strong> <br/>它封装了一系列算法，使它们在运行时可以互换。</p><p id="61d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">示例</strong>:分类报告数据(按名称分类、按日期分类……)，支付策略(借记卡、信用卡、UPI……)</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://www.java67.com/2014/12/strategy-pattern-in-java-with-example.html"><div class="er es jd"><img src="../Images/de801461be08b3f3dda18be3472c4a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0RfgjB7uBWSFnyre_Pd2Cw.png"/></div></a></figure><p id="f0fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">何时使用:</strong></p><ol class=""><li id="5de4" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">在运行时更改行为。<br/>例如:基于用户输入的不同支付策略，基于用户输入的不同报告数据排序方式</li><li id="07e1" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">当你有一个以不同方式解决相同用例的类家族时。</li></ol><p id="3f36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优点:</strong></p><ol class=""><li id="4bb3" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">干净的代码— <a class="ae jz" href="https://javarevisited.blogspot.com/2014/11/strategy-design-pattern-in-java-using-Enum-Example.html" rel="noopener ugc nofollow" target="_blank">战略模式</a> n坚持OCP。我们不需要更新现有的策略类来添加新的策略。</li><li id="4102" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">关注点分离——我们可以在不同的类中分离业务逻辑和算法的实现细节。</li><li id="a0cd" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">更喜欢组合而不是继承——允许在运行时交换策略。</li></ol><p id="a4d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以报表数据排序为例来看一个实现。用户将有一个报告，并可以选择根据报告中的列对数据进行排序。</p><p id="1988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个ReportGenerator类负责生成报告。</p><pre class="je jf jg jh fd ka kb kc bn kd ke bi"><span id="b909" class="kf kg hi kb b be kh ki l kj kk">public class ReportGenerator {<br/>   public Report sortReport(ReportData reportData, String sortByColumn) {<br/>    if (sortByColumn == "name") {<br/>     return sortReportByName(reportData);<br/>    } else if (sortByColumn == "productNumber") {<br/>     return sortReportByProductNumber(reportData);<br/>    } else {<br/>     return sortReportByDate(reportData);<br/>    }<br/>   }<br/>  <br/>   private Report sortReportByName(ReportData reportData) {<br/>    // sort the report based on date column<br/>   }<br/>  <br/>   private Report sortReportByProductNumber(ReportData reportData) {<br/>    // sort the report based on product number<br/>   }<br/>  <br/>   private Report sortReportByDate(ReportData reportData) {<br/>    // sort the report based on name column<br/>   }<br/>}</span></pre><p id="5dc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设一个UIController类处理用户的UI交互。这将调用ReportGenerator类来根据用户需要的列生成报告数据。</p><pre class="je jf jg jh fd ka kb kc bn kd ke bi"><span id="c069" class="kf kg hi kb b be kh ki l kj kk">package behavioral.strategy.sortingreport;<br/><br/>public class UIController {<br/> public Report sortReport(ReportData reportData, String sortType) {<br/>  // call to ReportGenerator<br/>  return new ReportGenerator().sortReport(reportData, sortType);<br/> }<br/>}</span></pre><p id="2b20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上述方法有什么问题？</strong></p><ol class=""><li id="fb1a" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated"><strong class="ih hj">不遵循OCP: </strong> ReportGenerator不遵循开闭原则。每当有一个新的排序机制，或者如果我们必须更新一些现有的机制，类必须改变。这可能会导致代码中潜在的错误。</li><li id="3786" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated"><strong class="ih hj">维护:</strong>随着更多实现的加入，if else会变得庞大而复杂。这影响了代码的可读性和理解</li><li id="815a" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated"><strong class="ih hj">关注点没有分离:</strong>report generator类的业务逻辑和排序报表的实现细节没有分离。</li></ol><p id="a3b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何使用策略模式来解决这个问题？ <br/> <strong class="ih hj">步骤:</strong> <br/> 1 .将算法家族移到单独的类中。在我们的示例中，我们将把排序策略(按名称排序、按日期排序、按产品编号排序)移动到单独的类中= &gt; SortByName、sort by date、sort by product number。</p><p id="f283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.为所有策略提供一个公共界面。这个接口作为一个抽象，向调用者/客户隐藏策略的实现逻辑。在我们的示例中，我们将创建一个定义排序方法的SortingStrategy接口。</p><p id="ce4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.更新您的上下文类(我们示例中的ReportGenerator类)以使用接口。</p><p id="bd1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.客户端代码(我们示例中的UIController)将在上下文类中设置所需的算法，并调用上下文类。</p><p id="009b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kl">实现:</em> </strong></p><p id="26d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为所有的报表排序实现创建一个公共接口类(SortingStrategy)。</p><pre class="je jf jg jh fd ka kb kc bn kd ke bi"><span id="961a" class="kf kg hi kb b be kh ki l kj kk">public interface SortingStrategy {<br/>   Report sort(ReportData reportData);<br/>}</span></pre><p id="cab2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将所有的排序机制分解成独立的类，这些类将实现上面的接口</p><pre class="je jf jg jh fd ka kb kc bn kd ke bi"><span id="7abe" class="kf kg hi kb b be kh ki l kj kk">public class SortByName implements SortingStrategy {<br/>   @Override<br/>   public Report sort(ReportData reportData) {<br/>    // sort the report based on name<br/>   }<br/>}</span></pre><pre class="km ka kb kc bn kd ke bi"><span id="234b" class="kf kg hi kb b be kh ki l kj kk">public class SortByDate implements SortingStrategy {<br/> @Override<br/> public Report sort(ReportData reportData) {<br/>  // sort the report based on date<br/> }<br/>}</span></pre><pre class="km ka kb kc bn kd ke bi"><span id="1169" class="kf kg hi kb b be kh ki l kj kk">public class SortByProductNumber implements SortingStrategy {<br/> @Override<br/> public Report sort(ReportData reportData) {<br/>  // sort data based on product number<br/> }<br/>}</span></pre><p id="c5cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们重构ReportGenerator类以使用SortingStrategy接口。我们将删除以前的排序实现代码。</p><pre class="je jf jg jh fd ka kb kc bn kd ke bi"><span id="e990" class="kf kg hi kb b be kh ki l kj kk"><br/>public class ReportGenerator {<br/>   private SortingStrategy sortingStrategy;<br/>  <br/>   // setter to allow setting the strategy at run time based on clients choice.<br/>   // we can also pass the SortingStrategy in the constructor if we want.<br/>   public void setSortingStrategy(SortingStrategy sortingStrategy) {<br/>      this.sortingStrategy = sortingStrategy;<br/>   }<br/>  <br/>   // this method will directly call the sort method of the interface. Which <br/>   // concrete implementatation to call will be decided by the client <br/>   // at run time (Run time polymorphism)<br/>   public Report generateReport(ReportData reportData) {<br/>      this.sortingStrategy.sort(reportData);<br/>   }<br/>}<br/></span></pre><p id="8b0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们的代码就与具体的排序实现解耦了。</p><p id="7e66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在客户机(在我们的例子中是UIController类)将决定使用哪种排序策略。客户端将在ReportGenerator对象中设置相应的策略，并将调用它。ReportGenerator对象将调用相应策略对象中的排序方法。</p><pre class="je jf jg jh fd ka kb kc bn kd ke bi"><span id="55c7" class="kf kg hi kb b be kh ki l kj kk">public class UIController {<br/>   public Report sortReport(ReportData reportData, String sortType) {<br/>      ReportBuilder reportBuilder = new ReportBuilder();<br/>      <br/>      // client will set the sorting strategy dynamically at run time<br/>      if(sortType == "name") {<br/>       reportBuilder.setSortingStrategy(new SortByName());<br/>      } else if (sortType == "productNumber"){<br/>       reportBuilder.setSortingStrategy(new SortByProductNumber());<br/>      } else if (sortType == "date"){<br/>       reportBuilder.setSortingStrategy(new SortByDate());<br/>      }<br/>    <br/>      return reportBuilder.generateReport(reportData);<br/>   }<br/>}</span></pre><p id="4b11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这种方式的优点:</strong></p><ol class=""><li id="19fa" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">遵循OCP——新策略将进入自己的类，不会影响任何其他代码。对现有策略的更新也将在它自己的类中，并且不会影响任何其他代码。</li><li id="876c" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">我们的业务逻辑(报告生成)与报告排序的实现细节是分开的。</li><li id="c979" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">代码的维护将会很容易，因为每个实现都被分离到自己的类中。</li></ol><p id="126a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对策略模式的讨论到此为止。编码快乐！</p></div></div>    
</body>
</html>