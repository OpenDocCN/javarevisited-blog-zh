<html>
<head>
<title>KUBERNETES: Step-by-Step Guide with Spring Boot, Docker &amp; GKE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KUBERNETES:一步一步的指南与 Spring Boot，多克和 GKE</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/kubernetes-step-by-step-with-spring-boot-docker-gke-35e9481f6d5f?source=collection_archive---------0-----------------------#2019-05-04">https://medium.com/javarevisited/kubernetes-step-by-step-with-spring-boot-docker-gke-35e9481f6d5f?source=collection_archive---------0-----------------------#2019-05-04</a></blockquote><div><div class="es gl gm gn go gp"/><div class="gq gr gs gt gu"><div class=""/><figure class="ec ee hv hw hx hy dy dz paragraph-image"><a href="https://javarevisited.blogspot.com/2019/05/top-5-courses-to-learn-docker-and-kubernetes-for-devops.html"><div class="dy dz hu"><img src="../Images/a5c688585528e6400e363cfd6af5b493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIGSaTJNo_vmaRJKEc2_7A.png"/></div></a></figure><p id="8c51" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">又见面了。欢迎回来。🤗</p><p id="e207" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">今天我们要讲的是世界上另一个众所周知的技术；<a class="ae iz" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>。我相信你已经听过很多次了。但是你真的知道那是什么吗？如果答案是一个大大的“不”，那就继续读这篇文章吧。今天的帖子会有点长，但你会看到自己从“零”到“英雄”的转变。💪</p><p id="34e2" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">我先说一下今天的大纲:</p><ol class=""><li id="68db" class="ja jb gx id b ie if ii ij im jc iq jd iu je iy jf jg jh ji bi translated">容器</li><li id="349a" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated">容器编排器及其角色</li><li id="8f93" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated">什么是 Kubernetes</li><li id="f72b" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated">为什么是 Kubernetes</li><li id="0916" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated">库伯内特斯的建筑</li><li id="2d9f" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated">库伯内特斯的主要成分</li><li id="0908" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated">亲自动手</li></ol><h1 id="acb2" class="jo jp gx bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">容器</h1><p id="5f61" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">简单来说，容器是指没有自己的操作系统的虚拟机。我们可以在遥远的数据中心创建这些容器，并完成我们的工作。它的重要性在于，它确保我们的工作最大限度地利用资源，而不是为操作系统等浪费资源。</p><p id="cb1c" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">在通常的生产环境中，有成百上千个容器专用于各种<a class="ae iz" href="https://javarevisited.blogspot.com/2018/02/top-5-spring-microservices-courses-with-spring-boot-and-spring-cloud.html" rel="noopener ugc nofollow" target="_blank">微服务</a>。因此，管理它们不是一项简单的任务。他们需要更新、版本控制、健康检查、扩展和更多的功能。这就是需要一个<strong class="id gy"> <em class="kr">【容器编制器】</em> </strong>的地方。如果你想了解更多关于容器的知识，你也可以查看这些<a class="ae iz" href="https://dev.to/javinpaul/top-10-courses-to-learn-docker-and-kubernetes-for-programmers-4lg0" rel="noopener ugc nofollow" target="_blank">最佳课程，为开发者学习 Docker 和 Kubernetes </a>。</p><div class="ks kt eg ei ku kv"><a href="https://javarevisited.blogspot.com/2019/05/top-5-courses-to-learn-docker-and-kubernetes-for-devops.html" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fz"><div class="kx ab ky cl cj kz"><h2 class="bd gy ev z la lb lc ld le lf lg gw bi translated">2020 年学习 Docker 和 Kubernetes 的 5 大课程-最佳课程</h2><div class="lh l"><h3 class="bd b ev z la lb lc ld le lf lg ft translated">伙计们，你们好吗？你有望实现今年的目标吗？我相信你在…的时候已经有了目标</h3></div><div class="li l"><p class="bd b fc z la lb lc ld le lf lg ft translated">javarevisited.blogspot.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo hz kv"/></div></div></a></div><h1 id="8167" class="jo jp gx bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">容器编排器及其角色</h1><p id="7ac5" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">想想一场足球比赛。如果教练不告诉球员他们的位置，他们会站在他们想站的地方。如果是那样的话，那个队会赢吗？我想不会。</p><blockquote class="lp"><p id="7593" class="lq lr gx bd ls lt lu lv lw lx ly iy ft translated">所以教练做的是，他告诉球员他们需要站在哪里，他们需要做什么。</p></blockquote><p id="9383" class="pw-post-body-paragraph ib ic gx id b ie lz ig ih ii ma ik il im mb io ip iq mc is it iu md iw ix iy gq bi translated">类似地，<a class="ae iz" href="https://javarevisited.blogspot.com/2019/01/top-5-free-kubernetes-courses-for-DevOps-Engineer.html" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>，或者任何其他容器编排器，告诉容器它们应该呆在哪里以及它们应该如何表现。简而言之，容器编排者就像教练，而玩家就像容器或微服务。</p><h1 id="d5cd" class="jo jp gx bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是 Kubernetes</h1><p id="71c5" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">Kubernetes 诞生于 Google，是他们管理容器的内部技术之一。它是用 Go 语言写的。</p><p id="18b6" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">2015 年，Kubernetes 首次向公众发布。后来，谷歌把它交给了 CNCF (Linux 基金会)来管理。</p><p id="1ada" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">所以目前 Kubernetes 是 Apache 2.0 许可下的一个开源项目。有时在业内，<a class="ae iz" href="http://www.java67.com/2019/03/5-free-devops-courses-to-learn-jenkins.html" rel="noopener ugc nofollow" target="_blank"> Kubernete </a> s 也被称为“K8s”。广泛用来形容 Kubernetes 的术语是<strong class="id gy"> <em class="kr">【容器管弦乐】</em> </strong>。</p><p id="1df0" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">如果你想学习 Kubernetes 和 Docker，那么<a class="ae iz" href="https://click.linksynergy.com/deeplink?id=JVFxdTr9V80&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fdocker-and-kubernetes-the-complete-guide%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="id gy"> Docker 和 Kubernetes:完全指南</strong> </a> <strong class="id gy"> </strong>是最好的开始。</p><div class="ks kt eg ei ku kv"><a href="https://click.linksynergy.com/deeplink?id=JVFxdTr9V80&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fdocker-and-kubernetes-the-complete-guide%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fz"><div class="kx ab ky cl cj kz"><h2 class="bd gy ev z la lb lc ld le lf lg gw bi translated">Docker 和 Kubernetes:完全指南</h2><div class="lh l"><h3 class="bd b ev z la lb lc ld le lf lg ft translated">如果你厌倦了学习如何部署 web 应用程序，那么这就是适合你的课程。CI+CD…</h3></div><div class="li l"><p class="bd b fc z la lb lc ld le lf lg ft translated">click.linksynergy.com</p></div></div><div class="lj l"><div class="me l ll lm ln lj lo hz kv"/></div></div></a></div><h1 id="2e4c" class="jo jp gx bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么 Kubernetes 胜过其他管弦乐队</h1><ul class=""><li id="e814" class="ja jb gx id b ie km ii kn im mf iq mg iu mh iy mi jg jh ji bi translated"><strong class="id gy">与平台无关</strong>:即 Kubernetes 可用于裸机、虚拟机、云、开放堆栈等。</li><li id="2e17" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy mi jg jh ji bi translated">不仅仅是基于容器的编排。您也可以将它与普通聚类一起使用。</li><li id="8436" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy mi jg jh ji bi translated">不与<a class="ae iz" href="https://hackernoon.com/10-free-courses-to-learn-docker-for-programmers-and-devops-engineers-7ff2781fd6e0" rel="noopener ugc nofollow" target="_blank"> Docker </a>等任何其他特定公司或平台捆绑。许多公司支持基于 Kubernetes 的集群，包括 Google、<a class="ae iz" href="https://hackernoon.com/top-5-amazon-web-services-or-aws-courses-to-learn-online-free-and-best-of-lot-d94e192054b7" rel="noopener ugc nofollow" target="_blank"> Amazon Web Services </a>等。</li><li id="dc94" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy mi jg jh ji bi translated">让目标部署</li></ul><h1 id="ce78" class="jo jp gx bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">库伯内特斯的建筑</h1><figure class="mk ml mm mn ek hy dy dz paragraph-image"><a href="https://click.linksynergy.com/deeplink?id=JVFxdTr9V80&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fdocker-and-kubernetes-the-complete-guide%2F"><div class="dy dz mj"><img src="../Images/39c435b9253ecef16a9277fd29e96e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iaQlYvTG7NhAjlu9sdXNyA.png"/></div></a><p class="mo mp ea dy dz mq mr bd b be z ft translated">库伯内特建筑在一个图像中</p></figure><p id="a57a" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated"><strong class="id gy">如你所见，Kubernetes 也遵循主-从架构(也称为主-从)。让我们以一种非常高级的方式逐一讨论这些组件。</strong></p><h2 id="72a6" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated"><strong class="ak">主人</strong></h2><p id="2e34" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">主设备是集群的控制元素。有人称之为集群的“大脑”。它是唯一对集群用户开放的端点。出于容错的目的，一个集群可以有多个主设备。</p><p id="ce4d" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">母版有 4 个部分:</p><ol class=""><li id="8a65" class="ja jb gx id b ie if ii ij im jc iq jd iu je iy jf jg jh ji bi translated">API 服务器:</li></ol><p id="8279" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">这是和用户沟通的前端。它是一个基于 REST 的 API ,用于消费 JSON 输入。默认情况下，它运行在端口 443。</p><p id="56f4" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">2.调度程序:</p><p id="bb6b" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">调度程序监视 API 服务器的新 Pod 请求。它与节点通信以创建新的 pod，并在分配资源或施加约束时向节点分配工作。</p><p id="3cca" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">3.群集存储:</p><p id="4115" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">群集存储是保存群集状态和配置详细信息的持久性存储。它使用 ETCD(开源分布式键值存储)来存储这些数据。</p><p id="f664" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">4.控制器:</p><p id="a972" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">包括节点控制器、端点控制器、名字空间控制器等。</p><h2 id="c9ad" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">节点(从属/下属)</h2><p id="0dde" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">节点是工人。他们执行分配给集群的所有“工作”。在一个节点内，除了<strong class="id gy"> <em class="kr">【吊舱】</em> </strong>(稍后我会谈到吊舱)，还有 3 个主要组件。这三个部分是:</p><ol class=""><li id="79b8" class="ja jb gx id b ie if ii ij im jc iq jd iu je iy jf jg jh ji bi translated">库伯莱</li></ol><p id="a2ab" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">Kublets 在节点内部做了很多工作。它们向集群注册节点，监视来自调度程序的工作分配，实例化新的 pod，向主节点报告，等等。</p><p id="488c" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">2.集装箱发动机</p><p id="dcfe" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">容器引擎是管理容器的负责人。它完成所有的图像提取、容器停止、启动等操作。使用最广泛的容器引擎是<a class="ae iz" href="https://javarevisited.blogspot.com/2018/02/10-free-docker-container-courses-for-Java-Developers.html" rel="noopener ugc nofollow" target="_blank"> Docker </a>。但是，您也可以使用 Rocket 来实现这一点。</p><p id="843f" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">3.Kube 代理</p><p id="40bd" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">Kube 代理负责为每个 pod 分配 IP 地址。每次 pod 创建时，都会为该 pod 分配一个新的 IP 地址。Kube 代理也做负载平衡工作。</p><p id="b75f" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">除了上面提到的组件，节点有自己的默认组件，如日志、健康检查、DNS 等。每个节点通过(通常)localhost:10255 公开 3 个只读端点。这些端点是，</p><ul class=""><li id="35e4" class="ja jb gx id b ie if ii ij im jc iq jd iu je iy mi jg jh ji bi translated">/规格</li><li id="60d8" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy mi jg jh ji bi translated">/健康 z</li><li id="cb24" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy mi jg jh ji bi translated">/豆荚</li></ul><h1 id="4c1b" class="jo jp gx bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">库伯内特斯的主要成分</h1><p id="7864" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">在开始使用 Kubernetes 之前，任何人都应该知道 Kubernetes 集群架构的几个主要组件。第一个是豆荚:</p><h2 id="d87a" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">分离舱</h2><blockquote class="lp"><p id="3b2c" class="lq lr gx bd ls lt lu lv lw lx ly iy ft translated">pod 是 Kubernetes 中部署或调度的原子单位。</p></blockquote><p id="f619" class="pw-post-body-paragraph ib ic gx id b ie lz ig ih ii ma ik il im mb io ip iq mc is it iu md iw ix iy gq bi translated">Pod 是一个环形环境，有自己的网络堆栈和内核名称空间。里面有容器。没有容器就没有 pod。但是，根据我们部署的应用程序，可能有单容器容器或多容器容器。</p><p id="e90e" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">例如，如果您有一个带有 API 和日志的紧密耦合的应用程序，您可以使用一个 API 容器和另一个日志容器。但是您可以在同一个 Pod 中部署它们。然而，行业最佳实践是采用单容器架构。</p><p id="e6a6" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">关于 Pod 另一个需要注意的小事情是，他们是<strong class="id gy"> <em class="kr">“凡人”。</em> </strong>糊涂了？让我解释一下。pod 的生命周期有 3 个阶段:</p><p id="301c" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">挂起→运行→成功/失败</p><p id="4613" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">这类似于出生→活着→死去。不会有<strong class="id gy">复活</strong>；不再生。如果一个 Pod 没有完成他的任务就死了，一个新的 Pod 将被创建来代替死的 Pod。最重要的是，这个新 pod 的 IP 和所有其他因素都将与死 pod 不同。</p><h2 id="b0e3" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">部署控制器</h2><p id="2bc3" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">为了管理 pod，Kubernetes 中提供了许多<a class="ae iz" href="https://kubernetes.io/docs/concepts/workloads/controllers" rel="noopener ugc nofollow" target="_blank">控制器。这种用于部署和声明性更新的控制器被称为部署控制器。</a></p><p id="f371" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">在部署对象中(最常用的格式是 YAML 文件。但在本教程中，我使用命令行)我们可以描述我们的“期望状态”，如需要部署什么样的映像、要公开什么样的端口、要有多少副本、需要添加什么样的标签等。部署控制器所做的是定期检查这个期望的状态，并在集群中进行更改，以确保达到期望的状态。</p><h2 id="b0b6" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">服务</h2><p id="e49c" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">我将在本教程中使用的另一个组件是“服务”。在讲述什么是服务之前，我将描述一下我们为什么需要服务。</p><p id="c962" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">正如我前面提到的，豆荚是会死的。当一个豆荚死亡时，一个新的豆荚就会诞生来取代它。它和死去的那个没有相同的 IP 地址。</p><p id="bb23" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">因此，设想一个场景，我们有一个同时具有前端服务和后端服务的系统。从前端调用后端，我们需要一个 IP 或者 URL。假设我们在前端代码中使用了后端服务的 pod IP。我们面临三个问题:</p><ol class=""><li id="7c8f" class="ja jb gx id b ie if ii ij im jc iq jd iu je iy jf jg jh ji bi translated">我们需要首先部署我们的后端并获取它的 IP。然后我们需要在制作 docker 映像之前将其包含在前端代码中。该命令<strong class="id gy">必须</strong>遵守。</li><li id="ffdc" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated">如果我们想扩展我们的后端，该怎么办？我们需要用新的 pod IPs 再次更新前端。</li><li id="1d4a" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated">如果后端 pod 失效，将会创建一个新的 pod。然后我们需要用新的 pod IP 更改前端代码，并再次制作 docker 映像。我们还必须在前端交换图像。如果后端有几个 pod，这将变得更加困难。</li></ol><p id="2adf" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">工作太多，工作复杂。这就是我们需要“服务”的原因。</p><figure class="mk ml mm mn ek hy dy dz paragraph-image"><a href="https://click.linksynergy.com/deeplink?id=JVFxdTr9V80&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Flearn-kubernetes%2F"><div class="dy dz ng"><img src="../Images/fa533f78418ebf14b2f3d234307abfe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCf0TytaKNVF2d510o6sJw.png"/></div></a><p class="mo mp ea dy dz mq mr bd b be z ft translated">Kubernetes 服务如何工作</p></figure><p id="ca61" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">服务有自己的 IP 地址和稳定的 DNS。所以前端成功地从后端服务中分离出来。因此，服务是多个 pod 的高级稳定抽象点。</p><p id="906c" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">对于 pod 的发现，服务使用一种叫做“标签”的东西。pod 通过标签属于服务。在服务初始化阶段，我们通过“选择器”标志描述服务应该寻找什么标签。如果服务找到一个带有选择器部分中提到的所有标签的 pod，服务将附加其端点列表并将 Pod 添加到列表中。(除上述标签外，还可以有额外的标签。但是不应该错过任何提到的标签。)</p><p id="28fd" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">当服务收到请求时，它使用 Round-Robbin、Random 等方法。选择“请求转发”窗格。</p><p id="6ca5" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">服务对象的使用为我们提供了许多优势，比如只将请求转发给健康的 pod、负载平衡、版本回滚等。但是服务最重要的优势是系统组件的成功解耦。</p><p id="aec7" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">Kubernetes 中有 5 种服务可供我们根据自己的目的进行选择:(来源:Kubernetes.io，2019)</p><ol class=""><li id="0689" class="ja jb gx id b ie if ii ij im jc iq jd iu je iy jf jg jh ji bi translated"><strong class="id gy"> ClusterIP </strong>:公开集群内部 IP 上的服务。选择该值将使服务只能从集群内部访问。这是默认的<code class="eu nh ni nj nk b">ServiceType</code>。</li><li id="fb7c" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated"><a class="ae iz" href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" rel="noopener ugc nofollow" target="_blank"> <strong class="id gy">节点端口</strong> </a>:在一个静态端口(节点端口)公开每个节点 IP 上的服务。自动创建节点端口服务将路由到的 ClusterIP 服务。您将能够通过请求<code class="eu nh ni nj nk b">&lt;NodeIP&gt;:&lt;NodePort&gt;</code>从集群外部联系节点端口服务。</li><li id="31d7" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated"><a class="ae iz" href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer" rel="noopener ugc nofollow" target="_blank"> <strong class="id gy">负载平衡器</strong> </a>:使用云提供商的负载平衡器对外公开服务。会自动创建外部负载平衡器将路由到的节点端口和集群 IP 服务。</li><li id="84ac" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy jf jg jh ji bi translated"><a class="ae iz" href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname" rel="noopener ugc nofollow" target="_blank"> <strong class="id gy"> ExternalName </strong> </a>:将服务映射到<code class="eu nh ni nj nk b"><strong class="id gy">externalName</strong></code>字段的内容(例如 foo.bar.example.com)，返回一个<code class="eu nh ni nj nk b"><strong class="id gy">CNAME</strong></code>记录及其值。没有设置任何类型的代理。这需要 1.7 或更高版本的<code class="eu nh ni nj nk b"><strong class="id gy">kube-dns</strong></code></li></ol><p id="ad9c" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">好吧！理论说够了。让我们把手弄脏吧😉。如果你想了解更多，请查看面向绝对初学者的 Kubernetes 动手课程，这绝对是一种享受。</p><div class="ks kt eg ei ku kv"><a href="https://click.linksynergy.com/deeplink?id=JVFxdTr9V80&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Flearn-kubernetes%2F" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fz"><div class="kx ab ky cl cj kz"><h2 class="bd gy ev z la lb lc ld le lf lg gw bi translated">Kubernetes 的绝对初学者-动手</h2><div class="lh l"><h3 class="bd b ev z la lb lc ld le lf lg ft translated">“这是迄今为止 Udemy 上最好的 Kubernetes 课程”-学生证明学习 Kubernetes 对任何…</h3></div><div class="li l"><p class="bd b fc z la lb lc ld le lf lg ft translated">click.linksynergy.com</p></div></div><div class="lj l"><div class="nl l ll lm ln lj lo hz kv"/></div></div></a></div><h1 id="0bda" class="jo jp gx bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">实践 Springboot 和 Google Kubernetes 引擎</h1><p id="703b" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">我们的小系统可以将美国州代码转换为州名，反之亦然。我需要制作这个教程来谈谈<strong class="id gy">和<em class="kr">吊舱之间的通信。因此我将使系统有两个 API 而不是一个，即使我们只用一个服务就能做到。</em></strong></p><p id="fdd0" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">好吧！我们将制作 2 个 APIs“<strong class="id gy"> <em class="kr">用户 API </em> </strong>”和“<strong class="id gy"><em class="kr">Datareader API</em></strong>”。</p><figure class="mk ml mm mn ek hy dy dz paragraph-image"><a href="https://dev.to/javinpaul/top-10-courses-to-learn-spring-boot-and-microservices-for-java-programmers-3hjg"><div class="dy dz nm"><img src="../Images/30ff430716bdf3f64aacecf5757ba71e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Bqqhvkk-f-zJlsbWsv7CA.png"/></div></a><p class="mo mp ea dy dz mq mr bd b be z ft translated">导师项目的微服务架构</p></figure><p id="77d7" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">由用户授权访问的用户 API 有两个端点。</p><ul class=""><li id="0f1f" class="ja jb gx id b ie if ii ij im jc iq jd iu je iy mi jg jh ji bi translated">[GET]请求→ /codeToState(带参数“代码”)</li><li id="3d02" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy mi jg jh ji bi translated">[GET] request → /stateToCode(带参数“state”)</li></ul><p id="7e15" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">由 UserAPI 访问的 Datareader API 也有两个端点。</p><ul class=""><li id="c2f8" class="ja jb gx id b ie if ii ij im jc iq jd iu je iy mi jg jh ji bi translated">[GET]请求→ /readDataForCode</li><li id="af2a" class="ja jb gx id b ie jj ii jk im jl iq jm iu jn iy mi jg jh ji bi translated">[GET]请求→ /readDataForState</li></ul><p id="d40f" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">让我们从使用 Spring boot 在本地开发这个开始。</p><h2 id="6224" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">1.开发 Spring Boot API</h2><p id="5ff2" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">我将使用 IntelliJ Idea Ultimate 来创建我的 Spring Boot 项目。</p><p id="f29d" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">在 IntelliJ 中，转到“新建项目”并从侧窗格中选择 Spring Initializer。将服务 URL 保留为默认值，并选择您的 JDK 版本，然后单击 next。在下一个窗口中，也记得选择合适的<a class="ae iz" href="http://www.java67.com/2018/12/how-to-set-specific-java-version-for-Maven.html" rel="noopener ugc nofollow" target="_blank"> Java 版本</a>。其余的你可以根据自己的喜好修改，再次点击下一步。</p><p id="117b" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">在下一个窗口中，从侧窗格中选择 web，并选中 Web 和 Rest 存储库依赖项前面的复选框。再次单击下一步。在最终窗口中选择项目位置，然后单击完成。</p><p id="0639" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">首先，我们将使用刚刚创建的项目制作 Datareader API。在主类中，编写以下代码。</p><figure class="mk ml mm mn ek hy dy dz paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="dy dz nn"><img src="../Images/9ccaec413f0cd837e9844e70be31a5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FvzlUcCX7BuHBC77tqUjkQ.png"/></div></div><p class="mo mp ea dy dz mq mr bd b be z ft translated">Datareader API 的代码(在<a class="ae iz" href="https://github.com/PhantomGrin/code2statebkend" rel="noopener ugc nofollow" target="_blank"> my GitHub repo </a>中找到代码)</p></figure><p id="9786" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">因为我希望在 Spring boot 默认端口(8080)中运行用户 API，所以我将使用 resource 文件夹中的“<strong class="id gy"><em class="kr">application . properties</em></strong>”文件将这个端口更改为 9090。在 application.properties 中，写入<code class="eu nh ni nj nk b">server.port=9090</code>。</p><p id="393a" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">然后执行 Maven Goal(在 Maven 侧边栏)→全新安装。</p><p id="3e21" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">现在运行项目，并使用软件如<a class="ae iz" href="https://www.udemy.com/postman-crash-course-for-beginners-learn-rest-api-testing/?ranMID=39197&amp;ranEAID=JVFxdTr9V80&amp;ranSiteID=JVFxdTr9V80-yrke8E7QSrnBAypGRS7BPQ&amp;LSNPUBID=JVFxdTr9V80" rel="noopener ugc nofollow" target="_blank"> Postman </a>或使用浏览器检查端点。如果你成功了，你将从调用两个端点得到两个不同的 JSON。</p><p id="b8b7" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">让我们在用户触发用户 API 的端点时，使用用户 API 调用 DataReader API。下面是它的代码:</p><figure class="mk ml mm mn ek hy dy dz paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="dy dz ns"><img src="../Images/b7db416e60da7419fa3accafb136fb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTo7an0_1NDtE7QBCjbhgQ.png"/></div></div><p class="mo mp ea dy dz mq mr bd b be z ft translated">用户 API 代码(在<a class="ae iz" href="https://github.com/PhantomGrin/codestate.git" rel="noopener ugc nofollow" target="_blank"> my GitHub repo </a>中找到代码)</p></figure><p id="f60c" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">同时运行这两个服务，并检查所有端点是否都在工作。</p><blockquote class="nt nu nv"><p id="38c9" class="ib ic kr id b ie if ig ih ii ij ik il nw in io ip nx ir is it ny iv iw ix iy gq bi translated">注意:这里用户 API 的 serverUrl 变量是 localhost</p></blockquote><p id="7f02" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">如果一切正常，你就可以进入下一步了。</p><h2 id="9d54" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">2.将 Spring Boot API 转换为 Docker 图像</h2><p id="a4d1" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">我将首先对我的 Datareader API 进行 dockerize。</p><p id="c568" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">转到项目的根目录(在我的例子中是“codestatebkend”)并在终端中打开它。接下来，使用<code class="eu nh ni nj nk b">touch Dockerfile</code>创建一个 Dockerfile 文件。使用文本编辑器或<code class="eu nh ni nj nk b">nano</code>打开 docker 文件，并输入以下内容:</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="28c1" class="ms jp gx nk b ev od oe l of og"># Start with a base image containing Java runtime (mine java 8)<br/>FROM openjdk:8u212-jdk-slim</span><span id="fb3c" class="ms jp gx nk b ev oh oe l of og"># Add Maintainer Info<br/>LABEL maintainer="<a class="ae iz" href="mailto:savindi.narmada@gmail.com" rel="noopener ugc nofollow" target="_blank">savindi.narmada@gmail.com</a>"</span><span id="2fe8" class="ms jp gx nk b ev oh oe l of og"># Add a volume pointing to /tmp<br/>VOLUME /tmp</span><span id="fa19" class="ms jp gx nk b ev oh oe l of og"># Make port 8080 available to the world outside this container<br/>EXPOSE 8080</span><span id="c8ed" class="ms jp gx nk b ev oh oe l of og"># The application's jar file (when packaged)<br/>ARG JAR_FILE=target/codestatebkend-0.0.1-SNAPSHOT.jar</span><span id="484d" class="ms jp gx nk b ev oh oe l of og"># Add the application's jar to the container<br/>ADD ${JAR_FILE} codestatebkend.jar</span><span id="9f3d" class="ms jp gx nk b ev oh oe l of og"># Run the jar file <br/>ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/codestatebkend.jar"]</span></pre><p id="78c5" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">我们已经完成了 Docker 文件，现在我们可以继续制作<a class="ae iz" href="http://www.java67.com/2018/02/5-free-docker-courses-for-java-and-DevOps-engineers.html" rel="noopener ugc nofollow" target="_blank"> Docker 图像</a>。为了避免在我的本地机器上安装任何东西，也为了方便起见，我将从 Dockerizing 到 Kubernetes 部署使用 Google shell。</p><p id="d407" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">让你的项目进入 Google shell 最简单的方法是通过一个<a class="ae iz" href="https://dev.to/javinpaul/5-free-courses-to-learn-git-and-github-in-depth-jpp" rel="noopener ugc nofollow" target="_blank"> Git 库</a>。在 Git Repo 中提交代码后，进入 Google cloud account，点击右上角的 shell 按钮。然后使用<code class="eu nh ni nj nk b">git clone</code>在项目 shell 中克隆 Git repo。</p><p id="2d1e" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">转到克隆项目的根目录，键入<code class="eu nh ni nj nk b">./mvnw clean package</code>来创建 jar 文件。现在都准备好了。首先，使用以下命令设置<code class="eu nh ni nj nk b">PROJECT-ID</code>变量:</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="ee58" class="ms jp gx nk b ev od oe l of og">export PROJECT_ID=”$(gcloud config get-value project -q)”</span></pre><p id="b2ad" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">现在，让我们用下面的代码在终端中构建 Docker 映像。(不要忘记结尾的点)</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="61cf" class="ms jp gx nk b ev od oe l of og">docker build -t gcr.io/${PROJECT_ID}/codestatebkend .</span></pre><p id="7141" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">让我们看看我们是否成功:</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="801d" class="ms jp gx nk b ev od oe l of og">docker images</span></pre><p id="aa24" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">如果你在列表中看到你的图像，你就成功了！</p><figure class="mk ml mm mn ek hy dy dz paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="dy dz oi"><img src="../Images/c381bb05e98d6b92c084a223db39ae03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVmU7Bi6xSiN5xi-0MU4Ew.png"/></div></div></figure><p id="4f25" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">现在让我们运行这个 docker 映像来检查是否一切正常。</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="3e38" class="ms jp gx nk b ev od oe l of og">docker run --rm -p 8080:8080 gcr.io/${PROJECT_ID}/codestatebkend:latest</span></pre><p id="9ce8" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">点击 Shell 窗口右上角的“Web 预览”按钮。您将看到消息“您好，我是 DataReader”</p><p id="b8fd" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">类似地，为用户 API 创建 Docker 映像。在此之前，不要忘记将代码中的目标 URL(我的代码中名为<code class="eu nh ni nj nk b">serverUrl</code>的变量)从 localhost 改为下面的:</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="00a3" class="ms jp gx nk b ev od oe l of og">http://dataservice.default.svc.cluster.local</span></pre><p id="b6b3" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">使用上面使用的 URL，必须<strong class="id gy">将我们的 ClusterIP 服务命名为“dataservice”。</strong></p><h2 id="98c8" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">3.在 Google 图像库中部署 Docker 图像</h2><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="28a8" class="ms jp gx nk b ev od oe l of og">docker push gcr.io/${PROJECT_ID}/codestatebkend:latest</span></pre><h2 id="2c50" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">4.形成一个集群</h2><p id="eba4" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">在创建群集之前，我将向您描述我将在部署中使用的体系结构:</p><figure class="mk ml mm mn ek hy dy dz paragraph-image"><a href="https://medium.com/javarevisited/top-10-free-courses-to-learn-maven-jenkins-and-docker-for-java-developers-51fa7a1e66f6"><div class="dy dz oj"><img src="../Images/9e3e5542e5f2558c88b05d147112081c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6FfaDo1-IyVr8ZMsIEoblg.png"/></div></a><p class="mo mp ea dy dz mq mr bd b be z ft translated">正在部署的系统的架构</p></figure><p id="7cf8" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">这里根据用例，我为我们的系统选择了 Loadbalancer 服务和 ClusterIP 服务。</p><p id="d744" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">让我们首先创建一个包含 3 个节点的集群。</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="3b83" class="ms jp gx nk b ev od oe l of og">gcloud container clusters create k8s-medium --num-nodes=3 --zone=us-central1-b</span></pre><h2 id="cb3d" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">5.部署 Datareader API</h2><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="6d10" class="ms jp gx nk b ev od oe l of og">kubectl run dataserver --image=gcr.io/${PROJECT_ID}/codestatebkend:latest --port 8080 --labels="app=codestatebkend,tier=backend"</span></pre><p id="2440" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">让我们检查一个 pod 是否是用我们的部署对象创建的</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="3b10" class="ms jp gx nk b ev od oe l of og">kubectl get pods<br/>kubectl get deployment</span></pre><figure class="mk ml mm mn ek hy dy dz paragraph-image"><div class="dy dz ok"><img src="../Images/7db1d2d1fa3812319bfe726a2a377f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*1l466RVOseRLnnrx9kLpfA.png"/></div><p class="mo mp ea dy dz mq mr bd b be z ft translated">带有 Datareader API 映像和新创建的部署对象的新创建的 pod</p></figure><h2 id="3b06" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">6.服务发现</h2><p id="c727" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">使用<code class="eu nh ni nj nk b">expose</code>命令向外界公开您的用户 API:</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="319f" class="ms jp gx nk b ev od oe l of og">kubectl expose deployment userapi --type=LoadBalancer --port 80 --target-port 8080</span></pre><p id="416a" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">使用<code class="eu nh ni nj nk b">kubectl get service</code>获取 Kubernetes 服务列表。</p><figure class="mk ml mm mn ek hy dy dz paragraph-image"><div class="dy dz ol"><img src="../Images/d042189c226af0ee9c056bdd1c322890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*d_fps76hGXlrZb5xEa2izQ.png"/></div><p class="mo mp ea dy dz mq mr bd b be z ft translated">新创建的服务对象</p></figure><p id="9aa6" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">使用这里提到的外部 IP 通过网络浏览器访问服务。你可以看到信息“我是你的转换器”正在显示。</p><p id="eb01" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">现在让我们将用户 API 与后端 Datareader API 连接起来。为此，我将使用 ClusterIP 服务。</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="76c5" class="ms jp gx nk b ev od oe l of og">kubectl expose deployment dataservice --type=ClusterIP --port 80 --target-port 8080 --selector="app=codestatebkend,tier=backend"</span></pre><figure class="mk ml mm mn ek hy dy dz paragraph-image"><div class="dy dz om"><img src="../Images/b9efee3573130ab4919133b3fc4693a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*NvgJVbU-KkJE-30Pm07QwA.png"/></div><p class="mo mp ea dy dz mq mr bd b be z ft translated">这两项服务都已启动并运行！</p></figure><p id="d9d2" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">为了检查一切是否正常工作，使用 postman 或浏览器调用用户 API 的端点</p><p id="80b5" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">例:<em class="kr">http://104.154.103.27/stateToCode?state=alabama</em></p><figure class="mk ml mm mn ek hy dy dz paragraph-image"><div class="dy dz on"><img src="../Images/5284a573fbd662e80376e13d4fa185f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*mNBlO5xuDrkNeEusFi0VLw.png"/></div><p class="mo mp ea dy dz mq mr bd b be z ft translated">成功！我们的系统按预期运行</p></figure><p id="001e" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">瞧啊。您有一个两层系统，完全运行在 Google Cloud 的 Kubernetes 集群上！</p><h2 id="9dc2" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">6.自动缩放功能</h2><p id="26d7" class="pw-post-body-paragraph ib ic gx id b ie km ig ih ii kn ik il im ko io ip iq kp is it iu kq iw ix iy gq bi translated">给你额外的东西😋</p><p id="2e78" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">上面的系统我为每个 API 都做了一个运行 pod。但是在实际场景中，您需要不止一个 Pod 来管理负载。让我告诉你如何扩展你的应用:</p><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="f05c" class="ms jp gx nk b ev od oe l of og">kubectl scale deployment userapi --replicas=2</span></pre><p id="5359" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">用<code class="eu nh ni nj nk b">kubectl get pods</code>来检查一下是否成功。</p><figure class="mk ml mm mn ek hy dy dz paragraph-image"><div class="dy dz oo"><img src="../Images/4bb7a940cbaab1f4e5502d9cbce6df27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*hRp3wEhgUhCTqwcRp8aM7A.png"/></div><p class="mo mp ea dy dz mq mr bd b be z ft translated">具有 2 个用户应用编程接口单元的集群</p></figure><h2 id="2de8" class="ms jp gx bd jq mt mu mv ju mw mx my jy im mz na kc iq nb nc kg iu nd ne kk nf bi translated">7.打扫</h2><pre class="mk ml mm mn ek nz nk oa ob aw oc bi"><span id="3fca" class="ms jp gx nk b ev od oe l of og">gcloud container clusters delete [CLUSTER NAME]--zone=us-central1-b</span></pre><p id="4216" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">是啊！事情就是这么简单🤗</p><p id="67e9" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">希望你喜欢和我一起编码。请在下面留下你对本教程的评论。如果你面临任何问题，留下你的评论，我会帮助你。批评也是受欢迎的😉</p><p id="b123" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">下一篇文章再见！</p><p id="a799" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">编码快乐！❤</p><blockquote class="nt nu nv"><p id="8ff6" class="ib ic kr id b ie if ig ih ii ij ik il nw in io ip nx ir is it ny iv iw ix iy gq bi translated">更多知识:<br/><a class="ae iz" href="https://kubernetes.io/docs/concepts/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/concepts/</a><br/><a class="ae iz" href="https://javarevisited.blogspot.com/2019/01/top-5-free-kubernetes-courses-for-DevOps-Engineer.html" rel="noopener ugc nofollow" target="_blank">5 门免费课程学习 Kubernetes </a> <br/> <a class="ae iz" href="https://www.udemy.com/docker-and-kubernetes-the-complete-guide/?ranMID=39197&amp;ranEAID=JVFxdTr9V80&amp;ranSiteID=JVFxdTr9V80-ldJ9hcxgvGr.BFe0RYD7ZQ&amp;LSNPUBID=JVFxdTr9V80" rel="noopener ugc nofollow" target="_blank"> Docker 和 Kubernetes:完整指南</a> <br/> <a class="ae iz" href="https://www.udemy.com/learn-devops-the-complete-kubernetes-course/?ranMID=39197&amp;ranEAID=JVFxdTr9V80&amp;ranSiteID=JVFxdTr9V80-h_6jHKhNbh1wFRTLXcjPCw&amp;LSNPUBID=JVFxdTr9V80" rel="noopener ugc nofollow" target="_blank">学习 DevOps:完整的 Kubernetes 课程</a> <br/> <a class="ae iz" href="https://hackernoon.com/the-2018-devops-roadmap-31588d8670cb" rel="noopener ugc nofollow" target="_blank">完整的 DevOps 路线图</a> <br/> <a class="ae iz" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-maven-jenkins-and-docker-for-java-developers-51fa7a1e66f6"> 10 门免费课程学习 Maven、Jenkins 和 Docker </a></p></blockquote><p id="d0b4" class="pw-post-body-paragraph ib ic gx id b ie if ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy gq bi translated">如果你不是媒体成员，我强烈推荐你加入媒体，阅读不同领域伟大作家的精彩故事。你可以在这里<strong class="id gy">加入中等</strong><a class="ae iz" rel="noopener" href="/@somasharma_81597/membership"><strong class="id gy"/></a></p></div></div>    
</body>
</html>