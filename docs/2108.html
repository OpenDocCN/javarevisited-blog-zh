<html>
<head>
<title>Spring Boot Authorization: Creating an Authorization Server for your Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot授权:为您的微服务创建授权服务器</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-boot-authorization-creating-an-authorization-server-for-your-microservices-50a3aefd6ce8?source=collection_archive---------0-----------------------#2022-05-14">https://medium.com/javarevisited/spring-boot-authorization-creating-an-authorization-server-for-your-microservices-50a3aefd6ce8?source=collection_archive---------0-----------------------#2022-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a4f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文详细解释了如何使用集中式授权服务器和API网关实现身份验证机制。</p><h1 id="3b26" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是JWT代币，为什么使用它？</h1><blockquote class="kb"><p id="5fbf" class="kc kd hi bd ke kf kg kh ki kj kk jc dx translated">JSON Web Token是一个提议的互联网标准，用于创建带有可选签名和/或可选加密的数据，其有效负载包含断言一些声明的JSON。使用私有秘密或公共/私有密钥对令牌进行签名。</p></blockquote><p id="0796" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi kq translated">它们可以用来实现无状态认证。它们可以跨实例或多个服务共享，并且可以包含对它们进行身份验证所需的详细信息。因此，不需要设置单独的资源来维护会话或将令牌/会话细节存储在单独的数据库/高速缓存中。</p><h2 id="5cd1" class="kz je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">使用的架构</h2><figure class="lo lp lq lr fd ls er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/01/how-to-learn-spring-core-spring-mvc-boot-security-framework.html#axzz7TNldBrH4"><div class="er es ln"><img src="../Images/db1f1e0b416dac792a971e3728434841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qeGDMX6xNFoD_JIPV-Yl2g.png"/></div></a><p class="lv lw et er es lx ly bd b be z dx translated">对安全资源的请求的一般流程</p></figure><p id="b663" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用的一般设计是:</p><ul class=""><li id="a4c9" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">将用于创建和验证JWT令牌的集中式授权服务器。</li><li id="af1e" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">API网关将充当应用程序的入口点。这将把请求路由到相应的微服务。</li><li id="d10d" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">网关过滤器将被添加到路由中，用于验证对安全资源的请求中的JWT令牌。这将对授权服务器进行API调用，以验证令牌并获得用户的用户名和权限。这些详细信息将被转发给标头部分中的下游服务进行验证。</li><li id="10a5" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">Eureka发现客户端将用于服务发现。</li></ul><h2 id="33ab" class="kz je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">认证流程</h2><figure class="lo lp lq lr fd ls er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/01/how-http-basic-authentication-works-in.html#axzz6hhgr3Uqg"><div class="er es mn"><img src="../Images/ef1accb1c5ece1ad86974598d619e2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fTOXcShuL-I8Ey4HfYs-w.png"/></div></a></figure><p id="8482" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务的一般流程是:</p><ul class=""><li id="3c3d" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">用户user可以通过使用用户名和密码调用<strong class="ih hj">/登录</strong> ( <strong class="ih hj">发布</strong>)端点来登录/创建认证令牌。这将返回不记名令牌作为头参数。</li><li id="cca1" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">从响应标头中获取授权令牌。这应该作为对安全资源请求的格式为<strong class="ih hj">载体<em class="mo">访问令牌</em> </strong>的<strong class="ih hj"> <em class="mo">授权</em> </strong>报头的值传递。</li><li id="22c0" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">对于受保护的资源，将调用自定义的<strong class="ih hj"> <em class="mo">网关过滤器(</em>AuthenticationPrefilter<em class="mo">)</em></strong>)。这将对认证服务中的<strong class="ih hj"> /api/v1/validateToken </strong>端点进行API调用，认证服务验证令牌并在成功验证的情况下发送用户名和授予用户的权限作为响应。</li><li id="f8f3" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">如果令牌有效，则用户的用户名和<a class="ae mp" href="https://javarevisited.blogspot.com/2013/07/role-based-access-control-using-spring-security-ldap-authorities-mapping-mvc.html" rel="noopener ugc nofollow" target="_blank">权限</a>在被转发到用户请求的资源之前被附加到头部请求。</li><li id="1952" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">其他微服务(例如:用户服务)将有一个从<strong class="ih hj"> spring-security </strong>中的<strong class="ih hj"> OncePerRequestFilter </strong>扩展而来的授权过滤器，它将使用<strong class="ih hj">usernamepasswordtauthenticationtoken</strong>类创建一个<strong class="ih hj">身份验证</strong>对象(使用来自header的<em class="mo"> username </em>和<em class="mo"> SimpleGrantedAuthority </em>作为输入，密码为空)。</li><li id="0ff8" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">如果用户有权访问资源，则允许该请求。否则，向客户端返回401未授权/ 403禁止响应。</li></ul></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h1 id="3e6c" class="jd je hi bd jf jg mx ji jj jk my jm jn jo mz jq jr js na ju jv jw nb jy jz ka bi translated">设置服务:</h1><h2 id="5d51" class="kz je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">尤里卡服务器</h2><ul class=""><li id="e094" class="lz ma hi ih b ii nc im nd iq ne iu nf iy ng jc me mf mg mh bi translated">使用pom文件中的Spring-cloud-starter-网飞-尤里卡-服务器依赖关系，使用<a class="ae mp" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">Spring initializr</strong></a><strong class="ih hj"/>创建一个Spring Boot应用程序。spring-cloud-dependencies也必须添加到依赖项管理下以获得支持。</li><li id="06c0" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">现在，通过将<a class="ae mp" href="https://www.java67.com/2018/12/top-5-spring-cloud-annotations-for-java.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">@ EnableEurekaServer</strong>注释</a>添加到应用程序的主类中，可以将应用程序配置为作为Eureka服务器启动。</li><li id="b007" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">以下属性被添加到属性文件中以支持Eureka服务器。</li></ul><pre class="lo lp lq lr fd nh ni nj nk aw nl bi"><span id="45de" class="kz je hi ni b fi nm nn l no np">spring.application.name=naming-server<br/>server.port=8761<br/><br/>eureka.client.register-with-eureka=false<br/>eureka.client.fetch-registry=false<br/>eureka.instance.prefer-ip-address=true</span></pre><ul class=""><li id="ecf6" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">现在，尤里卡服务器启动后可以在<a class="ae mp" href="http://localhost:8761/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">http://localhost:8761/</strong></a><strong class="ih hj"/>中访问。它将显示向其注册的服务列表。</li></ul><figure class="lo lp lq lr fd ls er es paragraph-image"><a href="https://www.java67.com/2021/01/spring-cloud-interview-questions-with-answers-java.html"><div class="er es nq"><img src="../Images/1595a2404a40698ae92e3ced8139623b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0brYZihGHoxBFyaqZYDCA.png"/></div></a></figure><h2 id="f434" class="kz je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">授权服务</h2><ul class=""><li id="0cb4" class="lz ma hi ih b ii nc im nd iq ne iu nf iy ng jc me mf mg mh bi translated">创建一个Spring Boot应用<strong class="ih hj"><em class="mo">spring-boot-starter-security</em></strong>，<strong class="ih hj"><em class="mo">spring-boot-starter-web</em>，<strong class="ih hj">，<em class="mo">spring-cloud-starter-sleuth</em>，<strong class="ih hj">，<em class="mo">spring-cloud-starter-config</em>，</strong>，<strong class="ih hj"><em class="mo">spring-cloud-starter-eureka-client</em>，<strong class="ih hj"> <em class="mo"/></strong></strong></strong></strong></li><li id="5eee" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated"><strong class="ih hj"><em class="mo">spring-boot-starter-security</em></strong>用于授权和认证目的，而<strong class="ih hj">spring-boot-starter-data-MongoDB</strong>和<strong class="ih hj">spring-boot-starter-data-JPA</strong>用于访问mongodb集合中的凭证。创建和验证jwt令牌需要依赖关系<strong class="ih hj"><em class="mo">io . jsonwebtoken:jjwt</em></strong>。</li><li id="2017" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">为了使用数据库中的凭证启用身份验证，必须提供来自<a class="ae mp" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-security-and-oauth2-with-spring-boot-for-java-developers-8f0222d6066d"> Spring Security </a>的<strong class="ih hj">userdailsservice</strong>类的自定义实现。这将实现<strong class="ih hj"><em class="mo">loaduserbysusername()</em></strong>方法，该方法将用于从<a class="ae mp" rel="noopener" href="/javarevisited/top-5-sql-and-database-courses-to-learn-online-48424533ac61">数据库</a>获取用户凭证，并返回<strong class="ih hj"> UserDetails </strong>的实例(来自spring security)。</li></ul><pre class="lo lp lq lr fd nh ni nj nk aw nl bi"><span id="2dbf" class="kz je hi ni b fi nm nn l no np">@Service<br/>public class ApplicationUserDetailsService implements UserDetailsService {<br/><br/>    @Autowired<br/>    private UsersService usersService;<br/><br/><br/>    @Override<br/>    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {<br/>        return new ApplicationUsers(usersService.getByUsrName(s).orElseThrow(() -&gt; new UsernameNotFoundException("Username Not Found")));<br/>    }<br/>}</span></pre><ul class=""><li id="4934" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">创建了一个定制的<strong class="ih hj"> UserDetails </strong>类的实现来将定制的数据库对象映射到spring security所需的格式。</li><li id="7db5" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">创建了一个新的配置类，扩展了<a class="ae mp" href="https://javarevisited.blogspot.com/2017/05/how-to-enable-spring-security-in-java-web-application.html" rel="noopener ugc nofollow" target="_blank"> spring security </a>中的<strong class="ih hj">WebSecurityConfigurerAdapter</strong>类。</li></ul><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><ul class=""><li id="460b" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">这里，DaoAuthenticationProvider的Bean是用密码编码器和我们创建的UserDetailsService实现的实例创建的。</li><li id="d7a9" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">这又用于通过配置<strong class="ih hj">AuthenticationManagerBuilder</strong>来使用我们创建的自定义身份验证提供程序，从而覆盖<strong class="ih hj"><em class="mo">configure(AuthenticationManagerBuilder auth)</em></strong>方法。</li><li id="93ee" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">现在，为了每次都使用JWT/承载令牌而不是基于用户名和密码的身份验证，我们必须配置两个过滤器:一个用于生成承载令牌，另一个用于验证它。</li><li id="ba4a" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">JWT生成过滤器:这是作为Spring Security中的<strong class="ih hj">usernamepasswordtauthenticationfilter</strong>的子类创建的。在这里，我们将覆盖<strong class="ih hj"> <em class="mo">尝试验证()</em> </strong>方法d来验证凭证，并覆盖<strong class="ih hj"> <em class="mo">成功验证()</em> </strong>来创建JWT令牌，以防授权成功。</li></ul><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><ul class=""><li id="2ce1" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">JWT验证过滤器:该过滤器是通过扩展由<a class="ae mp" href="https://www.java67.com/2012/08/spring-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank"> spring security </a>提供的<strong class="ih hj"> OncePerRequestFilter </strong>类创建的，并由配置中的<strong class="ih hj">T5】addFilterAfter()</strong>配置，以便在JWT生成过滤器之后调用。</li></ul><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><p id="3eb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">附加功能:</strong></p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="er es nt"><img src="../Images/468dee9c935f5a77ce757d46d2a7fde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O970T1NdSz4XIkeDMAtwZA.png"/></div></div><p class="lv lw et er es lx ly bd b be z dx translated">生成UUID和存储令牌所涉及的额外过程</p></figure><p id="804f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，JWT令牌的内容一旦创建就不能修改。但是，它可以很容易地被解密，内容可以被任何人读取。</p><p id="5b3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以返回一个为认证请求生成的随机UUID，并将对它们的引用存储在redis缓存中，而不是将JWT令牌完全返回给用户。</p><p id="05f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于面向客户端的应用程序，生成的UUID将被返回并使用，而JWT令牌可以在服务之间共享，以用于授权/认证目的。</p><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><h2 id="a729" class="kz je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">API网关</h2><ul class=""><li id="2d98" class="lz ma hi ih b ii nc im nd iq ne iu nf iy ng jc me mf mg mh bi translated">使用spring-cloud-starter-gateway、spring-cloud-starter-config和spring-cloud-starter-网飞-尤里卡-客户端依赖项创建一个Springboot应用程序,这是使用尤里卡客户端设置API网关所需要的。</li><li id="313b" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">云配置服务器和Eureka服务器的详细信息被添加到配置文件中。</li></ul><pre class="lo lp lq lr fd nh ni nj nk aw nl bi"><span id="a622" class="kz je hi ni b fi nm nn l no np">debug: true<br/>logging:<br/>  level:<br/>    org.springframework.cloud.gateway: DEBUG<br/>    reactor.netty.http.client: DEBUG<br/>server:<br/>  port: '8765'<br/>spring:<br/>  cloud:<br/>    config:<br/>      profile: dev<br/>    gateway:<br/>      discovery.locator.enabled: true<br/>  config:<br/>    import: optional:configserver:http://clouduser:configserver705!@localhost:8888<br/>  application:<br/>    name: api-gateway<br/>  jackson:<br/>    date-format: yyyy-MM-dd HH:mm:ss<br/>management:<br/>  endpoints:<br/>    web:<br/>      exposure:<br/>        include: '*'<br/>eureka:<br/>  client:<br/>    serviceUrl:<br/>      defaultZone: http://eurekauser:eureka124!@localhost:8761/eureka<br/>  instance:<br/>    prefer-ip-address: 'true'</span></pre><ul class=""><li id="b895" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">将<strong class="ih hj"> @EnableFeignClients </strong>注释添加到Api Gateway应用程序的主类中，这样它将连接到已配置的Eureka服务器。</li><li id="e245" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">配置网关过滤器，通过调用授权服务器中的<strong class="ih hj"> /validateToken </strong>端点来验证请求中的承载令牌。这个类是通过扩展Spring-API Gateway提供的<strong class="ih hj">AbstractGatewayFilterFactory</strong>类并覆盖其<strong class="ih hj"><em class="mo">apply(Config Config)</em></strong>方法创建的，该方法为<strong class="ih hj"> GatewayFilter </strong>返回一个对象。</li></ul><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><p id="ffc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">配置路线</strong></p><p id="6214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些路由在一个单独的配置文件中进行配置，上面创建的<strong class="ih hj"> GatewayFilter </strong>类作为一个过滤器附加到这些路由上。</p><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><h2 id="d84d" class="kz je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">用户服务(配置Spring安全性和资源端点)</h2><ul class=""><li id="812a" class="lz ma hi ih b ii nc im nd iq ne iu nf iy ng jc me mf mg mh bi translated">使用Spring初始化器创建一个用户服务项目。这将有用户资源，是一个后端服务的例子。</li><li id="349b" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">创建扩展WebSecurityConfigurerAdapter类的配置类，覆盖它的<strong class="ih hj"><em class="mo">void configure(http security http)<br/>throws Exception</em></strong>。这里，自定义过滤器被定义为执行<a class="ae mp" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e"> Spring Boot </a>中的<strong class="ih hj">usernamepasswordtauthenticationfilter</strong>过滤器。</li></ul><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><ul class=""><li id="100b" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated"><strong class="ih hj"> JWTVerifierFilter </strong>过滤器将检查是否有任何用户名和权限数据被添加到请求的header参数中(通过API网关),并将通过使用<strong class="ih hj">usernamepasswordtauthenticationtoken</strong>类创建一个认证对象。</li><li id="c3b0" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">然后使用<strong class="ih hj"> SecurityContextHolder </strong>类将其设置为Spring Security 的<a class="ae mp" href="https://javarevisited.blogspot.com/2018/02/what-is-securitycontext-and-SecurityContextHolder-Spring-security.html" rel="noopener ugc nofollow" target="_blank">安全上下文。</a></li></ul><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><p id="2712" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果请求资源/端点的用户具有对它们的访问/授权，则该请求将被允许到资源/端点。下面是用户资源中<strong class="ih hj"> GET </strong>方法的示例块。</p><figure class="lo lp lq lr fd ls"><div class="bz dy l di"><div class="nr ns l"/></div></figure><p id="4d84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用的常见依赖关系:</strong></p><pre class="lo lp lq lr fd nh ni nj nk aw nl bi"><span id="56c5" class="kz je hi ni b fi nm nn l no np">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>    &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>    &lt;optional&gt;true&lt;/optional&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;<br/>    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;<br/>    &lt;version&gt;0.9.1&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="1d44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使用Spring Cloud库，比如Config Server和Eureka Clients，必须在相应的POM文件中的依赖关系管理下添加一个单独的部分。</p><pre class="lo lp lq lr fd nh ni nj nk aw nl bi"><span id="0f97" class="kz je hi ni b fi nm nn l no np">&lt;properties&gt;<br/>   &lt;spring-cloud.version&gt;2020.0.3&lt;/spring-cloud.version&gt;<br/>&lt;/properties&gt;<br/>&lt;dependencyManagement&gt;<br/>   &lt;dependencies&gt;<br/>      &lt;dependency&gt;<br/>         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>         &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;<br/>         &lt;version&gt;${spring-cloud.version}&lt;/version&gt;<br/>         &lt;type&gt;pom&lt;/type&gt;<br/>         &lt;scope&gt;import&lt;/scope&gt;<br/>      &lt;/dependency&gt;<br/>   &lt;/dependencies&gt;<br/>&lt;/dependencyManagement&gt;</span></pre></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h1 id="c3be" class="jd je hi bd jf jg mx ji jj jk my jm jn jo mz jq jr js na ju jv jw nb jy jz ka bi translated">JWT令牌用法</h1><h2 id="2537" class="kz je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">请求的验证:</h2><ul class=""><li id="1a89" class="lz ma hi ih b ii nc im nd iq ne iu nf iy ng jc me mf mg mh bi translated">这是在最后公开的登录API，可用于对用户进行身份验证并生成JWT令牌。</li></ul><figure class="lo lp lq lr fd ls er es paragraph-image"><a href="https://javarevisited.blogspot.com/2016/09/top-5-json-library-in-java-JEE.html"><div class="er es nq"><img src="../Images/405d01af6af9a8dd587949f9ba31906d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgIeYj5QFdQ9h5J2bFOQqA.png"/></div></a></figure><ul class=""><li id="b6e6" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">在内部使用的<strong class="ih hj"><em class="mo">validate token</em></strong>API，用于验证请求中发送的令牌并获取令牌的授权细节。(该API稍后将被阻止外部访问)。</li></ul><figure class="lo lp lq lr fd ls er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/how-to-parse-json-with-date-field-in-java-jackson-example.html"><div class="er es nq"><img src="../Images/cd87b4af721e0ee0d488c1905ac452d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRqRfWYsHi6qJ9WdO1zmFw.png"/></div></a></figure><ul class=""><li id="4ecd" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">当使用有效的授权令牌通过API网关调用时，用户服务中的安全资源。</li></ul><figure class="lo lp lq lr fd ls er es paragraph-image"><a href="https://www.java67.com/2019/09/3-ways-to-ignore-null-fields-in-json-java-jackson.html"><div class="er es nq"><img src="../Images/69ac4cc41164bfbcebcda724b9b0c498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_1MD-fu1JT7GJaXI2LqWg.png"/></div></a></figure><ul class=""><li id="8909" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">在没有有效授权令牌的情况下，通过API网关调用用户服务中的安全资源。</li></ul><figure class="lo lp lq lr fd ls er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/03/3-examples-to-parse-json-in-java-using.html"><div class="er es nq"><img src="../Images/715c5ba7e1dc74c204e5503f793e7be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AgnOUjhdMTH5Diz9yPdJQ.png"/></div></a></figure><ul class=""><li id="c1e9" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">由授权服务生成的样本JWT令牌。</li></ul><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="er es nq"><img src="../Images/6be7a779e58b8ed162eb2a73a020ec4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cU15sDGUaPkU9B5dVP94JA.png"/></div></div></figure></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="0e64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">更新</strong>:你可以在<a class="ae mp" href="https://github.com/Vicky-cmd/Authentication-Service.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Vicky-cmd/Authentication-Service.git</a>找到完整项目</p><p id="0a54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这就是目前这个话题的全部内容。评论总是受欢迎的。✌️</p></div></div>    
</body>
</html>