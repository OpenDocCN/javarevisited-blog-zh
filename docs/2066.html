<html>
<head>
<title>Deploying A Spring Boot Application on Kubernetes using Jenkins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jenkins在Kubernetes上部署Spring Boot应用程序</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/deploying-a-spring-boot-application-on-kubernetes-using-jenkins-672961425a42?source=collection_archive---------0-----------------------#2022-04-20">https://medium.com/javarevisited/deploying-a-spring-boot-application-on-kubernetes-using-jenkins-672961425a42?source=collection_archive---------0-----------------------#2022-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="58c0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是Kubernetes？</h1><p id="ce2d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Kubernetes，俗称<strong class="jf hj"> K8s </strong>是一个开源容器编排系统，由Google开发，用于软件应用程序的自动化部署、扩展和管理。它用于部署使用<a class="ae kb" rel="noopener" href="/javarevisited/5-best-docker-courses-for-java-and-spring-boot-developers-bbf01c5e6542"> Docker </a>、containerd和CRI-O容器化工具创建的容器化映像。</p><p id="6c8d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><a class="ae kb" rel="noopener" href="/javarevisited/10-best-kubernetes-courses-for-developers-and-devops-engineers-94c35cd3a2fd"> Kubernetes </a>帮助控制云应用/微服务的资源分配和流量。</p><h2 id="2edc" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated"><strong class="ak">特性</strong></h2><ul class=""><li id="8f77" class="kv kw hi jf b jg jh jk jl jo kx js ky jw kz ka la lb lc ld bi translated"><strong class="jf hj">零停机时间的自动推出/回滚</strong>:它可用于在零停机时间内部署对应用程序的更改。实例的健康状况被持续监控，以确保部署的所有实例不会同时被终止。因此，版本中的变化被连续地部署在实例上，以便一段时间后所有实例都是指定的版本。</li><li id="64fd" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated"><strong class="jf hj">可扩展性</strong>:支持使用ReplicaSets和Horizontal Pod Autoscaler (hpa)基于CPU利用率扩展部署。</li><li id="c16c" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated"><strong class="jf hj">活跃度和就绪度探测器</strong>:支持使用活跃度和就绪度探测器进行容错，并在崩溃时自动重启。</li><li id="3ef6" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated"><a class="ae kb" href="https://javarevisited.blogspot.com/2022/02/top-5-courses-to-learn-nginx-in-depth.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj">负载均衡</strong> </a> <strong class="jf hj"> : </strong>它可以用于在使用服务的应用程序的多个实例之间实现负载均衡。</li></ul><h1 id="78b2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="123b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我分享了我使用<a class="ae kb" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jenkins-and-ci-cd-for-devops-engineers-and-software-developers-df2de8fe38f3"> Jenkins </a>在Kubernetes中部署Spring Boot应用程序的方法。这是通过使用两个不同的Jenkins项目实现的——一个用于创建映像，另一个用于部署映像的一个版本。目前，docker守护进程运行在同一台机器上，可以使用相同的脚本进行部署。如果docker守护进程在远程机器上运行，那么可以使用<a class="ae kb" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-jenkins-docker-and-kubernetes-for-devops-in-2020-best-of-lot-62a0541ffeb3"> Jenkins </a>中的SSH插件在远程机器上运行脚本。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/09/top-5-jenkins-courses-for-java-and-DevOps-Programmers.html#axzz7Byop1XFr"><div class="er es lj"><img src="../Images/0c407fbce7b9c841a737914d15281803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWV_9hjAERYUUJ39NRQMCg.png"/></div></a></figure><h1 id="eb1f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">设置所需的服务</h1><h2 id="3f9a" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">库伯内特斯</h2><p id="7c6d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在你的本地电脑上运行Kubernetes节点有很多不同的方法，比如使用<a class="ae kb" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> minikube </strong> </a>，<a class="ae kb" href="https://www.docker.com/products/docker-desktop/" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> Docker Desktop </strong> </a>等等。这里，我已经使用Docker Desktop在我的本地系统中设置了一个节点。</p><p id="7bc7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">Docker桌面可以从这里安装到windows:<a class="ae kb" href="https://docs.docker.com/desktop/windows/install/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/desktop/windows/install/</a>。要运行docker桌面，还必须安装最新版本的WSL 2。可以从微软的<a class="ae kb" href="https://docs.microsoft.com/en-us/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package" rel="noopener ugc nofollow" target="_blank">官方网站</a>安装。</p><p id="bccc" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">一旦Docker桌面被设置并运行，它就可以用来运行<a class="ae kb" rel="noopener" href="/javarevisited/7-free-online-courses-to-learn-kubernetes-in-2020-3b8a68ec7abc"> Kubernetes </a>节点，也可以从设置中运行。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/05/top-5-courses-to-learn-docker-and-kubernetes-for-devops.html"><div class="er es lr"><img src="../Images/829622ca98a0a6dc889998ae5bba5190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVHwwojX-UV7VcFU099HsA.png"/></div></a></figure><p id="b388" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">一旦它们都设置好了，您应该能够在命令提示符下看到它们的版本。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><a href="https://www.java67.com/2021/04/top-5-courses-to-learn-docker-for-java.html"><div class="er es ls"><img src="../Images/430949a240298433a6e3a4396625ed4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*sfUw5P3uKQZyxRyDcU8Vjw.png"/></div></a><p class="lt lu et er es lv lw bd b be z dx translated">检查Docker版本的命令</p></figure><figure class="lk ll lm ln fd lo er es paragraph-image"><a href="https://www.java67.com/2020/07/top-5-courses-to-learn-linux-in-depth.html"><div class="er es lx"><img src="../Images/97017b80dfd04687bcdfa84e1c0cd10d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7FV8bMROXO3BJ2GgvdMW7w.png"/></div></a><p class="lt lu et er es lv lw bd b be z dx translated">检查Kubernetes版本的命令</p></figure><h2 id="11df" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">詹金斯和吉特回购</h2><p id="ed60" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">要设置Jenkins和其他服务，可以参考我之前的文章<a class="ae kb" rel="noopener" href="/javarevisited/deploying-a-springboot-application-in-docker-using-jenkins-cicd-2489bfe752c3"> <strong class="jf hj">使用Jenkins CICD </strong> </a>在Docker中部署Springboot应用程序。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="2ebc" class="if ig hi bd ih ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc bi translated">詹金斯·CICD工作</h1><h2 id="f8ab" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">持续集成项目</h2><ol class=""><li id="8b21" class="kv kw hi jf b jg jh jk jl jo kx js ky jw kz ka mk lb lc ld bi translated">创建新的Jenkins自由式项目</li></ol><p id="fc94" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">名称</strong>:跳羚-V1</p><p id="3c1b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">项目类型</strong>:自由式项目</p><p id="f362" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在项目配置中，给出的Git URL以及身份验证，如果在源代码管理选项下的话。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-spring-microservices-courses-with-spring-boot-and-spring-cloud.html"><div class="er es ml"><img src="../Images/6c3ae5918b3be8976ca3ccdd6d2d4235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WawyePWAvTeBpJL4.png"/></div></a></figure><p id="c7aa" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，构建过程包括两个阶段。它们是:</p><p id="533f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">1.首先，选择<strong class="jf hj">调用顶级Maven目标</strong>选项。将<strong class="jf hj"> <em class="mm">清洗<br/> </em> </strong>和<strong class="jf hj"> <em class="mm">安装</em> </strong>目标作为输入给出。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/03/top-5-course-to-learn-apache-maven-for.html"><div class="er es ml"><img src="../Images/0f7d6979a3adc53b962a09b2d546e13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aojqd3VSU8tCdH3i.png"/></div></a><p class="lt lu et er es lv lw bd b be z dx translated">为构建设置maven生命周期</p></figure><p id="8837" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">2.接下来，选择<strong class="jf hj">执行窗口批处理命令</strong>选项。这用于执行批处理文件，该文件将:</p><ul class=""><li id="d731" class="kv kw hi jf b jg kc jk kd jo mn js mo jw mp ka la lb lc ld bi translated">获取当前提交id并将其存储在<strong class="jf hj"> version.txt </strong>中。</li><li id="0502" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated">将构建(war)文件复制到一个公共文件夹中。</li><li id="666b" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka la lb lc ld bi translated">因为docker实例运行在同一台机器上，所以新版本的映像构建在同一个脚本中，并被推送到docker registry。</li></ul><p id="ffd0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">使用的批处理脚本是:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="1e18" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，Post Script动作用于触发CD构建，以便新实例可以部署在<a class="ae kb" rel="noopener" href="/javarevisited/top-15-online-courses-to-learn-docker-kubernetes-and-aws-for-fullstack-developers-and-devops-d8cc4f16e773"> docker </a>中。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="er es lr"><img src="../Images/826d27a059d7dcefdffc649953452769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jUnpbp4ogWfigeJFVkWcw.png"/></div></div><p class="lt lu et er es lv lw bd b be z dx translated">为CD项目设置自动触发器</p></figure><h2 id="3720" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">持续部署项目</h2><ol class=""><li id="c98e" class="kv kw hi jf b jg jh jk jl jo kx js ky jw kz ka mk lb lc ld bi translated">创建新的Jenkins自由式项目</li></ol><p id="462c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">名字</strong>:跳羚-V1-CD</p><p id="c82a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">项目类型</strong>:自由式项目</p><p id="6722" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这是一个参数化的项目，接受版本作为输入。此版本用于确定要部署的docker映像的版本，默认情况下配置为“最新”。</p><p id="aa9a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">它运行一个批处理脚本来部署具有指定映像版本的服务。</p><ol class=""><li id="b6c9" class="kv kw hi jf b jg kc jk kd jo mn js mo jw mp ka mk lb lc ld bi translated">首先，它检查“springboot-v1”是否已经部署在Kubernetes集群中。</li><li id="0575" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka mk lb lc ld bi translated">如果是，那么它更新部署的映像版本，或者如果部署了最新版本，则重新启动部署。由于<strong class="jf hj"> <em class="mm"> imagePullPolicy </em> </strong>在部署配置中一如既往地进行配置，因此这将自动从docker注册表中提取新的映像。</li><li id="5090" class="kv kw hi jf b jg le jk lf jo lg js lh jw li ka mk lb lc ld bi translated">否则，它使用存储的<a class="ae kb" href="https://javarevisited.blogspot.com/2021/11/top-5-courses-to-learn-yaml-in-2022.html" rel="noopener ugc nofollow" target="_blank"> YAML配置</a>创建新的部署和服务，并基于输入参数更新镜像版本。</li></ol><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="bfda" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">部署的YAML配置</h2><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mq mr l"/></div></figure><h2 id="f86b" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">使用的Dockerfile文件</h2><pre class="lk ll lm ln fd mw mx my mz aw na bi"><span id="2f38" class="kh ig hi mx b fi nb nc l nd ne">FROM adoptopenjdk/openjdk11:jre-11.0.6_10-alpine    <br/>EXPOSE 8080:8081 <br/>RUN addgroup -S spring &amp;&amp; adduser -S spring -G spring <br/>USER spring:spring  <br/>COPY SpringbootV1-0.0.1-SNAPSHOT.war SpringbootV1-0.0.1-SNAPSHOT.war <br/>ENTRYPOINT ["java","-jar","/SpringbootV1-0.0.1-SNAPSHOT.war"]</span></pre><h1 id="70f3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">检查服务的部署</h1><ul class=""><li id="e817" class="kv kw hi jf b jg jh jk jl jo kx js ky jw kz ka la lb lc ld bi translated"><strong class="jf hj">ku bectl get deployments-o wide</strong></li></ul><p id="e677" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">显示在Kubernetes集群中创建的部署列表。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><a href="https://www.java67.com/2019/03/5-free-devops-courses-to-learn-jenkins.html"><div class="er es nf"><img src="../Images/0dbe7c9a2eaf0580f3ddeb39e0e73c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r8eD4oLWfieB9toXd6sQeg.png"/></div></a><p class="lt lu et er es lv lw bd b be z dx translated">kubectl get部署的输出-o范围</p></figure><ul class=""><li id="e883" class="kv kw hi jf b jg kc jk kd jo mn js mo jw mp ka la lb lc ld bi translated"><strong class="jf hj"> kubectl获取豆荚</strong></li></ul><p id="49b8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这将显示为给定服务运行的窗格列表。为该服务部署的每个pod都有一个唯一的名称，使用该名称可以对其进行识别。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es ng"><img src="../Images/aa46a1183a08cf183c1ba0f0bd0dde01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*MS9TvZpxpE5FQYCFWICcQw.png"/></div><p class="lt lu et er es lv lw bd b be z dx translated">kubectl get pods的输出</p></figure><ul class=""><li id="30ee" class="kv kw hi jf b jg kc jk kd jo mn js mo jw mp ka la lb lc ld bi translated"><strong class="jf hj"> kubectl获取svc -o wide </strong></li></ul><p id="baf1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这将显示为部署创建的服务列表及其类型(负载平衡器、节点端口等)。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="er es nh"><img src="../Images/15844114360a4fabae6d66ea4623edf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yPk6hvMhMZ7wn31fxYKZg.png"/></div></div><p class="lt lu et er es lv lw bd b be z dx translated">kubectl get svc -o wide的输出</p></figure><ul class=""><li id="cd43" class="kv kw hi jf b jg kc jk kd jo mn js mo jw mp ka la lb lc ld bi translated"><strong class="jf hj"> kubectl获取hpa </strong></li></ul><p id="34fa" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这将显示已配置的水平窗格自动缩放列表。这可用于根据收到的请求/CPU利用率自动扩展单元。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="er es ni"><img src="../Images/0be67e22fc8562270d96295c1beb2c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Nvhdyy2j3Ctke1gEsTsiw.png"/></div></div></figure><p id="2b43" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">通过传递选择器参数(<em class="mm"> app=infotrends </em>)作为输入，可以进一步过滤所有命令，以获得属于特定应用程序的窗格(<em class="mm">ku bectl get pods—selector = app = info trends</em>)</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="er es nj"><img src="../Images/2481d55bc262fe9cc7dd028bedc9669b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SK2lcX7klt8zhQcfXbHCLQ.png"/></div></div><p class="lt lu et er es lv lw bd b be z dx translated">kubectl get pods的输出—选择器=app=infotrends</p></figure><p id="9db7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">使用此服务，我们现在可以使用8081端口访问应用程序。该服务将在三个pod之间对请求进行负载平衡。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="er es nk"><img src="../Images/2eade6c658223dc5025bec5febc732a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dVDIq-wseptJeJfp.png"/></div></div></figure></div></div>    
</body>
</html>