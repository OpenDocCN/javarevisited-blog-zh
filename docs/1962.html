<html>
<head>
<title>The elusive and beautiful Java Method Reference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">难以捉摸而美丽的Java方法参考</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/the-elusive-and-beautiful-java-method-reference-97e566d2088b?source=collection_archive---------0-----------------------#2022-02-19">https://medium.com/javarevisited/the-elusive-and-beautiful-java-method-reference-97e566d2088b?source=collection_archive---------0-----------------------#2022-02-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f576" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我喜欢Java 8中的lambdas，但是方法引用难以捉摸，令人惊讶</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3a202da662d9de5fcd935b238e93913e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L8WtwhRjg4BuTCGR"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳森派</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="458d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Lambdas是灵活的匿名代码</h1><p id="b1ea" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们可以用lambdas解决Java中很多有趣的问题。对于简单的事情，我们可以使用表达式，对于更复杂的事情，我们可以使用语句。Lambdas可以调用当前对象(<code class="du kx ky kz la b">this</code>)或范围内对象的其他方法，如迭代的当前元素，或lambda之外的最终局部变量。我们总是可以通过将代码放入另一个方法来简化lambda。</p><p id="caa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">写好兰姆达斯需要自律。例如，为参数使用揭示意图的名称是很重要的。这里有一个简单的例子，使用λ来过滤<code class="du kx ky kz la b">Strings</code>的<code class="du kx ky kz la b">List</code>。</p><pre class="je jf jg jh fd lb la lc bn ld le bi"><span id="57ec" class="lf jv hi la b be lg lh l li lj">@Test<br/>public void filterStringsLambda()<br/>{<br/>    var list = Lists.mutable.with(<br/>            "Atlanta", <br/>            "Atlantic City", <br/>            "Boston", <br/>            "Boca Raton");<br/>    <br/>    var actual = list.stream()<br/>            .filter(string -&gt; string.startsWith("At"))<br/>            .collect(Collectors.toList());<br/><br/>    var expected = List.of("Atlanta", "Atlantic City");<br/><br/>    Assertions.assertEquals(expected, actual);<br/>}</span></pre><p id="2bcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这段代码中，lambda是以<code class="du kx ky kz la b">Predicate</code>的形式传递给<code class="du kx ky kz la b">filter</code>方法的参数。在这个例子中，<code class="du kx ky kz la b">Predicate</code>接受一个类型为<code class="du kx ky kz la b">String</code>的参数，我将其命名为<code class="du kx ky kz la b">string</code>。分隔符(<code class="du kx ky kz la b">-&gt;</code>)后的表达式将针对列表中的每个元素进行计算，并且只包括计算结果为<code class="du kx ky kz la b">true</code>的元素。</p><p id="da50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du kx ky kz la b">Stream</code> API中有几个方法将把<code class="du kx ky kz la b">Predicate</code>作为参数。方法包括<code class="du kx ky kz la b">filter</code>、<code class="du kx ky kz la b">anyMatch</code>、<code class="du kx ky kz la b">allMatch</code>、<code class="du kx ky kz la b">noneMatch</code>。</p><p id="ddbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我没有简单的方法来使用方法引用，因为我需要将参数<code class="du kx ky kz la b">“At”</code>传递给方法<code class="du kx ky kz la b">startsWith</code>。参数是方法引用使用的氪星石。我们可以通过使用lambda并将其提取到一个单独的方法中来模拟方法引用，如下所示。</p><pre class="je jf jg jh fd lb la lc bn ld le bi"><span id="851c" class="lf jv hi la b be lg lh l li lj">@Test<br/>public void filterStringsLambdaInMethod()<br/>{<br/>    var list = Lists.mutable.with(<br/>            "Atlanta", <br/>            "Atlantic City", <br/>            "Boston", <br/>            "Boca Raton");<br/><br/>    var actual = list.stream()<br/>            .filter(this.stringStartsWith("At"))<br/>            .collect(Collectors.toList());<br/><br/>    var expected = List.of("Atlanta", "Atlantic City");<br/><br/>    Assertions.assertEquals(expected, actual);<br/>}<br/><br/>private Predicate&lt;String&gt; stringStartsWith(String prefix)<br/>{<br/>    return string -&gt; string.startsWith(prefix);<br/>}</span></pre><p id="3121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">必须在一个类上创建一个方法来生成可以在范围内利用局部变量的lambdas并不理想。我希望能够只使用<code class="du kx ky kz la b">startsWith</code>方法作为方法引用。</p><h1 id="4e23" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何满足一个方法引用偏好？</h1><p id="d765" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用<a class="ae jt" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>中的<code class="du kx ky kz la b">With</code>方法。</p><blockquote class="lk ll lm"><p id="0973" class="if ig ln ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated">这是方法</p></blockquote><p id="db59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于Eclipse集合API中的许多可用方法，都有一个对应的带后缀<code class="du kx ky kz la b">With</code>的方法。每个<code class="du kx ky kz la b">With</code>方法都有一个不同的命名函数接口，该接口有两个参数(例如<code class="du kx ky kz la b">Predicate2</code>、<code class="du kx ky kz la b">Function2</code>等)。).下面的思维导图展示了Eclipse Collections API中的一些基本方法，以及它们对应的<code class="du kx ky kz la b">With</code>等价物和它们作为参数的函数接口类型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/c43b670fc5706d3115d068561106dfa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ThVSlLKYPlQGoH8T2VSAA.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">可丰富的basic和“With”方法</p></figure><p id="9df8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些额外的方法如何帮助您使用带参数的方法引用？让我们看一些例子。</p><h2 id="3825" class="ls jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">基本使用Lambda</h2><p id="c912" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">让我们看一个使用lambda的一个基本Eclipse集合方法过滤字符串列表的例子。</p><pre class="je jf jg jh fd lb la lc bn ld le bi"><span id="be36" class="lf jv hi la b be lg lh l li lj">@Test<br/>public void selectStringsLambda()<br/>{<br/>    var list = Lists.mutable.with(<br/>            "Atlanta", <br/>            "Atlantic City", <br/>            "Boston", <br/>            "Boca Raton");<br/><br/>    var actual = list.select(string -&gt; string.startsWith("At"));<br/><br/>    var expected = List.of("Atlanta", "Atlantic City");<br/><br/>    Assertions.assertEquals(expected, actual);<br/>}</span></pre><h2 id="1319" class="ls jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated"><code class="du kx ky kz la b">With</code>方法参考</h2><p id="be24" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在让我们看看如何使用与<code class="du kx ky kz la b">select</code>等价的<code class="du kx ky kz la b">With</code>来满足我们的方法引用偏好。</p><pre class="je jf jg jh fd lb la lc bn ld le bi"><span id="648a" class="lf jv hi la b be lg lh l li lj">@Test<br/>public void selectStringsWithMethodReference()<br/>{<br/>    var list = Lists.mutable.with(<br/>            "Atlanta", <br/>            "Atlantic City", <br/>            "Boston", <br/>            "Boca Raton");<br/><br/>    var actual = list.selectWith(String::startsWith, "At");<br/><br/>    var expected = List.of("Atlanta", "Atlantic City");<br/><br/>    Assertions.assertEquals(expected, actual);<br/>}</span></pre><blockquote class="lk ll lm"><p id="c69a" class="if ig ln ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated">我已经说过了</p></blockquote><p id="bb71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你没有“啊哈！”矩，不要惊慌。我们仍然不能将参数直接传递给方法引用。目前Java中没有支持它的语法。这里有一个诡计。</p><p id="40ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我试着解释一下这是如何工作的。方法<code class="du kx ky kz la b">selectWith</code>有两个参数。第一个参数是一个<code class="du kx ky kz la b">Predicate2</code>，它将匹配<code class="du kx ky kz la b">String::startsWith</code>的签名。更具体地说，<code class="du kx ky kz la b">Predicate2&lt;String, String&gt;</code>与<code class="du kx ky kz la b">String::startsWith</code>的签名相匹配。第二个参数<code class="du kx ky kz la b">selectWith</code>是任何类型的参数，在本例中恰好是一个<code class="du kx ky kz la b">String</code>。</p><p id="ea8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是<code class="du kx ky kz la b">RichIterable</code>上<code class="du kx ky kz la b">selectWith</code>的确切签名。</p><pre class="je jf jg jh fd lb la lc bn ld le bi"><span id="e021" class="lf jv hi la b be lg lh l li lj">&lt;P&gt; RichIterable&lt;T&gt; selectWith(<br/>        Predicate2&lt;? super T, ? super P&gt; predicate, <br/>        P parameter);</span></pre><p id="3cc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我最初发表博客后，我添加了下一部分。一个朋友建议，一个小的改进是包括一个“如何做”的例子，这样开发人员可以看到没有魔法，可以开始利用他们自己的代码。谢谢你的建议Rustam！</p><h1 id="4ef7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">一个<code class="du kx ky kz la b">selectWith</code>模式实现的例子</h1><p id="7c38" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Eclipse集合中有一个名为<code class="du kx ky kz la b"><a class="ae jt" href="https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections/src/main/java/org/eclipse/collections/impl/utility/internal/IteratorIterate.java" rel="noopener ugc nofollow" target="_blank">IteratorIterate</a></code>的类。它包含了Eclipse集合中的许多基本的急切迭代模式，这些模式允许与Java中的任何<code class="du kx ky kz la b">Iterable</code>类型一起使用。我分享这个例子是因为<code class="du kx ky kz la b">Iterator</code>是一个足够基本的概念，大多数Java开发人员应该能够阅读和理解代码。下面显示了在<code class="du kx ky kz la b">IteratorIterate</code>中<code class="du kx ky kz la b"><a class="ae jt" href="https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections/src/main/java/org/eclipse/collections/impl/utility/internal/IteratorIterate.java#L271" rel="noopener ugc nofollow" target="_blank">selectWith</a></code>的实现，它对于带有单个参数的方法引用是方法引用友好的。</p><pre class="je jf jg jh fd lb la lc bn ld le bi"><span id="2b06" class="lf jv hi la b be lg lh l li lj">public static &lt;T, P, R extends Collection&lt;T&gt;&gt; R selectWith(<br/>        Iterator&lt;T&gt; iterator,<br/>        Predicate2&lt;? super T, ? super P&gt; predicate,<br/>        P injectedValue,<br/>        R targetCollection)<br/>{<br/>    while (iterator.hasNext())<br/>    {<br/>        T item = iterator.next();<br/>        if (predicate.accept(item, injectedValue))<br/>        {<br/>            targetCollection.add(item);<br/>        }<br/>    }<br/>    return targetCollection;<br/>}</span></pre><p id="7588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种模式可以用于任何可以创建<code class="du kx ky kz la b">Iterator</code>的类型。</p><p id="63d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个使用JDK <code class="du kx ky kz la b">Set</code>和<code class="du kx ky kz la b">IteratorIterate.selectWith</code>的例子。</p><pre class="je jf jg jh fd lb la lc bn ld le bi"><span id="4cc8" class="lf jv hi la b be lg lh l li lj">@Test<br/>public void selectWithOnIteratorIterate()<br/>{<br/>    Set&lt;String&gt; strings = Set.of(<br/>            "Atlanta", <br/>            "Atlantic City", <br/>            "Boston", <br/>            "Boca Raton");<br/>    <br/>    HashSet&lt;String&gt; actual = IteratorIterate.selectWith(<br/>            strings.iterator(),<br/>            String::startsWith,<br/>            "At",<br/>            new HashSet&lt;&gt;());<br/>    var expected = Set.of("Atlanta", "Atlantic City");<br/>    Assertions.assertEquals(expected, actual);<br/>}</span></pre><p id="c96c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这个额外的部分是有帮助的。</p><h1 id="2337" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">更多的方法参考请！</h1><p id="940f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">既然我们已经知道了如何在<code class="du kx ky kz la b">With</code>方法中使用方法引用，让我给你看更多的例子。</p><pre class="je jf jg jh fd lb la lc bn ld le bi"><span id="eaed" class="lf jv hi la b be lg lh l li lj">@Test<br/>public void predicatesWithMethodReference()<br/>{<br/>    var list = Lists.mutable.with(<br/>            "Atlanta", <br/>            "Atlantic City", <br/>            "Boston", <br/>            "Boca Raton");<br/><br/>    var selected1 = list.selectWith(String::startsWith, "At");<br/><br/>    var expected1 = List.of("Atlanta", "Atlantic City");<br/>    Assertions.assertEquals(expected1, selected1);<br/><br/>    var rejected = list.rejectWith(String::startsWith, "At");<br/><br/>    var expected2 = List.of("Boston", "Boca Raton");<br/>    Assertions.assertEquals(expected2, rejected);<br/><br/>    var selected2 = list.selectWith(String::startsWith, "Bo");<br/><br/>    Assertions.assertEquals(expected2, selected2);<br/><br/>    var detected = list.detectWith(String::endsWith, "y");<br/><br/>    Assertions.assertEquals("Atlantic City", detected);<br/><br/>    var count = list.countWith(String::contains, "c");<br/><br/>    Assertions.assertEquals(2, count);<br/>    Assertions.assertTrue(<br/>        list.anySatisfyWith(String::contains, "a"));<br/>    Assertions.assertTrue(<br/>        list.allSatisfyWith(String::contains, "t"));<br/>    Assertions.assertTrue(<br/>         list.noneSatisfyWith(String::contains, "z"));<br/><br/>    var partitioned = list.partitionWith(String::endsWith, "n");<br/><br/>    Assertions.assertEquals(expected2, partitioned.getSelected());<br/>    Assertions.assertEquals(expected1, partitioned.getRejected());<br/>}</span></pre><p id="96f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多取单参数的方法可以匹配<code class="du kx ky kz la b">Predicate2</code>、<code class="du kx ky kz la b">Function2</code>、<code class="du kx ky kz la b">Procedure2</code>等。作为方法引用。Eclipse集合中的With方法大大增加了可以使用方法引用而不是lambdas的地方。</p><h1 id="a8fe" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">享受方法引用和Lambdas</h1><p id="ae95" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我希望这篇博客能帮助您发现Eclipse集合中可用的一个漂亮特性，它能帮助您找到更多使用方法引用的地方。在方法引用出现在Java 8之前，我们在Eclipse集合中就有了“<code class="du kx ky kz la b">With</code>”方法。我们最初添加它们是为了创造更多的机会将匿名内部类提升到静态变量中，以减少垃圾生成。我们过去称这些为“fat free闭包”,因为它们不需要你不断向堆中添加新的对象。巧合的是，这使得利用方法引用来利用这些方法变得更加容易，这是一个令人非常愉快和受欢迎的惊喜。</p><p id="d294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您阅读本博客！我希望你能像我现在一样喜欢使用方法引用。</p><p id="d988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ln">我是</em><a class="ae jt" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="ln">Eclipse Collections</em></a><em class="ln">OSS项目在</em><a class="ae jt" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="ln">Eclipse Foundation</em></a><em class="ln">的项目负责人。</em> <a class="ae jt" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="ln">月食收藏</em> </a> <em class="ln">是开投</em> <a class="ae jt" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="ln">投稿</em> </a> <em class="ln">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p><h2 id="7b30" class="ls jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">进一步学习</h2><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/javarevisited/10-best-places-to-learn-java-online-for-free-ce5e713ab5b2"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">2022年免费在线学习Java的10个最佳地点</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">我最喜欢的免费在线学习Java的网站，适合初学者和想学习Java编码的人…</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx jn mj"/></div></div></a></div><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/javarevisited/the-java-programmer-roadmap-f9db163ef2c2"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">2022年Java程序员路线图</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">2022年成为Java开发人员的图解指南，包含相关课程的链接</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="my l mu mv mw ms mx jn mj"/></div></div></a></div><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/javarevisited/20-essential-java-libraries-and-apis-every-programmer-should-learn-5ccd41812fc7"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">2022年每个程序员都应该学习的22个基本Java库和API</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">成为更好的Java开发人员可以学习的最基本的Java库。它包括用于日志记录的Java库…</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mz l mu mv mw ms mx jn mj"/></div></div></a></div></div></div>    
</body>
</html>