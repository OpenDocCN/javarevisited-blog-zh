<html>
<head>
<title>Software Design Patterns: Singleton in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计模式:简单地说，单一模式</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/design-patterns-101-hello-singleton-2d3f227c7729?source=collection_archive---------1-----------------------#2020-12-30">https://medium.com/javarevisited/design-patterns-101-hello-singleton-2d3f227c7729?source=collection_archive---------1-----------------------#2020-12-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/a5135b3537738efb5defd73d6bae40e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYgt_szGSiX9GG5XaP6_3w.png"/></div></div></figure><div class=""/><p id="0cbe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创造性设计模式为对象创建(类的实例化)提供了选项，因为有时，对象创建的基本形式可能会导致设计问题或增加设计的复杂性。创造性设计模式通过某种方式控制对象的创建来解决这个问题。它们由两个主导思想组成:第一个是封装关于系统使用哪些具体类的知识；第二个是隐藏这些具体类的实例是如何创建和组合的。单一模式是最常用的设计模式之一。这是第二个主导思想的例子:它隐藏了具体类的实例是如何创建的。</p><h1 id="66e4" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">目标</h1><p id="f2a4" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Singleton的目标是<strong class="is hu">确保一个类有且只有一个实例</strong>(对象)。它用于向<strong class="is hu">提供对对象</strong>的全局访问点。例如，日志记录、数据源访问、线程池、配置设置管理、连接实例等等。Singleton有时与<a class="ae kr" rel="noopener" href="/javarevisited/design-patterns-101-factory-vs-builder-vs-fluent-builder-da2babf42113">工厂模式</a>相结合，以保证整个系统中只存在一个工厂。</p><h1 id="1f79" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">解决办法</h1><p id="7747" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们如何确保只能存在一个实例？我们可以分三步走。我们来复习一下。</p><p id="5b3b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设您有一个类DataSource，它实现了从连接到您的计算机的硬件设备或远程服务器收集数据。我们的DataSource类可以如图1所示。没有什么特别的，只是一个和其他类一样的类——一个有属性和方法的类。</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div><p class="ky kz et er es la lb bd b be z dx translated">图一。DataSource.java——一个简单的班级</p></figure><p id="c1ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您不希望多个DataSource对象中的每个对象都创建自己的连接，从而导致多个对象争用访问权。让我们把它转换成单一数据源。</p><h2 id="ffd2" class="lc jp ht bd jq ld le lf ju lg lh li jy jb lj lk kc jf ll lm kg jj ln lo kk lp bi translated">第一步。私人构造函数</h2><p id="9ef4" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">首先，为了创建我们类的实例，其他类会调用构造函数，对吗？大概是这样的:</p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="be5c" class="lc jp ht lr b fi lv lw l lx ly">DataSource ds = new DataSource();</span></pre><p id="1ea7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构造函数是公共的，因为通常我们希望其他类调用它们。创建单例的第一步是将访问修饰符从<em class="lz"> public </em>改为<em class="lz"> private </em>(或<em class="lz"> protected)。</em>为什么？避免任何类创建实例。如果您将构造函数设为私有，则没有人能够创建类的实例。那么，我们是从能够创建N个对象发展到能够创建0个对象吗？是的，这是目前为止的重点。</p><h2 id="460b" class="lc jp ht bd jq ld le lf ju lg lh li jy jb lj lk kc jf ll lm kg jj ln lo kk lp bi translated">第二步。静态公共方法</h2><p id="aed1" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们需要一个替换构造函数的方法，一个其他类可以用来请求实例的<em class="lz">公共</em>方法。特别是，我们需要一个无需创建类的对象就可以调用的方法(因为此时我们不能创建对象，我们只是使构造函数不可访问)。我们需要一个<em class="lz">静态</em>方法。这种方法在单例模式模板中被称为<em class="lz"> getInstance() </em>，开发者通常保留这个名字。</p><p id="2aaf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">方法<em class="lz"> getInstance() </em>将从类中给我们一个新对象，就像构造函数一样。方法<em class="lz"> getInstance() </em>应该是公共的(每个其他类都应该能够访问它)，应该是静态的(如前所述)，并且应该返回该类的一个实例(在我们的示例中，返回一个DataSource)。该方法如下所示:</p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="5cf7" class="lc jp ht lr b fi lv lw l lx ly">public static DataSource getInstance() {</span><span id="b8f3" class="lc jp ht lr b fi ma lw l lx ly">}</span></pre><p id="bf12" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，方法的主体。请求数据源实例时有两种情况:</p><ul class=""><li id="3a08" class="mb mc ht is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">如果是第一次，那么创建一个新对象；否则，</li><li id="e038" class="mb mc ht is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">只需返回第一次调用时创建的对象的引用。这似乎很容易实现。</li></ul><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="6651" class="lc jp ht lr b fi lv lw l lx ly">public static DataSource getInstance() {<br/>  if (instance == null)<br/>    instance = new DataSource ();<br/>  return instance;<br/>}</span></pre><p id="3d75" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">等等，那个<em class="lz">实例</em>变量是什么？我们需要一个变量来知道我们是否已经创建了一个对象。</p><h2 id="fd8c" class="lc jp ht bd jq ld le lf ju lg lh li jy jb lj lk kc jf ll lm kg jj ln lo kk lp bi translated">第三步。静态实例</h2><p id="dba0" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">实例变量需要是静态的，因为我们需要在静态方法中访问它。注意，我们在方法<em class="lz"> getInstance()内部调用构造函数。</em>构造函数不能从外部调用，但是类可以使用。</p><p id="5da8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们新的<em class="lz"> DataSource </em>类应用了Singleton模式，如图2所示。注意:</p><ul class=""><li id="855c" class="mb mc ht is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">第2行中的静态变量；</li><li id="754f" class="mb mc ht is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">第6行的公共静态方法<em class="lz">getInstance()</em>；而且，</li><li id="9d83" class="mb mc ht is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated">第12行中的私有构造函数。</li></ul><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div><p class="ky kz et er es la lb bd b be z dx translated">图二。DataSource.java——实现单例模式</p></figure><p id="143d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这些，在任何需要访问数据源的地方，我们都可以使用指令<em class="lz"> DataSource.getInstance()。我们可以将实例存储在一个局部变量中，也可以根据需要直接调用方法。例如:</em></p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="5646" class="lc jp ht lr b fi lv lw l lx ly">DataSource ds = DataSource.getInstance();<br/>ds.send("Hello");</span></pre><p id="19b5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者</p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="eb24" class="lc jp ht lr b fi lv lw l lx ly">DataSource.getInstance().send("Hello");</span></pre><h1 id="68ab" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">类图</h1><p id="07ca" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Singleton是少数不使用接口(或一组类)的设计模式之一。此外，还有一个名为Singleton的元素。类名应该是正在解决的问题的上下文中所需要的，比如在我们的示例DataSource中。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mp"><img src="../Images/77cb6641fe9f39b6f4f227b617f38c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1jZmAI29jJvQtnOMlNjtQ.jpeg"/></div></div><p class="ky kz et er es la lb bd b be z dx translated">图3。应用单例模式的DataSource类的类图:私有构造函数、getInstance()方法和同一类的静态实例</p></figure><p id="d85b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图3显示了单例模板(作为一个类图):</p><ul class=""><li id="d6c5" class="mb mc ht is b it iu ix iy jb md jf me jj mf jn mg mh mi mj bi translated">私人或受保护的<strong class="is hu">建造者</strong>，</li><li id="5358" class="mb mc ht is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><em class="lz">静态属性</em>通常称为实例，而</li><li id="7605" class="mb mc ht is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj bi translated"><strong class="is hu">公共静态<em class="lz"> getInstance() </em>方法</strong>。</li></ul><p id="96be" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很简单但是很强大。然而，没有金锤。注意不要滥用这个工具。您不希望以面向对象语言中的过程化解决方案结束。</p><h1 id="16b7" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">示例应用程序</h1><p id="f49e" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在一些框架或库中有使用过单例模式的例子吗？是的。让我们回顾一些。</p><h2 id="e8e8" class="lc jp ht bd jq ld le lf ju lg lh li jy jb lj lk kc jf ll lm kg jj ln lo kk lp bi translated">java.util.logging.Logger</h2><p id="f8fb" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">日志记录是在程序执行期间将日志消息写到中心位置的过程。日志允许您记录错误、警告和信息消息。<strong class="is hu"> Logger </strong>对象提供日志功能。例如:</p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="a9b0" class="lc jp ht lr b fi lv lw l lx ly">import java.util.logging.Logger; <br/>public class Example { <br/>  public static void main(String[] args) { <br/>    // Create a Logger with class name Example <br/>    Logger logger = <strong class="lr hu">Logger.getLogger</strong>(Example.class.getName()); <br/>    // Call info method <br/>    logger.info("Hello!"); <br/>    logger.log(Level.<em class="lz">WARNING</em>, "Bye"); <br/>    } <br/>}</span></pre><p id="7271" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">记录器</strong>是单例的，方法<em class="lz"> getLogger() </em>提供了对<strong class="is hu">记录器</strong> <em class="lz"> </em>实例的访问。</p><h2 id="5c61" class="lc jp ht bd jq ld le lf ju lg lh li jy jb lj lk kc jf ll lm kg jj ln lo kk lp bi translated">java.awt.Desktop</h2><p id="3ca1" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><strong class="is hu"> Desktop </strong>类提供对主机默认浏览器、电子邮件客户端和打印机等的访问。<strong class="is hu">桌面</strong>的访问如下例所示:</p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="91c3" class="lc jp ht lr b fi lv lw l lx ly">import java.awt.Desktop; <br/>public class Example { <br/>  public static void main(String[] args) { <br/>    try { <br/>      URI uri = new URI("mscjaviergs.medium.com"); <br/>      Desktop d = <strong class="lr hu">Desktop.getDesktop()</strong>; <br/>      d.browse(uri); <br/>    }. catch (Exception e) { <br/>    }<br/>  } <br/>}</span></pre><p id="5940" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">桌面</strong>是单例的，方法<em class="lz"> getDesktop() </em>提供对<strong class="is hu">桌面</strong> <em class="lz"> </em>实例的访问。</p><p id="2812" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意<em class="lz"> getInstance() </em>是模式模板中的名称，但是可以自定义，比如<em class="lz"> getDesktop() </em>和<em class="lz"> getLogger() </em>。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="c697" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在你有了大局。希望你喜欢阅读。请在下面留下您的评论或问题。</p></div></div>    
</body>
</html>