<html>
<head>
<title>Eager is Easy, Lazy is Labyrinthine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">渴望是容易的，懒惰是迷宫</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/eager-is-easy-lazy-is-labyrinthine-b12605f13048?source=collection_archive---------2-----------------------#2020-04-29">https://medium.com/javarevisited/eager-is-easy-lazy-is-labyrinthine-b12605f13048?source=collection_archive---------2-----------------------#2020-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9732" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从初始化到迭代，学渴望比学懒惰容易。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2544099ffc6f676a242776db0c2794e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9s6rrVRO24P3zDqkiGDwA.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">java.util.*接口和类(黄色)以及带有急切迭代方法的自定义集合接口(青色)</p></figure><h1 id="4a47" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">渴望和懒惰的区别</h1><p id="f4f5" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">eager算法立即执行并返回结果。惰性算法将计算推迟到必须执行时再产生结果。</p><p id="d362" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">急切算法和懒惰算法各有利弊。Eager算法更容易理解和调试。它们也可以针对单个用例进行高度优化(例如<code class="du kw kx ky kz b">filter</code>)。懒惰算法有时导致较少的计算，并且如果在计算中有多个步骤(例如，<code class="du kw kx ky kz b">filter</code>、<code class="du kw kx ky kz b">map</code>、<code class="du kw kx ky kz b">reduce</code>)，将会有较少的临时垃圾被创建。</p><p id="e9b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，我通常更喜欢使用急切算法，当我看到优化的机会时，我更喜欢使用懒惰算法。急切算法和懒惰算法都很有用，所以我总是希望我的工具箱里有这两种算法。</p><p id="723a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个简单的例子，展示了急切初始化和懒惰初始化。</p><h2 id="59c6" class="la ju hi bd jv lb lc ld jz le lf lg kd iq lh li kh iu lj lk kl iy ll lm kp ln bi translated">急切初始化</h2><pre class="je jf jg jh fd lo kz lp lq aw lr bi"><span id="5ffb" class="la ju hi kz b fi ls lt l lu lv">class Someclass<br/>{<br/>    private final List&lt;String&gt; strings = new ArrayList&lt;&gt;();<br/><br/>    public List&lt;String&gt; getStrings()<br/>    {<br/>        return this.strings;<br/>    }<br/>}</span></pre><p id="f8ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在急切的情况下，当<code class="du kw kx ky kz b">SomeClass</code>的实例被创建时，名为<code class="du kw kx ky kz b">strings</code>的<code class="du kw kx ky kz b">List</code>被立即初始化。这允许将变量字符串定义为<code class="du kw kx ky kz b">final</code>，因为它只会在创建类的实例时被初始化。</p><h2 id="8e46" class="la ju hi bd jv lb lc ld jz le lf lg kd iq lh li kh iu lj lk kl iy ll lm kp ln bi translated">惰性初始化</h2><pre class="je jf jg jh fd lo kz lp lq aw lr bi"><span id="4851" class="la ju hi kz b fi ls lt l lu lv">class Someclass<br/>{<br/>    private List&lt;String&gt; strings;<br/><br/>    public List&lt;String&gt; getStrings()<br/>    {<br/>        if (this.strings == null)<br/>        {<br/>            this.strings = new ArrayList&lt;&gt;();<br/>        }<br/>        return this.strings;<br/>    }<br/>}</span></pre><p id="8fdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在惰性情况下，只有当方法<code class="du kw kx ky kz b">getStrings</code>被调用时，名为<code class="du kw kx ky kz b">strings</code>的<code class="du kw kx ky kz b">List</code>才会被初始化。所需的计算将推迟到调用方法时进行。如果从未调用该方法，则从不需要额外的计算。</p><h1 id="9cdb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">懒惰是一项艰苦的工作</h1><p id="3105" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">初始化的急切实现比上面显示的懒惰实现稍微简单一些。在急切迭代和懒惰迭代的情况下，复杂度的差异要明显得多。</p><p id="22c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码示例展示了如何使用急切和懒惰实现将<code class="du kw kx ky kz b">filter</code>应用于集合。惰性实现使用Java流。eager的实现使用了一个概念证明集合框架，它的类型叫做<code class="du kw kx ky kz b">MutableList</code>，如上图所示。<code class="du kw kx ky kz b">MutableList</code>上的<code class="du kw kx ky kz b">filter</code>方法将<code class="du kw kx ky kz b">Predicate</code>应用于列表的每个元素，并返回一个<code class="du kw kx ky kz b">MutableList</code>。POC集合框架的代码链接在这个博客的底部。</p><pre class="je jf jg jh fd lo kz lp lq aw lr bi"><span id="b0d8" class="la ju hi kz b fi ls lt l lu lv">@Test<br/>public void filter()<br/>{<br/>    MutableList&lt;Integer&gt; list = MutableList.<em class="lw">of</em>(1, 2, 3, 4, 5);<br/><br/>    <em class="lw">// eager filter method on MutableList<br/>    </em>MutableList&lt;Integer&gt; eagerFilter = <br/>            list.filter(each -&gt; each % 2 == 0);<br/><br/>    <em class="lw">// lazy filter method on java.util.stream.Stream<br/>    </em>List&lt;Integer&gt; lazyFilter = list.stream()<br/>            .filter(each -&gt; each % 2 == 0)<br/>            .collect(Collectors.<em class="lw">toList</em>());<br/><br/>    var expected = List.<em class="lw">of</em>(2, 4);<br/>    Assert.<em class="lw">assertEquals</em>(expected, eagerFilter);<br/>    Assert.<em class="lw">assertEquals</em>(expected, lazyFilter);<br/>}</span></pre><p id="946f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个例子应该足够容易阅读，并且具有与测试代码所示相同的结果。这两个例子都采用了一个从1到5的整数列表，并对这些整数进行平均，得到一个包含2和4的列表。急切实现只需要一个方法调用(<code class="du kw kx ky kz b">filter</code>)，相比之下，迟缓实现需要四个方法调用(<code class="du kw kx ky kz b">stream</code>、<code class="du kw kx ky kz b">filter</code>、<code class="du kw kx ky kz b">collect</code>、<code class="du kw kx ky kz b">toList</code>)。</p><p id="4c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">真正的复杂性隐藏在这里的实现代码之下，如果我们在<code class="du kw kx ky kz b">Predicate</code>中放置一个断点，就可以在调试期间看到。</p><p id="b057" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将从调试eager <code class="du kw kx ky kz b">filter</code>方法开始。我将在lambda上放置一个断点，测试整数是否为偶数，这会暂停列表中每个整数的执行。</p><h2 id="d74e" class="la ju hi bd jv lb lc ld jz le lf lg kd iq lh li kh iu lj lk kl iy ll lm kp ln bi translated">调试紧急过滤器</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/29a2f82ddcf00974a68ec1be96ec9707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m815AkmgTeN_nd9SCevkXw.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">急切过滤器谓词上的断点</p></figure><p id="b837" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我调试代码时，这是我看到的堆栈跟踪。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ly"><img src="../Images/7cfc2d3360510da51ff3f1249a3a256e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsqEYlATRruY-bSwwXHNzQ.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">Lambda代码位于堆栈跟踪的顶部</p></figure><p id="3ff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我在<code class="du kw kx ky kz b">MutableList</code>上单步执行<code class="du kw kx ky kz b">filter</code>方法，这就是我看到的代码。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/2e4c94b2b7c60fddd8ffbc04cc7ac73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdeX45ZS3xnZalD3V5wSVA.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">在<code class="du kw kx ky kz b">MutableList</code>上调试<code class="du kw kx ky kz b">filter</code>方法的实现</p></figure><p id="f165" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很容易推理，我只有一种方法来理解<code class="du kw kx ky kz b">MutableList</code>上的<code class="du kw kx ky kz b">filter</code>方法如何工作。我可以看到lambda被转换成了一个<code class="du kw kx ky kz b">Predicate</code>并且<code class="du kw kx ky kz b">Predicate</code>接口的<code class="du kw kx ky kz b">test</code>方法在遍历列表的for循环内部的if语句中被调用。</p><h2 id="02ee" class="la ju hi bd jv lb lc ld jz le lf lg kd iq lh li kh iu lj lk kl iy ll lm kp ln bi translated">调试惰性过滤器</h2><p id="05dd" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">现在让我们在<code class="du kw kx ky kz b">Stream</code>上调试<code class="du kw kx ky kz b">lazy</code>过滤方法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ma"><img src="../Images/0c20e08a10b9b1f32a849805d1039bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APwfAlMQMwkFUuHoK56VYg.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">惰性过滤器谓词上的断点</p></figure><p id="2c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我调试代码时，这是我看到的堆栈跟踪。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/e2b299e1786b517407bb4d674fed17d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THMQ8QK2ecViio4JqNSoFA.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">Lambda代码位于堆栈跟踪的顶部</p></figure><p id="d849" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似于我调试eager代码时，lambda代码在堆栈跟踪的顶部。但是，我在堆栈跟踪中没有看到<code class="du kw kx ky kz b">Stream</code>上的<code class="du kw kx ky kz b">filter</code>方法。这是因为<code class="du kw kx ky kz b">filter</code>返回一个新的<code class="du kw kx ky kz b">Stream</code>，但不执行lambda中的代码。执行发生在<code class="du kw kx ky kz b">collect</code>方法中，因为它是一个终端操作。如果我进入<code class="du kw kx ky kz b">collect</code>方法，这就是我所看到的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mc"><img src="../Images/86bfbd6bc820620a9910f2c5dc37ee71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrnlSG11e7B-bzF11vWpqg.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">在<code class="du kw kx ky kz b">Stream</code>上调试<code class="du kw kx ky kz b">collect</code>方法的实现</p></figure><p id="7a7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我想找到遍历列表元素的循环，我需要进入堆栈跟踪中的<code class="du kw kx ky kz b">forEachRemaining</code>方法，该方法在<code class="du kw kx ky kz b">ArrayList</code>类的<code class="du kw kx ky kz b">ArrayListSpliterator</code>中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/8059cb9b1f4f31fcbbfdf048e12e2e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2uC_hPMGM-kbcvIy_c7FQ.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">调试ArrayList中ArrayListSpliterator上的forEachRemaining</p></figure><p id="04ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">懒惰迭代比急切迭代更难理解。您将需要在错综复杂的方法中导航，以遵循Java流的执行路径。希望理解算法如何工作的开发人员很可能会发现，首先理解一个热切的实现会更容易。</p><h1 id="ab70" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">理解事物的顺序</h1><p id="c288" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">如果我们将几个操作堆叠在一起，并使用<code class="du kw kx ky kz b">peek</code>方法输出某个东西的当前值，我们就可以跟踪急切执行和懒惰执行完成事情的顺序。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es me"><img src="../Images/4b878215b752ed189ab6d050ee0fcf8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrDv95d1O6otabJsY3HMqw.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">使用eager和lazy算法跟踪filter、map、reduce的执行顺序</p></figure><h2 id="0a83" class="la ju hi bd jv lb lc ld jz le lf lg kd iq lh li kh iu lj lk kl iy ll lm kp ln bi translated">渴望的输出</h2><p id="366b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><code class="du kw kx ky kz b">filter</code>:1<br/><code class="du kw kx ky kz b">filter</code>:2<br/><code class="du kw kx ky kz b">filter</code>:3<br/><code class="du kw kx ky kz b">filter</code>:4<br/><code class="du kw kx ky kz b">filter</code>:5<br/><code class="du kw kx ky kz b">map</code>:2<br/><code class="du kw kx ky kz b">map</code>:4<br/><code class="du kw kx ky kz b">reduce</code>:2<br/><code class="du kw kx ky kz b">reduce</code>:4</p><h2 id="5a93" class="la ju hi bd jv lb lc ld jz le lf lg kd iq lh li kh iu lj lk kl iy ll lm kp ln bi translated">懒惰的输出</h2><p id="c2ba" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">流<code class="du kw kx ky kz b">filter</code> : 1 <br/>流<code class="du kw kx ky kz b">filter</code> : 2 <br/>流<code class="du kw kx ky kz b">map</code> : 2 <br/>流<code class="du kw kx ky kz b">reduce</code> : 2 <br/>流<code class="du kw kx ky kz b">filter</code> : 3 <br/>流<code class="du kw kx ky kz b">filter</code> : 4 <br/>流<code class="du kw kx ky kz b">map</code> : 4 <br/>流<code class="du kw kx ky kz b">reduce</code> : 4 <br/>流<code class="du kw kx ky kz b">filter</code> : 5</p><p id="74d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，eager的顺序与方法调用的顺序是如何匹配的。接着是<code class="du kw kx ky kz b">filter</code>，接着是<code class="du kw kx ky kz b">map</code>，然后是<code class="du kw kx ky kz b">reduce</code>。在惰性的情况下，方法的顺序是由数据决定的。对于在<code class="du kw kx ky kz b">filter</code>中匹配的每个元素，然后对该元素执行<code class="du kw kx ky kz b">map</code>和<code class="du kw kx ky kz b">reduce</code>。</p><p id="fcc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">急切和懒惰的执行总数在这里是相同的:9。急切方法虽然更容易理解和推理，但它生成两个临时的<code class="du kw kx ky kz b">MutableList</code>实例(一个用于<code class="du kw kx ky kz b">filter</code>，一个用于<code class="du kw kx ky kz b">map</code>)，而懒惰方法不生成任何临时集合。这是一个使用惰性方法可能会提高性能的地方，特别是如果源<code class="du kw kx ky kz b">MutableList</code>很大的话。</p><p id="edba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">lazy真正闪耀的地方是短路可能发生的时候，减少了必要的工作总量。</p><h1 id="ebb1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">了解短路的影响</h1><p id="451a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">如果我们使用类似<code class="du kw kx ky kz b">anyMatch</code>的短路方法，我们可以看到使用惰性迭代的一些真正的潜在性能优势。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/291705815798057c03d27dd31cf4d5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3svWp5YCnVPrkCvVjEa4iA.jpeg"/></div></div></figure><h2 id="7284" class="la ju hi bd jv lb lc ld jz le lf lg kd iq lh li kh iu lj lk kl iy ll lm kp ln bi translated">渴望的输出</h2><p id="bd4b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><code class="du kw kx ky kz b">filter</code>:1<br/><code class="du kw kx ky kz b">filter</code>:2<br/><code class="du kw kx ky kz b">filter</code>:3<br/><code class="du kw kx ky kz b">filter</code>:4<br/><code class="du kw kx ky kz b">filter</code>:5<br/><code class="du kw kx ky kz b">map</code>:2<br/><code class="du kw kx ky kz b">map</code>:4<br/><code class="du kw kx ky kz b">anyMatch</code>:2<br/><code class="du kw kx ky kz b">anyMatch</code>:4</p><h2 id="63b5" class="la ju hi bd jv lb lc ld jz le lf lg kd iq lh li kh iu lj lk kl iy ll lm kp ln bi translated">懒惰的输出</h2><p id="fbf8" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">流<code class="du kw kx ky kz b">filter</code> : 1 <br/>流<code class="du kw kx ky kz b">filter</code> : 2 <br/>流<code class="du kw kx ky kz b">map</code> : 2 <br/>流<code class="du kw kx ky kz b">anyMatch</code> : 2</p><p id="ff62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很好地说明了懒惰迭代的优势。惰性迭代不必访问整个集合。在所有实现和理解的艰苦工作之后，我们可以通过使用懒惰迭代来减少必要的工作总量。</p><h1 id="4b5f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">渴望还是懒惰？为什么不两者都要？</h1><p id="d5be" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">直接在集合接口上实现算法的急切实现以及在流上实现对称的懒惰实现是有意义的。直接在集合上使用eager迭代方法将使代码更容易学习、教授和调试。这降低了开发人员理解迭代模式实现的成本。流上的惰性实现是一个很好的性能优化，并且很容易转移到集合接口上的对称API，如<code class="du kw kx ky kz b">filter</code>、<code class="du kw kx ky kz b">map</code>、<code class="du kw kx ky kz b">reduce</code>等。与所有性能优化一样，lazy的代码可能更难理解和调试。</p><h1 id="9521" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">进一步的信息</h1><p id="f890" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">下面的博客更深入地解释了eager、lazy、serial和parallel，并比较了针对大型数据集的不同算法的性能。</p><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/javarevisited/the-4am-jamestown-scotland-ferry-and-other-optimization-strategies-66365ac415ef"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">凌晨4点詹姆斯敦-苏格兰渡轮和其他优化策略</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">当性能很重要时，了解您的可用选项也很重要。</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx jn mj"/></div></div></a></div><p id="5929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想看我在<a class="ae my" href="https://github.com/BNYMellon/CodeKatas/tree/master/deck-of-cards-kata/src/main/java/bnymellon/codekatas/deckofcards/custom/collections" rel="noopener ugc nofollow" target="_blank">定制收藏</a>中使用的代码，请点击这里查看GitHub回购<a class="ae my" href="https://github.com/BNYMellon/CodeKatas" rel="noopener ugc nofollow" target="_blank">中的卡牌卡塔。</a></p><p id="c9f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想了解更多关于在Java集合中使用eager方法的潜在好处，那么看看下面的博客。</p><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/javarevisited/java-streams-are-great-but-its-time-for-better-java-collections-42d2c04235d1"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">Java流很棒，但现在是更好的Java集合的时候了</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">25年后，Java是时候进行集合升级了。</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mz l mu mv mw ms mx jn mj"/></div></div></a></div><p id="d1f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">祝编程愉快！</p><p id="3523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">我是</em><a class="ae my" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="lw">Eclipse Collections</em></a><em class="lw">OSS项目在</em><a class="ae my" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="lw">Eclipse Foundation</em></a><em class="lw">的项目负责人。</em> <a class="ae my" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="lw">月食收藏</em> </a> <em class="lw">开作</em> <a class="ae my" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="lw">投稿</em> </a> <em class="lw">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div></div>    
</body>
</html>