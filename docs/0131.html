<html>
<head>
<title>Understanding Garbage Collection in java — Java2Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解java中的垃圾收集— Java2Blog</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/understanding-garbage-collection-in-java-java2blog-639bceaa4426?source=collection_archive---------0-----------------------#2019-09-17">https://medium.com/javarevisited/understanding-garbage-collection-in-java-java2blog-639bceaa4426?source=collection_archive---------0-----------------------#2019-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="caf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将会看到在<a class="ae jd" href="https://java2blog.com/core-java-tutorial-for-beginners-experienced/" rel="noopener ugc nofollow" target="_blank"> java </a>中的垃圾收集。</p><p id="e09e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将尝试借助图表和例子而不是理论来解释。</p><p id="55f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://java2blog.com/java-virtual-machine-architecture/" rel="noopener ugc nofollow" target="_blank"> JVM </a>内存分为三部分</p><ul class=""><li id="a121" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">年轻一代</li><li id="a6a4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">老一代</li><li id="56b7" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">元空间(Perm Gen)</li></ul><h1 id="2719" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">年轻一代</h1><p id="7f3b" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">顾名思义，年轻一代是分配新创建的<a class="ae jd" href="https://java2blog.com/object-class-java/" rel="noopener ugc nofollow" target="_blank">对象</a>的区域。</p><ul class=""><li id="6660" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">当年轻一代填满时，会导致较小垃圾收集，也称为较小的GC。</li><li id="42b8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">当小Gcs发生时，死亡对象将从年轻一代中移除。</li><li id="c47b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">如果年轻一代中有很多死对象，那么小规模的GC会执行得更快。</li><li id="1085" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">所有次要GC都是“停止世界”事件，因此当次要GC发生时，应用程序线程也会停止。</li></ul><p id="852b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们更多地了解对象在年轻一代中是如何分配的。</p><p id="dab2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">年轻一代分为三部分。</p><p id="670c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是年轻一代和年老一代的一个例子。</p><figure class="kw kx ky kz fd la er es paragraph-image"><a href="https://javarevisited.blogspot.com/2011/05/java-heap-space-memory-size-jvm.html"><div class="er es kv"><img src="../Images/5dd37d7bcb90d13be050ebfda42ce96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bBDBeUSxpc8nsd4j.png"/></div></a></figure><ul class=""><li id="599a" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">所有新创建的对象都在eden空间中分配。</li><li id="d635" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">当伊甸园空间完全被对象填满时，就会发生小规模的GC。所有未死亡或未被引用的对象将被移动到一个幸存者空间。在我们的例子中，假设所有的物体都被移动到S0。</li></ul><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ld"><img src="../Images/afe17791a4619660272d1794e3b7ca12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*OXjZRfFPJ3309VXf.jpg"/></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ld"><img src="../Images/164f340030a8ddb7943a1f7d6e9d92e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*W9J1eY43WgLY_Kg8.jpg"/></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><a href="https://medium.com/javarevisited/10-free-courses-to-learn-java-in-2019-22d1f33a3915"><div class="er es ld"><img src="../Images/42715dbde8311bb36d58cfb2106863f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*b_cirz_hSKF5SsF-.jpg"/></div></a></figure><figure class="kw kx ky kz fd la er es paragraph-image"><a href="https://www.java67.com/2019/02/top-10-free-algorithms-and-data.html"><div class="er es ld"><img src="../Images/316f2336fd65ffa5086d825875d40e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*smrTXoyPsNX2Dxyq.jpg"/></div></a></figure><p id="0726" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着借助例子来演示这种行为:<br/>你有下面的类，在这个类中我创建了短命的对象来进行演示。</p><p id="435b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你运行程序时。让我们在Visual GC(一个visualVM插件)中检查内存分配</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es kv"><img src="../Images/966e309967fc3e5db119d88b382006bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DOMk4fT0jndmtz13.png"/></div></div></figure><p id="6ba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，S0中的对象很少，一旦eden空间完全填满，所有引用的对象都将被转移到S1。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es kv"><img src="../Images/95a8e0e7890d2cefa5246dd5be281f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EHDXQeBlMQLhNx7E.png"/></div></div></figure><h1 id="f9a1" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">老一代</h1><ul class=""><li id="7c04" class="je jf hi ih b ii kq im kr iq li iu lj iy lk jc jj jk jl jm bi translated">它被用来保存古老的长期保存的物品</li><li id="ce2a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">一般比年轻一代大。</li><li id="0759" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">当占有空间被对象完全填满(或达到预定义的阈值)时，就会发生大规模GC。它将回收内存并释放空间。</li><li id="a91d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">通常，主要GC比次要GC速度更慢，频率更低。</li></ul><p id="b8db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你如何利用这些信息来优化记忆？ <br/>这取决于应用的性质。<br/>如果你有很多临时对象，那么就会有很多小的gc。您可以提供参数XX:NewRatio=1，将50%分配给年轻一代，50%分配给年老一代。<br/>默认情况下，NewRatio=2，因此年轻代是总堆的1/3。<br/>类似地，如果您有太多的长寿命对象，那么您可能需要通过设置较高的NewRatio值来增加使用权空间的大小。</p><h1 id="aa9c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为什么有两个幸存者空间？</h1><p id="3805" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">你一定想知道为什么我们有两个幸存者空间。我们有两个幸存者空间，以避免内存碎片。每次你从伊甸园复制对象到幸存者，你得到一个空的伊甸园空间和一个空的幸存者空间。</p><h1 id="4679" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">垃圾收集算法</h1><p id="43c6" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">JVM为年轻一代和老一代提供了几种算法。有3种算法</p><h1 id="c770" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">串行收集器</h1><p id="5a84" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">它使用一个<a class="ae jd" href="https://dzone.com/articles/top-5-courses-to-learn-java-concurrency-in-2019" rel="noopener ugc nofollow" target="_blank">单线程</a>来执行所有的垃圾收集，适用于单处理器机器的基本应用程序。</p><figure class="kw kx ky kz fd la er es paragraph-image"><a href="https://www.java67.com/2016/08/10-jvm-options-for-java-production-application.html"><div class="er es ll"><img src="../Images/785354ee108db1cfaeaa0b986bc506d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/0*3iAUd645yfy7EaG4.jpg"/></div></a></figure><h1 id="27f9" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">平行收集器</h1><p id="c952" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">它使用多个CPU来执行垃圾收集器。串行收集器使用一个线程来执行垃圾收集，而并行垃圾收集使用几个<a class="ae jd" href="https://javarevisited.blogspot.com/2014/07/top-50-java-multithreading-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank">线程</a>来执行垃圾收集，这在有足够的内存和足够数量的内核时非常有用。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lm"><img src="../Images/b6e74c34db9e2969d7caab8dbba91c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/0*l8H8h3RiDZb9TAdy.jpg"/></div></figure><h1 id="d051" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">并发收集器</h1><p id="df77" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">并发收集器使用应用程序线程执行<a class="ae jd" href="https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html#axzz4zt6jlTWS" rel="noopener ugc nofollow" target="_blank">垃圾收集</a>。这对于具有中型到大型数据集并需要快速响应时间的应用程序非常有用。</p><figure class="kw kx ky kz fd la er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html"><div class="er es ln"><img src="../Images/7c7538d85fb6af5fd163d4d6df49a7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/0*zZ7d-S0NdkwLgxWu.jpg"/></div></a></figure><p id="fc2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以对年轻一代和老一代使用不同的GC算法，但是你只能配对兼容的算法。</p><p id="03b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例如，</strong>您不能将年轻代的并行清除与旧代的并行标记清除配对，因为并行清除不提供CMS中所需的同步。</p><p id="3e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Java 8 之后，垃圾收集器有了很多变化，我会在下一篇文章中介绍它们。</p><p id="d538" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对这篇文章有什么建议，请评论。</p><h2 id="9ac9" class="lo jt hi bd ju lp lq lr jy ls lt lu kc iq lv lw kg iu lx ly kk iy lz ma ko mb bi translated">您可能还喜欢:</h2><ul class=""><li id="a39a" class="je jf hi ih b ii kq im kr iq li iu lj iy lk jc jj jk jl jm bi translated"><a class="ae jd" href="https://www.java67.com/2019/08/best-books-to-learn-java-virtual-machine-in-depth.html" rel="noopener ugc nofollow" target="_blank">学习垃圾收集的书籍</a></li><li id="96db" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html" rel="noopener ugc nofollow" target="_blank">学习JVM内部的课程</a></li><li id="e0fb" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://java2blog.com/java-multithreading-interview-questions-and-answers/" rel="noopener ugc nofollow" target="_blank"> Java多线程面试问题</a>。</li><li id="472a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://java2blog.com/java-interview-questions/" rel="noopener ugc nofollow" target="_blank"> Java面试问题</a></li><li id="57d0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://java2blog.com/java-interview-questions-for-5-years-experience/" rel="noopener ugc nofollow" target="_blank">5年经验Java面试问题</a></li><li id="6fe1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://java2blog.com/java-collections-interview-questions/" rel="noopener ugc nofollow" target="_blank"> Java集合面试问题</a></li><li id="286d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://java2blog.com/java-thread-example/" rel="noopener ugc nofollow" target="_blank"> Java线程示例</a></li><li id="89b0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://hackernoon.com/20-string-coding-interview-questions-for-programmers-6b6735b6d31c" rel="noopener ugc nofollow" target="_blank">字符串编码面试问题</a></li></ul></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><div class="kw kx ky kz fd mj"><a rel="noopener follow" target="_blank" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">面向初学者的10大Java在线课程</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">如果你是计算机科学专业的毕业生，或者想学习Java并且正在寻找一些很棒的资源，比如…</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx lb mj"/></div></div></a></div></div></div>    
</body>
</html>