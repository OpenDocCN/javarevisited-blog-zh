<html>
<head>
<title>Kafka Partitions and Consumer Groups in 6 mins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6分钟内卡夫卡分区和消费群</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/kafka-partitions-and-consumer-groups-in-6-mins-9e0e336c6c00?source=collection_archive---------0-----------------------#2022-02-28">https://medium.com/javarevisited/kafka-partitions-and-consumer-groups-in-6-mins-9e0e336c6c00?source=collection_archive---------0-----------------------#2022-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5b0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我之前的文章中，我们已经讨论了卡夫卡是如何工作的，并且浏览了一些基本的卡夫卡术语。在本文中，我们将回顾一下<a class="ae jd" rel="noopener" href="/javarevisited/top-10-apache-kafka-online-training-courses-and-certifications-621f3c13b38c"> <strong class="ih hj">【卡夫卡】</strong> </a>中的分区和消费群是如何工作的。</p><p id="8c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你没有读过我的前一篇文章，或者你不熟悉卡夫卡，我建议你读一读，因为它会帮助你对卡夫卡的作品有一个基本的了解。</p><h1 id="386f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">那么，什么是隔断呢？</h1><p id="1b53" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在谈论分区之前，我们需要理解什么是主题。在Kafka中，主题基本上是一个存储单元，生产者发送的所有消息都存储在这个存储单元中。通常，相似的数据存储在单独的主题中。例如，您可以有一个名为“用户”的主题，其中仅存储用户的详细信息，或者您可以有一个名为“付款”的主题，其中仅存储所有与付款相关的详细信息。一个主题可以进一步细分为多个存储单元，主题的这些细分称为<strong class="ih hj">分区</strong>。</p><p id="fe18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，创建的主题只有一个分区，发布到该主题的任何消息都存储在该分区中。如果您将一个主题配置为具有多个分区，那么生产者发送的消息将存储在这些分区中，这样就不会有两个分区具有相同的消息/事件。</p><p id="8aba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个主题中的所有分区也有它们自己的<strong class="ih hj">偏移量</strong>(如果你不知道什么是偏移量，我推荐你查看我讨论过的<a class="ae jd" rel="noopener" href="/@ahmedgulabkhan/a-basic-introduction-to-kafka-a7d10a7776e6">这篇文章</a></p><p id="1aee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，一个生产者向一个包含3个分区的Kafka主题发送消息，如下所示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/04/top-5-apache-kafka-course-to-learn.html"><div class="er es kh"><img src="../Images/5956cb6c539afaffdb5cbde3a0ae114e.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*9Qm9qjZbvfV0X1pAlUUxcw.png"/></div></a></figure><h1 id="e08d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">那么，什么是消费群体呢？</h1><p id="2c5d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">一群消费者可以组成一个组，以便合作和消费来自一组主题的消息。这个消费者分组被称为<strong class="ih hj">消费者组</strong>。如果两个消费者订阅了同一个主题，并且出现在同一个消费者组中，那么这两个消费者将被分配不同的分区集，并且这两个消费者都不会接收到相同的消息。</p><p id="e13c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kp">注意:如果多个消费者从同一个主题消费，消费群可以帮助获得更高的消费率。</em></p><p id="1250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们通过几个场景来更好地理解上述概念</p><p id="838f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">场景1 </strong>:假设我们有一个主题，有4个分区和一个消费者组，其中只有一个消费者。消费者已经订阅了主题1，并被分配使用所有分区中的内容。下图描述了这种情况:</p><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/06/java-lock-and-condition-example-producer-consumer.html#axzz7CGC6wxzA"><div class="er es kq"><img src="../Images/9c4ea77c0e105a37db586dae385cef2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPGKO_Z-rKbM00dJd0QV7w.png"/></div></a></figure><p id="6542" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">场景2 </strong>:现在让我们考虑一下我们的消费群体中有两个消费者。这两个消费者将被分配从不同的分区读取数据—消费者1被分配从分区0、2读取数据；和被分配从分区1、3读取的消费者2。</p><p id="05bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kp">注:卡夫卡将一个主题的分区分配给一个消费群中的消费者，这样每个分区正好被消费群中的一个消费者消费。Kafka保证一条消息只被消费者群体中的一个消费者阅读。</em></p><p id="3dc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于存储在同一主题的各个分区中的消息是不同的，所以两个使用者永远不会读取同一条消息，从而避免了在使用者端多次使用相同的消息。下图描述了这种情况:</p><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://www.java67.com/2018/05/top-5-free-big-data-courses-to-learn-Hadoop-Apache-Spark.html"><div class="er es kq"><img src="../Images/9d6b61e6cd3fcdbbef011d99ebf8d29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTRQR9H_Glv1xbPWl_yY6w.png"/></div></a></figure><p id="795c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">但是，如果一个消费群中的消费者数量多于分区数量呢？查看场景3 </strong></p><p id="22d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">场景3 </strong>:假设消费者组中有5个消费者，多于主题1的分区数量，那么每个消费者将被分配一个分区，剩下的消费者(消费者5)将被闲置。下图描述了这种情况:</p><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://dzone.com/articles/5-courses-to-learn-apache-kafka-in-2019"><div class="er es kq"><img src="../Images/3a2254c70200aa2d50331162da8f034f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INW2vHXkN7v47-WvrgbhbA.png"/></div></a></figure><p id="d71f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">好吧，那么如果您希望多个消费者从同一个分区读取数据呢？查看场景4 </strong></p><p id="e182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">场景4 </strong>:如果您想要分配多个消费者从同一个分区中读取数据，那么您可以将这些消费者添加到不同的消费者组中，并让这两个消费者组都订阅主题1。这里，来自TopicT1的Partition0的消息由ConsumerGroup1的Consumer1和ConsumerGroup2的Consumer1读取。下图描述了这种情况:</p><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://dev.to/javinpaul/5-best-courses-to-learn-apache-kafka-in-2020-584h"><div class="er es kq"><img src="../Images/09ef1eb324f9f58db4c8288d3b2d4d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uH_krFrkQgJYpHYjKXLyJw.png"/></div></a></figure><h2 id="66e2" class="kr jf hi bd jg ks kt ku jk kv kw kx jo iq ky kz js iu la lb jw iy lc ld ka le bi translated">所有这些似乎都没问题，但是什么时候应该将消费者添加到同一个消费者组，什么时候应该将消费者添加到不同的消费者组呢？</h2><ul class=""><li id="1ac3" class="lf lg hi ih b ii kc im kd iq lh iu li iy lj jc lk ll lm ln bi translated">如果您的目标是获得更高的吞吐量或增加特定主题的消耗率，那么在同一个消费者组中添加多个消费者将是一个不错的选择。在一个使用者组中，最多可以有与一个主题的分区数量相等的使用者，添加的使用者多于分区数量会导致额外的使用者保持空闲，因为Kafka认为不能将两个分区分配给一个使用者组中的使用者。当从一个主题中消费的消费者的数量等于该主题中分区的数量时，每个消费者将从单个主题中读取消息，并且消息消费将并行发生，从而增加了消费率。</li><li id="4907" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">但是，如果您有一个用例，您希望多个消费者使用一个主题的相同消息，那么让多个消费者组订阅该主题，并根据您的需求将消费者添加到这些消费者组中，这将是您可以利用的。</li></ul><h1 id="5df3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">一些常见的问答:</h1><p id="6a8b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">问:在卡夫卡那里，有一个消费群体是强制性的吗？</p><p id="3a9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.是的，强制规定卡夫卡哪个消费者属于哪个消费群体。如果您没有在应用程序中设置消费者组id，将会出现异常。如果您使用Kafka CLI命令启动一个消费者来消费某个主题，则会创建一个名为<strong class="ih hj">console-consumer-&lt;some _ random _ number&gt;</strong>的新随机消费者组，该消费者会自动归入该消费者组。</p><p id="18e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:如果一个新用户加入了一个用户组，如何将分区分配给这个新用户？</p><p id="c984" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.假设我们有一个包含3个分区的主题；以及由2个消费者组成的1个消费者组。在这3个分区中，2个将被分配给一个用户，剩余的分区将被分配给另一个用户。现在，考虑这两种情况</p><ul class=""><li id="1b82" class="lf lg hi ih b ii ij im in iq lt iu lu iy lv jc lk ll lm ln bi translated"><strong class="ih hj">案例1 </strong>:如果一个新的消费者加入消费者组，<strong class="ih hj">重新平衡</strong>发生，每个消费者现在被分配到一个单独的分区(因为我们有相同数量的分区和消费者)。</li><li id="017d" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><strong class="ih hj">情况2 </strong>:如果一个消费者停止使用，那么消费者组中只剩下一个消费者，所有分区都将通过重新平衡分配给这个消费者。</li></ul><p id="e3de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:卡夫卡的再平衡是什么？</p><p id="a13c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.<strong class="ih hj">重新平衡</strong>是在给定消费者组内的消费者之间重新分配分区所有权，从而为消费者组中的每个消费者分配一个或多个分区。重新平衡发生在以下情况:</p><ul class=""><li id="3cee" class="lf lg hi ih b ii ij im in iq lt iu lu iy lv jc lk ll lm ln bi translated">一个新的消费者加入了消费者群体</li><li id="a7bd" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">一个现有的消费者倒下了</li><li id="90b6" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">添加了新的分区</li><li id="3235" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">现有消费者被<strong class="ih hj">组协调人</strong>视为死亡</li></ul><p id="7386" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:什么是团队协调员？</p><p id="b8ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.组协调器是一个kafka代理，它接收来自一个消费者组的所有消费者的心跳。每个消费者团体都有一个团体协调员。</p><p id="ebe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:什么是团队领导？</p><p id="8265" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.第一个加入消费者团体的消费者被称为该消费者团体的团体领导者</p><p id="ff40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:我们可以减少一个主题中的分区数量吗？</p><p id="371a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">A.Apache Kafka不支持减少主题的划分。因为，发送到一个主题的所有数据都被发送到所有分区，删除其中一个分区就意味着数据丢失。</p><p id="1cc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以浏览该系列中更多的卡夫卡文章:</p><ol class=""><li id="d855" class="lf lg hi ih b ii ij im in iq lt iu lu iy lv jc lw ll lm ln bi translated">阿帕奇卡夫卡:基础介绍</li><li id="a245" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lw ll lm ln bi translated"><a class="ae jd" rel="noopener" href="/@ahmedgulabkhan/3-simple-steps-to-set-up-kafka-locally-using-docker-b07f71f0e2c9">使用Docker在本地设置Kafka的3个简单步骤</a></li></ol><p id="8d43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kp">关注卡夫卡系列的下一篇博客。我也将发布更多关于软件工程概念的文章。</em></p><p id="1a02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">你也可以在<br/></strong><a class="ae jd" href="https://github.com/ahmedgulabkhan" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/><a class="ae jd" href="https://dev.to/ahmedgulabkhan" rel="noopener ugc nofollow" target="_blank">dev . to</a>上找到我</p></div></div>    
</body>
</html>