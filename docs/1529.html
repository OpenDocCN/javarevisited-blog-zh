<html>
<head>
<title>When constructors aren’t doing it for you, use a Builder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当构造函数不为你做的时候，使用构造函数</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/when-constructors-arent-doing-it-for-you-use-a-builder-11559fa41e39?source=collection_archive---------1-----------------------#2021-09-04">https://medium.com/javarevisited/when-constructors-arent-doing-it-for-you-use-a-builder-11559fa41e39?source=collection_archive---------1-----------------------#2021-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a795" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我相信是在2016年左右，我第一次读《有效的Java》这本书的时候，我就被吸引住了[1]。它也是我读的第一批编程书籍之一，从那以后，我再也没有找到一本像它那样有价值的书。在这篇文章中，我想谈谈书中的一个技巧，我发现它非常有用。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/1e7b6eb57353768f23380c84e25e563e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jZegOe8Xl2XpBtMn"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">由<a class="ae jd" href="https://unsplash.com/@toluobde?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托卢·奥卢博德</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="dd9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；当你觉得需要创建多个或长构造函数时，考虑使用<a class="ae jd" href="http://javarevisited.blogspot.sg/2012/06/builder-design-pattern-in-java-example.html" rel="noopener ugc nofollow" target="_blank">构建器模式</a>。它将简化你的代码，增加可读性，并允许不变性。</strong></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="2aec" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">什么时候用？</h2><p id="7fb8" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">如果您需要创建一个具有许多可能的参数、组合等的对象，那么这种模式非常有用。请继续阅读，了解它是如何工作的。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="5279" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">基本想法</h2><p id="1412" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">假设我们想要模拟一个<strong class="ih hj">纳税申报表</strong>。想想我们在这里可以有多少个字段。最直接的方法是创建一个构造函数，见下面的例子。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">不使用构建器的IncomeTaxReturn.java。</p></figure><p id="36db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这里我们有一个长构造函数，当实例化时，很难阅读和理解哪个参数对应什么值。如果我们以后想要添加一个新的字段，这也是有问题的。或者我们想模拟不同的组合。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ld"><img src="../Images/85ed22f36f7fe68c735963867a351f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*Ut1b3xHrB_KcD1aFtJSmZA.jpeg"/></div></figure><p id="ff4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然还有其他方法可以做到这一点，可能使用多个构造函数，或者setters，或者容器对象。但是让我向您展示如何使用<strong class="ih hj">构建器</strong>来实现这一点。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="adcc" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">确定必填字段</h2><p id="d3e5" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">关于这个例子，我们可以注意到的一点是，大多数人可能只需要指定劳动收入和他们的年龄。因此，假设这两个字段是必需的，其余的是可选的。这意味着我们希望在构造函数中输入劳动收入和一个人的年龄，但是其他字段应该在之后指定。</p><h2 id="595c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">不变性增益</h2><p id="d0cd" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">现在，我们不想使用setters，为什么？因为这意味着我们可能有尚未完全构造(语义上)的对象，例如当涉及到<a class="ae jd" rel="noopener" href="/javarevisited/6-multithreading-and-concurrency-books-every-java-programmer-should-read-b6a08d2aae54">多线程</a>时这是有问题的。因此，我们希望对我们的纳税申报单实施<em class="le">不变性</em>。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="7479" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">使用构建器模式</h2><p id="2515" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">这种情况下的构建器看起来像这样。</p><p id="b779" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简洁起见，我删除了一些字段，但请记住，我们在这里解决的问题如上所述。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">使用生成器模式的IncomeTaxReturn.java。</p></figure><p id="4671" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于这个例子，你能注意到什么？</p><ul class=""><li id="51f1" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">纳税申报表只有最终字段，其中的可选值已在构建器中指定。</li><li id="1b5b" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">创建任何类型的复杂报税组合都非常容易。</li><li id="ad16" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">我们还可以在不影响当前用户的情况下添加新的字段。</li><li id="1d18" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">由于有一个私有构造函数，不使用构建器就无法创建纳税申报单。</li></ul><p id="47f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也使得代码易于阅读，因为所有的特殊字段现在都有了名称。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">用法示例。</p></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="3fe0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我考虑过在这里结束这篇文章，但是决定稍微谈一谈另一个简单但是非常强大的技术。</p><h2 id="13aa" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">静态工厂方法</h2><p id="4dbf" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">如前所述，构造函数有一些缺点，比如没有名字。使用<a class="ae jd" href="http://javarevisited.blogspot.sg/2017/02/5-difference-between-constructor-and-factory-method-in-java.html#axzz4tUeeQOAU" rel="noopener ugc nofollow" target="_blank"> <em class="le">静态工厂方法</em> </a>我们可以解决这个问题，使我们的代码更具可读性。</p><p id="3320" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设大多数人只需要报告他们的劳动收入和年龄，我们可以使用静态工厂来帮助，如下例所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="http://javarevisited.blogspot.sg/2017/02/5-difference-between-constructor-and-factory-method-in-java.html#axzz4tUeeQOAU"><div class="er es lt"><img src="../Images/69ea1ba2e239e2e97c12b3cdb4791e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XN5XBnhaPgihFq7Nd0mxcg.png"/></div></a><p class="jq jr et er es js jt bd b be z dx translated">静态工厂方法示例。</p></figure><p id="0b39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很不自然，但是很有用，因为它允许本质上命名一个构造函数。它还允许你用相同的类型参数拥有<a class="ae jd" href="https://javarevisited.blogspot.com/2012/12/what-is-constructor-in-java-example-chainning-overloading.html" rel="noopener ugc nofollow" target="_blank">多个构造函数。换句话说，下面的例子不能编译。</a></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">无法编译的虚拟示例。</p></figure><p id="18b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这个会。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">静态工厂方法的虚拟示例。</p></figure><p id="cf91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以反复返回同一个实例或者一个子类。我相信它们比构造函数更灵活，然而，由于它们是一个方法，在代码中可能不容易找到，所以在命名它们时要考虑这一点。</p><p id="ec45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><p id="0283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[1]有效Java作者约书亚·布洛赫<br/><a class="ae jd" href="https://www.oreilly.com/library/view/effective-java/9780134686097/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/Effective-Java/9780134686097/</a></p></div></div>    
</body>
</html>