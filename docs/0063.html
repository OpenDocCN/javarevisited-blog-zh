<html>
<head>
<title>How HashMap works internally in Java: A debug approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HashMap 如何在 Java 内部工作:一种调试方法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/how-hashmap-works-internally-in-java-a-debug-approach-286c9f3945b2?source=collection_archive---------0-----------------------#2019-05-03">https://medium.com/javarevisited/how-hashmap-works-internally-in-java-a-debug-approach-286c9f3945b2?source=collection_archive---------0-----------------------#2019-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5769" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">学习 Java 中 HashMap 如何工作的有趣方法</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/53e9efc7f5cb54b24d8504efd073aec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWBMy4bzQWCsHFo2X8xcIQ.jpeg"/></div></div></figure><p id="19fb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最常见的面试问题是“HashMap 如何在<a class="ae kf" href="https://java2blog.com/core-java-tutorial-for-beginners-experienced/" rel="noopener ugc nofollow" target="_blank"> Java </a>中工作”、“如何在内部获取和放置<a class="ae kf" href="https://java2blog.com/hashmap-in-java-with-examples/" rel="noopener ugc nofollow" target="_blank"> HashMap </a>工作的方法”。在这里，我试图用一个简单的例子来解释内部功能。</p><p id="c7a2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">HashMap 是 java 中使用最多的<a class="ae kf" href="https://java2blog.com/collections-java/" rel="noopener ugc nofollow" target="_blank">集合之一。我们先从一个例子开始，而不是从理论开始，这样你会有更好的理解，然后我们会看到</a><a class="ae kf" href="http://www.java67.com/2013/06/how-get-method-of-hashmap-or-hashtable-works-internally.html" rel="noopener ugc nofollow" target="_blank">如何在 java </a>中获取和放置函数。</p><p id="a1f7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们举一个很简单的例子。我有一个<code class="du kg kh ki kj b">Country </code>类，我们将使用 Country 类对象作为键，它的大写名称(字符串)作为值。下面的例子将帮助你理解，这些键值对将如何存储在 hashmap 中。</p><h1 id="2443" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak"> 1。Country.java</strong></h1><pre class="iy iz ja jb fd lc kj ld le aw lf bi"><span id="code" class="lg kl hi kj b fi lh li l lj lk">package org.arpit.java2blog;<br/>public class Country {</span><span id="738e" class="lg kl hi kj b fi ll li l lj lk">String name;<br/>	long population;</span><span id="3030" class="lg kl hi kj b fi ll li l lj lk">public Country(String name, long population) {<br/>		super();<br/>		this.name = name;<br/>		this.population = population;<br/>	}<br/>	public String getName() {<br/>		return name;<br/>	}<br/>	public void setName(String name) {<br/>		this.name = name;<br/>	}<br/>	public long getPopulation() {<br/>		return population;<br/>	}<br/>	public void setPopulation(long population) {<br/>		this.population = population;<br/>	}</span><span id="6d3c" class="lg kl hi kj b fi ll li l lj lk">// If length of name in country object is even then return 31(any random number) and if odd then return 95(any random number).<br/>	// This is not a good practice to generate hashcode as below method but I am doing so to give better and easy understanding of hashmap.<br/>	@Override<br/>	public int hashCode() {<br/>		if(this.name.length()%2==0)<br/>			return 31;<br/>		else <br/>			return 95;<br/>	}<br/>	@Override<br/>	public boolean equals(Object obj) {</span><span id="2571" class="lg kl hi kj b fi ll li l lj lk">Country other = (Country) obj;<br/>		if (name.equalsIgnoreCase((other.name)))<br/>			return true;<br/>		return false;<br/>	}</span><span id="75e7" class="lg kl hi kj b fi ll li l lj lk">}</span></pre><p id="2753" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果想进一步了解对象的 hashcode 和 equals 方法，可以参考 java  中的<strong class="jl hj"> </strong> <a class="ae kf" href="http://www.java2blog.com/2014/02/hashcode-and-equals-method-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj"> hashcode()和 equals()方法</strong></a></p><h1 id="288d" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak"> 2。HashMapStructure.java</strong>(主班)</h1><pre class="iy iz ja jb fd lc kj ld le aw lf bi"><span id="71ec" class="lg kl hi kj b fi lh li l lj lk">import java.util.HashMap;<br/>import java.util.Iterator;</span><span id="9cfc" class="lg kl hi kj b fi ll li l lj lk">public class HashMapStructure {</span><span id="f92e" class="lg kl hi kj b fi ll li l lj lk">/**<br/>	 * @author Arpit Mandliya<br/>	 */<br/>	public static void main(String[] args) {</span><span id="a828" class="lg kl hi kj b fi ll li l lj lk">Country india=new Country("India",1000);<br/>		Country japan=new Country("Japan",10000);</span><span id="21e6" class="lg kl hi kj b fi ll li l lj lk">Country france=new Country("France",2000);<br/>		Country russia=new Country("Russia",20000);</span><span id="6564" class="lg kl hi kj b fi ll li l lj lk">HashMap&lt;Country, String&gt; countryCapitalMap=new HashMap&lt;Country,String&gt;();  <br/>		countryCapitalMap.put(india,"Delhi");  <br/>		countryCapitalMap.put(japan,"Tokyo");  <br/>		countryCapitalMap.put(france,"Paris");  <br/>		countryCapitalMap.put(russia,"Moscow");</span><span id="a6a7" class="lg kl hi kj b fi ll li l lj lk">Iterator countryCapitalIter=countryCapitalMap.keySet().iterator();//put debug point at this line  <br/>		while(countryCapitalIter.hasNext())  <br/>		{  <br/>			Country countryObj=countryCapitalIter.next();  <br/>			String capital=countryCapitalMap.get(countryObj);  <br/>			System.out.println(countryObj.getName()+"----"+capital);  <br/>		}  <br/>	}</span><span id="8bd5" class="lg kl hi kj b fi ll li l lj lk">}</span></pre><p id="24bf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在在第 24 行放置一个<a class="ae kf" href="http://www.java67.com/2018/01/how-to-remote-debug-java-application-in-Eclipse.html" rel="noopener ugc nofollow" target="_blank">断点</a>并右击<code class="du kg kh ki kj b">project-&gt;debug as-&gt; java application</code>。程序将在第 24 行停止执行，然后右键单击<code class="du kg kh ki kj b">countryCapitalMap </code>,然后选择一块手表。您将能够看到如下结构。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/53e9efc7f5cb54b24d8504efd073aec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWBMy4bzQWCsHFo2X8xcIQ.jpeg"/></div></div></figure><p id="d58d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从上图中，你可以观察到以下几点</p><ol class=""><li id="8226" class="lm ln hi jl b jm jn jp jq js lo jw lp ka lq ke lr ls lt lu bi translated">有一个名为 table 的<code class="du kg kh ki kj b">Entry[]</code>数组，大小为 16。</li><li id="864c" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated">此表存储入口类的对象。HashMap 类有一个内部类叫做 Entry。该条目具有作为实例变量的键值。让我们看看入口类入口结构的结构。</li></ol><pre class="iy iz ja jb fd lc kj ld le aw lf bi"><span id="fa29" class="lg kl hi kj b fi lh li l lj lk">static class Entry implements Map.Entry<br/>{<br/>        final K key;<br/>        V value;<br/>        Entry next;<br/>        final int hash;<br/>        ...//More code goes here<br/>}</span></pre><ol class=""><li id="12ca" class="lm ln hi jl b jm jn jp jq js lo jw lp ka lq ke lr ls lt lu bi translated">每当我们试图将任何键-值对放入 hashmap 时，Entry 类对象被实例化为键值，该对象将被存储在上述 Entry[](table)中。现在您一定想知道，上面创建的条目对象将存储在哪里(表中的确切位置)。答案是，通过调用<a class="ae kf" href="https://javarevisited.blogspot.com/2011/02/how-to-write-equals-method-in-java.html" rel="noopener ugc nofollow" target="_blank"> hashcode() </a>方法为一个键计算出<a class="ae kf" href="http://javarevisited.blogspot.sg/2013/08/10-equals-and-hashcode-interview.html" rel="noopener ugc nofollow" target="_blank">哈希码</a>。这个 hashcode 用于计算上面 Entry[]表的索引。</li><li id="dbe8" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated">现在，如果您在上图中看到数组索引 10，它有一个名为<code class="du kg kh ki kj b">HashMap$Entry</code>的条目对象。</li><li id="a1c1" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated">我们在 hashmap 中放了 4 个键值，但它似乎只有 2 个！！！！这是因为如果两个对象有相同的 hashcode，它们将被存储在相同的索引中。现在的问题是如何做到的？它以 LinkedList 的形式存储对象(逻辑上)。</li></ol><p id="08d6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么上述国家键值对的 hashcode 是如何计算的呢？</p><pre class="iy iz ja jb fd lc kj ld le aw lf bi"><span id="6755" class="lg kl hi kj b fi lh li l lj lk">Hashcode for Japan = 95 as its length is odd.<br/>Hashcode for India =95 as its length is odd<br/>HashCode for Russia=31 as its length is even.<br/>HashCode for France=31 as its length is even.</span></pre><p id="cd4f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下图将清楚地解释<a class="ae kf" href="https://javarevisited.blogspot.com/2017/07/top-10-linked-list-coding-questions-and.html" rel="noopener ugc nofollow" target="_blank">链表</a>的概念。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/e7e2791a9911d6378783c6dc7423aa4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_XqWVRvHz8olljDfszJ8w.jpeg"/></div></div></figure><p id="a852" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以现在如果你对<a class="ae kf" href="http://www.java67.com/2013/08/ata-structures-in-java-programming-array-linked-list-map-set-stack-queue.html" rel="noopener ugc nofollow" target="_blank">哈希表数据结构</a>有了很好的理解，让我们来看看吞吐量和 get 方法。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><h1 id="3f01" class="kk kl hi bd km kn mi kp kq kr mj kt ku io mk ip kw ir ml is ky iu mm iv la lb bi translated">放</h1><p id="c9f2" class="pw-post-body-paragraph jj jk hi jl b jm mn ij jo jp mo im jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">让我们看看 put 方法的实现:</p><pre class="iy iz ja jb fd lc kj ld le aw lf bi"><span id="8c2f" class="lg kl hi kj b fi lh li l lj lk">/**<br/>		 * Associates the specified value with the specified key in this map. If the<br/>		 * map previously contained a mapping for the key, the old value is<br/>		 * replaced.<br/>		 *<br/>		 * @param key<br/>		 *            key with which the specified value is to be associated<br/>		 * @param value<br/>		 *            value to be associated with the specified key<br/>		 * @return the previous value associated with key, or null<br/>		 *         if there was no mapping for key. (A null return<br/>		 *         can also indicate that the map previously associated<br/>		 *         null with key.)<br/>		 */<br/>		public V put(K key, V value) {<br/>			if (key == null)<br/>				return putForNullKey(value);<br/>			int hash = hash(key.hashCode());<br/>			int i = indexFor(hash, table.length);<br/>			for (Entry e = table[i]; e != null; e = e.next) {<br/>				Object k;<br/>				if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {<br/>					V oldValue = e.value;<br/>					e.value = value;<br/>					e.recordAccess(this);<br/>					return oldValue;<br/>				}<br/>			}</span><span id="3c03" class="lg kl hi kj b fi ll li l lj lk">modCount++;<br/>			addEntry(hash, key, value, i);<br/>			return null;<br/>		}</span></pre><p id="ef88" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们一步步理解上面的代码</p><ol class=""><li id="7100" class="lm ln hi jl b jm jn jp jq js lo jw lp ka lq ke lr ls lt lu bi translated">检查关键字对象的<a class="ae kf" href="https://javarevisited.blogspot.com/2014/12/9-things-about-null-in-java.html" rel="noopener ugc nofollow" target="_blank">是否为空</a>。如果一个键为 null，那么它将被存储在表[0]中，因为 null 的 hashcode 总是 0。</li><li id="5d04" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated">调用 Key 对象的 hashcode()方法并计算散列码。这个 hashcode 用于查找存储条目对象的数组的索引。有时可能会发生这样的情况，这个 hashcode 函数写得很差，所以 JDK 设计者放了另一个名为 hash()的函数，它将上面计算的哈希值作为参数。如果想进一步了解 hash()函数，可以参考 hashmap 中的<a class="ae kf" href="http://www.java2blog.com/2014/02/hash-and-indexfor-method-in-hashmap.html" rel="noopener ugc nofollow" target="_blank"> hash and indexFor 方法。</a></li><li id="51bb" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated"><code class="du kg kh ki kj b">indexFor(hash, table.length)</code>用于计算存储条目对象的表数组中的精确索引。</li><li id="fac1" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated">正如我们在例子中看到的，如果两个关键对象有相同的 hashcode(这被称为<strong class="jl hj">冲突</strong>)，那么它将以链表的形式存储。所以在这里，我们将遍历链表。</li></ol><ul class=""><li id="c3ac" class="lm ln hi jl b jm jn jp jq js lo jw lp ka lq ke ms ls lt lu bi translated">如果在我们刚刚计算的那个索引中没有元素，那么它将直接把我们的入口对象放在那个索引中。</li><li id="9a07" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">如果该索引中存在元素，那么它将进行迭代，直到得到 Entry-&gt;next 为 null。</li><li id="4e22" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">如果我们再次输入相同的键，逻辑上它应该替换旧值。是的，它会这样做。迭代时，它将通过调用<a class="ae kf" href="https://javarevisited.blogspot.com/2012/12/difference-between-equals-method-and-equality-operator-java.html#axzz5Y4Kd7uK1" rel="noopener ugc nofollow" target="_blank"> equals() </a>方法(<strong class="jl hj"> key.equals(k) </strong>)来检查键的相等性，如果该方法返回 true，那么它将使用当前条目的值对象替换值对象。</li><li id="b2d1" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">如果它没有找到重复的键，那么当前条目对象将成为链表中的第一个节点，当前条目-&gt;下一个将成为该索引中现有的第一个节点。</li></ul></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><h1 id="5d0e" class="kk kl hi bd km kn mi kp kq kr mj kt ku io mk ip kw ir ml is ky iu mm iv la lb bi translated">得到</h1><p id="80df" class="pw-post-body-paragraph jj jk hi jl b jm mn ij jo jp mo im jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">让我们看看 get now 的实现:</p><pre class="iy iz ja jb fd lc kj ld le aw lf bi"><span id="fb8d" class="lg kl hi kj b fi lh li l lj lk">/**<br/>	 * Returns the value to which the specified key is mapped, or {@code null}<br/>	 * if this map contains no mapping for the key.<br/>	 *<br/>	 *<br/>	 * More formally, if this map contains a mapping from a key {@code k} to a<br/>	 * value {@code v} such that {@code (key==null ? k==null :<br/>	 * key.equals(k))}, then this method returns {@code v}; otherwise it returns<br/>	 * {@code null}. (There can be at most one such mapping.)<br/>	 *<br/>	 *<br/>	 * A return value of {@code null} does not <em class="mt">necessarily</em> indicate that<br/>	 * the map contains no mapping for the key; it's also possible that the map<br/>	 * explicitly maps the key to {@code null}. The {@link #containsKey<br/>	 * containsKey} operation may be used to distinguish these two cases.<br/>	 *<br/>	 * @see #put(Object, Object)<br/>	 */<br/>	public V get(Object key) {<br/>		if (key == null)<br/>			return getForNullKey();<br/>		int hash = hash(key.hashCode());<br/>		for (Entry e = table[indexFor(hash, table.length)]; e != null; e = e.next) {<br/>			Object k;<br/>			if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))<br/>				return e.value;<br/>		}<br/>		return null;<br/>	}</span></pre><p id="812c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">随着您对 hashmap 的 put 功能的理解。因此，理解 get 功能非常简单。如果你向<a class="ae kf" href="https://javarevisited.blogspot.com/2011/02/how-hashmap-works-in-java.html#axzz4sZOoYUxv" rel="noopener ugc nofollow" target="_blank">传递任何键，从 hashmap </a>中获取值对象。</p><ol class=""><li id="ccba" class="lm ln hi jl b jm jn jp jq js lo jw lp ka lq ke lr ls lt lu bi translated">检查密钥对象是否为空。如果键为空，那么将返回驻留在表[0]中的对象的值。</li><li id="9b6c" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated">调用 Key 对象的 hashcode()方法并计算散列码。</li><li id="338d" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated">indexFor(hash，table.length)用于使用生成的 hashcode 计算表数组中的精确索引，以获取条目对象。</li><li id="ce26" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated">在<a class="ae kf" href="http://www.java67.com/2015/07/array-concepts-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank">表数组</a>中获取索引后，它将遍历链表，并通过调用 equals()方法检查键是否相等，如果返回 true，则返回 Entry 对象的值，否则返回 null。</li></ol><h1 id="477f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">要记住的要点:</h1><ul class=""><li id="a09f" class="lm ln hi jl b jm mn jp mo js mu jw mv ka mw ke ms ls lt lu bi translated">HashMap 有一个名为 Entry 的内部类，用于存储键值对。</li><li id="2ada" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">在 Entry 之上，对象存储在名为 table 的 Entry[ ](数组)中</li><li id="411d" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">表的索引在逻辑上称为桶，它存储链表的第一个元素</li><li id="fb62" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">Key 对象的<a class="ae kf" href="https://java2blog.com/hashcode-and-equals-method-in-java/" rel="noopener ugc nofollow" target="_blank"> hashcode </a>()用于查找那个 Entry 对象的 bucket。</li><li id="a72f" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">如果两个键对象有相同的 hashcode，它们将放入表数组的同一个桶中。</li><li id="391e" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">Key 对象的 equals()方法用于确保 key 对象的唯一性。</li><li id="6c1a" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">值对象的 equals()和 hashcode()方法根本没有使用</li></ul><p id="9177" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更多面试问题请浏览<a class="ae kf" href="http://www.java2blog.com/2016/07/core-java-interview-questions-and-answers.html" rel="noopener ugc nofollow" target="_blank">核心 java 面试问题</a>和<a class="ae kf" href="https://java2blog.com/java-interview-questions/" rel="noopener ugc nofollow" target="_blank"> java 面试问题</a>。</p><h1 id="a842" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">您可能还喜欢:</h1><ul class=""><li id="1030" class="lm ln hi jl b jm mn jp mo js mu jw mv ka mw ke ms ls lt lu bi translated"><a class="ae kf" href="http://www.java2blog.com/2016/04/hashmap-in-java-with-examples.html" rel="noopener ugc nofollow" target="_blank">Java 中的 HashMap</a></li><li id="eb39" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated">【HashMap 如何在 java 中工作</li><li id="f73a" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated"><a class="ae kf" href="http://www.java2blog.com/2014/02/hash-and-indexfor-method-in-hashmap.html" rel="noopener ugc nofollow" target="_blank">HashMap 中方法的散列和索引</a></li><li id="1289" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated"><a class="ae kf" href="http://www.java2blog.com/2014/02/hashcode-and-equals-method-in-java.html" rel="noopener ugc nofollow" target="_blank">Java 中的 hashcode 和 equals 方法</a></li><li id="9c0a" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated"><a class="ae kf" href="http://www.java2blog.com/2016/05/how-to-sort-hashmap-in-java-by-keys-and.html" rel="noopener ugc nofollow" target="_blank">如何通过键和值对 HashMap 进行排序</a></li><li id="9382" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated"><a class="ae kf" href="http://www.java2blog.com/2013/02/difference-between-hashmap-and-hashset.html" rel="noopener ugc nofollow" target="_blank">HashMap 和 HashSet 的区别</a></li><li id="86df" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated"><a class="ae kf" href="http://www.java2blog.com/2013/02/difference-between-hashtable-and-hashmap.html" rel="noopener ugc nofollow" target="_blank">HashMap 和 Hashtable 的区别</a></li><li id="c355" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke ms ls lt lu bi translated"><a class="ae kf" href="http://www.java2blog.com/2015/06/how-to-iterate-over-map-or-hashmap-in.html" rel="noopener ugc nofollow" target="_blank">如何迭代 HashMap </a></li></ul><p id="4434" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="mt">原载于 2019 年 5 月 3 日 https://java2blog.com</em><em class="mt">的</em> <a class="ae kf" href="https://java2blog.com/how-hashmap-works-in-java/" rel="noopener ugc nofollow" target="_blank"> <em class="mt">。</em></a></p></div></div>    
</body>
</html>