<html>
<head>
<title>What’s a monitor in Java?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的监视器是什么？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/whats-a-monitor-in-java-8f0ebecaea2a?source=collection_archive---------3-----------------------#2022-02-03">https://medium.com/javarevisited/whats-a-monitor-in-java-8f0ebecaea2a?source=collection_archive---------3-----------------------#2022-02-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0fa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在进入Monitor之前，我们需要了解两件事。</p><ol class=""><li id="4339" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">互斥</li></ol><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="jr js l"/></div></figure><blockquote class="jt"><p id="3d55" class="ju jv hi bd jw jx jy jz ka kb kc jc dx translated">当一个进程/线程正在执行它的临界区时，不允许其他进程执行它的临界区。(每个进程都有一个被称为“临界区”的代码段，在这个代码段中访问共享数据。)</p></blockquote><p id="85a0" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">2.同步</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="jr js l"/></div></figure><blockquote class="jt"><p id="765e" class="ju jv hi bd jw jx jy jz ka kb kc jc dx translated">当线程试图通过协同工作来实现一个共同的目标时，这些线程之间需要合作。当他们专注于一个共同的目标时，他们需要同步。</p></blockquote><p id="6ebc" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated"><strong class="ih hj">监视器用于实现互斥和同步</strong></p><h2 id="7394" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">了解显示器</h2><figure class="jm jn jo jp fd jq er es paragraph-image"><a href="https://javarevisited.blogspot.com/2014/07/top-50-java-multithreading-interview-questions-answers.html#axzz6hX6XfwBD"><div class="er es ld"><img src="../Images/cffee968d0cee22b6fa3a01e934902eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/0*b0YB2mo0sEppYQt6.png"/></div></a></figure><blockquote class="lg lh li"><p id="362e" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">不要把这个临界区和临界区混淆了。因为在这里，关键区域是在对象级别提到的，而不是在线程级别。共享数据被认为是一个关键领域。</p></blockquote><p id="2c14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个对象及其类都与一个监视器相关联。需要防止并发访问的对象的实例变量包括与对象相关联的监视器的关键区域，并且需要防止并发访问的类的实例变量/静态变量包括在与类相关联的监视器的关键区域中。</p><ul class=""><li id="5375" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ln jj jk jl bi translated">这个关键区域有一把锁保护着，这把锁确保了互斥。</li><li id="247a" class="jd je hi ih b ii lo im lp iq lq iu lr iy ls jc ln jj jk jl bi translated">等待集还与用于提供线程间协调的监视器相关联。</li><li id="fa3a" class="jd je hi ih b ii lo im lp iq lq iu lr iy ls jc ln jj jk jl bi translated">一个条目集用于保存已经请求锁的线程，而锁还没有被它们获得。*</li></ul><p id="fcef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">显示器上的互斥是如何实现的？</strong></p><p id="b41b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个对象都与一个监视器相关联，这个监视器有一个<strong class="ih hj">锁</strong>，每个线程在访问共享变量时都可以使用这个<strong class="ih hj">锁</strong>来锁定或解锁对象。</p><p id="4006" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显而易见，这意味着一次只有一个线程可以在监视器上持有<strong class="ih hj">锁</strong>。任何试图锁定该锁的其他线程都会被阻塞，直到它们可以获得该锁。</p><p id="709c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个新线程试图获取锁时，如果一个线程已经拥有该锁，那么该线程将等待条目集来获取该锁。</p><p id="a820" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当获得锁的线程完成其临界区时，它将释放锁。所以下一个线程将获得锁，但是这个下一个线程是从条目集中获取的，并且将由JVM基于一些标准(比如FIFO)来确定。</p><p id="c5d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们实现的是互斥，因为我们给了一个线程对对象的独占访问，并且我们不允许任何其他线程进入它们的临界区。</p><p id="0896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用监视器实现互斥的java代码示例</p><pre class="jm jn jo jp fd lt lu lv lw aw lx bi"><span id="bcfa" class="ki kj hi lu b fi ly lz l ma mb">class Counter</span><span id="dd19" class="ki kj hi lu b fi mc lz l ma mb">{</span><span id="ccbc" class="ki kj hi lu b fi mc lz l ma mb">private int count = 0;</span><span id="2d20" class="ki kj hi lu b fi mc lz l ma mb">public void synchronized Increment() {</span><span id="fc29" class="ki kj hi lu b fi mc lz l ma mb">int n = count;</span><span id="5af6" class="ki kj hi lu b fi mc lz l ma mb">count = n+1;</span><span id="f493" class="ki kj hi lu b fi mc lz l ma mb">} //Here synchronized is used to indicate those things should be done sequentially.</span><span id="631e" class="ki kj hi lu b fi mc lz l ma mb">}</span></pre></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h2 id="10c1" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">如何通过监视器实现协调/同步？</h2><p id="0880" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">使用与监视器和“等待并通知”或“发信号并继续”机制相关联的等待集来实现同步。</p><p id="dec5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个线程需要某些数据处于特定状态，而另一个线程负责让数据进入该状态时，例如生产者/消费者问题，同步非常重要</p><p id="8b12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个线程调用与该对象相关的wait()方法时，该线程被挂起并被添加到等待集合中，直到某个其他线程对同一对象调用notify()或notifyAll()。</p><p id="d343" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae mp" href="https://javarevisited.blogspot.com/2015/07/how-to-use-wait-notify-and-notifyall-in.html" rel="noopener ugc nofollow" target="_blank"> notify()方法</a>用于唤醒特定对象的监视器的等待集中的线程。有两种方法通知等待的线程。</p><ul class=""><li id="1741" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ln jj jk jl bi translated">notify() →对于所有等待等待的线程，设置方法notify()通知它们中的任何一个任意唤醒。选择唤醒哪个线程是不确定的，这取决于JVM。</li><li id="3dda" class="jd je hi ih b ii lo im lp iq lq iu lr iy ls jc ln jj jk jl bi translated">notifyAll() →这个方法只是唤醒所有正在等待集合中等待的线程。被唤醒的线程将无法继续，直到当前线程释放该对象上的锁。被唤醒的线程将以通常的方式与任何其他可能主动竞争同步的线程竞争。</li></ul><h2 id="fe41" class="ki kj hi bd kk kl km kn ko kp kq kr ks iq kt ku kv iu kw kx ky iy kz la lb lc bi translated">在生产者-消费者问题中使用监视器实现同步的示例java代码</h2><pre class="jm jn jo jp fd lt lu lv lw aw lx bi"><span id="6dd3" class="ki kj hi lu b fi ly lz l ma mb">class Buffer {</span><span id="22b5" class="ki kj hi lu b fi mc lz l ma mb">private char [] buffer;</span><span id="3d4e" class="ki kj hi lu b fi mc lz l ma mb">private int count = 0, in = 0, out = 0;</span><span id="4741" class="ki kj hi lu b fi mc lz l ma mb">Buffer(int size)</span><span id="b743" class="ki kj hi lu b fi mc lz l ma mb">{</span><span id="1aa0" class="ki kj hi lu b fi mc lz l ma mb">buffer = new char[size];</span><span id="726a" class="ki kj hi lu b fi mc lz l ma mb">}</span><span id="5a3c" class="ki kj hi lu b fi mc lz l ma mb">public synchronized void Put(char c) {</span><span id="fff0" class="ki kj hi lu b fi mc lz l ma mb">while(count == buffer.length)</span><span id="1cdd" class="ki kj hi lu b fi mc lz l ma mb">{</span><span id="926d" class="ki kj hi lu b fi mc lz l ma mb">try { wait(); }</span><span id="ed1a" class="ki kj hi lu b fi mc lz l ma mb">catch (InterruptedException e) { }</span><span id="bdda" class="ki kj hi lu b fi mc lz l ma mb">finally { }</span><span id="2516" class="ki kj hi lu b fi mc lz l ma mb">}</span><span id="0bd0" class="ki kj hi lu b fi mc lz l ma mb">System.out.println(“Producing “ + c + “ …”);</span><span id="67f4" class="ki kj hi lu b fi mc lz l ma mb">buffer[in] = c;</span><span id="ef84" class="ki kj hi lu b fi mc lz l ma mb">in = (in + 1) % buffer.length;</span><span id="9715" class="ki kj hi lu b fi mc lz l ma mb">count++;</span><span id="9e59" class="ki kj hi lu b fi mc lz l ma mb">notify();</span><span id="6ac1" class="ki kj hi lu b fi mc lz l ma mb">}</span><span id="4730" class="ki kj hi lu b fi mc lz l ma mb">public synchronized char Get() {</span><span id="6756" class="ki kj hi lu b fi mc lz l ma mb">while (count == 0)</span><span id="56d9" class="ki kj hi lu b fi mc lz l ma mb">{</span><span id="a786" class="ki kj hi lu b fi mc lz l ma mb">try { wait(); }</span><span id="31f2" class="ki kj hi lu b fi mc lz l ma mb">catch (InterruptedException e) { }</span><span id="3173" class="ki kj hi lu b fi mc lz l ma mb">finally { }</span><span id="0a22" class="ki kj hi lu b fi mc lz l ma mb">}</span><span id="4aa7" class="ki kj hi lu b fi mc lz l ma mb">char c = buffer[out];</span><span id="a795" class="ki kj hi lu b fi mc lz l ma mb">out = (out + 1) % buffer.length;</span><span id="0608" class="ki kj hi lu b fi mc lz l ma mb">count — ;</span><span id="c333" class="ki kj hi lu b fi mc lz l ma mb">System.out.println(“Consuming “ + c + “ …”);</span><span id="64f2" class="ki kj hi lu b fi mc lz l ma mb">notify();</span><span id="e5bf" class="ki kj hi lu b fi mc lz l ma mb">return c;</span><span id="d922" class="ki kj hi lu b fi mc lz l ma mb">}</span><span id="217a" class="ki kj hi lu b fi mc lz l ma mb">}</span></pre><p id="4bbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在博客上分享了<a class="ae mp" href="https://stackoverflow.com/questions/3362303/whats-a-monitor-in-java/64116702#64116702" rel="noopener ugc nofollow" target="_blank">我的SO答案</a>。你可以在这里找到问题<a class="ae mp" href="https://stackoverflow.com/questions/3362303/whats-a-monitor-in-java" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>