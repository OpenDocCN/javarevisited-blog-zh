<html>
<head>
<title>Java Virtual Machine (JVM) Internals, Part 2 — Class file format</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java虚拟机(JVM)内部机制，第2部分—类文件格式</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-virtual-machine-jvm-internals-part-2-class-file-format-7752e5f7dbbe?source=collection_archive---------0-----------------------#2019-07-07">https://medium.com/javarevisited/java-virtual-machine-jvm-internals-part-2-class-file-format-7752e5f7dbbe?source=collection_archive---------0-----------------------#2019-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1c10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一系列文章中，我将讨论Java虚拟机是如何工作的。在第1部分中，我们看了Java虚拟机的类加载器子系统。在这篇文章中，我们将讨论类文件格式。</p><p id="50f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经知道，所有用Java编程语言编写的源代码都是先用Java开发工具包中提供的<em class="je"> javac </em>编译器编译成<a class="ae jd" href="https://en.wikipedia.org/wiki/Java_bytecode" rel="noopener ugc nofollow" target="_blank">字节码</a>(Java虚拟机的指令)。字节码以二进制文件格式保存，称为<em class="je">类</em>文件格式。这些类文件(字节码)然后由Java虚拟机的类加载器组件动态地(仅在需要时)加载到内存中。在简单的<em class="je">解释器</em>模式下，Java执行引擎在主机CPU上逐个执行这些字节码。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/5c65b243e052e8a97e321fd01547a196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ToNENPH-yfs0zSe203DqsQ.jpeg"/></div></div><p class="jr js et er es jt ju bd b be z dx translated">Java源代码编译</p></figure><blockquote class="jv"><p id="1045" class="jw jx hi bd jy jz ka kb kc kd ke jc dx translated"><strong class="ak">每个文件都带有。java扩展编译成至少一个。类文件。有一个。源代码中定义的每个类、接口和模块的类文件。这也适用于嵌套类或接口。</strong></p></blockquote><p id="53c4" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated"><strong class="ih hj">注</strong>:为简单起见，文件带有。类扩展在这里叫做类文件。</p><p id="3c4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们写一个简单的程序</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="9eee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个文件上运行<em class="je"> javac </em>会产生以下文件。</p><pre class="jg jh ji jj fd km kn ko kp aw kq bi"><span id="32d5" class="kr ks hi kn b fi kt ku l kv kw">ClassOne$StaticNestedClass.class<br/>ClassOne.class<br/>ClassTwo.class<br/>InterfaceOne.class</span></pre><p id="0614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，为源文件中定义的每个类、接口创建了一个类文件。</p><h1 id="7cfb" class="kx ks hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">类文件里面有什么？</h1><p id="9b14" class="pw-post-body-paragraph if ig hi ih b ii lu ik il im lv io ip iq lw is it iu lx iw ix iy ly ja jb jc hb bi translated">类文件是二进制文件格式。信息通常被写到类文件中，在连续的信息段之间没有空格或填充，所有内容都在字节边界上对齐。所有16位和32位量都是通过分别读取两个和四个连续的8位字节来构造的。</p><p id="689f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类文件包含以下信息</p><p id="c1f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">幻数</em> </strong>:每个类文件的前四个字节总是0xCAFEBABE。这四个字节将类文件格式与其他文件格式区分开来。</p><p id="00b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">主版本和次版本</em> </strong>:类文件的第二个四字节包含主版本号和次版本号。主版本号和次版本号共同决定了类文件格式的版本。如果一个类文件有主版本号M和次版本号M，我们把它的类文件格式的版本表示为M.m。</p><p id="f163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个JVM都有一个可以加载的最大版本，JVM会拒绝更高版本的类文件。例如，Java 11支持从45到55的主要版本，而Java 12支持主要版本45..56</p><p id="b163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">常量池</em> </strong>:表示字符串常量、类和接口名、字段名、方法名以及类文件结构及其子结构中引用的其他常量的结构表(异构)。这个常量池的每个元素都以一个单字节标记开始，该标记指定了表中该位置的常量类型。根据常量的类型，下一个字节可以是常量值或对池中另一个元素的引用。</p><p id="325f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">访问标志</em> </strong>:标志列表，告诉这个类或接口是公共的还是私有的访问，这个类是最终的还是允许扩展的。JVM规范文档中定义了各种标志，如ACC_PUBLIC、ACC_FINAL、ACC_INTERFACE、ACC_ENUM等。</p><p id="eb41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">该类</em> </strong>:指常量池中的条目。</p><p id="7af6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">超类</em> </strong>:指常量池中的条目。</p><p id="b2f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">接口</em> </strong>:统计该类实现的接口数。</p><p id="0951" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">字段计数</em> </strong>:统计该类或接口中字段的个数。</p><p id="f7b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">字段</em> </strong>:字段计数后是一个变长结构表，每个字段一个，描述字段类型和名称(引用常量池条目)</p><p id="c0dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">方法计数</em> </strong>:统计类或接口中方法的数量。此计数仅包括由该类显式定义的方法，不包括任何可能从超类继承的方法。</p><p id="daed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">方法</em> </strong>:跟随方法计数的是方法本身。每个方法的结构包含关于该方法的几条信息，包括方法描述符(其返回类型和参数列表)、方法局部变量所需的字数、方法操作数堆栈所需的最大堆栈字数、方法捕获的异常表、字节码序列和行号表。</p><p id="cbe8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">属性计数</em> </strong>:统计该类或接口或模块中的属性个数。,</p><p id="498f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">属性</em> </strong>:属性计数之后是描述每个属性的表格或变长结构。例如，一个属性是源代码属性；它显示了编译这个类文件的源文件的名称。</p><p id="5e9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然类文件格式不是直接可读的，但是<strong class="ih hj"> JDK提供了一个名为<em class="je"> javap </em> </strong> <em class="je"> </em>的工具，它可以反汇编类文件并以可读格式输出其内容。</p><p id="a17a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们写一个简单的Java程序，如下所示</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="7b09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用将产生HelloWorld.class文件的<em class="je"> javac </em>命令来编译这个程序，然后使用<em class="je"> javap </em>工具来分解这个HelloWorld.class文件。在HelloWorld.class上使用带有-v (verbose)的<em class="je"> javap </em>会产生以下输出</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="b595" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里你可以看到这个类是可公开访问的，它的常量池有37个条目，有一个属性(底部的源文件)，实现了两个接口(Serializable，Cloneable)，有0个字段和2个方法。</p><p id="778e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能想知道源代码中只有一个静态main方法，但是类文件却说有两个方法。嗯，记住Java编程语言中的默认构造函数，它是由<em class="je"> javac </em>编译器添加的无参数构造函数，其字节码在输出中也是可见的。构造函数被视为方法。</p><p id="6621" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里阅读更多关于<strong class="ih hj"> <em class="je"> javap </em> </strong>工具<a class="ae jd" href="https://docs.oracle.com/en/java/javase/12/tools/javap.html" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="lz ma mb"><p id="b55b" class="if ig je ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">提示:您可以使用<em class="hi"> javap </em>工具来看看lambdas与匿名内部类有什么不同。</p></blockquote><p id="ba94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本系列的下一部分，我将讨论运行JVM实例的内存布局。</p><p id="4ea7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">学习Java的其他<strong class="ih hj">有用资源</strong>你可能喜欢的<br/> <a class="ae jd" href="https://javarevisited.blogspot.com/2019/04/top-5-courses-to-learn-jvm-internals.html" rel="noopener ugc nofollow" target="_blank">学习JVM内部的前5门课程</a> <br/> <a class="ae jd" href="http://www.java67.com/2018/08/top-10-free-java-courses-for-beginners-experienced-developers.html" rel="noopener ugc nofollow" target="_blank">从头开始学习Java的10门免费课程</a> <br/> <a class="ae jd" href="https://medium.freecodecamp.org/must-read-books-to-learn-java-programming-327a3768ea2f" rel="noopener ugc nofollow" target="_blank">深入学习Java的10本书</a> <br/> <a class="ae jd" href="http://www.java67.com/2018/04/10-tools-java-developers-should-learn.html" rel="noopener ugc nofollow" target="_blank"> 10个工具每个Java开发者都应该知道的</a> <br/> <a class="ae jd" href="http://javarevisited.blogspot.sg/2013/04/10-reasons-to-learn-java-programming.html" rel="noopener ugc nofollow" target="_blank">学习Java编程语言的10个理由</a><br/><a class="ae jd" href="http://javarevisited.blogspot.sg/2018/01/10-frameworks-java-and-web-developers-should-learn.html" rel="noopener ugc nofollow" target="_blank">2019年Java和Web开发者应该学习的10个框架</a>【T29】 2019年更好的Java开发者<br/><a class="ae jd" href="http://javarevisited.blogspot.sg/2018/04/top-5-java-frameworks-to-learn-in-2018_27.html" rel="noopener ugc nofollow" target="_blank">2019年要学习的5大Java框架</a> <br/> <a class="ae jd" href="https://javarevisited.blogspot.sg/2018/01/10-unit-testing-and-integration-tools-for-java-programmers.html" rel="noopener ugc nofollow" target="_blank">每个Java开发者都应该知道的10个测试库</a></p></div></div>    
</body>
</html>