<html>
<head>
<title>Understanding Garbage Collection Algorithms in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Java中的垃圾收集算法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/understanding-garbage-collection-algorithms-in-java-6d6e7ddf5272?source=collection_archive---------0-----------------------#2022-10-12">https://medium.com/javarevisited/understanding-garbage-collection-algorithms-in-java-6d6e7ddf5272?source=collection_archive---------0-----------------------#2022-10-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es im"><img src="../Images/8febd3e9f6441877b1ce19b8323673bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*bHSv-V0AaVexpSbw_l1NoQ.png"/></div></figure><p id="9030" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">什么是垃圾收集器？</strong></p><p id="f269" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">垃圾收集器(GC)是JVM中管理应用程序堆的一个组件。它负责给对象分配内存，销毁它们为分配更多的对象腾出空间。</p><p id="cf80" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">堆是所有线程共享的一块内存。在堆中，所有的类实例(对象)和数组都是分配的。最小和最大堆大小可以使用<em class="js"> -Xms= &lt; n &gt; </em>和<em class="js"> -Xmx= &lt; m &gt; </em>命令行选项来设置。</p><p id="4feb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">垃圾收集(GC)算法的用例？</strong></p><p id="8def" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">可以找到多种垃圾收集算法。例如JDK8和先前使用的<strong class="iw hj"> <em class="js">并行GC </em> </strong> <em class="js"> </em>算法，该算法通过完成尽可能多的工作来关注吞吐量，而不考虑延迟因素。JDK9+使用算法<strong class="iw hj"> <em class="js">垃圾优先(G1) </em> </strong>垃圾收集，试图平衡吞吐量和延迟。通过阅读本文，这些概念会变得更加清晰。耐心:)</p><p id="2adf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不管怎样，继续前进；垃圾收集算法的最基本目的是:</p><ol class=""><li id="4aaa" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">应该能够尽快为任何新的请求/操作提供内存空间</li><li id="7d10" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">应该能够通过销毁不需要的对象来清除内存。这个过程应该很快。</li><li id="63a9" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">在步骤2之后，当空间再次可用时，GC应该在需要时快速地将对象分配给空闲空间。</li></ol><p id="4b6c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi kh translated">暂停时间是垃圾收集器停止应用程序以回收内存的持续时间。这个变量直接影响延迟，因此目标是限制最长的暂停时间。</p><p id="03a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">GC组件的实现各不相同，因为每个算法都针对一个特定的<strong class="iw hj">性能指标</strong>。</p><p id="8df9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在编写GC时，三个主要的性能指标是:吞吐量、延迟和内存占用。</p><h2 id="7992" class="kq kr hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">GC算法针对的性能指标</h2><ol class=""><li id="9b00" class="jt ju hi iw b ix ll jb lm jf ln jj lo jn lp jr jy jz ka kb bi translated"><strong class="iw hj">吞吐量</strong>是在指定的时间单位内可以完成的工作量。在短时间内做更多工作的GC算法是优选的。</li><li id="ea54" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><strong class="iw hj">延迟</strong>是完成一个请求所花费的时间。GC算法将尝试尽可能少地暂停垃圾收集，以便请求不必等待垃圾收集，即GC算法不会让任何请求/操作等待，它将尝试尽可能快地完成操作</li><li id="d557" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><strong class="iw hj">内存占用</strong>是GC进程顺利执行所需的内存。如果GC algo占用了更多的内存，就意味着我们有更少的内存可以用于堆。</li></ol><p id="23ad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">这三个指标是相互关联的</em>:高吞吐量的收集器可能会显著影响延迟(但会最小化对应用程序的影响)，反之亦然。较低的内存消耗可能需要使用在其他指标上不太理想的算法。作为应用程序执行的一部分，较低延迟的收集器可以并发地或以较小的步骤完成更多的工作，从而占用更多的处理器资源。</p><p id="4e07" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">试图在一个或多个指标上提高GC通常会损害其他指标。很明显，对吧？这就是为什么我们有针对不同性能因素的不同算法。</p><p id="df83" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">OpenJDK提供了五种侧重于不同性能指标的GC算法:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/d3bb6eb9b9fc0fd0a484bb978ce85caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqtxejOZgxwZPURbS6gL6w.png"/></div></div><p class="lv lw et er es lx ly bd b be z dx translated"><a class="ae lz" href="https://blogs.oracle.com/javamagazine/post/java-garbage-collectors-evolution" rel="noopener ugc nofollow" target="_blank">https://blogs . Oracle . com/Java magazine/post/Java-garbage-collectors-evolution</a></p></figure><p id="1202" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将主要关注上面列表中的两个主要算法:并行(Java8和之前版本使用)和垃圾优先(Java9+使用)。</p><h2 id="9bce" class="kq kr hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">垃圾优先垃圾收集</h2><p id="9b8d" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ma jh ji jj mb jl jm jn mc jp jq jr hb bi translated">G1 GC是Java9及更高版本中使用的默认算法。G1同样关注吞吐量和延迟。<br/> <em class="js">停止世界概念- </em>基本上就是暂停应用一段时间，让垃圾收集可以工作。该算法使用Stop the World(STW)暂停，但使暂停更短，从而可以减少延迟，即请求/操作不必等待更长时间才能完成。<br/>缩短暂停时间意味着GC算法只在非常短的时间内工作，这样应用程序就可以平稳运行，最终用户不会注意到这些暂停。</p><p id="bf47" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">G1与应用程序并行执行这项冗长的工作，也就是说，当应用程序使用多线程运行时。这显著减少了最大暂停时间，但代价是总吞吐量有所下降。</p><p id="219e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个G1算法是稳定的、非常成熟的，并且一直在用更新的思想进行升级。你可以在这个算法中请求停止世界的暂停不超过x毫秒。G1的一个关键设计目标是使垃圾收集引起的停顿的持续时间和分布是可预测和可配置的。分代垃圾收集在切换b/w这一角色的两个性能指标(吞吐量和延迟)方面起着关键作用。G1所做的是，它将堆内存分成两部分<strong class="iw hj"> 1。年轻一代2。老一代。</strong>分配给老一代的内存空间比年轻一代多得多。活动时间较长的对象会从年轻代移动到老代，即当一个对象经历了一定数量的GC后，收集器会将其移动到老代。较新的对象最初被分配给年轻的内存。这意味着年轻一代拥有临时或短命对象的概率更高。有道理？因为长期以来一直处于活动状态的所有对象都将驻留在旧的内存位置。因此，每当G1垃圾收集运行时，检查年轻一代内存是合乎逻辑的。这样我们就可以从年轻的内存中释放出空间，并且这个空间可以分配给新的请求&amp;操作。</p><p id="f435" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，老一代的记忆最终会被填满。为了解决这个问题，G1垃圾收集算法使用分代垃圾收集，这意味着它检查整个年轻一代的垃圾收集内存，但对老一代内存使用增量方法。因为旧的分代内存会包含更多的活动对象(当前正被应用程序使用),所以如果没有分代垃圾收集的概念，针对该内存的GC所花费的时间会相对较长。</p><h2 id="0e83" class="kq kr hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">分代垃圾收集是如何工作的？</h2><p id="0022" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ma jh ji jj mb jl jm jn mc jp jq jr hb bi translated">G1 GC跟踪旧的分代内存，并找出应用程序当前使用的所有活动对象(它使用表和不同的数据结构来获取此信息)。现在，由于G1 GC知道当前活动的活对象，所以旧代中要检查垃圾收集的内存范围减少了很多，因为具有活动对象的空间不能被清除或垃圾收集。</p><p id="dc40" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">首先收集垃圾最多的区域。首先检查年轻内存，然后检查除活动/活动对象内存之外的旧内存。因此得名:垃圾优先收集。</em></p><p id="902d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将最终减少延迟，因为垃圾收集的暂停时间非常短。实际的内存回收，如果一次完成，在大型应用程序堆上会非常耗时，就像在并行GC模型中一样。每当G1 GC运行时，随着时间的推移，在每个GC周期中，它都会处理完整的年轻内存，并处理一小部分老一代内存，从而随着时间的推移释放旧内存上的空间。因此，它通过在每个GC周期中处理更小的内存块来对旧内存采取增量方法。<br/>分代垃圾收集很复杂，因为活动/活对象使用数据结构进行跟踪。这些会占用额外的空间来跟踪活动对象。然而，GC的一个关键性能指标(即延迟)大幅降低，因为垃圾收集的暂停时间非常短。</p><p id="46d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从JDK 9开始，G1自动确定一个最佳点，在这个点开始老代跟踪。在Java9之前，这个时间是由用户手动选择的，这是一件复杂的事情，因为选择时间太晚或太早都会导致性能问题。G1 GC还优先检查较大的对象，因为如果它被清除，我们就有更多的空闲空间可以分配。</p><p id="5d6f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从Jdk8到Jdk18，<strong class="iw hj">内存占用也有了巨大的改进。</strong>内存占用是指GC算法在堆内存之外为顺利工作而占用的额外空间量。对于G1 GC算法，Jdk8需要的空间量是5.8Gb，现在在Java18中需要的空间量是1.25GB</p><p id="9693" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">G1最适合具有非常严格的暂停时间目标和适度的总吞吐量的应用程序，比如交易平台或交互式图形程序等实时应用程序。</p><h2 id="f3c8" class="kq kr hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">并行GC</h2><p id="0579" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ma jh ji jj mb jl jm jn mc jp jq jr hb bi translated">并行GC是JDK 8和更早版本的默认收集器。它试图以更紧凑的形式将对象从堆中的一个位置复制到另一个位置，以便我们可以在内存中有更多的空间。有一个概念叫做停止世界(STW)停顿。当有新的请求等待时，会触发STW暂停，并且因为堆没有任何空间，所以没有内存可以分配。在这种情况下，JVM将完全停止应用程序，并专注于使用所有专用于GC的线程和进程来运行GC算法。一旦堆中的空间被清空，JVM就把空间分配给请求对象，最后继续执行应用程序。该算法关注吞吐量，试图在一个时间单位内完成更多工作，而对延迟(暂停)的关注最少。它使用多线程来完成工作，通常需要较长的暂停时间，因为它关注的是吞吐量。每一次暂停都更长，并且在这些更长的暂停期间收集垃圾。因此延迟会受到影响，因为应用程序请求必须在这些暂停期间等待。</p><p id="61c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过对JVM使用以下命令或在JVM启动脚本中使用并行GC，可以选择它作为默认GC算法:</p><pre class="in io ip iq fd md me mf mg aw mh bi"><span id="d1d9" class="kq kr hi me b fi mi mj l mk ml">java -XX:+UseParallelGC com.mypackages.MyExecutableClass<br/>java -XX:+UseParallelOldGC com.mypackages.MyExecutableClass<br/>java -XX:+UseParallelGC -XX:+UseParallelOldGC com.mypackages.MyExecutableClass</span></pre><p id="1228" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">ZGC和谢南多厄的GC</strong>更喜欢通过补偿吞吐量来实现延迟目标。它们试图在没有明显停顿的情况下完成所有垃圾收集工作。这些分别在JDK 15号和JDK 12号上作为非实验版本首次推出。</p><p id="50d2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">串行GC </strong>顾名思义就是串行的，也就是说它只用一个线程来完成STW(停止世界)的工作。它不能利用多处理器硬件。这种GC算法可以用于小型、短期运行的应用程序，因为它的方法简单，没有复杂性规则。这个算法被Java5 &amp; Java6使用过。</p><h2 id="00db" class="kq kr hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">参考资料:</h2><div class="mm mn ez fb mo mp"><a href="https://blogs.oracle.com/javamagazine/post/java-garbage-collectors-evolution" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hj fi z dy mu ea eb mv ed ef hh bi translated">Java垃圾收集:从JDK 8到JDK 18的10个版本的演进</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">下载本文的PDF文件JDK 18的全面上市标志着自仍受欢迎的JDK 8以来的第10次发布…</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">blogs.oracle.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd is mp"/></div></div></a></div><div class="mm mn ez fb mo mp"><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hj fi z dy mu ea eb mv ed ef hh bi translated">GC算法:实现| Plumbr -用户体验和应用程序性能监控</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">现在我们已经回顾了GC算法背后的核心概念，让我们转到具体的实现上来…</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">管道工</p></div></div><div class="my l"><div class="ne l na nb nc my nd is mp"/></div></div></a></div><div class="mm mn ez fb mo mp"><a href="https://stackoverflow.com/questions/9299339/garbage-collection-changing-collector-algorithm" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hj fi z dy mu ea eb mv ed ef hh bi translated">垃圾收集-改变收集器算法</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">我们在Tomcat (Java 1.5)上运行Spring+Hibernate web应用程序。目前我们使用2GB的堆空间(我被告知这是…</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">stackoverflow.com</p></div></div><div class="my l"><div class="nf l na nb nc my nd is mp"/></div></div></a></div><h2 id="ac4f" class="kq kr hi bd ks kt ku kv kw kx ky kz la jf lb lc ld jj le lf lg jn lh li lj lk bi translated">结论:</h2><p id="1425" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ma jh ji jj mb jl jm jn mc jp jq jr hb bi translated">希望本文对解释垃圾收集机制和算法有所帮助。请随时在vivek.sinless@gmail.com或在<a class="ae lz" href="https://www.linkedin.com/in/vivek-singh-a109b511a/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div></div>    
</body>
</html>