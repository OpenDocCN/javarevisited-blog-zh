<html>
<head>
<title>Design Difference Between State Design Pattern and Strategy Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">状态设计模式和策略设计模式的设计差异</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/micro-biology-of-state-and-strategy-design-pattern-2add63460ab7?source=collection_archive---------3-----------------------#2019-03-06">https://medium.com/javarevisited/micro-biology-of-state-and-strategy-design-pattern-2add63460ab7?source=collection_archive---------3-----------------------#2019-03-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6d6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都知道状态和策略模式被归类在行为设计模式下。其中对象保持不变，但是行为根据上下文和操作类型而改变。现在，让我们理解这两种设计模式及其微观生物学差异。</p><p id="8b0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">状态模式:</strong>当对象根据内部状态改变其行为时，使用状态模式。对象在运行时部分改变其类型或行为是一种干净的方式。</p><p id="af0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">策略模式:</strong>策略模式又称为<strong class="ih hj"> <em class="jd">策略模式。</em> </strong>当一个特定的对象有多个算法或计算，并且上下文实现是在运行时决定的时候使用。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-java-design-pattern-courses-for-developers.html"><div class="er es je"><img src="../Images/6db991a6452f9a0d4029ff5d48c8e593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Kq7ts156oub4sC0H.jpg"/></div></a><p class="jm jn et er es jo jp bd b be z dx translated">战略</p></figure><h1 id="bed6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">两种设计模式之间的差异与实时用例。</h1><p id="2c4f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">让我们以人类的生命周期为例。</p><p id="68f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都知道当我们一年比一年老的时候。我们在生活中会遇到许多状态，在每个状态下我们会执行不同的任务。</p><p id="c1d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以各种状态为例</p><ol class=""><li id="aa4f" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">婴儿(0-2岁)</li><li id="3d00" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">婴儿(2-5岁)</li><li id="2921" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">男孩(5-14岁)</li><li id="8410" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">青少年(14-18岁)</li><li id="9ebb" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">青年(18-28岁)</li><li id="6689" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">成人(28-60岁)</li><li id="07b4" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">老年公民(60-80岁)</li><li id="e33f" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">超级老年人(80岁及以上)</li></ol><p id="eb68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们完成各种任务</p><ol class=""><li id="1354" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">接种疫苗</li><li id="cf9b" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">日托</li><li id="5fd8" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">玩具</li><li id="8e83" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">运动</li><li id="2eb7" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">游戏学校</li><li id="429b" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">学校</li><li id="b57e" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">毕业</li><li id="ef15" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">结婚</li><li id="8b2d" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">假日</li></ol><p id="2cf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经确定了需要执行的状态和任务。在如下所示的简单图表中，我们可以很容易地<a class="ae lh" href="http://javarevisited.blogspot.sg/2014/04/difference-between-state-and-strategy-design-pattern-java.html" rel="noopener ugc nofollow" target="_blank">区分状态和策略模式</a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://medium.com/swlh/5-free-object-oriented-programming-online-courses-for-programmers-156afd0a3a73"><div class="er es li"><img src="../Images/af0f6901e2836e3d12fb1000edec0b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*E3rcRwtqp7f7SrGSbJpLCA.jpeg"/></div></a></figure><h1 id="956e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">用于计算人员运行时费用的策略模式的实现。</h1><p id="1779" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><strong class="ih hj">ApplicationRun.java</strong>，用来充当应用的入口点。</p><pre class="jf jg jh ji fd lj lk ll lm aw ln bi"><span id="1bb9" class="lo jr hi lk b fi lp lq l lr ls">package org.nbk.designpattern.behavioural.strategy.example;</span><span id="55f9" class="lo jr hi lk b fi lt lq l lr ls">public class <strong class="lk hj">ApplicationRun </strong>{</span><span id="f203" class="lo jr hi lk b fi lt lq l lr ls">public static void main(String[] args) {<br/>        LifeCycleStrategy lifeCycleStrategy = new Infant();<br/>        LifeCycleStrategyContext lifeCycleStrategyContext = new LifeCycleStrategyContext(lifeCycleStrategy);<br/>        lifeCycleStrategyContext.getExpenses();<br/>    }<br/>}</span></pre><p id="b5cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建一个接口<strong class="ih hj">LifeCycleStrategy.java</strong>，它拥有一个人的每个<strong class="ih hj">生命周期</strong>的公共行为。</p><pre class="jf jg jh ji fd lj lk ll lm aw ln bi"><span id="baff" class="lo jr hi lk b fi lp lq l lr ls">package org.nbk.designpattern.behavioural.strategy.example;</span><span id="db0b" class="lo jr hi lk b fi lt lq l lr ls">public interface <strong class="lk hj">LifeCycleStrategy </strong>{<br/>   public void getExpenses();<br/>}</span></pre><p id="85dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建一个上下文类<strong class="ih hj">LifeCycleStrategyContext.java</strong>，它是我们的<strong class="ih hj">生命周期策略</strong>接口的集合。本课程将帮助注入用于计算费用的年龄类别类型。</p><pre class="jf jg jh ji fd lj lk ll lm aw ln bi"><span id="2bfc" class="lo jr hi lk b fi lp lq l lr ls">package org.nbk.designpattern.behavioural.strategy.example;</span><span id="68fb" class="lo jr hi lk b fi lt lq l lr ls">public class <strong class="lk hj">LifeCycleStrategyContext </strong>{<br/>    <br/>    private LifeCycleStrategy lifeCycleStrategy;<br/>    <br/>    public LifeCycleStrategyContext(LifeCycleStrategy lifeCycleStrategy){<br/>    this.lifeCycleStrategy = lifeCycleStrategy;<br/>    }<br/>    <br/>    public void getExpenses() {<br/>    lifeCycleStrategy.getExpenses();<br/>    }<br/>}</span></pre><p id="8fd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们有一个具体的类，它将帮助我们得到费用。在我们的例子中，我想计算一个婴儿的费用。</p><p id="847d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Infant.java</strong>实现<strong class="ih hj">LifeCycleStrategy.java</strong>接口，获取婴儿生命周期的所有常见行为。</p><pre class="jf jg jh ji fd lj lk ll lm aw ln bi"><span id="c6f4" class="lo jr hi lk b fi lp lq l lr ls">package org.nbk.designpattern.behavioural.strategy.example;</span><span id="8234" class="lo jr hi lk b fi lt lq l lr ls">public class Infant implements <strong class="lk hj">LifeCycleStrategy </strong>{</span><span id="10c8" class="lo jr hi lk b fi lt lq l lr ls">@Override<br/>    public void getExpenses() {<br/>        System.out.println(" Expenses of Infants");<br/>        System.out.println(" 1. Vaccination");<br/>        System.out.println(" 2. Day Care");<br/>    }<br/>}</span></pre><h1 id="7c63" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">实现状态设计模式以获取年龄类别组的生命周期。</h1><p id="ccb5" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><strong class="ih hj">ApplicationRun.java</strong>曾经充当应用的入口点。</p><pre class="jf jg jh ji fd lj lk ll lm aw ln bi"><span id="aec2" class="lo jr hi lk b fi lp lq l lr ls">package org.nbk.designpattern.behavioural.state.example;</span><span id="8488" class="lo jr hi lk b fi lt lq l lr ls">public class <strong class="lk hj">ApplicationRun </strong>{</span><span id="36eb" class="lo jr hi lk b fi lt lq l lr ls">public static void main(String[] args) {</span><span id="f975" class="lo jr hi lk b fi lt lq l lr ls">LifeCycleState lifeCycleState = new Infant();<br/>        LifeCycleStateContext lifeCycleStateContext = new LifeCycleStateContext();<br/>        lifeCycleStateContext.setLifeCycleState(lifeCycleState);<br/>        lifeCycleStateContext.getLifeCycle();<br/>    }<br/>}</span></pre><p id="882b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建了一个接口<strong class="ih hj">LifeCycleState.java</strong>，它有共同的行为来识别生命周期。</p><pre class="jf jg jh ji fd lj lk ll lm aw ln bi"><span id="2d62" class="lo jr hi lk b fi lp lq l lr ls">package org.nbk.designpattern.behavioural.state.example;</span><span id="1fb5" class="lo jr hi lk b fi lt lq l lr ls">public interface <strong class="lk hj">LifeCycleState </strong>{<br/>    public void getLifeCycle(LifeCycleStateContext ctx);<br/>}</span></pre><p id="0d28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建一个名为LifeCycleStateContext.java<strong class="ih hj">的<strong class="ih hj"> StateContext </strong>类。context类通过<strong class="ih hj">life cycle estate</strong>接口聚合。上下文使用构造函数在<strong class="ih hj">运行时</strong>设置<strong class="ih hj">生命周期</strong>的类型。<strong class="ih hj"> getLifeCycle </strong>方法有助于获取具体<strong class="ih hj">life cycle estate</strong>的生命周期。</strong></p><pre class="jf jg jh ji fd lj lk ll lm aw ln bi"><span id="16bb" class="lo jr hi lk b fi lp lq l lr ls">package org.nbk.designpattern.behavioural.state.example;</span><span id="6704" class="lo jr hi lk b fi lt lq l lr ls">public class <strong class="lk hj">LifeCycleStateContext </strong>{</span><span id="d424" class="lo jr hi lk b fi lt lq l lr ls">private LifeCycleState lifeCycleState;</span><span id="8f5b" class="lo jr hi lk b fi lt lq l lr ls">public LifeCycleStateContext() {}</span><span id="f1ca" class="lo jr hi lk b fi lt lq l lr ls">public void setLifeCycleState(LifeCycleState lifeCycleState) {<br/>        this.lifeCycleState = lifeCycleState;<br/>    }</span><span id="9ce2" class="lo jr hi lk b fi lt lq l lr ls">public LifeCycleStateContext(LifeCycleState lifeCycleState) {<br/>        this.lifeCycleState = lifeCycleState;<br/>    }</span><span id="f99b" class="lo jr hi lk b fi lt lq l lr ls">public LifeCycleState getLifeCycleState() {<br/>        return lifeCycleState;<br/>    }<br/>    public void getLifeCycle() {<br/>        lifeCycleState.getLifeCycle(this);<br/>    }<br/>}</span></pre><p id="7a03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们有子具体类<strong class="ih hj">Infant.java</strong>，它实现了我们的<strong class="ih hj">LifeCycleState.java</strong>接口来定义上下文的生命周期。</p><pre class="jf jg jh ji fd lj lk ll lm aw ln bi"><span id="39ec" class="lo jr hi lk b fi lp lq l lr ls">package org.nbk.designpattern.behavioural.state.example;</span><span id="16d4" class="lo jr hi lk b fi lt lq l lr ls">public class <strong class="lk hj">Infant </strong>implements <strong class="lk hj">LifeCycleState</strong>{</span><span id="2ddb" class="lo jr hi lk b fi lt lq l lr ls">@Override<br/>    public void getLifeCycle(LifeCycleStateContext ctx) {<br/>        System.out.println("I am an Infant");<br/>    }<br/>}</span></pre><h1 id="e5f7" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">状态模式与战略模式</h1><p id="0199" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这两种模式是相似的，但是这两种模式之间的思想略有不同。</p><p id="d782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">策略模式定义了一系列可互换的算法</strong>，即该模式可用于任何种类的<strong class="ih hj">计算或算法。</strong>然而，在<strong class="ih hj">状态模式中，行为完全根据实际状态而改变。</strong></p><p id="d1cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在策略模式中，<strong class="ih hj">客户端应该知道要使用的策略类型，并明确地更改</strong>。鉴于，<strong class="ih hj">每个状态被一个接一个地链接，以创建状态模式中有限状态机</strong>中定义的流。</p><h1 id="1397" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="f54f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><strong class="ih hj">状态模式:</strong> It <strong class="ih hj"> </strong>当开发人员想要<strong class="ih hj">避免原始if/else语句时非常有用。</strong>取而代之的是，<strong class="ih hj">提取逻辑来分离类</strong>，并让我们的<strong class="ih hj">上下文对象将行为委托给状态类中实现的</strong>方法。此外，我们可以利用状态之间的转换，其中一个状态可以改变上下文的状态。</p><p id="3fa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">策略模式:</strong>很棒<strong class="ih hj"> </strong>当我们有<strong class="ih hj">多种方式来执行同一个任务</strong> <strong class="ih hj">(在软件语言中当我们有多种算法来执行同一个操作)</strong>时，我们应该考虑实现策略模式。通过使用这种模式，<strong class="ih hj">我们可以自由添加/删除算法，因为这些算法的切换对应用程序来说是不透明的</strong>。</p></div></div>    
</body>
</html>