<html>
<head>
<title>Let’s Learn Together Sessions: Hazelcast</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们一起学习会话:Hazelcast</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/lets-learn-together-sessions-hazelcast-e6e1816e44a4?source=collection_archive---------0-----------------------#2020-04-12">https://medium.com/javarevisited/lets-learn-together-sessions-hazelcast-e6e1816e44a4?source=collection_archive---------0-----------------------#2020-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3be2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将学习流行的内存数据网格技术Hazelcast的基础知识，并使用Java制作一个简单的例子。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a6de3f601165a1baf7383985be1f1c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q5Q85ry3LD5OjvCe"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">柯蒂斯·麦克牛顿在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="2326" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">什么是黑兹尔卡斯特？</strong></h1><p id="cc95" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Hazelcast是一种开源技术，以分布式内存方式设计，使可伸缩的应用程序具有更快的数据访问和写入。</p><p id="240b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Hazelcast是用Java实现的，但是提供的客户端有</strong> <a class="ae jt" rel="noopener" href="/javarevisited/10-best-c-programming-courses-for-beginners-2c2c1f6bcb12"> <strong class="ih hj"> C </strong> </a> <strong class="ih hj">，</strong><a class="ae jt" rel="noopener" href="/javarevisited/10-best-c-and-c-programming-books-for-beginners-and-experienced-programmers-eb5ee8dbdc5a"><strong class="ih hj">c++</strong></a><strong class="ih hj">，</strong> <a class="ae jt" rel="noopener" href="/javarevisited/7-best-online-courses-to-learn-asp-net-core-and-mvc-in-depth-a68c1b728090?source=---------28------------------"> <strong class="ih hj">。NET、</strong></a><strong class="ih hj"/><a class="ae jt" rel="noopener" href="/javarevisited/top-5-books-and-courses-to-learn-restful-web-services-in-java-using-spring-mvc-and-spring-boot-79ec4b351d12?source=---------17------------------"><strong class="ih hj">REST</strong></a><strong class="ih hj">，</strong><a class="ae jt" rel="noopener" href="/javarevisited/10-best-python-certification-courses-from-coursera-4576890eb6b3"><strong class="ih hj">Python</strong></a><strong class="ih hj">，</strong> <a class="ae jt" rel="noopener" href="/javarevisited/top-10-online-courses-to-learn-node-js-in-depth-8ef0e31ca139"> <strong class="ih hj"> Node.js </strong> </a>，<strong class="ih hj">等等</strong> …所以你可以通过使用这些广泛分布的客户端，轻松地将其与你的后端系统集成。选择Hazelcast的另一个原因是，除了核心Java模块之外，它不需要外部依赖。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/c317f7ea470c44308b2a40331aa74e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LEVZTIFzafU9iVt_X64Jg.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">图片来源:Hazelcast网站</p></figure><p id="7f42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Hazelcast不为数据系统提供单点故障</strong>。这意味着什么，Hazelcast是如何实现的？因为它在成员之间使用对等通信，所以集群成员之间没有主从关系。所有集群成员都以相同的方式配置，因此任何成员都可以被其他成员替换。(集群中创建的第一个节点管理集群成员，如果第一个节点出现故障，第二个最旧的节点将承担责任。)</p><p id="2246" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast具有高度的可扩展性。如果您向集群添加新成员，Hazelcast会自动发现新成员并重组内存和处理能力。</p><p id="5778" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，<strong class="ih hj"> Hazelcast还提供了许多分布式数据结构</strong>，比如标准的实用程序集合:<a class="ae jt" href="https://javarevisited.blogspot.com/2020/09/10-examples-of-concurrenthashmap-in-java.html" rel="noopener ugc nofollow" target="_blank">映射</a>、<a class="ae jt" href="https://javarevisited.blogspot.com/2012/12/blocking-queue-in-java-example-ArrayBlockingQueue-LinkedBlockingQueue.html#axzz6iYmMFnsA" rel="noopener ugc nofollow" target="_blank">队列</a>、<a class="ae jt" href="https://javarevisited.blogspot.com/2012/06/hashset-in-java-10-examples-programs.html" rel="noopener ugc nofollow" target="_blank">集合</a>，以及<a class="ae jt" href="https://javarevisited.blogspot.com/2011/05/example-of-arraylist-in-java-tutorial.html#axzz6qVaG06bu" rel="noopener ugc nofollow" target="_blank">列表</a>，发布/订阅机制的主题。除此之外，并发实用程序数据结构也包含在Hazelcast中，比如FencedLock、ISemaphore等等。如果已经存在的分布式数据结构不足以满足您的需要，您可以通过使用Hazelcast为用户提供的服务提供者接口来创建自己的分布式数据结构。</p><h1 id="ee3e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">在哪里使用Hazelcast？</strong></h1><p id="71ce" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">尽管Hazelcast被认为是一种内存缓存解决方案，但它并不仅限于此。Hazelcast不仅是分布式缓存需求的好选择，也可用于<a class="ae jt" href="https://javarevisited.blogspot.com/2011/04/synchronization-in-java-synchronized.html#axzz6ngd8ND25" rel="noopener ugc nofollow" target="_blank">同步</a>、集群、处理和发布/订阅消息需求。</p><p id="3b01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序可以使用Hazelcast更快地访问和写入最常用的数据，如会话或订户信息。在我以前的一次经历中，我们使用Hazelcast在微服务架构中的微服务之间共享客户信息和外部系统会话信息。由于Hazelcast，每个微服务都可以通过创建一个Hazelcast客户端来快速获取这些数据。</p><p id="7d10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，分析应用程序可以使用Hazelcast对b <a class="ae jt" rel="noopener" href="/javarevisited/top-5-big-data-frameworks-java-developers-can-learn-in-2021-9a3e20437c8c"> ig数据进行分区处理</a>。利用Hazelcast的分布式处理机制，可以更好更快地解析和处理数据。</p><p id="1e07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，应用程序可以将Hazelcast作为应用程序发布/订阅通信的核心机制。因此，应用程序可以与相关用户和用户连接的通道共享主题(发布/订阅机制的数据结构)。</p><p id="84ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同行业的许多公司都使用Hazelcast，如摩根大通、威瑞森、空中客车、施耐德电气等。在我的国家土耳其，我知道Hazelcast用于电信、银行，甚至保险部门。</p><p id="83c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast支持Windows、<a class="ae jt" rel="noopener" href="/javarevisited/7-best-linux-courses-for-developers-cloud-engineers-and-devops-in-2021-7415314087e1"> Linux </a>等多种操作环境，VM解决方案，以及VMware、【Azure】、<a class="ae jt" rel="noopener" href="/javarevisited/top-5-free-courses-to-learn-docker-for-beginners-best-of-lot-b2b1ad2b98ad?source=collection_home---4------2-----------------------"> Docker、</a>和<a class="ae jt" rel="noopener" href="/javarevisited/6-best-openshift-courses-for-beginners-and-experienced-developers-d124edd2baff"> OpenShift </a>等容器。下面你可以看到一个高层次的Hazelcast基础设施。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ky"><img src="../Images/0ac8cb8973667c98757b2b5de7ab8d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZFfqAQwo7SSfheP9YPg8Q.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">Hazelcast建筑:::(图片鸣谢:Hazelcast网站)</p></figure><p id="8ba3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast IMDG公司为公司和个人提供不同版本的免费和付费服务。上面的Hazelcast基础设施显示了不同版本的Hazelcast功能或模块的兼容性。</p><h1 id="6d83" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">它是如何工作的？</h1><p id="65b2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Hazelcast为用户提供了两种类型的部署选项:嵌入式部署和客户机/服务器部署。</p><p id="56df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于关注异步和高性能计算以及低延迟数据访问的应用程序来说，嵌入式部署是必不可少的。但是嵌入式部署只支持<a class="ae jt" rel="noopener" href="/javarevisited/10-advanced-java-books-and-courses-for-experienced-developers-b90cc1086975"> Java </a>。因此，如果您计划使用Java客户端之外的编程语言来集成Hazelcast，那么嵌入式部署将不是一个合适的选择。</p><p id="d857" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在嵌入式部署中，每个成员不仅包括应用程序本身，还包括Hazelcast服务模块。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kz"><img src="../Images/31250fb61ee112e63dd2605c3594425f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIcoWKz_OxcrS5vAnO2bWg.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">嵌入式部署图示</p></figure><p id="0468" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了嵌入式部署，您还可以使用客户机/服务器部署选项。客户机/服务器部署将Hazelcast服务模块与应用程序隔离开来。由于Hazelcast服务模块与应用程序相隔离，因此您可以轻松地诊断Hazelcast的问题，还可以扩展您的Hazelcast服务模块。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es la"><img src="../Images/938e16a45611ea8d9e8ad3a54cef786b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpgShRit8qmbCk9LmK4CVQ.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">客户端/服务器部署图示</p></figure><p id="2919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast的优势之一来自于数据分片机制。每个分片数据块称为一个分区。分区是存储大量数据的内存段。每个分区包括分布式集群成员上的一个或多个副本。主分区称为主分区，其他分区称为备份分区。</p><p id="3fb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分区计数是一个动态属性，可以通过hazelcast.xml文件以声明方式或编程方式进行修改。对于包含单个成员的集群，默认分区数是271。当您增加集群成员时，分区以成员增加的速度复制。</p><p id="4621" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分发机制基于散列算法。对于集群成员中的每个数据，使用以下公式计算分区id:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lb"><img src="../Images/6f120cd9a8cb420e48538f5bc9bb2c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ogsJYyHQsqZ_GjnGQcUBtg.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">黑兹尔卡斯特分配公式</p></figure><p id="1c41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过计算每个成员的分区id，创建一个分区表。每个集群成员都知道这个分区表，所以每个成员都知道所搜索的数据在哪里。</p><p id="116e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我前面提到的，分区表的责任在这个节点上，因为集群中的第一个或最老的节点管理集群。它将所有的更改和最新的分区表共享给集群成员。并且一个新成员加入集群或者一个成员离开集群，则由Hazelcast触发重新划分过程。这个过程对于分区所有权分配至关重要。</p><h1 id="1c34" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">从哪里开始？</strong></h1><p id="74a3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我希望我上面提到的关于Hazelcast的工作方式在你的脑海中有一席之地。所以我们可以进入文章的下一部分:<strong class="ih hj">我们如何开发一个端到端的Hazelcast缓存系统？从哪里开始？</strong></p><p id="e140" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开发Hazelcast集群的第一个也是最重要的部分是配置部分，就像其他关系型或<a class="ae jt" rel="noopener" href="/javarevisited/10-free-online-courses-to-learn-mongodb-and-nosql-942609611664"> NoSQL </a>技术一样。Hazelcast提供了两种配置管理方式:</p><ul class=""><li id="df1e" class="lc ld hi ih b ii ij im in iq le iu lf iy lg jc lh li lj lk bi translated"><strong class="ih hj">声明式配置</strong></li><li id="b488" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated"><strong class="ih hj">程序化配置</strong></li></ul><p id="7e60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于声明式配置，您可以使用相同的<strong class="ih hj"> hazelcast.xml </strong>或<strong class="ih hj"> hazelcast.yaml </strong>文件之一。(这些文件位于下载的hazelcast.jar的bin文件夹中)另一个XML文件名为hazelcast-full-example.xml或hazelcast-full-example.yaml，是hazelcast.xml或hazelcast.yaml文件的指导文档，在下载的包中提供。您可以访问许多配置元素和属性，并使用它们将所需的配置复制到hazelcast.xml文件中。或者您可以通过用hazelcast.xml更改它的名称来直接使用它</p><p id="eae8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到下面的配置示例:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/f3a1e8ffff8a5a609de5956a0f082041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCzwtZlsCC1O5kLMKWVP7w.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">hazelcast.xml配置示例</p></figure><p id="4164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast配置集群的另一种方式是编程配置。对于这种配置方式，您可以在首选的Hazelcast客户端中使用Hazelcast的<strong class="ih hj"> Config </strong>对象。</p><p id="7bed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> *** </strong>由于Java是我最喜欢的编程语言，所以我将在本文的<a class="ae jt" rel="noopener" href="/javarevisited/why-java-is-the-best-programming-language-to-learn-coding-for-beginners-cba79aed1271"> Java languag </a> e中展示示例，不过不用担心，其他的Hazelcast客户端也很相似。</p><p id="b961" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了使用编程配置方法创建的Hazelcast配置示例:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="ccaa" class="lw jv hi ls b fi lx ly l lz ma">Config config = new Config();<br/>config.setNetworkConfig(getHazelcastNetworkConfig());<br/>config.setClusterName("hazelcast-cluster");<br/>config.setInstanceName("hazelcast-template");<br/>config.setPartitionGroupConfig(getPartitionGroupConfig());<br/>config.setProperty("hazelcast.health.monitoring.level","NOISY");<br/>config.addMapConfig(getHazelcastMapConfig());</span></pre><p id="005a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，您可以添加基于网络、分区和分布式数据结构的配置。以上配置我都一一说明。</p><p id="50aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过网络配置，您可以设置Hazelcast集群成员端口号，并为新的集群成员启用/禁用自动递增机制等。在此配置示例中，我们将默认端口设置为5900，并禁用端口自动递增选项。(Hazelcast默认端口是5701)</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="7c53" class="lw jv hi ls b fi lx ly l lz ma">NetworkConfig networkConfig = new NetworkConfig().setPort(5900)  <br/>                          .setPortAutoIncrement(false);</span></pre><p id="47f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一部分是关于如何创建一个用于发现Hazelcast成员的连接配置，并提供一个集群形式的工作机制。您可以使用许多不同的连接配置。从<a class="ae jt" rel="noopener" href="/javarevisited/5-best-books-and-courses-to-learn-computer-networking-tcp-ip-and-udp-protocols-5a0e4dce75fa"> TCP/IP </a>，组播，<a class="ae jt" rel="noopener" href="/javarevisited/how-to-prepare-for-aws-solution-architect-associate-certification-saa-c01-saa-c02-exam-in-2021-a6e7e7e771fc"> AWS </a>到<a class="ae jt" rel="noopener" href="/javarevisited/7-free-microsoft-azure-fundamentals-az-900-online-courses-for-beginners-in-2021-efd01d8be403"> Azure，</a>，甚至还有网飞OSS的Eureka。<br/>在我之前的经验中，在电信领域，我使用了TCP/IP和多播配置，因此我将通过这些配置来解释本文中使用的示例。您可以通过遵循<a class="ae jt" href="https://docs.hazelcast.org/docs/3.12.1/manual/html-single/index.html" rel="noopener ugc nofollow" target="_blank"> Hazelcast文档</a>轻松使用其他不同的配置。</p><p id="3a33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以在Hazelcast上为不同的集群添加多个配置。您可以针对不同的集群配置启用/禁用它们。以下示例显示了TCP/IP和多播配置:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="d323" class="lw jv hi ls b fi lx ly l lz ma">private NetworkConfig getHazelcastNetworkConfig(){<br/><br/>    NetworkConfig networkConfig = new NetworkConfig().setPort(5900)  <br/>                              .setPortAutoIncrement(false);<br/><br/>    JoinConfig joinConfig = new JoinConfig();<br/>    TcpIpConfig tcpIpConfig = new TcpIpConfig();<br/>    tcpIpConfig.setConnectionTimeoutSeconds(30); <br/>    tcpIpConfig.setEnabled(true);<br/>    <br/>    List&lt;String&gt; memberList = new ArrayList&lt;&gt;();<br/>    memberList.add("127.0.0.1:5900");<br/>    tcpIpConfig.setMembers(memberList);<br/><br/>    joinConfig.setTcpIpConfig(tcpIpConfig);<br/><br/>    //------------------------------------------<br/><br/>    MulticastConfig multicastConfig = new MulticastConfig();<br/>    multicastConfig.setMulticastTimeoutSeconds(30);<br/>    multicastConfig.setMulticastTimeToLive(255);<br/>    multicastConfig.setEnabled(false);<br/><br/>    joinConfig.setMulticastConfig(multicastConfig);<br/><br/>    networkConfig.setJoin(joinConfig);<br/><br/>    return networkConfig;<br/>}</span></pre><p id="b573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们通过使用setEnabled方法来启用<strong class="ih hj"> TCP/IP配置</strong>，并将连接超时周期设置为30秒。该选项意味着一个成员最多等待30秒，以通过网络从其他TCP/IP成员处获得响应<strong class="ih hj">。</strong>设置太低的值<strong class="ih hj"> </strong>可能意味着成员无法连接到集群。</p><p id="db15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，您不应该为超时输入太高的值，以防止新集群成员的启动时间变长。此外，我们定义了将托管集群的IP地址和端口号。</p><p id="0328" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，我们定义了多播配置，但使用setEnabled方法禁用了它。对于这种类型的加入配置，我们设置了与TCP / IP相同的超时时间，即30秒。与TCP/IP不同，我们还将多播生存时间变量设置为255。这里我应该特别注意，您不应该在生产环境中使用多播配置，因为UDP在生产环境中经常被阻止，而其他发现机制更加明确。</p><p id="7c8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一个配置部分是<strong class="ih hj">分区配置</strong>，它对于集群上的数据分区过程的机制至关重要。Hazelcast随机平均地分发分区副本。但是，这种随机机制会阻止您将主数据和副本放在不同的JVM中。为此，Hazelcast提供了组分区功能，使您能够在一个分区组上托管主数据分区，并在另一个分区组上托管副本。Hazelcast为分区组的分布提供了许多分区组类型。默认的分区组是<strong class="ih hj"> PER_MEMBER </strong>。在此配置中，Hazelcast为每个成员定义了一个组分区。像<strong class="ih hj"> PER_MEMBER </strong>一样，您可以使用<strong class="ih hj"> PER_ZONE </strong>根据服务器位置对Hazelcast成员进行分组。在下面的配置中，我们启用了组分区属性，并将组分区类型设置为默认的<strong class="ih hj"> PER_MEMBER </strong></p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="dcf9" class="lw jv hi ls b fi lx ly l lz ma">private PartitionGroupConfig getPartitionGroupConfig(){<br/><br/>  return new PartitionGroupConfig().setEnabled(true)                                    .setGroupType(PartitionGroupConfig.MemberGroupType.<em class="mb">PER_MEMBER</em>);<br/>                                  <br/>}</span></pre><p id="6e47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还可以通过使用键值对来配置Hazelcast上的属性。<br/>您可以使用这个键-值方法设置任何配置参数，包括我上面提到的配置。</p><p id="eeba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的示例中，我们将Hazelcast监控级别设置为<strong class="ih hj">噪音</strong>。Hazelcast监控内存和CPU的使用情况，并在使用情况超过阈值时记录下来。对于噪声级别，您可以启用Hazelcast始终打印日志，Hazelcast不会检查写入日志的阈值。</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="25c9" class="lw jv hi ls b fi lx ly l lz ma">config.setProperty("hazelcast.health.monitoring.level","NOISY");</span></pre><p id="4bc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在本文中介绍的最后一个配置是<strong class="ih hj">地图配置</strong>。正如我已经说过的，使用Hazelcast，您甚至可以配置像<a class="ae jt" href="https://www.java67.com/2013/02/10-examples-of-hashmap-in-java-programming-tutorial.html" rel="noopener ugc nofollow" target="_blank"> Map </a>这样的分布式数据结构。对于我的例子，我使用map作为分布式数据结构，所以我添加了一个Map配置，如下所示:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="b0d9" class="lw jv hi ls b fi lx ly l lz ma">private MapConfig getHazelcastMapConfig(){<br/><br/>    MapConfig mapConfig = new MapConfig();<br/><br/>    mapConfig.setName("hazelcast-map-config");<br/>    mapConfig.setBackupCount(2);<br/>    mapConfig.setAsyncBackupCount(1); <br/><br/>    mapConfig.setMaxIdleSeconds(3600);<br/>    mapConfig.setTimeToLiveSeconds(3600);</span><span id="39df" class="lw jv hi ls b fi mc ly l lz ma">    EvictionConfig evictionConfig = new EvictionConfig();<br/>    evictionConfig.setEvictionPolicy(EvictionPolicy.<em class="mb">LRU</em>); <br/>    evictionConfig.setMaxSizePolicy(MaxSizePolicy.<em class="mb">PER_PARTITION</em>);<br/>    evictionConfig.setSize(1000);<br/><br/>    mapConfig.setEvictionConfig(evictionConfig);<br/><br/>    mapConfig.setMetadataPolicy(MetadataPolicy.<em class="mb">CREATE_ON_UPDATE</em>);</span><span id="507b" class="lw jv hi ls b fi mc ly l lz ma">    mapConfig.setReadBackupData(false);<br/> <br/>    mapConfig.addEntryListenerConfig(<br/>            new EntryListenerConfig( "com.justayar.springboot.util.MapEntryListener",<br/>                    true, false ) );<br/><br/>    return mapConfig;<br/>}</span></pre><p id="8148" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我将地图配置的名称定义为<strong class="ih hj">“hazel cast-map-config”</strong>。在同一集群中使用多个映射配置时，命名配置对于避免混淆至关重要。</p><p id="8e91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我将<strong class="ih hj">备份计数</strong>设为2。(默认值为1)。因此，对于地图中的每个数据，Hazelcast在不同的集群成员上创建两个副本。我还为地图配置设置了<strong class="ih hj">异步备份计数</strong>属性。所以这里可能会出现问题:<strong class="ih hj">同步和异步备份有什么区别？</strong>在同步备份中，Hazelcast在put操作完成之前更新备份，因此它使集群稳定。但是这会导致每个put操作的延迟问题，因此您必须选择最小的备份计数来提供高性能。(建议的最大计数为6)。</p><p id="cf9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，异步备份操作是在某个时间点执行的，因此操作速度更快，但在这种情况下，群集稳定性可能会令人怀疑。默认的<strong class="ih hj"> async-backup-count </strong>值是0，但是您可以像上面那样通过编程来设置它</p><p id="4f6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，请记住，Hazelcast群集可以同时拥有同步和异步备份，如下所示:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="6783" class="lw jv hi ls b fi lx ly l lz ma">mapConfig.setBackupCount(2);<br/>mapConfig.setAsyncBackupCount(1);</span></pre><p id="bfec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们定义了另外两个属性分别是<strong class="ih hj">maxidlesseconds</strong>和<strong class="ih hj"> timeToLiveSeconds </strong>。这些特性是决定Hazelcast集群中数据过期的关键因素。我们可以将<strong class="ih hj"> MaxIdleSeconds </strong>值定义为每个条目在不调用任何读或写操作的情况下保留在地图上的最大有效时间(秒)。另一方面，<strong class="ih hj"> TimeToLiveSeconds </strong>可以被认为是每个条目在没有写访问的情况下保留在地图上的最长时间(以秒为单位)的值。与映射配置中的备份计数一样，您可以为相同的映射配置设置MaxIdleSeconds和TimeToLiveSeconds，如下所示:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="b71d" class="lw jv hi ls b fi lx ly l lz ma">mapConfig.setMaxIdleSeconds(3600);<br/>mapConfig.setTimeToLiveSeconds(3600);</span></pre><p id="3ebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，你可以为每个地图元素设置不同的时间。</p><p id="5117" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast中的另一个重要概念是<strong class="ih hj">驱逐</strong>。驱逐过程是基于分区的状态执行的。如果您在配置中定义每个分区节点最多可以有n个元素，那么当分区有n-1个元素，并且您想要添加一个新元素时，分区必须决定将哪个元素逐出。在基于策略的驱逐系统完成之后，该元素将被添加到分区中。有三种驱逐策略:<strong class="ih hj">无</strong>、<strong class="ih hj"> LRU </strong>(最近最少使用)，以及<strong class="ih hj"> LFU </strong>(最少使用)。您可以使用setEvictionPolicy方法选择您的策略，还可以配置maxSizePolicy和maxSize属性，如下所示:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="0028" class="lw jv hi ls b fi lx ly l lz ma">EvictionConfig evictionConfig = new EvictionConfig();<br/>evictionConfig.setEvictionPolicy(EvictionPolicy.<em class="mb">LRU</em>); <br/>evictionConfig.setMaxSizePolicy(MaxSizePolicy.<em class="mb">PER_PARTITION</em>);<br/>evictionConfig.setSize(1000);</span><span id="5b53" class="lw jv hi ls b fi mc ly l lz ma">mapConfig.setEvictionConfig(evictionConfig);</span></pre><p id="f448" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">元数据策略</strong>是在更新时预处理数据条目的重要选项之一，使查询返回快速响应。这是默认属性<strong class="ih hj"> CREATE_ON_UPDATE </strong>，但是您可以通过将<strong class="ih hj">关闭</strong>选项来禁用它，如下所示:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="ba20" class="lw jv hi ls b fi lx ly l lz ma">mapConfig.setMetadataPolicy(MetadataPolicy.<em class="mb">OFF</em>);</span></pre><p id="9f0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，您可以向地图中添加侦听器来跟踪地图上的事件。(如放置、移除、驱逐、更新、清除等操作)。您可以通过指定监听程序类将条目监听程序配置添加到映射中，如下所示:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="5190" class="lw jv hi ls b fi lx ly l lz ma">mapConfig.addEntryListenerConfig(<br/>        new EntryListenerConfig( "com.justayar.springboot.util.MapEntryListener",<br/>                true, false ) );</span></pre><p id="fed3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">监听器类的实现在本文后面的监听器部分。</p><p id="c5e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与上面的配置一样，您可以通过编程方式编辑Hazelcast上的任何配置。现在我们已经了解了如何以声明方式和编程方式配置Hazelcast，因此我们可以继续本文的下一部分:<strong class="ih hj">通过使用Hazelcast映射实现Hazelcast客户端</strong>。</p><h1 id="a47b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何实现一个基本的Hazelcast地图？</h1><p id="cac5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Hazelcast提供了一系列分布式数据结构来满足您的需求，比如Map、<a class="ae jt" href="https://javarevisited.blogspot.com/2013/10/what-is-priorityqueue-data-structure-java-example-tutorial.html#axzz6f4s58Ml9" rel="noopener ugc nofollow" target="_blank"> Queue </a>、Set、List、MultiMap、Topic( Pub/Sub)和Locks。对于本文，我将以地图为例，并使用它开发一个简单的应用程序。</p><p id="b747" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，您需要使用本文前面的配置创建一个hazelcast实例:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="b679" class="lw jv hi ls b fi lx ly l lz ma">HazelcastInstance hazelcastInstance = Hazelcast.<em class="mb">newHazelcastInstance</em>(hazelcastConfig);</span></pre><p id="d6eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您必须使用get方法来访问具有指定名称的分布式地图。它将创建一个新的地图，如果它以前不存在。它在文献中被称为延迟初始化，这意味着它在第一次访问地图时创建一个新的Hazelcast地图。我们已经在本文的配置部分定义了映射配置。</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="4074" class="lw jv hi ls b fi lx ly l lz ma">IMap&lt;String,String&gt; hazelcastMap = hazelcastInstance.getMap("hazelcast-map");</span></pre><p id="31f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast Map对象以分布式方式扩展了Java ConcurrentMap接口。所以可以使用的基本map操作有"<strong class="ih hj"> put" </strong>用于向map中写入一个新对象(这里我们用"<strong class="ih hj"> set" </strong>代替)和"<strong class="ih hj"> get" </strong>用于读取map中的对象)。对于本文，我使用以下方法为Hazelcast地图定义了基本的CRUD操作:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="8a60" class="lw jv hi ls b fi lx ly l lz ma">public void putToMap(String key,String value){<br/><br/>    if(key == null)<br/>        throw new NullPointerException("Key of element which is added to map cannot be null");<br/><br/>    if(key.isEmpty())<br/>        throw new IllegalArgumentException("Key of element which is added to map cannot be empty");<br/><br/>    hazelcastMap.set(key, value);<br/>    logger.info("New data added to hazelcast map with key: {}", key);<br/>}</span><span id="638b" class="lw jv hi ls b fi mc ly l lz ma">public String getMapItemWithKey(String key){<br/><br/>    if(key == null)<br/>        throw new NullPointerException("Key of element which is read from map cannot be null");<br/><br/>    if(key.isEmpty())<br/>        throw new IllegalArgumentException("Key of element which is read from map cannot be empty");<br/><br/>    logger.info("Getting data item from hazelcast map with key: {}", key);<br/>    return hazelcastMap.get(key);<br/>}<br/><br/>public Map&lt;String, String&gt; getAllMap(){<br/><br/>    return hazelcastMap;<br/>}<br/><br/>public void removeMapItemWithKey(String key){<br/><br/>    if(key == null)<br/>        throw new NullPointerException("Key of element which is removed from map cannot be null");<br/><br/>    if(key.isEmpty())<br/>        throw new IllegalArgumentException("Key of element which is removed from map cannot be empty");<br/><br/>    hazelcastMap.remove(key);<br/>    logger.info("Remove item from hazelcast map succeeded with key: {}", key);<br/>}<br/><br/>public void clearAllMap(){<br/><br/>    if(hazelcastMap.size()&gt;0){<br/>        hazelcastMap.clear();<br/>        logger.info("Remove all item from hazelcast map succeeded");<br/><br/>    }<br/>}</span></pre><p id="4bb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将自己设计的第一个向map添加新成员的方法命名为"<strong class="ih hj"> putToMap" </strong>。首先，我们进行了一些null和空检查，然后我们在Java Map接口中使用了一个"<strong class="ih hj"> set" </strong>方法，而不是"<strong class="ih hj"> put" </strong>方法。在分布式架构中，如本<a class="ae jt" href="https://hazelcast.com/blog/performance-top-5-1-map-put-vs-map-set/" rel="noopener ugc nofollow" target="_blank"> URL </a>中所述，put方法会导致开销或性能问题，因为它会返回旧值。如果您想要将新成员添加到映射中，而该映射中不存在具有相同键的成员，您可以使用<strong class="ih hj">puti absent</strong>方法。</p><p id="dd5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二种方法是提供用密钥访问成员的操作。这是Java Map接口中的“<strong class="ih hj">get”</strong>操作，所以我们在这里使用了同样的方法。</p><p id="a8a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个是removeMapItemWithKey，用于从映射中删除成员。通过使用成员的键，我们删除了带有键的成员(如果它存在于映射中)。</p><p id="877c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一种方法旨在通过从映射中删除所有成员来清除映射。我们为这个功能使用了Java Map接口的“<strong class="ih hj">clear”</strong>方法。您可以根据需要使用这四种方法来添加、更新、映射上的元素，以及从映射中删除或清除成员。在我的示例设计中，我在地图中保存了字符串对。如果您的对象比string更复杂，您也可以为您的键或值使用简单的Pojo类。</p><p id="9961" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进行演示，我为CRUD端点创建了一个简单的控制器，它们是"<strong class="ih hj"> write" </strong>，"<strong class="ih hj"> read" </strong>，"<strong class="ih hj"> readAll" </strong>，"<strong class="ih hj"> remove" </strong>和"<strong class="ih hj"> clear" </strong>，如下所示:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="47a6" class="lw jv hi ls b fi lx ly l lz ma">@RestController<br/>@RequestMapping("/hazelcast")<br/>public class HazelcastController {<br/><br/><br/>    @Autowired<br/>    private HazelcastMapManager hazelcastMapManager;<br/><br/>    @PostMapping("/write")<br/>    public String writeToHazelcast(@RequestParam String key,<br/>                                   @RequestParam String value) {<br/><br/>        hazelcastMapManager.putToMap(key, value);<br/><br/>        return "OK";<br/>    }<br/><br/>    @GetMapping("/read")<br/>    public String readFromHazelcast(@RequestParam String key) {<br/><br/>        return hazelcastMapManager.getMapItemWithKey(key);<br/>    }<br/><br/>    @GetMapping("/readAll")<br/>    public Map&lt;String, String&gt; readAllFromHazelcast() {<br/><br/>        return hazelcastMapManager.getAllMap();<br/>    }<br/><br/>    @DeleteMapping("/remove")<br/>    public String removeFromHazelcast(@RequestParam String key){<br/><br/>        hazelcastMapManager.removeMapItemWithKey(key);<br/>        return "OK";<br/>    }<br/><br/>    @DeleteMapping("/clear")<br/>    public String clearHazelcast(){<br/>        hazelcastMapManager.clearAllMap();<br/>        return "OK";<br/>    }<br/><br/><br/>}</span></pre><p id="9433" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们可以用run命令启动我们的Spring Boot应用程序。当您查看控制台日志时，可以看到Hazelcast对象的创建。如果向Hazelcast群集添加新客户端，日志的成员部分会自动更新。</p><blockquote class="md me mf"><p id="bc60" class="if ig mb ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">2020–04–09 21:25:25.032信息40330—[main]c . h . internal . cluster . clusterservice:[127 . 0 . 0 . 1]:5900[dev][4.0]</p><p id="77c2" class="if ig mb ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">Members {size:1，ver:1 }[<br/>Member[127 . 0 . 0 . 1]:5900—e9 B9 cf 09–61 C2–479 e-93bc-90ab 6 f 1449 a 1 this</p><p id="8e9e" class="if ig mb ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi">]</p></blockquote><p id="4322" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的演示应用程序运行在Spring Boot港<strong class="ih hj"> 8081 </strong>。(默认的Spring Boot项目端口是8080)。由于Hazelcast和我们的应用程序运行在同一台机器上，并且Hazelcast管理中心应用程序运行在端口8080上，因此我们将演示应用程序的端口更改为8081。对于此更改，我将在Spring Boot应用程序的application.properties文件中添加以下命令:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="c638" class="lw jv hi ls b fi lx ly l lz ma">server.port=8081</span></pre><p id="e5fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，Hazelcast使用TCP/IP网络在5900端口上运行。我们可以使用上面的rest端点来检查我们的Hazelcast地图实现是否工作。首先，您可以尝试编写一个端点来向map中添加一个新成员，然后使用一个read端点通过一个键从map中访问一个成员。</p><p id="f014" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">* * *这个演示应用程序的postman集合也可以在Github页面上找到。</p><p id="3fa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我之前所说，我们使用8081作为我们的演示应用程序端口，我们使用8080端口作为Hazelcast管理中心。<strong class="ih hj">那么什么是Hazelcast管理中心呢？为什么我们要在应用程序中使用它？怎么才能整合呢？</strong></p><blockquote class="md me mf"><p id="1e82" class="if ig mb ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">Hazelcast管理中心使您能够监控和管理运行Hazelcast的集群成员。除了监视集群的整体状态，您还可以详细分析和浏览您的数据结构，更新映射配置，并从成员获取线程转储。可以运行脚本(JavaScript、Groovy等。)和命令及其脚本和控制台模块。</p><p id="3774" class="if ig mb ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">(<strong class="ih hj">鸣谢:Hazelcast管理中心文件</strong>)</p></blockquote><p id="07c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了集成哈兹卡斯特管理中心，我们首先从下载页面(<a class="ae jt" href="https://hazelcast.org/imdg/download/" rel="noopener ugc nofollow" target="_blank">https://hazelcast.org/imdg/download/</a>)下载哈兹卡斯特IMDG。然后，解压缩zip或tar文件，并转到归档文件夹内的管理中心目录。可以从命令行直接启动<strong class="ih hj"> mancenter-version.war </strong>文件。之后打开自己喜欢的网页浏览器，进入页面:<a class="ae jt" href="http://localhost:8080/mancenter" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">http://localhost:8080/mancenter</strong></a></p><p id="2a7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您第一次尝试访问此页面时，Hazelcast会要求您为安全起见创建一个管理员用户。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mj"><img src="../Images/407e38e72164b013ba11c71e0ee7b1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/0*_oWWtbLZSm0MWJSS.png"/></div><p class="jp jq et er es jr js bd b be z dx translated">Hazelcast管理中心管理员用户创建</p></figure><p id="41b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将在以后的每次访问中使用该用户名和密码。登录系统后，可以进入集群管理页面。在此页面中，您可以看到您的集群或添加新的集群配置。对于我们的示例，我们添加了一个新的集群配置，如下所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mk"><img src="../Images/398c1d76b478eb40ab7177ab12d09d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7ATboMm2RXpdCJb2nLFYw.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">添加新集群配置面板</p></figure><p id="c27a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">群集名称将是hazelcast-cluster。(我们在本文的配置一节中进行了设置)我们将集群的状态设置为enabled，并将成员地址设置为127.0.0.1:5900，这在本文的join配置部分进行了定义。</p><p id="191e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加集群配置后，我们可以看到创建的集群如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ml"><img src="../Images/ba90ff5ed25821671bb9efb37d43b70e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVJoaDzzmFi64H37AfskEQ.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">Hazelcast管理集群面板</p></figure><p id="eeac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择创建的集群后，集群管理仪表板如下所示欢迎您。从集群管理仪表板中，您可以看到集群状态、健康状况、堆内存和分区分布、内存和CPU利用率。从左侧栏，您可以访问客户端、成员和管理面板。另一方面，从存储部分，您可以看到所使用的数据结构及其当前的用法</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mm"><img src="../Images/e5e9e883c5362e7d0c186068768d9318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSadnpTKeo6Ih9Y8dV2dZw.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">Hazelcast管理仪表板面板</p></figure><p id="e201" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们可以很容易地看到Hazelcast客户机，它是我们用示例演示应用程序运行的。当您调用write命令并向列表中添加新成员，然后刷新该仪表板时，您可以看到集群内存分布发生了变化，成员大小也将得到更新。此外，您可以在存储部分看到我们用演示应用程序创建的地图。</p><p id="1d7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您单击左侧栏中的maps部分时，可以看到关于条目数量、操作、内存和备份随时间变化的图表。您还可以看到客户端调用了多少get、put、remove和hits操作。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mn"><img src="../Images/12c850795b53b18c0896c04f952d3a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DKybSIbHx-srSTJagaagg.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">地图仪表板面板</p></figure><p id="f114" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在地图面板的顶部，还有地图浏览器和地图配置面板。使用地图浏览器面板和成员键，可以访问对象值、超时值、创建时间和其他属性:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mo"><img src="../Images/ac474353234b23958e06697c3d1724d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J0LOO19on79H7602cmpC2g.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">地图浏览器面板</p></figure><p id="b9fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，您可以使用地图配置面板更改地图配置，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mp"><img src="../Images/ecadcb9b67284a6ffd99ad36a8beb215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6QIC2Om7iFHyzmXRCO6MA.png"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">地图配置面板</p></figure><p id="bb59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，Hazelcast管理中心为您的Hazelcast集群提供了一个更优雅、更有用的仪表板。有了它，您可以轻松地监控集群和分布式数据对象。我个人的看法是，每一个使用Hazelcast的应用都应该主动激活并使用Hazelcast管理中心。</p><p id="f8ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们回到我们的代码，转到文章的最后一部分:<strong class="ih hj">向Map添加监听器。</strong></p><h1 id="415a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">如何将监听器添加到Hazelcast地图？</strong></h1><p id="4f02" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用Hazelcast，您可以为不同的功能添加多个侦听器。您可以添加监听器，不仅监听集群，还监听每个操作上的分布式对象。您可以使用<strong class="ih hj"> MembershipListener </strong>界面来跟踪添加到集群中的新成员，并在一些集群成员将他们从您的集群中删除时得到通知。此外，您可以通过这个监听器了解集群成员的任何属性变化。为此功能，我们创建了一个侦听器类，它实现了MembershipListener接口，如下所示:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="b521" class="lw jv hi ls b fi lx ly l lz ma">@Component<br/>public class ApplicationMembershipListener implements MembershipListener {<br/><br/><br/>    private Logger logger = LoggerFactory.<em class="mb">getLogger</em>(getClass());<br/><br/>    @Override<br/>    public void memberAdded(MembershipEvent membershipEvent) {<br/>        logger.info("New member added to cluster {} ",membershipEvent);<br/><br/>    }<br/><br/>    @Override<br/>    public void memberRemoved(MembershipEvent membershipEvent) {<br/>        logger.info("A member removed from cluster {} ",membershipEvent);<br/><br/>    }<br/>}</span></pre><p id="f19a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们使用下面的命令将这个侦听器添加到Hazelcast实例集群中:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="1e5e" class="lw jv hi ls b fi lx ly l lz ma">HazelcastInstance hazelcastInstance = Hazelcast.<em class="mb">newHazelcastInstance</em>(hazelcastConfig);<br/><br/>hazelcastInstance.getCluster().addMembershipListener(applicationMembershipListener);</span></pre><p id="b8e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了集群监听器接口，Hazelcast还提供分布式对象监听器。因为我在我们的演示应用程序中使用了map，所以我向map添加了<strong class="ih hj"> EntryListener </strong>接口。有了这个接口，我可以跟踪地图上的任何变化，比如添加到地图上的新元素、从地图上删除的元素或者地图上触发的get操作事件。您还可以通过使用这个接口来跟踪驱逐事件。</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="3fc0" class="lw jv hi ls b fi lx ly l lz ma">public class MapEntryListener implements EntryListener {<br/><br/>    private Logger logger = LoggerFactory.<em class="mb">getLogger</em>(getClass());<br/><br/><br/>    @Override<br/>    public void entryAdded(EntryEvent entryEvent) {<br/><br/>        logger.info("New object added to map with key {} and value {}",entryEvent.getKey(),entryEvent.getValue());<br/>    }<br/><br/>    @Override<br/>    public void entryEvicted(EntryEvent entryEvent) {<br/><br/>        logger.info("Map Entry was evicted : {}",entryEvent);<br/><br/>    }<br/><br/>    @Override<br/>    public void entryRemoved(EntryEvent entryEvent) {<br/><br/>        logger.info("Object with key {} removed from map.",entryEvent.getKey());<br/><br/>    }<br/><br/>    @Override<br/>    public void entryUpdated(EntryEvent entryEvent) {<br/><br/>        logger.info("Object with key {} updated from {} to {}.", entryEvent.getKey(),entryEvent.getOldValue(),entryEvent.getValue());<br/><br/>    }<br/><br/>    @Override<br/>    public void mapCleared(MapEvent mapEvent) {<br/><br/>        logger.info("Map was cleared : {}",mapEvent);<br/><br/><br/>    }<br/><br/>    @Override<br/>    public void mapEvicted(MapEvent mapEvent) {<br/><br/>        logger.info("Map was evicted: {}",mapEvent);<br/><br/>    }<br/><br/>    @Override<br/>    public void entryExpired(EntryEvent entryEvent) {<br/><br/>    }<br/>}</span></pre><p id="5f22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在Hazelcast实例映射对象上激活此监听器，必须将其添加到分布式映射对象，如下所示:</p><pre class="je jf jg jh fd lr ls lt lu aw lv bi"><span id="7a16" class="lw jv hi ls b fi lx ly l lz ma">hazelcastMap = hazelcastInstance.getMap(ApplicationConstants.<em class="mb">HAZELCAST_MAP</em>);<br/>hazelcastMap.addEntryListener(mapEntryListener,true);</span></pre><p id="a848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在listener类中，我添加了日志来跟踪事件。因此，当您在地图上调用"<strong class="ih hj"> putToMap" </strong>操作时，您可以看到一个示例日志:</p><blockquote class="md me mf"><p id="aea6" class="if ig mb ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">2020–04–11 13:37:28.925 INFO 4587—[emplate . event-2]c . j . spring boot . util . mapentrylistener:key为1的对象从Java更新到Java。</p></blockquote><h1 id="55c9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="be50" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Hazelcast提供高度可伸缩、分布式和更快的数据访问和写入，以满足不同的需求，如缓存、数据分析、数据处理等。它支持许多操作环境，并有许多不同软件语言的客户机。Hazelcast基础设施的大部分是开源的，因此您可以在您的企业或自由职业者解决方案中使用它。</p><p id="2e68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast为发布/订阅机制提供了许多分布式对象、线程安全对象，甚至主题对象，并且由于SPI(服务提供者接口),还让您有机会通过定制的配置来实现自己的分布式数据对象。</p><p id="f08f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast分区和分片机制保证了数据基础设施的高可用性和一致性。此外，对等系统(所有节点都以相同方式配置)完全消除了数据丢失问题。</p><p id="86a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在我的自由职业者和企业解决方案上使用Hazelcast，强烈推荐Hazelcast你试试。</p><p id="7640" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码在<a class="ae jt" href="https://github.com/justayar/SpringBootTemplates/tree/master/hazelcast" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Github </strong> </a>上有。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="7a8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我在Medium上的第一篇文章，请随意反馈:)</p></div></div>    
</body>
</html>