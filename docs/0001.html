<html>
<head>
<title>A Complete Guide to Variance in Java and Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java和Scala差异完全指南</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/variance-in-java-and-scala-63af925d21dc?source=collection_archive---------0-----------------------#2015-11-22">https://medium.com/javarevisited/variance-in-java-and-scala-63af925d21dc?source=collection_archive---------0-----------------------#2015-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b0f23260ac82bfaf97740e78d80f7843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIvRsp2QvkBG-FijXpl-QA.png"/></div></div></figure><p id="c3ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文旨在解释Java和Scala中类型参数的差异。在各种博客和文章中已经有很多关于这个主题的材料，但对我来说，他们总是觉得要么太复杂，直接进入高级功能，对于这个主题的新手来说很难理解，要么太简单，只触及表面。</p><p id="0902" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，这是我填补这个空白的尝试。</p><h2 id="2d7e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">首先，简单介绍一下背景</h2><p id="6c54" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我假设你们大多数人(或所有人)都非常熟悉面向对象编程中的多态性概念。例如，能够测试一个数组是否等于另一个数组，但不需要为每种类型的<a class="ae ko" href="https://javarevisited.blogspot.com/2012/01/sort-array-in-java-ascending-and.html#axzz5XfRjTLwH" rel="noopener ugc nofollow" target="_blank">数组</a>实现equality方法，这很酷。</p><p id="d373" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们只想使用<a class="ae ko" href="https://javarevisited.blogspot.com/2011/02/how-to-write-equals-method-in-java.html" rel="noopener ugc nofollow" target="_blank"> equals()方法</a>(假设它是为每个对象定义的，这对<a class="ae ko" rel="noopener" href="/javarevisited/10-best-places-to-learn-java-online-for-free-ce5e713ab5b2"> Java </a>和<a class="ae ko" rel="noopener" href="/javarevisited/10-best-scala-and-functional-programming-online-courses-for-beginners-b6461b27bf"> Scala </a>都是正确的)，我们不想关心数组中实际包含哪种确切类型的对象。</p><p id="003d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Java中，Integer[]是Number[]的子类，它们都是Object[]的子类。这叫做<strong class="is hj">协方差</strong>。给定A &lt; : B(意思是A是B的子类)，如果T【A】&lt;:T【B】那么T在其类型中是协变的。给定同样的关系A &lt; : B，如果T【B】&lt;:T【A】那么T在其类型中是<strong class="is hj">逆变</strong>。</p><p id="e6f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果这是你第一次听说contravariance，它可能现在对你来说没有多大意义，但是等到这篇文章的结尾。最后，如果T[A]和T[B]没有关系，尽管事实上一个<: b="" then="" we="" say="" t="" is="" class="is hj">不变量在其类型中。</:></p><p id="1a35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，Java中的数组是协变的。我们可以有一个方法isEqual()或sort()或shuffle()，它接受一个对象数组，我们可以传入我们想要的任何数组。耶！我们也可以定义一个方法，接受一个几何形状的数组，然后传入几何形状的数组，或者三角形，或者等边三角形，等等。最佳的多态性。</p><p id="22f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，这是有代价的。假设我们有一个整数数组。这是一个对象数组的子类，对吗？因此，如果我有一个名为“objectArray”的变量，它是一个对象数组，将我们的整数数组赋给objectArray是完全有效的。</p><p id="7ae2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了一个变量objectArray，它被编译器视为一个对象数组，但是在它的下面，我们真正拥有的是一个整数数组。好的，这还不是一个大问题……但是，在编译器看来，我们的整数数组现在是一个对象数组！我们被允许存储字符串、三角形和香蕉——编译器将只是站在那里，让它发生。当然，在运行时，当我们从保存整数数组的原始变量(或者，更准确地说，变量*认为*它仍然保存整数数组，而实际上它保存所有类型的东西)中获取内容时，我们的代码会崩溃和烧毁。</p><p id="efea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们遇到了一个问题。但是怎么办呢？现在已经没有回头路了(我们说的是2004年)，因为全世界已经有成千上万的商业项目在使用Java。数组必须保持“可攻击性”。但是，Java 5中出现了一个叫做<em class="kp">泛型</em>的很酷的新事物。你可能已经知道，它们是用Java写在&lt; &gt;里面的，而<a class="ae ko" rel="noopener" href="/javarevisited/7-free-scala-and-functional-programming-courses-for-beginners-370f3cd41a4e"> Scala </a>用的是[]符号。泛型允许任何类拥有一个类型标签，就像数组一样，但是与数组不同，这些类型标签<strong class="is hj">不是协变的</strong>。</p><p id="5e53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，在Java中，MyClass <string>不是MyClass <object>的子类。太好了，仿制药不能速成！但是，是的，这意味着我们没有数组的那种简洁的多态性特征。无法向采用MyClass <object>的方法传递MyClass <string>的实例。我们也不能在需要对象列表的地方传递字符串列表。真遗憾。我们总是可以强制进行一些难看的造型，但是这在运行时可能是危险的(让我们回到我们讨厌数组的地方),并且被认为是一个大禁忌。</string></object></object></string></p><h2 id="7dce" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">前往救援</h2><p id="ebe2" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在这种情况下，有一种方法可以实现多态性(即协方差和逆变)——通过使用<strong class="is hj">有界通配符。</strong>通配符有两种界限——上限和下限。上限允许“从上面”限制类型，也就是说，指定层次结构中允许的最高级别，而下限通过指定允许的最低类型来“从下面”限制类型。下面是一个上限通配符的示例:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="52ba" class="jo jp hi kv b fi kz la l lb lc">public void process(List<strong class="kv hj">&lt;? extends Car&gt;</strong> list) { ... }</span></pre><p id="09bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着process()接受由Car或Car的任何子类参数化的列表。耶，协方差！而如果我们用super来切换extends，它就变成了一个下界:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="dca4" class="jo jp hi kv b fi kz la l lb lc">public void process(List<strong class="kv hj">&lt;? super Car&gt;</strong> list) { ... }</span></pre><p id="ff9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在process()只接受Car或者Car的<em class="kp">任何超类</em>参数化的列表，这样就实现了逆变。</p><p id="8c62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很好。我们得到了我们想要的多态性。我们有一个方法process()，它的参数在类型上可以是协变的，也可以是逆变的，这取决于我们使用的是上限还是下限通配符。注意，Java中的边界不仅可用于通配符，也可用于类型参数，因此我们可以声明一个类，如MyClass，T extends Car，T12。类型参数(如T)不同于通配符(用？)在某种意义上，它可以在代码的其余部分重用。与有界通配符相比，有界类型参数有两个主要区别:</p><ul class=""><li id="06c1" class="ld le hi is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll bi translated">使用类型参数，您可以指定多个绑定的<strong class="is hj">。但是因为在Java中你只能扩展一个超类，其他的边界指定了必须实现的接口。例如，MyClass &lt; T扩展Bird&amp;CanSwim&amp;CanRun&gt;意味着MyClass实例的类型参数必须扩展Bird并实现can swim和can run。</strong></li><li id="d4e7" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated"><strong class="is hj">只有上限</strong>可以用于类型参数。这意味着MyClass &lt; T扩展Bird &gt;可以，但是MyClass &lt; T超级Bird &gt;不会编译。原因超出了本文的范围(已经够长了)，但是我们不会在类型参数上使用界限，所以我想这没问题。让我补充一下，在Scala中，类型参数可以有上限和下限，分别写为[T &lt; : Bird]和[T &gt; : Bird]。</li></ul><p id="5d99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们回到通配符的界限，因为它们确实为我们提供了协方差和逆变。我们实现了多态性，并且能够为process()方法提供List <car>的子类型或超类型，这取决于我们是将List参数声明为协变的(使用上限)还是逆变的(使用下限)。现在，在使用有界通配符时，有一些重要的限制必须考虑:我们只能从协变列表中获取内容，并且只能将内容放入逆变列表中。实际的规则更加通用，因为参数化的类可以是任何东西，而不仅仅是类似列表的容器。事情是这样的:我们只能用<strong class="is hj">协变类型参数作为返回类型</strong>，只能用<strong class="is hj">逆变类型参数作为输入类型</strong>。让我们在List get-put示例中解释这一点。</car></p><p id="3adc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在协变列表 extends Car&gt;(也称为上界列表)的情况下，我们知道里面有Car的实例。有些是跑车，有些是豪华轿车，也许我们还有进一步的子类(例如阿斯顿马丁)，但它们都是汽车。我们可以从这个列表中得到对象，并且知道我们得到的是一辆汽车。然而，由于我们不知道实际的底层类型是什么(汽车或跑车或阿斯顿马丁)，如果这样的列表允许将东西放入其中，那么我们会遇到与数组相同的问题。我们可以创建一个跑车列表，安全地将它赋给一个List <car>变量，然后“安全地”(就编译器而言)将豪华轿车放入其中。在运行时，我们会再次崩溃和燃烧。我们唯一允许放入的是null，因为它扩展了所有东西，所以不管实际的底层类型是什么，null都会扩展它。</car></p><p id="ab5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，在逆变列表 super Car&gt;(也称为下界列表)的情况下，我们知道把汽车放在里面是安全的(这包括子类型如AstonMartin它们也是汽车)。无论实际的底层类型可能是什么(例如，Vehicle或AnyRef)，每辆车都扩展它，所以如果我们在实际的底层类型是Vehicle时放置一个AstonMartin，我们没有做错什么，不是吗？阿斯顿马丁是一种交通工具。但是现在的情况与上限相反——虽然我们可以放置汽车，但是我们不能从这个列表中获得任何东西(实际上，我们可以，但是它是Object类型的，这不是很有用)。我们不能得到一辆车，因为如果基础类型是，比如说，一辆车，那么我们就有麻烦了。我们不知道实际的潜在类型是什么——就我们所知，列表中也可能充满了摩托车、拖拉机和水陆两用沙滩车。从该列表中获取Car类型的对象可能会导致运行时异常。</p><p id="19a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是所有代码:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="2d4b" class="jo jp hi kv b fi kz la l lb lc">List&lt;? extends Integer&gt; a = new ArrayList&lt;Integer&gt;();<br/>List&lt;? super Integer&gt; b = new ArrayList&lt;Integer&gt;();</span><span id="99b8" class="jo jp hi kv b fi lr la l lb lc">a.add(3);    // fails; let’s try with null<br/>a.add(null); // works<br/>b.add(3);    // no problem here</span><span id="0bc7" class="jo jp hi kv b fi lr la l lb lc">Integer ai = a.get(0); // no problem here either<br/>Integer bi = b.get(0); // fails; let’s try with Object<br/>Object o = b.get(0);   // works</span></pre><p id="a98d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你也可以这样想:在这两种情况下，你只能放入最低(最具体)的允许类型，你只能得到最高(最一般)的允许类型。对于协变(上限)列表，允许的最低类型是null，最高类型是Car，而对于逆变(下限)列表，允许的最低类型是Car，最高类型是Object</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="a30e" class="jo jp hi kv b fi kz la l lb lc">                upper bound            lower bound<br/>       null ------------------- Car ------------------- Object</span></pre><p id="f4b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好，所以我们只能从协变列表中得到东西，也只能把东西放到逆变列表中。这被称为<em class="kp">获取-放置原则</em>。现在让我们回到更一般的规则:</p><ul class=""><li id="7cce" class="ld le hi is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll bi translated">对于<strong class="is hj">返回</strong>泛型类型的方法，使用<strong class="is hj">协方差</strong></li><li id="4200" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">对于<strong class="is hj">将</strong>作为泛型的方法，使用<strong class="is hj">逆变</strong></li><li id="e7a9" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">对于<strong class="is hj">和</strong>都接受并返回泛型类型的方法，使用<strong class="is hj">不变性</strong></li></ul><p id="ec2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快速回顾:Java中的数组是<a class="ae ko" href="https://javarevisited.blogspot.com/2014/03/covariant-method-overriding-of-java-5.html" rel="noopener ugc nofollow" target="_blank">协变的</a>，这允许脏东西使我们的代码崩溃和烧毁。泛型(我们也可以称之为参数化的)类是不变的，这使得它们不受崩溃和烧毁的影响，但是我们失去了多态性。我们可以通过使用通配符界限来实现每个方法的协方差和逆变(并带回多态性)，但是在为一个方法定义方差时，我们必须记住get-put原则。</p><h2 id="2b2c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">Scala呢？</h2><p id="55fc" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">首先，在Scala中，数组是<strong class="is hj">不变的</strong>，这就排除了崩溃和烧毁的可能性。至于列表，它们现在默认是<strong class="is hj">协变的</strong>。由于它们的不变性，它们协变是安全的；不会有人将一个整数列表赋给一个对象列表(因为不可变性不允许重新赋值；相反，对列表的每个“添加”操作都返回一个新列表)。不变性将我们从失去多态性和崩溃烧毁场景之间的尴尬困境中解救出来。</p><p id="9292" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，让我们诚实地说，这并不是一个重大的改进。数组只是追求较小的邪恶(它们现在没有多态性，而不是易于崩溃和烧毁)，列表变得协变只是因为它们在默认情况下是不可变的。你也可以在Java 中使用<a class="ae ko" href="https://javarevisited.blogspot.com/2018/02/java-9-example-factory-methods-for-collections-immutable-list-set-map.html" rel="noopener ugc nofollow" target="_blank">不可变列表(比如在Guava库中的ImmutableList)或者实现他们自己的列表，并使用上限来寻找协方差。</a></p><p id="e22e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">真正的进步在语言本身。Java只支持<strong class="is hj"> use-site variance，</strong>表示使用类型参数<em class="kp">时定义方差。</em>在实践中，这意味着使用有界通配符为每个方法分别定义。</p><p id="5155" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，Scala既支持use-site variance(语法类似于Java，只是用[_ <: t="" and="" class="is hj">声明-site variance替换了 extends T&gt;。 Declaration-site，顾名思义就是在类型参数<em class="kp">声明</em>时定义方差。您可以简单地通过在类型参数前面加上“+”来声明协方差，而“-”表示逆变(没有符号意味着不变性)。</:></p><p id="d241" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，在Java里你会说:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="2811" class="jo jp hi kv b fi kz la l lb lc">public class Foo&lt;T&gt; { ... }<br/>...<br/>Foo&lt;? extends Integer&gt; covariantFoo = new Foo&lt;Integer&gt;();<br/>Foo&lt;? super Integer&gt; contravariantFoo = new Foo&lt;Integer&gt;();</span></pre><p id="a305" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，在一种情况下，Foo看起来是协变的(协变Foo)，而在另一种情况下是逆变的(逆变Foo)。它没有预先声明为协变或逆变；相反，它的差异是在它被使用的地方(使用地点)定义的。</p><p id="f809" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Scala中，你可以做同样的事情，只是语法有些不同(分别使用[_ <: integer="" and=""> : Integer])，但是你也可以在前面声明variance(declaration-site):</:></p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="d9f8" class="jo jp hi kv b fi kz la l lb lc">class CovariantFoo[+T] { ... }<br/>class ContravariantFoo[-T] { ... }<br/>...<br/>val covariantFoo = new CovariantFoo[Int]()<br/>val contravariantFoo = new ContravariantFoo[Int]()</span></pre><p id="0a06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这次我们有两个类，每个类都将其类型参数声明为协变或逆变。这里有一个简短的总结:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="9360" class="jo jp hi kv b fi kz la l lb lc"><strong class="kv hj">Covariance</strong>                           <br/>if A is a <em class="kp">subtype</em> of B then:<br/>Java:  L&lt;A&gt; is a subtype of L&lt;? extends B&gt; (use-site)<br/>Scala: L[A] is a subtype of L[_ &lt;: B]      (use-site)<br/>       L[A] is a subtype of L[+B]          (declaration-site)</span><span id="c00b" class="jo jp hi kv b fi lr la l lb lc"><strong class="kv hj">Contravariance</strong><br/>if A is a <em class="kp">supertype</em> of B then:<br/>Java:  L&lt;A&gt; is a subtype of L&lt;? super B&gt; (use-site)<br/>Scala: L[A] is a subtype of L[_ &gt;: B]    (use-site)<br/>       L[A] is a subtype of L[-B]        (declaration-site)</span></pre><p id="d197" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用站点和声明站点哪种方法更好？一般来说，两者都不好。它们是实现目标的不同方式。我个人更喜欢声明站点差异，因为它与整个“不可变的，因此很容易推理”的函数范型(Scala也允许您以命令式、非函数式的方式编写，但这是非常不鼓励的)。一旦你声明了你的类型参数的方差，就不能在剩下的代码中改变它们。</p><p id="1620" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，由于您是设计者，最好将声明差异的负担放在您自己身上；如果你把这个负担放在你的客户身上，他们可能会滥用它。引用Scala中的编程[1]:</p><blockquote class="ls lt lu"><p id="6cf3" class="iq ir kp is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">[使用站点差异]需要放入通配符的将是类的客户端，如果他们弄错了，一些重要的实例方法将不再适用。变化是一件棘手的事情，用户通常会弄错，他们会认为通配符和泛型过于复杂。通过定义位置差异，您向编译器表达了您的意图，编译器将仔细检查您希望可用的方法是否确实可用。</p></blockquote><p id="14e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Scala编译器到底双重检查什么？它检查你是否通过在逆变位置使用协变类型违反了方法定义中的协变和逆变的<strong class="is hj">规则，反之亦然。请注意，这与获取-输出原则直接相关；这只是它的一个更一般化的版本。我们可以称之为<em class="kp">协变位置——逆变位置</em>原理。它说协变类型可以作为方法返回类型，但不能作为方法参数类型，而对于逆变类型则相反。</strong></p><p id="d6f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个例子。我们可以从一开始就重温我们的老例子；它声称，如果没有get-put原则，“我们可以创建一个跑车列表，安全地将其赋给一个<code class="du ly lz ma kv b">List&lt;Car&gt;</code>变量，然后将豪华轿车放入其中”。现在，由于<a class="ae ko" href="https://javarevisited.blogspot.com/2018/01/10-reasons-to-learn-scala-programming.html#axzz5qk6KSalU" rel="noopener ugc nofollow" target="_blank"> Scala </a>支持不可变的值，这不会太糟糕。我们的旧跑车列表将仍然是跑车列表，而新列表将是所有类型的汽车列表。将豪华轿车加入跑车清单没有任何危险。让我用一个更好的例子来说明协变和逆变的规则。</p><p id="6a30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果Foo[T]在其类型T中是协变的，这意味着我们可以把一些Foo[SportsCar]当作Foo[Car]，对吗？好的，但是如果Foo[SportsCar]是Foo[Car]的子类，那么它必须支持来自Foo[Car]的所有方法(并且可能添加一些自己的、更具体的方法)。现在，如果Foo有一些方法使用T类型的值作为它的参数<em class="kp"> </em>(也就是在逆变位置)呢？这个特殊的方法在Foo[Car]中接受豪华轿车没有问题，但是现在在Foo[SportsCar]中突然只接受跑车了！我们将有一个在超类中工作的调用(传递一个limo给那个方法)，但是不能在子类中工作。这将违反整个子类-超类的概念。返回值类型为T的方法是可以的，因为返回一辆跑车遵守超类返回一辆车的义务。</p><p id="0b5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于类型逆变的类来说，情况正好相反。将T传递给方法是可以的——因为Foo的类型是逆变的，这意味着Foo的子类是所有那些由Car的超类型参数化的子类，比如Foo[Vehicle]或Foo[Any]。在这种情况下，使用汽车的方法就变成了使用汽车或任何其他工具的方法。这是可以的。必须遵守的是，在原始类中获取汽车的方法必须能够在子类中获取汽车，而不是像我们在SportsCar示例中看到的那样缩小范围。这确实实现了。如果我们用Foo[Car]替换它的一个子类，比如Foo[Vehicle]，那么任何使用Foo[Car]的方法为它提供cars的代码都可以工作。把汽车喂给一个吃Foo[Vehicle]的方法就可以了。</p><p id="49b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是现在在Foo是逆变的情况下，当我们想让一个方法返回一个Car类型的值时，我们遇到了问题。在协方差的情况下，它将返回豪华轿车，跑车，阿斯顿马丁等。事实上，它们都是汽车。然而，作为一个Foo[Car]并让你的子类返回一个Foo[Vehicle](不要忘记Foo是逆变的，所以它的子类必须由Car的超类型参数化)是不太正确的，因为拥有子类的全部意义在于你可以在任何需要它的父类的地方插入它，而这在这种情况下是不可能的。使用Foo[Vehicle]这样的子类会将我们的方法调用的结果限制为vehicles，这意味着我们的旧代码将不再工作(也许它会对结果调用“摔门”,但它真正得到的结果是一辆摩托车；法只答应给我们一辆车，记得吗？).如果这有点难以消化，不要担心。这真的不是一件小事。在下一节中，我将提供一个更丰富的关于对比的例子，当你读完这篇文章的时候，事情应该会变得有条不紊。</p><p id="f369" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回到我们的规则。因此，声明位置方差允许编译器检查协变和逆变规则是否得到遵守。然而，如果你使用使用位置变化，你的编译器不能帮助你使用这些规则，因为它不知道你的类在它的类型中是协变的还是逆变的。差异声明被推迟到使用该类的时候。这意味着你作为类的设计者，对这些东西没有控制权。您将定义您的类方法，并且您将祈祷您的类的未来用户将仅当他们将您的类实例化为协变时调用get-like方法，并且仅当他们将它实例化为逆变时调用put-like方法。协变/逆变的争论现在在他们的手上。我不知道你怎么想，但我更愿意自己承担这种丑陋的工作，让他们的生活更轻松。</p><p id="d34b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一节(也是最后一节),我将通过子类型化一个函数来提供一个Scala差异的例子。Scala中的函数是一等公民；它们不仅可以作为参数传递、从方法返回、保存在集合中等等。，但它们也可以是子类型和超类型。因此，除了子类和超类，你还可以有子函数和超函数！</p><h2 id="8d4c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">函数子类型的变化</h2><p id="4c06" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">Scala中的每个单参数函数实际上都是Function1 trait的一个实现(实际上要复杂一些，但为了简洁起见，这里省略了细节):</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="ca7f" class="jo jp hi kv b fi kz la l lb lc">trait Function1[-S, +T] { def apply(x: S): T }</span></pre><p id="f00a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意Function1在S中是逆变的，在t中是协变的，Function1 trait的某些实现(姑且称之为MySubFunction[S1，T1])是另一个(姑且称之为MySuperFunction[S2，T2])的子类，前提是它遵守Function1中提供的方差规则(也就是说，如果S2 <: s1="" and="" t1="" t2=""/></p><p id="3f74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">This rule of function being covariant in its input type and contravariant in its return type comes from the <em class="kp">利斯科夫替代原理</em> (LSP)。它说T是U的子类型，如果它支持与U相同的操作，并且它的所有操作<strong class="is hj">比U中的相应操作需要更少的</strong>(或相同)<em class="kp"> </em>和<strong class="is hj">提供更多的</strong>(或相同)(子类型是自反的，所以S &lt; : S)。</p><p id="682a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好，让我们看看这是什么意思。想一个函数:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="1304" class="jo jp hi kv b fi kz la l lb lc">def getCarInfo: Car =&gt; AnyRef</span></pre><p id="afa2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些都是getCarInfo的有效子类型:</p><ul class=""><li id="e0f1" class="ld le hi is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll bi translated">Car =&gt; AnyRef</li><li id="b03f" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">车辆=&gt; AnyRef</li><li id="6a9e" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">汽车= &gt;字符串</li><li id="f6c6" class="ld le hi is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">车辆= &gt;字符串</li></ul><p id="c0f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它们都像Car =&gt; AnyRef一样要求更少(或相同)，提供更多(或相同)。“少”就是“比较笼统”，“多”就是“比较具体”。这非常符合逻辑:vehicle是“小于”Car，因为我们对该对象了解较少(我们只知道它是vehicle，但不知道它是哪种类型的Vehicle)，而它是“大于”AnyRef，因为它提供给我们的不仅仅是AnyRef对象(我们在Vehicle中定义了所有的字段和方法)。</p><p id="d99e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们仔细看看这四种亚型。第一个和getCarInfo完全一样，这没问题，因为子类型是自反的(这也是我在LSP的定义中less/more后面加“or same”的原因)；第二个要求更少，因为它不仅仅局限于汽车——它允许任何车辆，这比汽车要求更低；第三个提供了更多，因为它不是只提供AnyRef，而是提供了更丰富的类型字符串；第四种比getCarInfo要求更少，提供更多。</p><p id="0b96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">停下来想一想。这是协变和逆变的全盛时期！如果我希望函数B是函数A的一个<strong class="is hj">子类</strong>，那么B的输入参数必须是A的输入参数(协方差)的一个<strong class="is hj">超类</strong>，B的返回值必须是A的返回值(协方差)的一个<strong class="is hj">子类</strong>。</p><p id="5c57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们构建一个完整的示例。代码如下:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="66a8" class="jo jp hi kv b fi kz la l lb lc">1   /**<br/>2    * Remember! In Scala, every function that takes one argument <br/>3    * is an instance of Function1 with signature:<br/>4    *<br/>5    * trait Function1[-T, +S] extends AnyRef<br/>6    */<br/>7   <br/>8   class Vehicle(val owner: String)<br/>9   class Car(owner: String) extends Vehicle(owner)<br/>10  <br/>11  object Printer {<br/>12<br/>13    val cars = List(new Car("john"), new Car("paul"))<br/>14<br/>15    def printCarInfo(getCarInfo: Car =&gt; AnyRef) {<br/>16      for (car &lt;- cars) println(getCarInfo(car))<br/>17    }<br/>18  }<br/>19  <br/>20  object Customer extends App {<br/>21<br/>22   val getOwnerInfo: (Vehicle =&gt; String) = _.owner<br/>23   <br/>24   Printer.printCarInfo(getOwnerInfo)<br/>25  }</span></pre><p id="404c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看printCarInfo方法(第15行),该方法将函数Car =&gt; AnyRef作为参数:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="fb12" class="jo jp hi kv b fi kz la l lb lc">def printCarInfo(getCarInfo: Car =&gt; AnyRef)</span></pre><p id="ef0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们要从自定义代码中调用这个方法(第24行)，我们必须要么传递一个具有相同签名的函数(Car =&gt; AnyRef)，要么传递一个Car =&gt; AnyRef的子类型的函数，也就是说，它需要更少或相同的内容，并提供更多或相同的内容。在示例中，我们选择了第二个选项，并传入了一个函数(在第22行中定义),该函数要求比Car(一辆车)少，但提供的比AnyRef(一个字符串)多:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="1d29" class="jo jp hi kv b fi kz la l lb lc">val getOwnerInfo: (Vehicle =&gt; String) = _.owner</span></pre><p id="5b5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很好，LSP得到满足，所以我们的函数Vehicle =&gt; String是Car =&gt; AnyRef的有效子类型。</p><p id="07a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">printCarInfo方法在第16行使用getCarInfo函数从汽车中获取信息并打印出来。即使printCarInfo代码对我们不可用，我们看不到方法内部，我们仍然知道它必须将cars(不要忘记这也包括子类型，例如AstonMartin)提供给getCarInfo。它的特征告诉我们。因此，如果我们说getCarInfo的替代函数使用了Vehicle，我们没有破坏任何东西，因为所有的汽车及其子类型都是Vehicle。我们所做的只是提供了一个<em class="kp">需要更少</em>的函数，所以printCarInfo不会注意到任何不同。printCarInfo说的是——“酷，不管怎样，只要你给我提供一个能接受我的车的功能，我就很好”。而一个接受车辆的功能当然也接受汽车。</p><p id="6c40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，我们的Vehicle =&gt; String返回一个字符串，这意味着它<em class="kp">提供了更多的</em>。printCarInfo说的是它想要一个返回AnyRef的函数。String是AnyRef吗？是的，它是。再说一次，我们没有打破任何东西。</p><p id="3465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！我们已经表明Vehicle =&gt; String是Car =&gt; AnyRef的完全有效的替代。PrintCarInfo将继续正常的工作流程，而不会注意到提供给它的不是Car =&gt; AnyRef，而是Vehicle =&gt; String。我们已经在真实的例子中，而不是在一些深奥的理论解释中，看到了方差家族中怪异的小成员——逆变。</p><p id="febe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以你有它。我对方差的解释到此为止。如果你想给我一些反馈，请随时联系我在sinisalouc@gmail.com。</p><h2 id="2c85" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">参考</h2><p id="a962" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">[1]: Martin Odersky，Lex Spoon，Bill Venners，《Scala中的<a class="ae ko" href="http://www.amazon.com/dp/0981531644/?tag=javamysqlanta-20" rel="noopener ugc nofollow" target="_blank">编程》，第二版</a></p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><h2 id="9c62" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">进一步学习</strong></h2><p id="374a" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated"><a class="ae ko" href="http://javarevisited.blogspot.sg/2017/04/5-books-to-learn-scala-and-functional-programming.html" rel="noopener ugc nofollow" target="_blank">学习Scala和函数式编程的5本书</a> <br/> <a class="ae ko" href="https://hackernoon.com/10-reasons-to-learn-scala-and-functional-programming-2fce385e6ec7" rel="noopener ugc nofollow" target="_blank">学习Scala的10个理由</a>on<a class="mi mj ge" href="https://medium.com/u/4a8a924edf41?source=post_page-----63af925d21dc--------------------------------" rel="noopener" target="_blank">hacker noon</a><br/><a class="ae ko" href="https://hackernoon.com/a-10-minute-introduction-to-scala-d1fed19eb74c" rel="noopener ugc nofollow" target="_blank">一个10分钟的Scala介绍</a>by<a class="mi mj ge" href="https://medium.com/u/1c96b0f1c413?source=post_page-----63af925d21dc--------------------------------" rel="noopener" target="_blank">Teiva Harsanyi</a><br/><a class="ae ko" href="https://javarevisited.blogspot.com/2019/01/5-free-scala-programming-courses-for-java-programmers-learn-online.html" rel="noopener ugc nofollow" target="_blank">学习Scala的5门免费课程</a> <br/> <a class="ae ko" href="https://javarevisited.blogspot.com/2017/03/top-30-scala-and-functional-programming.html" rel="noopener ugc nofollow" target="_blank">前30名Scala编程面试问题</a> <br/> <a class="ae ko" rel="noopener" href="/@sderosiaux/a-guide-to-introduce-scala-in-a-java-world-327b932699b4">一个案例介绍Java世界中的Scala</a></p><div class="mk ml ez fb mm mn"><a rel="noopener follow" target="_blank" href="/javarevisited/7-free-scala-and-functional-programming-courses-for-beginners-370f3cd41a4e"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">2021年7门面向初学者的免费Scala和函数式编程课程</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">我最喜欢的2021年学习Scala和函数式编程的免费在线课程、认证和教程来自…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">medium.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb io mn"/></div></div></a></div><div class="mk ml ez fb mm mn"><a rel="noopener follow" target="_blank" href="/javarevisited/10-best-scala-and-functional-programming-online-courses-for-beginners-b6461b27bf"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hj fi z dy ms ea eb mt ed ef hh bi translated">2021年面向初学者的10门最佳Scala和函数式编程在线课程</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">我最喜欢的从Udemy，Coursera，和Pluralsight学习和掌握Scala编程语言的课程，包括…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">medium.com</p></div></div><div class="mw l"><div class="nc l my mz na mw nb io mn"/></div></div></a></div></div></div>    
</body>
</html>