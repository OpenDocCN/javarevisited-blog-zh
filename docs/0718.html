<html>
<head>
<title>Configuring multiple validators using Spring validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring验证配置多个验证器</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/multiple-validations-using-spring-validation-aee5d89f0e79?source=collection_archive---------2-----------------------#2020-10-02">https://medium.com/javarevisited/multiple-validations-using-spring-validation-aee5d89f0e79?source=collection_archive---------2-----------------------#2020-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/428657b0077eda580254390dce4f22ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*13WFbAEeKBMRv6iS"/></div></div></figure><p id="4503" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Spring通过Spring Validation简化了请求验证，Spring Validation使我们能够将验证器绑定到控制器。</p><p id="909a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用基于Spring的验证，控制器的验证器是通过在控制器中用@Initbinder注释接受WebDataBinder类型的参数和void返回类型的方法来指定的。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/a4c0743c3e865d5048cd955e6ae3a377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FWZat923K_fy01A22H6Mrw.png"/></div></div></figure><p id="d2b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这种方法有其自身的局限性。我将在此详细阐述可能出现的问题以及您可以规避它们的方法。</p><p id="de7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只要控制器有一个接受RegistrationForm类型请求的单个端点，或者有多个接受相同类型请求的端点，一切似乎都很好。</p><p id="4266" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，当我们有两个不同的端点，有两种不同的请求类型，即RegistrationForm和PaymentInformation时，一切都乱套了。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/075be7eaa8aef884fae0ba7615bd536c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcelmIvEgqSxfxt8s_20VA.png"/></div></div></figure><p id="4fd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，使用@initbinder绑定的验证器将应用于控制器的所有端点，而不考虑其类型。</p><p id="6bb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，尽管我们的目的只是验证RegistrationForm类型的输入，但现在将在registration form和PaymentInformation上强制执行验证。这导致了IllegalStateException，因为spring现在试图在请求被发送到支付端点时用EmailValidator验证PaymentInformation请求</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/52305182c16ca43d778ce9c3d2b36c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*ZthYHhR_IXjCRUDlUBcL-g.png"/></div></figure><p id="eaaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过在@InitBinder注释中明确指定我们想要验证的输入类型，我们可以避免跨端点对所有输入字段进行隐式强制验证</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/b163abc1ef916dd9c6f2113bd9e47d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*Sild8d9-wcDE7YEsHMe7ug.png"/></div></figure><p id="e523" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这告诉spring验证器只应用于RegistrationForm类型的请求。</p><p id="d29a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止一切顺利。但是在某些情况下，我们希望验证不同类型的请求参数。一个看似显而易见的解决方案是为每个控制器配置多个验证器。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jv"><img src="../Images/7268ef9c2eea85d85d0cf92da5153a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*53oMLDSX7WwTJAVJqVcoow.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jw"><img src="../Images/64ccf3fe05105d38dd3ec6dea2d84dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*DmyRrNW6d5bj9a5xLiA4TA.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/e97b33c9ff67eda14860d6e5522c6643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVX3ioOPN9dc9LUW1ThChA.png"/></div></div></figure><p id="f664" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的例子中，我们有两个端点，每个端点都有不同类型的输入，每个端点都需要不同的验证器。</p><p id="374a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在用@InitBinder注释的方法中使用WebDataBinder参数上的addValidators指定多个验证器似乎是一个解决方案。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/5f1c7838d687ff83adacc8b85b3b42e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*ZqeMSqdMYPd6dzaOEcwerg.png"/></div></figure><p id="4480" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，使用@Initbinder不能指定多个验证器，否则会导致新的问题。</p><p id="b791" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个明显的缺陷是两个验证现在都将应用于两个端点。</p><p id="a1a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们又回到了起点。</p><p id="3c3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但并不是所有事情都像看上去那么糟糕。我们仍然可以通过基于绑定上下文信息指定要使用的验证器来解决这个问题</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/04d17878847db2ff3f7b341f876ec77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*gzpRWG2swC3e_DcGAuixoA.png"/></div></figure><p id="6046" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们确定请求字段的类型，并应用适当的验证器，从而成功地用两个验证器配置控制器，同时根据请求类型限制验证的应用。</p><p id="84ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一种简洁的方法是创建一个通用/复合验证器，并使用@InitBinder绑定它</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/46555b3f7c5704c873fe9a4234312ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*ei6Uew7tV7L5VVDYifUxaQ.png"/></div></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/39215c9b1c8be644e5dcc14f47897ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*0y9Rn6v5y1WNEmEji6enrw.png"/></div></figure><p id="b41f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里需要注意的是，当请求参数的类型是付款信息或注册表单时，我们配置override方法以返回true。</p><p id="6eb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，我们通过配置validator()方法来调用适当的验证器，以根据作为参数传递给方法的请求类型来触发验证</p><p id="22e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们不仅用多个验证器配置控制器，而且还控制验证的应用。</p></div></div>    
</body>
</html>