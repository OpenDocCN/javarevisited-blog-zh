<html>
<head>
<title>Make your microservices independent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的微服务独立</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/make-your-microservices-independent-7e4e48173bac?source=collection_archive---------1-----------------------#2021-08-01">https://medium.com/javarevisited/make-your-microservices-independent-7e4e48173bac?source=collection_archive---------1-----------------------#2021-08-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c74c9f3a3ec660539d4bbd94c4010957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uuGGxTwa4fmNUTIc"/></div></div><p class="iq ir et er es is it bd b be z dx translated">基特·苏曼在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3916" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">微服务架构现在被广泛使用。许多公司使用它，但不是每个人都百分之百地使用它。要让微服务大放异彩，三个方面必不可少:</p><ol class=""><li id="bb25" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">独立进化</li><li id="3ded" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">独立测试</li><li id="b5cf" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">独立部署</li></ol><p id="95ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">微服务真正的热闹是在所有这些点都满足的时候。否则，部署新版本可能需要与其他团队协调，级联所有依赖服务的更新，并祈祷所有更新都能成功滚动。级联回滚是一次冒险。</p><h1 id="319e" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">独立进化</h1><p id="90ca" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我们的应用程序会随着时间的推移而发展。这是一个不可避免的过程，因为企业无法提前预测所有必要的功能，开发人员也无法在一周内完成所有工作。</p><p id="7614" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们谈论<a class="ae iu" rel="noopener" href="/javarevisited/top-5-books-and-courses-to-learn-restful-web-services-in-java-using-spring-mvc-and-spring-boot-79ec4b351d12?source=---------17------------------"> REST </a>，那么有一百万篇关于API进化的文章告诉我们如何在不影响消费者的情况下更新它们。</p><p id="7233" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用消息队列(如<a class="ae iu" rel="noopener" href="/javarevisited/top-10-apache-kafka-online-training-courses-and-certifications-621f3c13b38c"> Kafka </a>)时，要注意Avro，不要快速启动JSON。Avro支持模式进化和兼容性，这将在未来为您节省大量时间。</p><p id="8314" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">专有协议仍然是你的良心。你可能要重新发明轮子。</p><h1 id="f1ab" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">独立测试</h1><p id="decf" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">有了测试，一切通常听起来很简单，但实际上，在一个请求的过程中，服务不得不拉一个又一个。测试不再如此独立。</p><p id="7f50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我建议查看<a class="ae iu" href="https://cloud.spring.io/spring-cloud-contract/2.1.x/multi/multi__spring_cloud_contract_wiremock.html" rel="noopener ugc nofollow" target="_blank">Spring Cloud Contract wire mock</a>和<a class="ae iu" href="https://docs.spring.io/spring-restdocs/docs/current/reference/html5/" rel="noopener ugc nofollow" target="_blank"> Spring REST Docs </a>，它允许您:</p><ol class=""><li id="629a" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">基于测试编写文档</li><li id="f3ad" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">生成一个清除服务的工件</li><li id="71bd" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">在其他微服务的测试中使用这个存根来模拟对它的调用</li></ol><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="lo lp l"/></div><p class="iq ir et er es is it bd b be z dx translated">Spring Cloud合同使用示例</p></figure><p id="12ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，您可以不太担心依赖服务在现实中会如何反应，因为您将使用它们的实际存根。</p><h1 id="d7ca" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">独立部署</h1><p id="5d70" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">不是每个人都能承受更新时的服务停机时间。但如果更新过程中出现循环依赖(新A需要新B，新B需要新C，新C需要新A)，这是不可避免的。我相信没有人愿意和其他团队协调发布新版本的微服务。在关于独立进化的第一节中，我们谈到了如何解决这个问题。但是还有一个问题——服务必须与它自己的先前版本相处。</p><p id="707d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能听说过蓝绿色部署和金丝雀部署这两个术语。这些方法假设新旧版本将共存一段时间。这意味着使用相同的数据库、分布式缓存等。</p><p id="041d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们所需要的是保持与1版本的兼容性。</p><p id="3d70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在关系数据库的情况下，新版本可能会在升级期间将一些迁移转移到数据库上。<br/>因此，如果您需要从版本1中更改一个字段，那么最好分三步完成:</p><ol class=""><li id="78f1" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">在版本2中添加一个新字段，并支持这两个字段</li><li id="f7e1" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">在版本3中，开始只使用新版本</li><li id="7b02" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">删除版本4中的旧版本</li></ol><p id="0610" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，如果新版本出现问题，以前的版本仍然可以正常工作，您不需要停止服务并恢复数据库。</p><p id="e7e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似的方法也适用于分布式缓存和NoSQL数据库</p><h1 id="60a6" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">结论</h1><p id="caa2" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">以上都需要努力。同时支持不同的API版本，准备测试存根(尤其是第一次)，分几个步骤改变数据结构——所有这些都需要时间。因此，发布可能会延迟。但是为了充分利用微服务架构，需要做这些额外的工作。</p></div></div>    
</body>
</html>