<html>
<head>
<title>OAuth 2.0 with Google Client Libraries: Java SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Google客户端库的OAuth 2.0:Java SDK</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/oauth-2-0-with-google-client-libraries-java-sdk-e5439accdf7a?source=collection_archive---------1-----------------------#2022-03-19">https://medium.com/javarevisited/oauth-2-0-with-google-client-libraries-java-sdk-e5439accdf7a?source=collection_archive---------1-----------------------#2022-03-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/02/spring-security-interview-questions-answers-java.html#axzz6qnblZnVj"><div class="er es if"><img src="../Images/f2893040467aa890d80a41d056444d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cklk53xxH0TReXX09lBw3Q.png"/></div></a></figure><blockquote class="im in io"><p id="0033" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="hi">免责声明:本实施指南旨在增强用户对概念的理解，而不是构建一个完全成熟的Gmail抓取应用程序，因此它只演示了在用户邮箱上执行的非常有限的操作。</em></p></blockquote><p id="0027" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">关于Google OAuth的设置和理论，我们已经讨论够了:</p><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/@hrishabhpurohit/google-oauth-2-0-securing-your-mail-scraping-application-b5520ef0f390"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Google OAuth 2.0:保护您的邮件抓取应用</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">免责声明:本文是对该解决方案的严格概述。详细的实施和设计不在…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="ke l kf kg kh kd ki ik ju"/></div></div></a></div><p id="e28d" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">现在让我们享受一些行动吧！</p><p id="4add" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">惊喜！！至少对我来说是。老实说，在我的上一篇文章中，我认为我已经承诺了很多，声明我将带着Google <a class="ae kj" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-security-and-oauth2-with-spring-boot-for-java-developers-8f0222d6066d"> OAuth 2.0 </a> Gmail用例的完整实现回来。结果是，我对自己的推销太少了。</p><p id="a2e7" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">是的，我带回了一份完整的指南，为你的Gmail抓取应用程序实现OAuth 2.0。所以，只是重申一下，本指南以Gmail作为Google OAuth 2.0实现的用例，使用Gmail API SDK进行实现。</p><p id="c082" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">现在，对于阅读这篇文章的聪明人来说，如果您已经在想，每次您想从实现中复制一些代码时，都必须参考这篇文章，不要担心，我已经为您做好了准备。你可以直接从我的<a class="ae kj" href="https://github.com/HrishabhPurohit/google-oauth-demo" rel="noopener ugc nofollow" target="_blank"> Git repo </a>中克隆实现，而不用参考本文中的代码片段。</p><p id="0378" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">不客气</p><p id="0337" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">所以我们直接开始吧，好吗？</p><h1 id="d24c" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">再说一遍，什么？</h1><p id="0ac3" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">好了，这是写给那些即使在“浏览”了前面提到的文章和Github库之后，仍然不知道我们到底在谈论什么的人的。</p><p id="8da1" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">这一切都是为了保护任何云应用程序与第三方电子邮件服务器的连接，这些云应用程序试图通过抓取邮件服务器并代表其客户端提取信息来实现工作流自动化。</p><p id="ccda" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">这是由<a class="ae kj" href="https://www.blogger.com/blog/post/edit/1146479294431978500/5630876963551024394#" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0协议</a>完成的。“如何设置”部分是我们在上一篇文章中讨论过的，而<strong class="is hj">“如何实施”</strong>部分是针对这一篇文章的。总而言之，我们将会看到如何使用<strong class="is hj"> Google的OAuth 2.0来连接给定用户的Gmail服务器</strong>并对其收件箱进行操作。</p><h1 id="ec1f" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">有意义</h1><p id="7786" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">正如我们现在必须知道的，OAuth设置有一些核心组件需要在利用协议之前定义。让我们试着回忆一下:</p><ul class=""><li id="aa7b" class="ln lo hi is b it iu ix iy jo lp jp lq jq lr jn ls lt lu lv bi translated"><strong class="is hj">客户端</strong> —在我们的例子中，它是我们的Java应用程序。</li><li id="a3dd" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn ls lt lu lv bi translated"><strong class="is hj">资源服务器</strong>——在我们的例子中，它是Gmail。</li><li id="241e" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn ls lt lu lv bi translated"><strong class="is hj">资源所有者</strong> —在我们的例子中，它是我们想要操作其收件箱的用户。</li><li id="39db" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn ls lt lu lv bi translated"><strong class="is hj">授权服务器</strong>——在我们的例子中，它是Google。</li></ul><p id="070d" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">现在，让我们<strong class="is hj">将这些组件</strong>编织在一起，让它们更有意义:</p><figure class="mc md me mf fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/01/how-http-basic-authentication-works-in.html#axzz6hhgr3Uqg"><div class="er es mb"><img src="../Images/7ba8c1cfdddd13076acb75ad91e7d6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/0*3nCPeNqHv2VdQe1t"/></div></a><p class="mg mh et er es mi mj bd b be z dx translated">注意:请继续阅读以理解上述流程的顺序</p></figure><p id="ec44" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">从上面的流程可以清楚地看出，客户机组件需要足够智能，能够理解来自所有其他组件的响应，并向这些组件发出有效的请求。</p><p id="e23f" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">这种智能只不过是第三方服务提供商提供的API SDKs。在我们的例子中，我们将使用Google OAuth API SDK和Gmail API SDK。这些<strong class="is hj">API定义了客户机和服务器之间的契约</strong>,这样客户机就可以发出有效的请求，并理解从服务器得到的响应。</p><h1 id="2db5" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">谷歌OAuth 2.0客户端</h1><p id="b8f3" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">正如我们已经讨论过的，对于我们的用例，我们将使用OAuth 2.0客户端方法实现OAuth 2.0。另一种方法是使用服务帐户，需要对组织的Gmail域拥有管理员权限。</p><p id="4947" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">对于这个客户端应用程序，我已经在一个公共的<strong class="is hj"> Google cloud console项目</strong>中创建了一个对应的OAuth 2.0客户端。我说的“公开”是指它对任何电子邮件地址以“gmail.com”结尾的用户开放，并由所有者添加到项目中。</p><h1 id="e628" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">客户端请求模拟资源所有者的权限</h1><p id="f85c" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">客户端应用需要从资源所有者处获得<strong class="is hj">授权，授权其代表资源所有者尝试请求<strong class="is hj">访问和刷新令牌</strong>。</strong></p><p id="d705" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">下面是我们如何通过Google OAuth Java SDK实现这一点:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="72a5" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">我们来分析一下，好吗？</p><p id="ba7d" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">您需要两个常量:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="3a9e" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">然后，我们需要向我们的客户端应用程序提供我们创建的OAuth 2.0客户端的<strong class="is hj">客户端id和客户端机密</strong>。这是OAuth客户端的身份，Google授权服务器需要它来验证我们的客户端应用程序。这一行获取创建OAuth 2.0客户端时从google cloud console下载的<strong class="is hj"> JSON文件</strong>:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="9a86" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">下面是我们的客户端应用程序将从读取这个JSON文件中获得的一些额外的重要信息:</p><ul class=""><li id="9555" class="ln lo hi is b it iu ix iy jo lp jp lq jq lr jn ls lt lu lv bi translated"><strong class="is hj">auth _ uri</strong>:<a class="ae kj" href="https://www.blogger.com/blog/post/edit/1146479294431978500/5630876963551024394#" rel="noopener ugc nofollow" target="_blank">https://accounts.google.com/o/oauth2/auth</a></li><li id="4168" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn ls lt lu lv bi translated"><strong class="is hj">token _ uri</strong>:<a class="ae kj" href="https://www.blogger.com/blog/post/edit/1146479294431978500/5630876963551024394#" rel="noopener ugc nofollow" target="_blank">https://oauth2.googleapis.com/token</a></li></ul><p id="2be9" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">我们最终会看到这些URIs的用途，但现在让我们启动授权流程:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="e1a4" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">这里，我们使用OAuth 2.0客户端来启动带有一些附加属性的<strong class="is hj">授权流</strong>。这里需要注意的一件重要事情是<strong class="is hj"> DataStoreFactory </strong>的使用。这个数据存储用于存储用户的访问和刷新令牌，这样即使应用程序被终止，下次应用程序启动时，它也不会从头开始。</p><p id="a925" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">现在，我们需要打开一个端口来监听来自资源所有者的<strong class="is hj">授权</strong>(只有<strong class="is hj">授权码</strong>)。以下命令将打开端口8888:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="50d0" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">如果您认为缺少了什么，我们还没有使用“auth_uri ”,下面是它的用法:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="8d97" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">让我们仔细看看，我们可能没有注意到auth_uri的使用。一旦执行了上面的代码行，就会在系统输出或控制台中打印一个URL:</p><blockquote class="im in io"><p id="4750" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kj" href="https://www.blogger.com/blog/post/edit/1146479294431978500/5630876963551024394#" rel="noopener ugc nofollow" target="_blank">https://accounts.google.com/o/oauth2/auth?access _ type = offline&amp;approval _ prompt = auto&amp;client _ id = 134130959775-v 05 vdon 8 u 5 da 7 eoa 1 k1 e 00 ufv 9 cnjru 9 . apps . Google user content . com&amp;redirect _ uri = http://localhost:8888/Callback&amp;response _ type = code&amp;scope = https://www . Google APIs . com/auth/Gmail . readonly</a></p></blockquote><p id="c66a" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">看起来很相似对吗？是的，你是对的，它就是auth_uri，只是它附加了一些查询参数。我假设参数定义是清楚的，因为我们在上次讨论中讨论了这里每个参数的含义。让我们分析这些参数，并尝试了解它们的来源:</p><ol class=""><li id="3629" class="ln lo hi is b it iu ix iy jo lp jp lq jq lr jn mm lt lu lv bi translated"><strong class="is hj"> access_type </strong>:来自6号代码行。</li><li id="c162" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn mm lt lu lv bi translated"><strong class="is hj">审批_提示</strong>:来自7号代码行。</li><li id="ff63" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn mm lt lu lv bi translated"><strong class="is hj"> client_id </strong>:来自1号代码行提供的OAuth客户端JSON文件。</li><li id="0fb6" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn mm lt lu lv bi translated"><strong class="is hj"> redirect_uri </strong>:这是一个本地主机uri，因为我们期望授权代码在本地端口8888上发送。</li><li id="5d99" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn mm lt lu lv bi translated"><strong class="is hj">response _ type</strong>:web应用的默认值。</li><li id="c46b" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn mm lt lu lv bi translated"><strong class="is hj">范围</strong>:来自5号代码行。</li></ol><h1 id="877b" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">资源所有者将权限授予客户端</h1><p id="5e85" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">到目前为止，我们已经将auth_uri输出到控制台。但是现在呢？</p><p id="53a1" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">OAuth客户端和服务帐户方法之间的重要区别在于:资源所有者的<strong class="is hj">手动干预</strong>。是的，资源所有者必须手动单击上述auth_uri并登录到其Google帐户，然后通过单击OAuth 2.0 <strong class="is hj">同意屏幕</strong>上的“允许”按钮授予权限。</p><p id="8469" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">一旦资源所有者这样做了，就会生成授权代码(代表所有者的授权)并发送回redirect_uri。</p><h1 id="5b6c" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">客户端请求使用资源所有者的授权连接到授权服务器</h1><p id="14eb" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">还是感觉少了点什么，对吗？我的意思是，是的，我们现在有了授权代码，但我们不必再编写任何代码来解释代码并将其交换为访问和刷新令牌，对吗？</p><p id="511a" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">SDK正在处理这个问题。</p><p id="24b9" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">由于我们的客户端应用程序知道了<strong class="is hj"> token_uri </strong>并且现在有了授权码，它可以<strong class="is hj">在资源所有者不知情的情况下悄悄地请求交换</strong>。酷！</p><h1 id="a29a" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">授权服务器向客户端发送访问和刷新令牌作为响应</h1><p id="c2b0" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">如果您还没有意识到，token_uri只不过是授权服务器。它验证授权码并返回与资源所有者对应的访问和刷新令牌。</p><p id="86af" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">我们没有看到的是，这种交换发生在这条线的一部分:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="13b7" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">“Credential”对象是存储用户的访问和刷新令牌的SDK类类型。</p><h1 id="a06d" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">客户端请求从资源服务器访问资源的权限</h1><p id="8fd0" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">对我们来说，资源是电子邮件，资源服务器是Gmail。现在我们有了资源所有者的访问令牌，让我们尝试从Gmail访问电子邮件:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="0f99" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">“Gmail”是知道如何与Gmail服务交互的Gmail API SDK类类型。请注意，仅这一行<strong class="is hj">不会</strong>触发任何<strong class="is hj"> API网络调用</strong>到Gmail API，因为它不会指定要访问的确切资源或Gmail上的确切操作。</p><p id="5e90" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">为了指定确切的操作，我们将使用相应的Gmail API SDK客户端方法:</p><p id="50d3" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">从收件箱获取电子邮件列表:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h1 id="a523" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">资源服务器向客户端发送所需的资源</h1><p id="32e2" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">上面的代码行将对资源服务器进行所需的网络调用，然后资源服务器根据资源所有者验证访问令牌，如果有效，则检查令牌的到期日<strong class="is hj">。无效或过期的访问令牌将导致4xx HTTP响应。</strong></p><p id="7edf" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jo jc jd je jp jg jh ji jq jk jl jm jn hb bi translated">尽管如果访问令牌有效且尚未过期，资源服务器会以所请求的资源进行响应。</p><h1 id="8474" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">立正！</h1><p id="b43e" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">我们现在很好地使用Google OAuth flow来操作用户的收件箱。但是，在实施时，有几个要点需要考虑:</p><ul class=""><li id="3d9f" class="ln lo hi is b it iu ix iy jo lp jp lq jq lr jn ls lt lu lv bi translated">人们可以<strong class="is hj">将访问令牌和刷新令牌</strong>通过适当的加密保存到DB中。这一点很重要，因为每次用户请求获取/刷新访问令牌时，应用程序都会访问google服务器，这会产生不必要的开销。因此，仅在新的访问令牌过期时才请求它可能是一种<strong class="is hj">高效的</strong>方法。</li><li id="3be0" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn ls lt lu lv bi translated">不应该将OAuth客户机JSON文件放在应用服务器中。原因是，它将大部分暴露在公共互联网上，因此会使你的客户的数据易受攻击。人们可以将文件保存在安全的BLOB存储器中，如<a class="ae kj" rel="noopener" href="/javarevisited/7-best-aws-s3-and-dynamodb-courses-for-beginners-in-2021-a8a44b6066da"> AWS S3 </a>，并将S3 BLOB的加密路径存储在数据库中。这确保了您的客户端数据的安全性。</li><li id="6630" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn ls lt lu lv bi translated">请记住，一旦<strong class="is hj">终端客户端更改其Gmail帐户的密码</strong>，刷新令牌就会失效。</li><li id="8a12" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn ls lt lu lv bi translated">为你的应用程序发出的每个Google API请求设置一个严格的一次性重试策略，以防间歇性网络故障，可以让你的应用程序更加健壮。</li><li id="c2f0" class="ln lo hi is b it lw ix lx jo ly jp lz jq ma jn ls lt lu lv bi translated">为用户的访问令牌构建一个应用程序级<strong class="is hj">缓存机制</strong>可能会有所帮助，因为这将减少对您的<a class="ae kj" rel="noopener" href="/hackernoon/top-5-sql-and-database-courses-to-learn-online-48424533ac61"> DB </a>的调用次数。</li></ul><h1 id="8006" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">下一步是什么？</h1><p id="23c4" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">接下来，将为同一解决方案实现Google服务帐户方法。虽然它需要一些领域管理活动，但我们将更多地关注我们作为开发人员能做些什么。小心那个！</p><h1 id="d786" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">参考</h1><p id="2ec6" class="pw-post-body-paragraph ip iq hi is b it li iv iw ix lj iz ja jo lk jd je jp ll jh ji jq lm jl jm jn hb bi translated">https://developers.google.com/gmail/api/quickstart/java</p></div></div>    
</body>
</html>