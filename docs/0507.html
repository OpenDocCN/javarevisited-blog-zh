<html>
<head>
<title>Keep calm and S.O.L.I.D</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持冷静和神盾局</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/keep-calm-and-s-o-l-i-d-7ab98d5df502?source=collection_archive---------5-----------------------#2020-06-15">https://medium.com/javarevisited/keep-calm-and-s-o-l-i-d-7ab98d5df502?source=collection_archive---------5-----------------------#2020-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="560a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2012年冬天，我有机会参加了罗伯特的演讲。c .马丁(又名鲍勃叔叔)都柏林。我觉得很棒。鲍勃大叔是<a class="ae jd" href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" rel="noopener ugc nofollow" target="_blank">干净代码的作者(我拿到了他的亲笔签名:p) </a>，也是软件行业非常有影响力的人物。</p><p id="e87c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自从那次演讲后，我一直想写一些关于他对这个行业的贡献的东西，并把它贴在我的博客上。</p><p id="09f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">他对我们说的最后一句话是，尽可能多地阅读……<br/>在开始写这篇文章之前，我想了一会儿这些话……<br/>我认为这是一个很好的建议。没有人否认真实的经历可能是最好的，但读书也很重要。他们带着前人的经验，也带着那些人在途中发现并记录下来的规则和原则。不要误会，严格遵守规则和原则并不总是能保证成功(“世界在不断变化”)，但在面临巨大挑战时，理解它们会有很大帮助。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/36d9db233f62c6c70887bface7a787a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*ClfRgwZd3BPIzpRG.jpg"/></div></figure><p id="d8e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以最后我决定写这篇关于Bob叔叔对面向对象编程世界的最大贡献之一的文章，那就是S.O.L.I.D原则。</p><p id="6fc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">单一责任原则<br/> </strong>如果我们有一个类有多种责任/特性/改变的理由；对其进行的修改会带来影响该类其他部分的风险(其他责任/功能/变更原因)。</p><p id="5c06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说:做多件事的类很难维护。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jm"><img src="../Images/88730ce09b102c8931b718a780bcbf8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*8BuQa3ssQpZZsRlK.jpg"/></div></figure><p id="cc5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SRP说:“一个类应该只有一个改变的理由”。</p><p id="57b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个例子:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div></figure><p id="a8c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，这是一个有多种原因需要更改的类的明显示例:</p><ul class=""><li id="5ab0" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">未来的业务需求可能需要我们改变计算方法(例如，不同的指标)</li><li id="e489" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">未来的业务需求可能需要我们改变结果的保存方式。</li><li id="fb0c" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">未来的业务需求可能需要我们改变在身体质量指数创建培训计划的方式。</li></ul><p id="4f52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不希望所有上面提到的需求变化影响到这个类。如果我们不在开发的早期阶段寻求粒度，我们将很容易以难以维护的软件而告终。</p><p id="4e6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要做的是思考这个班级的唯一目标。我们还可以思考这个类肯定不会做什么，这样我们就可以区分其他不应该改变的原因。在修复违反SRP的情况时，请遵循这种思路，它将帮助您发现需要提取的类:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div></figure><p id="19fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">开闭原理</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kd"><img src="../Images/af26a557685e89725254d06f6944f5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/0*lrZ_i_jwFZ7ILI5c.jpg"/></div></figure><p id="1879" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开闭原则背后的动机是在不修改现有代码的情况下扩展/改变行为。这个原则说:</p><p id="4cf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“模块应该对扩展开放，但对修改关闭”。</p><p id="48cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能认为，这听起来很矛盾，但是在许多面向对象编程语言中，比如Java，有一些机制允许你这样做。</p><p id="298c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中一个机制是多态性。通过定义抽象函数/方法</p><p id="4a7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先来看看对开闭原则的违反:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">Chef.java</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">Menu.java</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">NonVeg.java</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">Veg.java</p></figure><p id="3e6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，如果一个新的需求要求我们做一些不同于素食和非素食的其他类型的饭菜，那么这个类就需要修改。上面给出的例子是不可维护的。</p><p id="9ea6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看如何使用多态性来删除条件逻辑并改进解决方案:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">修改Chef类以删除if语句</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">膳食现在有了一个抽象的方法</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">NonVeg类必须提供实现</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">Veg类必须提供一个实现</p></figure><p id="687e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，解决方案更加灵活，现在更容易维护，我们也摆脱了一个邪恶的标志，从长远来看，它只会在操作时引起问题。包含敏感方法的类Meal对扩展开放，但对修改关闭。</p><p id="c265" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OCP原则非常强大，但我们也必须记住，通过增加抽象层次(<a class="ae jd" href="http://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noopener ugc nofollow" target="_blank">作为替代，你也可以考虑组合与继承</a>)，我们也增加了复杂性，理解这一原则应该只应用于那些更有可能经常发生需求变化的地方是非常重要的。</p><p id="1f7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">利斯科夫替代原理</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jm"><img src="../Images/4cd5293e95f2ffd759eb13d86b83cb03.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*GJXGQ_0Mdixqupad.jpg"/></div></figure><p id="5955" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个原则是关于子类代替基类的行为。</p><p id="5dec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果发生这种情况，当在程序的其他部分使用/调用这些新类时，它们可能会产生不希望的效果。</p><p id="208e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Liskov的替换原则指出，如果客户端正在调用基类，那么对基类的引用应该能够被派生类替换，而不会影响基类的功能。</p><p id="e892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个违反这一原则的例子:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">Duck.java</p></figure><p id="1a75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">野鸭还会嘎嘎叫和游泳。但是鸭子玩具呢？</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">DuckToy.java</p></figure><p id="64ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，一些鸭子玩具需要电池，而且它们并不真的嘎嘎叫，它们只是发出声音。即使没有编译错误，并且将duck toy包含在这个继承链中看起来很诱人，这也明显违反了Liskov的替换原则。原因是，如果客户端实例化基类，派生类DuckToy不能替换它，因为功能受到影响。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">Pond.java</p></figure><p id="3472" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，一个解决方案可以是拥有一个单独的类来表示鸭子玩具。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">一个独立的DuckToy类，与真正的野鸭无关(不再扩展Duck)</p></figure><p id="44cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">界面偏析原理</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ki"><img src="../Images/16019a0af152ddcd06a42a8eda372cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/0*eQpRUA55q9yCBvmP.jpg"/></div></figure><p id="ccfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个非常容易理解的原则，它说客户不应该被强迫实现他们不使用的接口。看一看对这一原则的违反:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">每种动物都会飞、跑和游泳吗？我不这么认为…</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">这里我们违反了接口隔离原则。狗不会飞！</p></figure><p id="3169" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太可怕了。所以有很多方法可以避免这种情况。<br/>一个例子是根据需要组合特定的接口:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">流道界面</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">游泳者界面</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">传单界面</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">海鸥是游泳者和飞行者</p></figure><p id="6cf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很有道理，我们可以说狗是跑步者和游泳者，但绝对不是飞行者。使用方法较少的接口有助于我们避免违反接口分离原则。</p><p id="b364" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">依存倒置原则</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jm"><img src="../Images/0a0db0f6342f508bc0bcdcd9f018733f.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*qQKiaRFR0FSOpOWv.jpg"/></div></figure><p id="68a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个原则说“不要依赖任何具体的东西，只依赖抽象的东西。”所以确保你所有的依赖都指向抽象的东西。这将为您的代码带来安全性，同时也使其更加灵活。也许你认为这个原则有点激进；但是很明显，在现实中严格遵循它是非常困难的(甚至是不可能的)。当你调用一个函数时，你可以使用一个技巧来验证你是否遵循了这个原则，那就是编程到接口而不是实现。</p><p id="d176" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个原则在实践中的一个很好的例子是模板设计模式。让我们先来看看一个常见的违反原则的情况:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">PizzaMaker.java</p></figure><p id="b3ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的例子是一个糟糕的编码类，它制作了两种披萨……这段代码中有很多不好的地方，但我将只关注对我们正在讨论的原则的违反。因为对pizza对象的每一次调用都是对一个具体方法的调用，所以我们得到的是非常僵化和不灵活的东西。每一种披萨都有一些配料是必须的，比如基础、番茄、奶酪和牛至，但其余的都是可选的，所以:如果这不是我们所关心的，为什么我们要关心调用具体的方法来设置那些额外的配料呢？</p><p id="9da7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的代码片段中，引入了一个模板方法来抽象可选部分，并让子类实现它们。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">比萨制造商现在是抽象的</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">肉类比萨饼模板方法的自定义实现</p></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jn jo l"/></div><p class="ke kf et er es kg kh bd b be z dx translated">素食比萨饼模板方法的自定义实现</p></figure><p id="7691" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">S.O.L.I.D原则是由Robert C.Martin提出的，但是首字母缩写词是由Michael Feathers在2000年创造的，今天它们在面向对象软件的世界中已经广为人知，在书籍和互联网上有很多关于它们的文献。</p><p id="8070" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章的最后，我想和你分享一个我在网上找到的很棒的播客采访，是鲍勃叔叔，S.O.L.I.D .详细解释道。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kj"><img src="../Images/b3f1c16b8a8426066b1dcbe8aa40c6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/0*vKZwSC4wpBGonX7L.png"/></div></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="cdcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【http://javing.blogspot.com/2013/09/keep-calm-and-solid.html】最初发表于<a class="ae jd" href="http://javing.blogspot.com/2013/09/keep-calm-and-solid.html" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>