<html>
<head>
<title>Why method naming is important</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么方法命名很重要</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/why-method-naming-is-important-1d1625a1aa8?source=collection_archive---------2-----------------------#2019-09-12">https://medium.com/javarevisited/why-method-naming-is-important-1d1625a1aa8?source=collection_archive---------2-----------------------#2019-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/fb707dacf3ccbfd964b723bc0f7056d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LQHOrLTUnfur1VzMd0xUA.jpeg"/></div><p class="im in et er es io ip bd b be z dx translated">动画<a class="ae iq" href="https://en.wikipedia.org/wiki/Adventures_of_Captain_Wrongel" rel="noopener ugc nofollow" target="_blank">错误船长历险记</a>中糟糕命名的说明(俄语双关语)</p></figure><p id="8642" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">方法命名很重要。我们都知道。这写在<a class="ae iq" href="https://javarevisited.blogspot.com/2017/10/clean-code-by-uncle-bob-book-review.html#axzz5jSEI4IYE" rel="noopener ugc nofollow" target="_blank">书籍</a>中，我们在每个拉取请求中都得到命名建议。这让我们更仔细地观察我们的命名，我们在命名我们的方法时变得更好:<code class="du jp jq jr js b">getThis()</code>，<code class="du jp jq jr js b">setThat()</code>。你知道的。</p><p id="6b02" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">但这不仅仅是为了清晰的名字。更多的是关于<em class="jt">这个名字如何真正反映代码在做什么</em>，它如何在没有文档的情况下支持更好的可读性和对代码的理解。</p><blockquote class="ju"><p id="f622" class="jv jw hi bd jx jy jz ka kb kc kd jo dx translated">它实际上是双向的:当检查一个方法时，你应该检查它是否真的做了它被命名的事情。因为如果不是这样，那么<em class="ke">可能是代码结构不良的标志</em>。</p></blockquote><p id="0ac3" class="pw-post-body-paragraph ir is hi it b iu kf iw ix iy kg ja jb jc kh je jf jg ki ji jj jk kj jm jn jo hb bi translated">我们来看一个例子。</p><p id="b39e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">假设我们有一个代表用户可能存储的一些配置设置的实体。让它也支持版本控制，以便一些设置更改可以恢复到以前的状态。原始设置实体存储在一个单独的表中(<code class="du jp jq jr js b">config_settings</code>)。不同以往的版本——在另一个(<code class="du jp jq jr js b">config_settings_history</code>)。总的来说，它对应于第四种缓变维度数据管理方法。</p><p id="8bf8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所有这些都用数据库模式备份，如下所示:</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="ko kp l"/></div><p class="im in et er es io ip bd b be z dx translated">代码片段 1:数据库模式</p></figure><p id="645b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在，假设我们有一个删除实体的需求。但是因为它是版本化的，所以在删除时，来自版本历史的最新实体应该是实际的。除非指定了<code class="du jp jq jr js b">allEntriesShouldBeDeleted</code>。在这种情况下，应删除实际和历史实体。一切都很简单。</p><p id="9620" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这是通过以下代码实现的:</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="ko kp l"/></div><p class="im in et er es io ip bd b be z dx translated">代码片段 2:初始实现</p></figure><p id="5da3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我希望你花一分钟时间研究一下代码。你对实施有什么问题吗？或者关于方法命名？</p><p id="a816" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">好的，现在我们一起来检查一下。</p><p id="b617" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里我们有<code class="du jp jq jr js b">deleteConfigSettings</code>，它检查标志，如果标志为真，就删除实体并清除它的历史记录。</p><p id="62f5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">或者，如果标志被设置为 false，它调用帮助器方法<code class="du jp jq jr js b">setNewestEntryFromHistoryAsActual</code>，将历史中的实体设置为实际实体。首先，它检查是否存在任何历史条目。如果没有-它只是删除实际的。嗯，好吧，到目前为止还说得通。</p><p id="e8c0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">等等，<strong class="it hj"> <em class="jt">删除实际的</em> </strong>？我以为我们是在讨论从方法名来判断设置内容？这应该是你的一面旗帜。所以记住这个。此外，我们现在有了一个<a class="ae iq" href="https://javarevisited.blogspot.com/2015/06/3-ways-to-find-duplicate-elements-in-array-java.html#axzz5zyF1CL8Y" rel="noopener ugc nofollow" target="_blank">代码重复</a>，因为在同一个工作流的不同部分调用了 delete。</p><p id="f0cb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du jp jq jr js b">Else</code>不过，block 还可以。我们将历史中的一个设置为当前并从历史中删除。这就是方法名<strong class="it hj">暗示</strong>的内容，也是应该出现的内容。但是第一部分确实属于<a class="ae iq" href="http://javarevisited.blogspot.sg/2011/08/what-is-polymorphism-in-java-example.html" rel="noopener ugc nofollow" target="_blank">父方法</a>。</p><p id="1123" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们稍微重构一下这些方法，以便方法命名更精确地反映方法实际在做什么:</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="ko kp l"/></div><p class="im in et er es io ip bd b be z dx translated">代码片段 3:重构</p></figure><p id="4efb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">好的，方法<code class="du jp jq jr js b">setNewestEntryFromHistoryAsActual</code>现在是正确的，名副其实。另外，请注意<a class="ae iq" href="https://www.java67.com/2012/09/what-is-rules-of-overloading-and-overriding-in-java.html" rel="noopener ugc nofollow" target="_blank">签名</a>。它现在只把<code class="du jp jq jr js b">ConfigSettingsHistoryEntity</code>作为一个参数。这是一个好迹象，表明我们正朝着正确的方向前进。</p><p id="9c23" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">方法<code class="du jp jq jr js b">deleteConfigSettings</code>现在，嗯……更丑陋了。但是，那是最好的！我们现在可以看到它有什么问题。还记得那些删除逻辑重复的吗？嗯，还是有的，只是现在更明显了。</p><p id="241f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们有两个删除:万一<code class="du jp jq jr js b">areAllEntriesShouldBeDeleted</code>被设置为真，以及万一没有历史条目。但是没有必要将它们放在代码的不同部分。但是第一个也<em class="jt">删除了所有的历史条目</em>，我们不能简单地把它们合并在一个地方。</p><p id="18d2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">等等，为什么会这样？如果我们想删除当前条目，历史条目不是应该已经被自动删除了吗？</p><p id="540c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">嗯，它们现在没有被删除，因为数据库中没有<strong class="it hj">级联</strong>！完全忽略了:</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="ko kp l"/></div><p class="im in et er es io ip bd b be z dx translated">片段 4:没有瀑布</p></figure><p id="5e8b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这是一个很好的方法来得到一个你要找几个小时的虫子。仔细想想——一旦原始的历史条目被删除，保留它们就没有意义了，因为它们不会被任何地方引用。</p><p id="ced0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">此外，如果要创建新条目，它将继承先前已删除条目的历史。在这里，你有一个错误。在代码中的某个地方忘记这个单独的调用。</p><p id="d827" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们添加级联:</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="ko kp l"/></div><p class="im in et er es io ip bd b be z dx translated">片段 5:瀑布</p></figure><p id="ebb9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对我们的方法进行更多的重构:</p><figure class="kk kl km kn fd ij"><div class="bz dy l di"><div class="ko kp l"/></div><p class="im in et er es io ip bd b be z dx translated">代码片段 6:最终实现</p></figure><p id="ecef" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">嗯好多了，不是吗？这个<code class="du jp jq jr js b">delete</code>只有一个且只在一个地方。<code class="du jp jq jr js b">setNewestEntryFromHistoryAsActual</code>我们发现并修复了<a class="ae iq" href="https://javarevisited.blogspot.com/2018/05/top-5-sql-and-database-courses-to-learn-online.html" rel="noopener ugc nofollow" target="_blank">数据库模式</a>中的一个问题，该问题被糟糕的方法命名所隐藏。</p><p id="fe2d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果代码现在读起来非常好，那么它的美妙之处在于:</p><blockquote class="ju"><p id="7bad" class="jv jw hi bd jx jy jz ka kb kc kd jo dx translated">如果设置了所有条目删除标志或没有历史条目—删除条目，<br/>否则—将最新设置为当前</p></blockquote><p id="1fc3" class="pw-post-body-paragraph ir is hi it b iu kf iw ix iy kg ja jb jc kh je jf jg ki ji jj jk kj jm jn jo hb bi translated">尝试阅读初始代码。嗯，这会很乱，而且很长，到最后你会忘记开头是什么！这基本上就是当你需要添加修改或任何东西时，你应该如何阅读代码。</p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="d69c" class="kx ky hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">你应该永远记住:越容易阅读，就越容易维护。</h1></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><p id="70eb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以这一切背后的想法。</p><p id="9195" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">糟糕的方法名或不符合名称的实现会降低代码的可读性，甚至会暴露一些严重的设计缺陷，应该被视为主要的代码问题。</p><h2 id="d550" class="lv ky hi bd kz lw lx ly ld lz ma mb lh jc mc md ll jg me mf lp jk mg mh lt mi bi translated">如何检查方法命名是否正确:</h2><ul class=""><li id="2a74" class="mj mk hi it b iu ml iy mm jc mn jg mo jk mp jo mq mr ms mt bi translated">方法名准确描述了方法的功能</li><li id="2c60" class="mj mk hi it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt bi translated">方法只做一件事，名字简单(共享多个函数的方法往往有复杂的名字，如<code class="du jp jq jr js b">deleteEntryAndSetLatestFromHistory</code>)</li><li id="60a4" class="mj mk hi it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt bi translated">方法参数不应该过多(<code class="du jp jq jr js b">setLatestFromHistory</code>不应该要求当前参数、时间戳或任何东西，因为它不应该对它们进行操作)</li><li id="ed4b" class="mj mk hi it b iu mu iy mv jc mw jg mx jk my jo mq mr ms mt bi translated">试着读出你的方法(当然，当没人的时候)，它应该是描述方法逻辑的正常句子</li></ul><p id="20b2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如往常一样，我很高兴收到任何反馈或问题！请随意将它们贴在这里的回复或个人笔记中。</p><h2 id="7fd0" class="lv ky hi bd kz lw lx ly ld lz ma mb lh jc mc md ll jg me mf lp jk mg mh lt mi bi translated">你可能喜欢的学习 Java 的其他有用资源</h2><p id="67d6" class="pw-post-body-paragraph ir is hi it b iu ml iw ix iy mm ja jb jc mz je jf jg na ji jj jk nb jm jn jo hb bi translated"><a class="ae iq" href="http://javarevisited.blogspot.sg/2014/10/10-java-best-practices-to-name-variables-methods-classes-packages.html#axzz5Bwn8nSNW" rel="noopener ugc nofollow" target="_blank">在程序中命名变量时要记住的 10 个最佳实践</a><br/><a class="ae iq" href="https://javarevisited.blogspot.com/2017/12/10-things-java-programmers-should-learn.html#axzz5atl0BngO" rel="noopener ugc nofollow" target="_blank">2019 年 Java 程序员应该学习的 10 件事</a> <br/> <a class="ae iq" href="http://www.java67.com/2018/08/top-10-free-java-courses-for-beginners-experienced-developers.html" rel="noopener ugc nofollow" target="_blank">从零开始学习 Java 的 10 门免费课程</a> <br/> <a class="ae iq" href="https://medium.freecodecamp.org/must-read-books-to-learn-java-programming-327a3768ea2f" rel="noopener ugc nofollow" target="_blank">深入学习 Java 的 10 本书</a> <br/> <a class="ae iq" href="http://www.java67.com/2018/04/10-tools-java-developers-should-learn.html" rel="noopener ugc nofollow" target="_blank">每个 Java 开发人员都应该知道的 10 个工具</a> <br/> <a class="ae iq" href="http://javarevisited.blogspot.sg/2013/04/10-reasons-to-learn-java-programming.html" rel="noopener ugc nofollow" target="_blank">学习 Java 编程语言的 10 个理由</a><br/><a class="ae iq" href="http://javarevisited.blogspot.sg/2018/01/10-frameworks-java-and-web-developers-should-learn.html" rel="noopener ugc nofollow" target="_blank">2010 年 Java 和 Web 开发人员应该学习的 10 个框架 2019 年成为更优秀 Java 开发者的小技巧</a><br/><a class="ae iq" href="http://javarevisited.blogspot.sg/2018/04/top-5-java-frameworks-to-learn-in-2018_27.html" rel="noopener ugc nofollow" target="_blank">2019 年要学习的 5 大 Java 框架</a> <br/> <a class="ae iq" href="https://javarevisited.blogspot.sg/2018/01/10-unit-testing-and-integration-tools-for-java-programmers.html" rel="noopener ugc nofollow" target="_blank">每个 Java 开发者都应该知道的 10 个测试库</a></p><div class="nc nd ez fb ne nf"><a rel="noopener follow" target="_blank" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">面向初学者的 10 大 Java 在线课程</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">如果你是计算机科学专业的毕业生，或者想学习 Java 并且正在寻找一些很棒的资源，比如…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">medium.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ik nf"/></div></div></a></div></div></div>    
</body>
</html>