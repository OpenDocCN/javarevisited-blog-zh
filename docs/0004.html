<html>
<head>
<title>As a matter of Factory — Part 2 (Immutable)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂问题—第2部分(不可变)</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/as-a-matter-of-factory-part-2-immutable-8cb72ff897ee?source=collection_archive---------5-----------------------#2017-09-04">https://medium.com/javarevisited/as-a-matter-of-factory-part-2-immutable-8cb72ff897ee?source=collection_archive---------5-----------------------#2017-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="77d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个关于集合工厂的博客系列的第1部分<a class="ae jd" rel="noopener" href="/@donraab/as-a-matter-of-factory-part-1-mutable-75cc2c5d72d9">中，我展示了如何使用</a><a class="ae jd" href="https://www.eclipse.org/collections/" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>中的工厂类来创建可变集合的实例。在第2部分中，我将展示如何使用相同的工厂类来创建不可变的集合。</p><p id="21da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想在Eclipse集合中创建不可变的集合，那么根据您对<code class="du je jf jg jh b">with</code>或<code class="du je jf jg jh b">of</code>的偏好，您可以使用<code class="du je jf jg jh b">&lt;FactoryClass&gt;.<strong class="ih hj"><em class="ji">immutable</em></strong>.with(x, y, z)</code>或<code class="du je jf jg jh b">&lt;FactoryClass&gt;.<strong class="ih hj"><em class="ji">immutable</em></strong>.of(x, y, z)</code>。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="591e" class="jr js hi jh b fi jt ju l jv jw">ImmutableList&lt;String&gt; list = <br/>    Lists.<strong class="jh hj"><em class="ji">immutable</em></strong>.with("1", "2", "3");</span><span id="9406" class="jr js hi jh b fi jx ju l jv jw">ImmutableSet&lt;String&gt; set = <br/>    Sets.<strong class="jh hj"><em class="ji">immutable</em></strong>.with("1", "2", "3");</span><span id="4093" class="jr js hi jh b fi jx ju l jv jw">ImmutableBag&lt;String&gt; bag = <br/>    Bags.<strong class="jh hj"><em class="ji">immutable</em></strong>.with("1", "2", "3");</span><span id="e91d" class="jr js hi jh b fi jx ju l jv jw">ImmutableMap&lt;Integer, String&gt; map = <br/>    Maps.<strong class="jh hj"><em class="ji">immutable</em></strong>.with(1, "1", 2, "2", 3, "3");</span></pre><p id="36e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想要一个更简洁的创建不可变容器的选项，您可以在Eclipse集合中使用静态导入的<code class="du je jf jg jh b"><a class="ae jd" href="https://www.eclipse.org/collections/javadoc/8.2.0/org/eclipse/collections/impl/factory/Iterables.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">Iterables</strong></a></code>类。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="5052" class="jr js hi jh b fi jt ju l jv jw">ImmutableList&lt;String&gt; list = <br/>    <strong class="jh hj"><em class="ji">iList</em></strong>("1", "2", "3");</span><span id="8200" class="jr js hi jh b fi jx ju l jv jw">ImmutableSet&lt;String&gt; set = <br/>    <strong class="jh hj"><em class="ji">iSet</em></strong>("1", "2", "3");</span><span id="a5b1" class="jr js hi jh b fi jx ju l jv jw">ImmutableBag&lt;String&gt; bag = <br/>    <strong class="jh hj"><em class="ji">iBag</em></strong>("1", "2", "3");</span><span id="4852" class="jr js hi jh b fi jx ju l jv jw">ImmutableMap&lt;Integer, String&gt; map = <br/>    <strong class="jh hj"><em class="ji">iMap</em></strong>(1, "1", 2, "2", 3, "3");</span></pre><p id="378c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> "i" </strong>方法是"<strong class="ih hj">不可变</strong>"的简称，<strong class="ih hj"> "m" </strong>方法是"<strong class="ih hj">可变</strong>"的简称。正如在第1部分中提到的，对于原始工厂，目前还没有等价的Iterables类。</p><p id="f299" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想要空的不可变集合，请在不可变工厂上使用empty方法。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="9f35" class="jr js hi jh b fi jt ju l jv jw">ImmutableList&lt;String&gt; list = <br/>    Lists.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();</span><span id="ddfa" class="jr js hi jh b fi jx ju l jv jw">ImmutableSet&lt;String&gt; set = <br/>    Sets.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();</span><span id="0470" class="jr js hi jh b fi jx ju l jv jw">ImmutableBag&lt;String&gt; bag = <br/>    Bags.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();</span><span id="fb0d" class="jr js hi jh b fi jx ju l jv jw">ImmutableMap&lt;Integer, String&gt; map = <br/>    Maps.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();</span></pre><p id="2fa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">空的不可变集合是单例集合。</p><h2 id="17f3" class="jr js hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">ImmutableCollection不扩展集合</h2><p id="577b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在Eclipse集合中,<code class="du je jf jg jh b"><strong class="ih hj">MutableCollection</strong></code>和<code class="du je jf jg jh b"><strong class="ih hj">ImmutableCollection</strong></code>层次之间有重要的区别。扩展<code class="du je jf jg jh b"><strong class="ih hj">ImmutableCollection</strong></code>的接口并不像它们的可变对应物那样扩展<code class="du je jf jg jh b"><strong class="ih hj">java.util</strong></code> <strong class="ih hj"> </strong>等价物。本<a class="ae jd" href="https://stackoverflow.com/questions/29504881/immutablelist-does-not-extend-list" rel="noopener ugc nofollow" target="_blank"> StackOverflow帖子</a>中详细解释了这一设计决策。虽然一个<code class="du je jf jg jh b"><strong class="ih hj">ImmutableList</strong></code>不扩展<code class="du je jf jg jh b"><strong class="ih hj">java.util.List</strong></code>，但是<code class="du je jf jg jh b"><strong class="ih hj">ImmutableList</strong></code>的每个实现都必须扩展<code class="du je jf jg jh b"><strong class="ih hj">java.util.List</strong></code>，如下图所示。<code class="du je jf jg jh b"><strong class="ih hj">ImmutableCollection</strong></code>实现不会有任何类似<code class="du je jf jg jh b">add</code>、<code class="du je jf jg jh b">remove</code>、<code class="du je jf jg jh b">addAll</code>、<code class="du je jf jg jh b">removeAll</code>或clear的变异方法，为这些类型返回的<code class="du je jf jg jh b">Iterator</code>将不支持<code class="du je jf jg jh b">remove</code>。然而，实现必须扩展<code class="du je jf jg jh b"><strong class="ih hj">java.util.List</strong></code>以支持<code class="du je jf jg jh b">List</code>的<code class="du je jf jg jh b">equals</code>和<code class="du je jf jg jh b">hashcode</code>契约。</p><figure class="jj jk jl jm fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/28fb157d9818c018b1c539559d2cc629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kteEV7063kfS91tJrLBvzA.png"/></div></div><p class="le lf et er es lg lh bd b be z dx translated">ImmutableList不扩展java.util.List</p></figure><p id="8d41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您不能直接创建<code class="du je jf jg jh b"><strong class="ih hj">ImmutableList</strong></code>实现，而是必须使用适当的工厂类。工厂类不返回实现类类型，而是返回接口类型，如<code class="du je jf jg jh b"><strong class="ih hj">ImmutableList</strong></code>或<code class="du je jf jg jh b"><strong class="ih hj">ImmutableSet</strong></code>。</p><p id="34d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工厂类可以为较小的集合大小返回一个优化的容器。例如，对于<code class="du je jf jg jh b"><strong class="ih hj">ImmutableList</strong></code>，有针对空、单例、双例、三例以及所有到十例的优化实现。这些实现都不需要后备数组，而是如图所示，直接引用它们的元素。对于集合和贴图，优化会进行到四元组(4)。对于包，有一个特殊的优化称为<code class="du je jf jg jh b"><strong class="ih hj">ImmutableArrayBag</strong></code>，它将高达20个元素，然后将使用一个<code class="du je jf jg jh b"><strong class="ih hj">ImmutableHashBag</strong></code>用于更大的集合。下面应该给出了通过使用小型不可变集合所获得的潜在内存节省的指示。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="f04c" class="jr js hi jh b fi jt ju l jv jw">Memory Cost in Bytes<br/> <br/>Type - Size: Mutable — Immutable<br/>— — — — — — — — — — - - - - - - -<br/>List — 0: 40 – 16<br/>List — 1: 48 – 16<br/>List — 2: 48 – 24<br/>List — 3: 56 – 24<br/>List — 4: 56 – 32<br/>List — 5: 64 – 32<br/>List — 6: 64 – 40<br/>List — 7: 72 – 40<br/>List — 8: 72 – 48<br/>List — 9: 80 – 48<br/>List -10: 80 – 56<br/>List -11: 88 – 80<br/>— — — — — — — — — — <br/>Bag — 0 : 216 – 16<br/>Bag — 1 : 232 – 32<br/>Bag — 2 : 248 – 104<br/>Bag — 3 : 264 – 136<br/>Bag — 4 : 280 – 152<br/>Bag — 5 : 296 – 184<br/>— — — — — — — — — — <br/>Set — 0 : 112 – 16<br/>Set — 1 : 72  – 32<br/>Set — 2 : 96  – 56<br/>Set — 3 : 112 – 72<br/>Set — 4 : 208 – 96<br/>Set — 5 : 224 – 176</span></pre><p id="f498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用了<code class="du je jf jg jh b">ObjectSizeCalculator.getObjectSize<em class="ji">()</em></code>来计算每个对象的内存开销。对于List，我对元素使用了<code class="du je jf jg jh b">null</code>,以减少数据结构的内存开销。对于包和布景，我使用了<code class="du je jf jg jh b">new Object()</code>来表示元素，使其具有尽可能小的对象足迹。如果不调整可变集合的大小，潜在的内存节省也会更大。我以前在一个应用程序中工作过，那里有数百万个小集合、列表和地图。使用这些小的不可变集合实现的内存节省是巨大的。</p><h2 id="96ae" class="jr js hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">与JDK集合类型的互操作</h2><p id="a3f7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">从技术上讲，您可以将一个<code class="du je jf jg jh b"><strong class="ih hj">ImmutableList</strong></code>强制转换成一个<code class="du je jf jg jh b"><strong class="ih hj">java.util.List</strong></code>，但是这是一种丑陋且不安全的为现有库提供互操作的方式。相反，每个不可变接口上都有方法可以将类型转换为合适的JDK类型。下面展示了如何使用这些方法。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="f9f7" class="jr js hi jh b fi jt ju l jv jw">List&lt;String&gt; list = <br/>    Lists.<strong class="jh hj"><em class="ji">immutable</em></strong>.with("1", "2", "3").<strong class="jh hj">castToList</strong>();</span><span id="9f87" class="jr js hi jh b fi jx ju l jv jw">Set&lt;String&gt; set = <br/>    Sets.<strong class="jh hj"><em class="ji">immutable</em></strong>.with("1", "2", "3").<strong class="jh hj">castToSet</strong>();</span><span id="8bd2" class="jr js hi jh b fi jx ju l jv jw">Map&lt;Integer, String&gt; map = <br/>    Maps.<strong class="jh hj"><em class="ji">immutable</em></strong>.with(1, "1", 2, "2", 3, "3").<strong class="jh hj">castToMap</strong>();</span></pre><p id="b11c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为现有的JDK集合类型提供良好的互操作一直是Eclipse集合的核心设计原则。</p><p id="1b7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong>在<code class="du je jf jg jh b"><strong class="ih hj">ImmutableBag</strong></code>上没有<code class="du je jf jg jh b"><strong class="ih hj">castToBag</strong></code>方法，因为现在的JDK没有<code class="du je jf jg jh b"><strong class="ih hj">Bag</strong></code>类型。</p><h2 id="ad83" class="jr js hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated"><strong class="ak">不可变集合的可变构建器</strong></h2><p id="2d79" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">还有另一种非常有用的创建不可变集合的工厂方法。在Eclipse集合中，每个可变类型都有一个方法，可以将自身复制到不可变的等价类型。方法名为<code class="du je jf jg jh b"><strong class="ih hj">toImmutable</strong></code>。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="2e3d" class="jr js hi jh b fi jt ju l jv jw">ImmutableList&lt;String&gt; list = <br/>    Lists.<strong class="jh hj"><em class="ji">mutable</em></strong>.with("1", "2", "3").<strong class="jh hj">toImmutable</strong>();</span><span id="a0b6" class="jr js hi jh b fi jx ju l jv jw">ImmutableSet&lt;String&gt; set = <br/>    Sets.<strong class="jh hj"><em class="ji">mutable</em></strong>.with("1", "2", "3").<strong class="jh hj">toImmutable</strong>();</span><span id="bb35" class="jr js hi jh b fi jx ju l jv jw">ImmutableBag&lt;String&gt; bag = <br/>    Bags.<strong class="jh hj"><em class="ji">mutable</em></strong>.with("1", "2", "3").<strong class="jh hj">toImmutable</strong>();</span><span id="247b" class="jr js hi jh b fi jx ju l jv jw">ImmutableMap&lt;Integer, String&gt; map = <br/>    Maps.<strong class="jh hj"><em class="ji">mutable</em></strong>.with(1, "1", 2, "2", 3, "3").<strong class="jh hj">toImmutable</strong>();</span></pre><p id="284f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着每个可变集合都是其对应的不可变类型的自然<strong class="ih hj"> <em class="ji">构建器</em> </strong>。然而，我们不提供不可变的构建器来转换成任何不同的类型。所以如果你想从一个<code class="du je jf jg jh b"><strong class="ih hj">MutableList</strong></code>构建一个<code class="du je jf jg jh b"><strong class="ih hj">ImmutableSet</strong></code>，你必须使用两种方法中的一种。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="a703" class="jr js hi jh b fi jt ju l jv jw">ImmutableSet&lt;String&gt; set1 = <br/>    Lists.<strong class="jh hj"><em class="ji">mutable</em></strong>.with("1", "2").<strong class="jh hj">toSet</strong>().<strong class="jh hj">toImmutable</strong>();<br/><br/>ImmutableSet&lt;String&gt; set2 = <br/>    Sets.<strong class="jh hj"><em class="ji">immutable</em></strong>.withAll(Lists.<strong class="jh hj"><em class="ji">mutable</em></strong>.with("1", "2"));</span></pre><h2 id="2caa" class="jr js hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated"><strong class="ak">对象和原语不可变集合</strong></h2><p id="9f21" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">以下是您可以使用不可变工厂创建的所有对象集合类型的示例。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="4f31" class="jr js hi jh b fi jt ju l jv jw">ImmutableList&lt;T&gt; list = Lists.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableSet&lt;T&gt; set = Sets.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableSortedSet&lt;T&gt; sortedSet = SortedSets.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableMap&lt;K, V&gt; map = Maps.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableSortedMap&lt;K, V&gt; sortedMap = SortedMaps.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableStack&lt;T&gt; stack = Stacks.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableBag&lt;T&gt; bag = Bags.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableSortedBag&lt;T&gt; sortedBag = SortedBags.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableBiMap&lt;K, V&gt; biMap = BiMaps.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableListMultimap&lt;K, V&gt; mm = Multimaps.<strong class="jh hj"><em class="ji">immutable</em></strong>.list.empty();<br/>ImmutableSetMultimap&lt;K, V&gt; mm = Multimaps.<strong class="jh hj"><em class="ji">immutable</em></strong>.set.empty();<br/>ImmutableBagMultimap&lt;K, V&gt; mm = Multimaps.<strong class="jh hj"><em class="ji">immutable</em></strong>.bag.empty();</span></pre><p id="db0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Eclipse集合也支持所有八种Java原语类型的不可变容器。这在对象和原始容器之间提供了良好的对称性。这里所有的原始类型都可以使用不可变工厂来创建。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="61f9" class="jr js hi jh b fi jt ju l jv jw">ImmutableIntList list = IntLists.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableIntSet set = IntSets.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();</span><span id="dbe9" class="jr js hi jh b fi jx ju l jv jw">// supports all combinations of primitives<br/>ImmutableIntIntMap map = IntIntMaps.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();  <br/>ImmutableIntObjectMap map = IntObjectMaps.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableObjectIntMap map = ObjectIntMaps.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();</span><span id="63bf" class="jr js hi jh b fi jx ju l jv jw">ImmutableIntStack stack = IntStacks.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableIntBag bag = IntBags.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();</span></pre><h2 id="4f2a" class="jr js hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">增长和收缩不可变集合</h2><p id="e50d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">一旦创建了一个不可变的集合，您可能希望通过添加或删除元素来扩大或缩小它。正如我之前提到的，在Eclipse集合中的不可变集合接口上没有像<code class="du je jf jg jh b">add</code>、<code class="du je jf jg jh b">addAll</code>、<code class="du je jf jg jh b">remove</code>或<code class="du je jf jg jh b">removeAll</code>这样的变异方法。除了提供<strong class="ih hj"> <em class="ji">结构不变性</em> </strong>之外，这还提供了我所说的<strong class="ih hj"> <em class="ji">契约不变性</em> </strong>。有一些方法允许安全地复制和增长或收缩不可变集合。<code class="du je jf jg jh b"><strong class="ih hj">ImmutableCollection</strong></code>的扩展有<code class="du je jf jg jh b">newWith</code>、<code class="du je jf jg jh b">newWithAll</code>、<code class="du je jf jg jh b">newWithout</code>、<code class="du je jf jg jh b">newWithoutAll</code>等方法。对于<code class="du je jf jg jh b"><strong class="ih hj">ImmutableMap</strong></code>实现，这些方法被命名为<code class="du je jf jg jh b">newWithKeyValue</code>、<code class="du je jf jg jh b">newWithAllKeyValues</code>、<code class="du je jf jg jh b">newWithoutKey</code>和<code class="du je jf jg jh b">newWithoutAllKeys</code>。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="a28b" class="jr js hi jh b fi jt ju l jv jw">ImmutableList&lt;String&gt; list0 = <br/>    Lists.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableList&lt;String&gt; list1 = <br/>    list0.<strong class="jh hj">newWith</strong>("1");<br/>ImmutableList&lt;String&gt; list2 = <br/>    list1.<strong class="jh hj">newWithAll</strong>(Lists.<strong class="jh hj"><em class="ji">mutable</em></strong>.with("2"));</span><span id="6a82" class="jr js hi jh b fi jx ju l jv jw">ImmutableSet&lt;String&gt; set0 = <br/>    Sets.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableSet&lt;String&gt; set1 = <br/>    set0.<strong class="jh hj">newWith</strong>("1");<br/>ImmutableSet&lt;String&gt; set2 = <br/>    set1.<strong class="jh hj">newWithAll</strong>(Sets.<strong class="jh hj"><em class="ji">mutable</em></strong>.with("2"));</span><span id="c193" class="jr js hi jh b fi jx ju l jv jw">ImmutableMap&lt;String, String&gt; map0 = <br/>    Maps.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableMap&lt;String, String&gt; map1 = <br/>    map0.<strong class="jh hj">newWithKeyValue</strong>("1", "1");<br/>ImmutableMap&lt;String, String&gt; map2 = <br/>    map1.<strong class="jh hj">newWithAllKeyValues</strong>(<br/>        Lists.<strong class="jh hj"><em class="ji">mutable</em></strong>.with(Tuples.<em class="ji">pair</em>("2", "2")))</span></pre><p id="2371" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了提供良好的对称性，这些方法在原始容器上也是可用的。</p><pre class="jj jk jl jm fd jn jh jo jp aw jq bi"><span id="850e" class="jr js hi jh b fi jt ju l jv jw">ImmutableIntList list0 =<br/>        IntLists.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableIntList list1 =<br/>        list0.<strong class="jh hj">newWith</strong>(1);<br/>ImmutableIntList list2 =<br/>        list1.<strong class="jh hj">newWithAll</strong>(IntLists.<strong class="jh hj"><em class="ji">mutable</em></strong>.with(2));</span><span id="5192" class="jr js hi jh b fi jx ju l jv jw">ImmutableIntSet set0 =<br/>        IntSets.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableIntSet set1 =<br/>        set0.<strong class="jh hj">newWith</strong>(1);<br/>ImmutableIntSet set2 =<br/>        set1.<strong class="jh hj">newWithAll</strong>(IntSets.<strong class="jh hj"><em class="ji">mutable</em></strong>.with(2));</span><span id="8f89" class="jr js hi jh b fi jx ju l jv jw">ImmutableIntIntMap map0 =<br/>        IntIntMaps.<strong class="jh hj"><em class="ji">immutable</em></strong>.empty();<br/>ImmutableIntIntMap map1 =<br/>        map0.<strong class="jh hj">newWithKeyValue</strong>(1, 1);</span></pre><p id="7f5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在写这篇博客的时候，我发现我们在不可变的原始地图容器中缺少了一些对称性。我们目前在不可变的原始地图上没有<code class="du je jf jg jh b"><strong class="ih hj">newWithAllKeyValues</strong></code>,所以我为这个特性提交了一个<a class="ae jd" href="https://github.com/eclipse/eclipse-collections/issues/344" rel="noopener ugc nofollow" target="_blank">发布请求</a>。</p><h2 id="0fb1" class="jr js hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">摘要</h2><p id="90f2" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">要在Eclipse集合中创建可变或不可变的容器类型，您需要记住的只是类型的多个工厂类名的模式(<code class="du je jf jg jh b"><strong class="ih hj">List</strong></code>有<code class="du je jf jg jh b"><strong class="ih hj">Lists</strong></code>，<code class="du je jf jg jh b"><strong class="ih hj">Set</strong></code>有<code class="du je jf jg jh b"><strong class="ih hj">Sets</strong></code>，等等)。).然后使用IDE的代码补全来决定您是想要不可变的 还是可变的<strong class="ih hj"><em class="ji"/></strong>实例。然后你可以根据你的方法命名偏好选择<code class="du je jf jg jh b"><strong class="ih hj">with</strong></code>或者<code class="du je jf jg jh b"><strong class="ih hj">of</strong></code>。</p><p id="a4b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>适用于Java版本5到9。因此，如果您正在从事任何尚未升级到Java 8的项目，这些工厂今天仍然可以使用。如果您使用的是Java 8之前的Java版本，只需使用<a class="ae jd" href="http://mvnrepository.com/artifact/org.eclipse.collections/eclipse-collections/7.1.1" rel="noopener ugc nofollow" target="_blank">Eclipse Collections 7 . 1 . 1</a>。如果使用的是Java 8或以上版本，可以使用<a class="ae jd" href="http://mvnrepository.com/artifact/org.eclipse.collections/eclipse-collections/8.2.0" rel="noopener ugc nofollow" target="_blank"> Eclipse Collections 8.x </a>或即将发布的9.x版本。如果你愿意尝试并给我们提供反馈，今天有9.x 的里程碑版本。</p><p id="0906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于所有工厂类型以及如何创建集合容器的完整参考，您可以阅读<a class="ae jd" href="https://github.com/eclipse/eclipse-collections/blob/master/docs/guide.md#-creating-collections-containers" rel="noopener ugc nofollow" target="_blank"> Eclipse集合参考指南</a>的这一部分。</p><p id="fb87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="ji">月食收藏</em> </a> <em class="ji">为</em> <a class="ae jd" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="ji">投稿</em> </a> <em class="ji">打开。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div></div>    
</body>
</html>