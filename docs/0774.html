<html>
<head>
<title>Legible Lambdas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清晰的兰姆达斯</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/legible-lambdas-4259c831918e?source=collection_archive---------0-----------------------#2020-11-10">https://medium.com/javarevisited/legible-lambdas-4259c831918e?source=collection_archive---------0-----------------------#2020-11-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1cb74310c858557cd548e71810a6a0fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjT02Am-JrYZJWyv0iABvA.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@builtbymath?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">数学</a>在<a class="ae iu" href="https://unsplash.com/s/photos/java?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="6357" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们都喜欢羊肉，不是吗？Lambdas是强大的(传递方法，摆脱匿名类……你明白了),强大的能力意味着巨大的责任。当我们在工作中切换到使用Java 8时，我很兴奋终于可以使用<a class="ae iu" rel="noopener" href="/javarevisited/7-best-java-tutorials-and-books-to-learn-lambda-expression-and-stream-api-and-other-features-3083e6038e14?source=---------14------------------"> lambdas </a>！但是很快，我发现自己把所有的代码都塞进了lambda。我不仅试图过度使用它，我还写了非常不可读的代码。</p><p id="4ac0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在过去几年的过程中，我收集了一些使用lambdas的“惊喜”和“陷阱”，这些是我遇到过的，更重要的是，是我逃避过的(所有的例子主要与Java有关):</p><h2 id="257a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">使用消费者、功能和供应商</strong></h2><p id="4e3c" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">消费者就像具有void返回类型和一个输入参数的方法。函数是处理方法，接受A类型的元素并产生B类型的元素(A和B也可以是相同的类型)。</p><p id="9e38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kt ku kv kw b">Suppliers </code>类似于没有输入参数但总是产生输出的方法。我花了一段时间才掌握这些细微差别。当您必须使用这些接口之一重构一些代码时，理解这些差异会有很大帮助。</p><p id="3d0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，考虑以下代码片段:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="9900" class="jt ju hi kw b fi lf lg l lh li">someList.stream().map(listItem -&gt; {<br/>    Step 1;<br/>    return<!-- --> <!-- -->result of Step 1;<br/>}).map(step1Item -&gt; {<br/>    Step 2;<br/>    return<!-- --> <!-- -->result of Step 2;<!-- --> <br/>})</span><span id="7548" class="jt ju hi kw b fi lj lg l lh li">someOtherList.stream().map(listItem -&gt; {<br/>    Step 1;<br/>    return result of Step 1;<br/>}).map(step1Item -&gt; {<br/>    Step 3;<br/>    return result of Step 3;<br/>})</span></pre><p id="6781" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了能够重用将步骤1应用到列表项，我们可以将第一个map方法的输入提取到一个<a class="ae iu" href="https://javarevisited.blogspot.com/2018/01/what-is-functional-interface-in-java-8.html" rel="noopener ugc nofollow" target="_blank">函数接口</a>中，经过这一更改，代码现在看起来如下:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="4a6c" class="jt ju hi kw b fi lf lg l lh li">someList.stream().map(applyStep1())<br/>.map(step1Item -&gt; {<br/>    Step 2;<br/>    return result of Step 2;<br/>})</span><span id="4e8c" class="jt ju hi kw b fi lj lg l lh li">someOtherList.stream().map(applyStep1())<br/>.map(step1Item -&gt; {<br/>    Step 3;<br/>    return result of Step 3;<br/>})</span><span id="964c" class="jt ju hi kw b fi lj lg l lh li">Function&lt;a&gt; applyStep1() {<br/>    return A -&gt; {<br/>        Step 1;<br/>        return result of Step 1;<br/>    };<br/>}</span></pre><p id="27ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个简单的方法是:让您的IDE帮助您将映射的输入提取到函数中(选择映射中的整个代码块-&gt;右键单击并重构-&gt;提取-&gt;方法-&gt;命名函数和TADA)。其他接口如<code class="du kt ku kv kw b">Consumers </code>和<code class="du kt ku kv kw b">Suppliers</code>也可以这样做！</p><h2 id="5b72" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">重复使用还原方法</strong></h2><p id="c442" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">想得到列表中所有项目的总和吗？平均水平？不用再看了，streams API对这两者都有一个方法！</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="88c5" class="jt ju hi kw b fi lf lg l lh li">integerList.stream().mapToInt(Integer::intValue).sum()<br/>integerList.stream().mapToInt(Integer::intValue).average()</span></pre><p id="c7fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在这里想说的是，有现成的简化方法可以提供，在冒险写自己的方法之前先看看是个好主意:)</p><h2 id="42e7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">并非所有东西都必须使用流/并行流API </strong></h2><p id="3a16" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated"><a class="ae iu" href="https://www.java67.com/2014/04/java-8-stream-examples-and-tutorial.html" rel="noopener ugc nofollow" target="_blank">流API </a>是java 8最广为人知的特性之一，的确如此。它与lambdas配合得非常好，作为一个新手，我下意识地将我所有的收藏转换成streams，不管它是否是必需的。</p><p id="f5d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地<a class="ae iu" href="https://www.java67.com/2018/10/java-8-stream-and-functional-programming-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank">流vs平行流</a>。平行是好的，对吗？是的。一直都好吗？绝对不行。互联网上有很多关于这些主题的文章和性能基准，我强烈建议您在浏览代码库之前做好研究。</p><h2 id="dda4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">打散巨型兰姆达斯！</strong></h2><p id="aae5" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们需要将44个步骤应用到我们的输入中，我们决定使用地图。但是我们需要在一个地图方法中应用所有的44个步骤吗？让我想想。因此，如果我们只使用一个map方法，我们的代码看起来应该是这样的:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="dcb7" class="jt ju hi kw b fi lf lg l lh li">someList.stream().map(listItem -&gt; {<br/>    Step 1;<br/>    Step 2;<br/>    Step 3;<br/>    Step 4;<br/>    .<br/>    .<br/>    .<br/>    Step 44;<br/>    return result of all above Steps;<br/>});</span></pre><p id="15ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来考虑这个:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="ddb4" class="jt ju hi kw b fi lf lg l lh li">someList.stream().map(listItem -&gt; {<br/>    Step 1;<br/>    return result of Step 1;<br/>}).map(step1Item -&gt; {<br/>    Step 2;<br/>    return result of Step 2;<br/>}).map(step2Item -&gt; {<br/>    Step 3;<br/>    return result of Step 3;<br/>}).map(step3Item -&gt; {<br/>    Step 4;<br/>    return result of Step 4;<br/>});<br/>.<br/>.<br/>.</span></pre><p id="4bf6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我相信使用lambdas的最大优势之一是您可以非常优雅地将处理步骤分解成它们自己的map方法(也可以使用其他方法，我在这里只是引用map作为例子)。我总是喜欢把大的<a class="ae iu" rel="noopener" href="/javarevisited/how-to-use-streams-map-filter-and-collect-methods-in-java-1e13609a318b?source=---------10------------------"> map方法</a>分解成更易读、更易维护的单个方法(这也考虑到了可重用性)。</p><p id="711f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同时，我建议不要盲目地在每个map方法中只执行一行代码。我们总是可以在合适的时候将处理步骤合并到一个映射中(例如，步骤1–3可以在一个映射中)。</p><h2 id="4df7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">带有中频环路的map()与滤波器</strong></h2><p id="baef" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">您可以使用<a class="ae iu" href="https://www.java67.com/2016/08/java-8-stream-filter-method-example.html" rel="noopener ugc nofollow" target="_blank"> filter() </a>过滤收藏中的项目。我花了多长时间才把if移动到我的映射中，使之成为过滤谓词？够久了。我要说的是:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="7343" class="jt ju hi kw b fi lf lg l lh li">someList.stream().map(listItem -&gt; {<br/>    if(listItem.startsWith("A") {<br/>        //Do Something<br/>    }<br/>});</span></pre><p id="c9c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以写成这样:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="0006" class="jt ju hi kw b fi lf lg l lh li">someList.stream()<br/>.filter(listItem -&gt; listItem.startsWith("A"))<br/>.map(listItem -&gt; {<br/>    //Do Something<br/>});</span></pre><p id="d352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然这可能会也可能不会提高性能，但它增加了可读性，并确保使用适当的方法。</p><p id="61ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">切换到使用<a class="ae iu" rel="noopener" href="/javarevisited/8-best-lambdas-stream-and-functional-programming-courses-for-java-developers-3d1836a97a1d"> lambdas </a>对我来说是一个很大的飞跃，花了很长时间来适应，它继续让我惊讶、沮丧，同时也让我惊叹！</p></div></div>    
</body>
</html>