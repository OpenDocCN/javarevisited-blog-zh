<html>
<head>
<title>Factory Design Pattern For Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的工厂设计模式</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/factory-design-pattern-for-beginners-addfe60aed02?source=collection_archive---------2-----------------------#2021-01-06">https://medium.com/javarevisited/factory-design-pattern-for-beginners-addfe60aed02?source=collection_archive---------2-----------------------#2021-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4ca255270638a36ec6c59264117ec8b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_8jG79dp14x2sh47vGI9g.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">安特·罗泽茨基在<a class="ae iu" href="https://unsplash.com/s/photos/factory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="fe94" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">工厂设计模式与生成器和单例设计模式一样，属于<a class="ae iu" rel="noopener" href="/javarevisited/7-best-online-courses-to-learn-object-oriented-design-pattern-in-java-749b6399af59">设计模式</a>的创造性设计模式类别。</p><p id="7496" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它为我们提供了一种机制，其中工厂方法有助于创建和实例化对象。在这种情况下，父类将保存对子类的引用。</p><p id="809b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，我们提供了<strong class="ix hj"> <em class="jt">抽象</em> </strong>，其中对象创建隐藏在工厂方法中。我们只需传递指示需要创建哪个对象的参数，然后工厂会为我们返回已创建的对象。</p><p id="a22d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对象的构造<strong class="ix hj"> <em class="jt">与对象的</em> </strong>分离，这在遵循工厂设计模式的同时形成了额外的优势。</p><p id="65f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">子类的公共实现可以保存在父类中，因此代码的可维护性也可以在这里实现。代码重复被删除，因此我们可以实现不重复自己(D.R.Y)原则。</p><p id="f31e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们动手看看这个模式是如何实现的。</p><p id="7eee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先让我们创建一个包含语言类型的<a class="ae iu" href="https://javarevisited.blogspot.com/2011/08/enum-in-java-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">枚举</a>。该枚举将具有语言Id和语言名称。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="f791" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">public enum </strong>LanguageType {<br/>    <strong class="jz hj"><em class="jt">GERMAN</em></strong>(1, <strong class="jz hj">"German"</strong>),<br/>    <strong class="jz hj"><em class="jt">FRENCH</em></strong>(2, <strong class="jz hj">"French"</strong>);<br/><br/>    <strong class="jz hj">private int languageId</strong>;<br/>    <strong class="jz hj">private </strong>String <strong class="jz hj">languageName</strong>;<br/><br/>    LanguageType(<strong class="jz hj">int </strong>languageId, String languageName) {<br/>        <strong class="jz hj">this</strong>.<strong class="jz hj">languageId </strong>= languageId;<br/>        <strong class="jz hj">this</strong>.<strong class="jz hj">languageName </strong>= languageName;<br/>    }<br/>}</span></pre><p id="2582" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们要求有一个<strong class="ix hj"> <em class="jt">超</em> </strong>的类语言。超类可以是一个<a class="ae iu" href="http://javarevisited.blogspot.sg/2013/05/difference-between-abstract-class-vs-interface-java-when-prefer-over-design-oops.html#axzz4pk4W5ie3" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">抽象类，也可以是一个</strong> </a> <strong class="ix hj">接口。</strong></p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="4d3c" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">public abstract class </strong>Language {<br/>    <strong class="jz hj">public abstract </strong>String greet();<br/>}</span></pre><p id="24d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当超类或父类被创建时，让我们创建子类，它将扩展父类。这是德语课:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="53cd" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">public class </strong>GermanLanguage <strong class="jz hj">extends </strong>Language{<br/>    @Override<br/>    <strong class="jz hj">public </strong>String greet() {<br/>        <strong class="jz hj">return "Guten Morgen"</strong>;<br/>    }<br/>}</span></pre><p id="9b5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是法语课:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="09f1" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">public class </strong>FrenchLanguage <strong class="jz hj">extends </strong>Language{<br/>    @Override<br/>    <strong class="jz hj">public </strong>String greet() {<br/>        <strong class="jz hj">return "Bonjour"</strong>;<br/>    }<br/>}</span></pre><p id="96b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在父类和子类都已经就位，让我们看看如何创建工厂类。下面是LanguageFactory类:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="46d1" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">public class </strong>LanguageFactory {<br/>    <strong class="jz hj">public static </strong>Language getLanguage(<strong class="jz hj">int </strong>languageId) {<br/>        <strong class="jz hj">if </strong>(languageId == <strong class="jz hj"><em class="jt">GERMAN</em></strong>.getLanguageId())<br/>            <strong class="jz hj">return new </strong>GermanLanguage();<br/>        <strong class="jz hj">else if </strong>(languageId == <strong class="jz hj"><em class="jt">FRENCH</em></strong>.getLanguageId())<br/>            <strong class="jz hj">return new </strong>FrenchLanguage();<br/>        <strong class="jz hj">return null</strong>;<br/>    }<br/>}</span></pre><p id="d963" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，我们匹配传递给getLanguage()方法的languageId，并相应地创建对象。</p><p id="75a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看看这个实现是如何工作的。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a36b" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">public class </strong>LanguageImplementation {<br/>    <strong class="jz hj">public static void </strong>main(String[] args) {<br/>        Language germanLanguage = LanguageFactory.<em class="jt">getLanguage</em>(LanguageType.<strong class="jz hj"><em class="jt">GERMAN</em></strong>.getLanguageId());<br/>        Language frenchLanguage = LanguageFactory.<em class="jt">getLanguage</em>(LanguageType.<strong class="jz hj"><em class="jt">FRENCH</em></strong>.getLanguageId());<br/><br/>        System.<strong class="jz hj"><em class="jt">out</em></strong>.println(<strong class="jz hj">"German Language Greeting : " </strong>+ germanLanguage.greet());<br/>        System.<strong class="jz hj"><em class="jt">out</em></strong>.println(<strong class="jz hj">"French Language Greeting : " </strong>+ frenchLanguage.greet());<br/>    }<br/>}</span></pre><p id="99fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在这里看到的输出是:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="7454" class="kd ke hi jz b fi kf kg l kh ki">German Language Greeting : Guten Morgen<br/>French Language Greeting : Bonjour</span></pre><p id="f33c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们的实现。</p><p id="a313" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用工厂设计模式实现的目标:</p><ol class=""><li id="00fe" class="kj kk hi ix b iy iz jc jd jg kl jk km jo kn js ko kp kq kr bi translated">将对象的创建与对象分离。</li><li id="1d6b" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">抽象。</li><li id="1606" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">遵循不重复自己的原则。</li></ol><p id="848e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那就这样吧。如果您有任何问题，请在评论框中告诉我。</p></div></div>    
</body>
</html>