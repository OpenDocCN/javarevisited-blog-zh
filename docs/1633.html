<html>
<head>
<title>Learn OSGi from Scratch — Eclipse, IntelliJ and WSO2 Platform 🖥️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始学习OSGi——eclipse、IntelliJ和WSO2平台🖥️</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/learn-osgi-from-scratch-eclipse-intellij-and-wso2-platform-%EF%B8%8F-bf4c5629e097?source=collection_archive---------0-----------------------#2021-10-11">https://medium.com/javarevisited/learn-osgi-from-scratch-eclipse-intellij-and-wso2-platform-%EF%B8%8F-bf4c5629e097?source=collection_archive---------0-----------------------#2021-10-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cd4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑下面这个问题。在任何大型工程项目中，例如，设计一座新桥或喷气式客机，最难克服的挑战是什么？</p><p id="c7cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是💥<em class="jd">复杂。</em></p><p id="9390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">兰博基尼Aventador有大约100万个零件，它是一台非常非常复杂的机器，因为这种复杂性，没有一个人能够完全理解它是如何工作的。尽管它已经建成，而且它的复杂性每年都在成倍增加。那么工程师如何才能造出这样的机器呢？</p><p id="f62a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是将机器分成更小、更容易理解的模块。</p><p id="b721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模块化带来了几个重要的好处。</p><ul class=""><li id="027c" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">分工</strong>——可以分配单独的个人或小组在单独的模块上工作。从事一个模块工作的人将会对他们自己的模块有一个彻底的了解。</li><li id="8db8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae js" href="https://javarevisited.blogspot.com/2010/10/abstraction-in-java.html#axzz6oOeSmpNw" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">抽象</strong></a>——把Aventador当做一个抽象模型。我们可以得到这样的想法，它会移动，而不必掌握燃料如何供应或发动机如何工作的想法。</li><li id="d70a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">重复使用</strong> —考虑到设计Aventador更小的组件所花费的时间，当我们需要在另一辆车上使用类似的组件时，从头开始设计是一种浪费。因此，如果我们可以重用组件，只需做最小的改动，那将会很有帮助。</li><li id="678e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">易于维护和修理</strong>——每当车胎漏气时就要重新组装整辆车简直是疯了。模块化设计允许在不影响机器其余部分的情况下，移除故障模块并进行维修或更换。</li></ul><p id="94c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java编程语言是构建大型企业应用程序以及小型但广泛部署的移动应用程序最流行的语言之一。然而，<strong class="ih hj"> Java本身并不能以任何有用的方式支持模块化。但是Java的灵活性和可伸缩性允许在其上构建一个强大的模块系统。</strong></p><p id="08d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那个模块系统被称为<strong class="ih hj"> OSGi </strong>(之前是<strong class="ih hj">开放服务网关倡议</strong>的首字母缩写)，读作(Oh-ess-gee-eye)。</p><h1 id="4ee4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀什么是模块？</h1><p id="36e4" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">那么，什么是<em class="jd">软件模块呢？</em>软件模块具有以下属性。</p><ul class=""><li id="4705" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">自包含</strong> —一个模块整体是逻辑的。它可以作为一个单元移动、安装和卸载。它由较小的部分组成，这些部分是模块的组成部分。如果其中一个被移除，模块可能会停止工作。</li><li id="38aa" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">高度内聚 —内聚是一个模块职责紧密相关程度的度量。一个模块不应该做很多不相关的事情，而应该坚持一个逻辑目的并完成它。(例如，网络模块不应检查持久性、数据库验证、输入验证。它应该只坚持网络部分。)</li><li id="5806" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">松耦合</strong> —一个模块不应该关心它与之交互的其他模块的内部实现。松散耦合允许我们更改一个模块的实现，而不需要更新使用它的所有其他模块。</li></ul><p id="2e5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了支持所有这三个属性，模块必须有一个<em class="jd">明确定义的接口</em>来与其他模块交互。稳定的接口加强了模块之间的逻辑界限，并防止对内部实现细节的访问。</p><h1 id="0d51" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀罐子的问题</h1><p id="52ca" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Java中的标准部署单元是JAR文件。jar是基于ZIP文件格式的归档文件，允许将许多文件聚集成一个文件。</p><p id="8867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，存档中包含的文件是编译后的Java类和图像等资源文件的组合。此外，在<a class="ae js" href="https://javarevisited.blogspot.com/2012/03/how-to-create-and-execute-jar-file-in.html" rel="noopener ugc nofollow" target="_blank"> JAR归档文件</a>中有一个元数据的标准位置——<strong class="ih hj">META-INF</strong>文件夹，其中可以包含许多不同格式的文件，而<strong class="ih hj"> MANIFEST。MF </strong>文件是最重要的文件。</p><p id="afcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JAR文件提供单个库或应用程序的一部分功能。因此，构建Java应用程序需要组合许多JAR文件。</p><p id="a9d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，Java开发工具包(<a class="ae js" href="https://javarevisited.blogspot.com/2011/12/jre-jvm-jdk-jit-in-java-programming.html" rel="noopener ugc nofollow" target="_blank"> JDK </a>)只提供了非常基本的管理和编写jar的工具。事实上，这些工具太简单了，以至于开发人员用“JAR Hell”这个术语来描述管理JAR的问题。</p><p id="9d84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JAR文件作为部署单元的最关键问题如下:</p><ul class=""><li id="7d8f" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">没有<strong class="ih hj">对应JAR的运行时</strong>概念；它们只在<strong class="ih hj">构建时</strong>和<strong class="ih hj">部署时有意义。</strong>一旦<a class="ae js" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686?source=---------8------------------"> JVM </a>运行，所有jar的内容都被简单地作为一个单一的全局列表:<strong class="ih hj"> Classpath。</strong></li><li id="c6b3" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">他们没有标准的元数据来表示依赖关系。</li><li id="dcd7" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">它们没有版本控制，因此不能同时加载多个jar。</li><li id="3fe9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">jar之间没有信息隐藏的机制。</li></ul><h2 id="7dfa" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">类加载和全局类路径</h2><p id="380b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">术语<a class="ae js" href="http://www.java67.com/2012/08/what-is-path-and-classpath-in-java-difference.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">类路径</strong> </a>来自命令行参数，当从命令shell运行简单的Java应用程序时，可以将该参数传递给<code class="du lk ll lm ln b">java</code>命令。它指定了一个包含编译后的Java类文件的JAR文件和目录的<strong class="ih hj">列表。</strong></p><p id="78a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，下面的命令启动一个Java应用程序，在类路径上有<code class="du lk ll lm ln b">log4j.jar</code>和<code class="du lk ll lm ln b">classes</code>目录。UNIX/macOS X命令是:</p><p id="46c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">java -classpath log4j.jar:classes org.example.HelloWorld</code></p><p id="391f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个参数是要执行的<strong class="ih hj">主</strong>类的名称，按照我们的假设，它被编译到<code class="du lk ll lm ln b">classes</code>目录中的<code class="du lk ll lm ln b">org/example/HelloWorld.class</code>。</p><p id="7d15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM的职责是加载该类文件中的<strong class="ih hj">字节</strong>并将它们转换成一个<code class="du lk ll lm ln b">Class</code>对象，然后它可以执行<code class="du lk ll lm ln b"><a class="ae js" href="http://javarevisited.blogspot.sg/2011/12/main-public-static-java-void-method-why.html#axzz4uMEUqg5v" rel="noopener ugc nofollow" target="_blank">static main</a></code>方法。让我们看看这在标准JRE中是如何工作的。</p><p id="eda3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java中加载类的类是<code class="du lk ll lm ln b"><a class="ae js" href="https://javarevisited.blogspot.com/2021/05/java-classloader-interview.html" rel="noopener ugc nofollow" target="_blank">java.lang.ClassLoader</a></code>，它有两个职责。</p><ul class=""><li id="6932" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">根据逻辑类名查找类，即磁盘上的物理字节。</li><li id="3f63" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">将这些物理字节转换成内存中的一个<code class="du lk ll lm ln b">Class</code>对象。</li></ul><p id="35a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们运行命令<code class="du lk ll lm ln b">java -classpath log4j.jar:classes org.example.HelloWorld</code>时，JRE确定它需要加载类<code class="du lk ll lm ln b">org.example.HelloWorld</code>，因为它是<code class="du lk ll lm ln b">main</code>类，它使用一个名为<em class="jd">应用程序类加载器的特殊<code class="du lk ll lm ln b">ClassLoader</code>。</em>应用程序类加载器做的第一件事是请求它的父类加载类。</p><p id="b6ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个过程是Java类加载中的一个关键特性，称为<strong class="ih hj">父类优先委托。为了简单地说明整个过程，我们将使用下面给出的流程图。</strong></p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2012/12/how-classloader-works-in-java.html#axzz6uFgb20Y4"><div class="er es lo"><img src="../Images/d858a8c5486f7535ef452eaa3b8b5230.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*8CDn2VTyeFrOHTUHetDOgg.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图JRE类加载</p></figure><p id="751f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图中有三个类加载器，bootstrap类加载器在树的顶部，它负责<strong class="ih hj">加载基础JRE库中的所有类</strong> ( <code class="du lk ll lm ln b">java</code>、<code class="du lk ll lm ln b">javafx</code>等。)</p><p id="75b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，扩展类加载器从<strong class="ih hj">扩展库加载，这些库不是基础JRE的一部分，而是由管理员安装到JRE的</strong> <code class="du lk ll lm ln b"><strong class="ih hj">libext</strong></code> <strong class="ih hj">目录中。</strong>最后是应用程序类加载器，加载<a class="ae js" href="https://javarevisited.blogspot.com/2011/01/how-classpath-work-in-java.html#axzz6uq12fuKh" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">类路径</strong> </a>。</p><ol class=""><li id="9823" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ma jk jl jm bi translated">JRE要求应用程序类加载器加载一个类</li><li id="994c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ma jk jl jm bi translated">应用程序类加载器要求扩展类加载器加载类。</li><li id="e641" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ma jk jl jm bi translated">扩展类装入器要求引导类装入器装入类。</li><li id="0ec1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ma jk jl jm bi translated">引导类装入器找不到类，所以扩展类装入器试图找到它。</li><li id="3af4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ma jk jl jm bi translated">扩展类加载器找不到类，应用程序类加载器试图找到它，首先在<code class="du lk ll lm ln b">log4j.jar</code>中查找</li><li id="1c44" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ma jk jl jm bi translated">该类不在<code class="du lk ll lm ln b">log4j.jar</code>中，因此类加载器在<code class="du lk ll lm ln b">classes</code>目录中查找。</li><li id="7cf0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ma jk jl jm bi translated">如果找到并加载了该类，它将从第1步开始再次加载其他类。否则，它将给出常见的<code class="du lk ll lm ln b">ClassNotFoundException.</code></li></ol><h2 id="bf61" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">冲突类</h2><p id="a84e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Java 中的<a class="ae js" href="https://javarevisited.blogspot.com/2012/07/when-class-loading-initialization-java-example.html#axzz6ucXRVFjY" rel="noopener ugc nofollow" target="_blank">加载类在大多数时候都能顺利运行，但是如果我们添加一个包含旧版本<code class="du lk ll lm ln b">HelloWorld</code>的过时JAR，会发生什么呢？让我们称这个JAR文件为<code class="du lk ll lm ln b">obsolete.jar</code></a></p><p id="f9da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">java -classpath obsolete.jar:log4j.jar:classes org.example.HelloWorld</code></p><p id="bab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于在类路径中，<code class="du lk ll lm ln b">obsolete.jar</code>出现在<code class="du lk ll lm ln b">classes</code>之前，并且由于<em class="jd">应用程序类加载器</em>在找到匹配项时会尽快停止，因此该命令将始终具有与使用旧版本的<code class="du lk ll lm ln b">HelloWorld</code>相同的影响，并且<code class="du lk ll lm ln b">classes</code>目录将<strong class="ih hj">永远不会</strong>被使用。</p><h2 id="526f" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">缺乏明确的依赖关系</h2><p id="b0eb" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">虽然有一些<strong class="ih hj">独立的</strong> JAR文件不依赖于其他JAR文件，但是大多数JAR文件依赖于其他JAR文件。如果没有正确的文档来说明如何使用这些JAR文件，那么这些功能将是有害的。</p><h2 id="faf7" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated"><strong class="ak">缺少版本信息</strong></h2><p id="5f20" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">世界不会静止不动，图书馆也不会。他们一直在更新和获得新的版本。因此，指出依赖项或库是不够的。我们需要知道我们需要的确切的<em class="jd">版本</em>。大多数时候，文档帮助我们不陷入那些版本陷阱。但有时我们会遇到类似下面这个例子的问题:</p><p id="4ac5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设有三个JAR文件，A.jar、B.jar和C.jar。A.jar需要1.1版本的C.jar，B.jar需要1.2版本的c . JAR。我们的应用程序需要a . JAR和B.jar。</p><p id="de79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，由于类路径只选择了C.jar的一个版本，我们会遇到与A.jar或B.jar的依赖问题。因此，很明显，如果不重写与A.jar或B.jar相关的源代码，传统的Java无法解决这些问题。</p><h2 id="e628" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">缺乏跨罐的信息隐藏</h2><p id="703f" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">所有面向对象编程语言都提供了不同的隐藏信息的方式。在Java中，<em class="jd">封装</em>依赖于我们使用的<em class="jd">访问修饰符</em>。</p><ul class=""><li id="f43e" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du lk ll lm ln b"><a class="ae js" href="https://javarevisited.blogspot.com/2012/10/difference-between-private-protected-public-package-access-java.html#axzz6j8KhisSX" rel="noopener ugc nofollow" target="_blank">public</a></code> <a class="ae js" href="https://javarevisited.blogspot.com/2012/10/difference-between-private-protected-public-package-access-java.html#axzz6j8KhisSX" rel="noopener ugc nofollow" target="_blank"> </a> —每个人都可以看到成员。</li><li id="56e8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lk ll lm ln b"><a class="ae js" href="http://www.java67.com/2012/12/what-is-public-private-protected-package-default-private-access-modifier-java.html" rel="noopener ugc nofollow" target="_blank">protected</a></code> <a class="ae js" href="http://www.java67.com/2012/12/what-is-public-private-protected-package-default-private-access-modifier-java.html" rel="noopener ugc nofollow" target="_blank"> </a> —成员对同一包中的子类和其他类可见。</li><li id="5158" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lk ll lm ln b">private</code> —成员仅在同一类中可见</li><li id="7c76" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lk ll lm ln b">default</code> —未声明上述三个访问级别的成员。它们只对同一个包内的其他类可见，对包外的类不可见。</li></ul><p id="4fc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，JAR之外的客户机可以访问所有这些声明为公共的类。因此，整个JAR基本上是公共API，甚至是我们希望隐藏的部分。</p><p id="13c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">所以，jar不是模块。尽管它们可以被移动，但是它们具有紧密耦合的低内聚力的ZIP存档。</strong></p><p id="9d5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但这并不是说我们不使用jar就不能构建模块化系统。模块化系统的实现需要jar，但它们不是模块。</p><h1 id="3903" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀J2EE级装载</h1><p id="c5e9" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Java 2企业版(J2EE)规范为<strong class="ih hj">分布式多层计算定义了一个平台。</strong>J2EE架构的关键特性是<em class="jd">应用服务器</em>，它托管多个应用组件并为它们提供企业级服务。</p><p id="62b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些需求暗示了图-1 中简单的类加载图是不够的。因为有了<strong class="ih hj">单一的平面类路径，来自一个应用程序的类很容易干扰其他应用程序。</strong>因此，J2EE使用了更高级的类加载层次结构，这基本上是一个树，每个部署的应用都有一个分支。</p><p id="fb4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">J2EE应用程序被部署为<strong class="ih hj">企业归档(EAR) </strong>文件，这些文件是包含元数据文件— <code class="du lk ll lm ln b">application.xml</code>以及一个或多个以下文件的ZIP文件:</p><ul class=""><li id="89cb" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">普通Java库JAR文件</li><li id="b6d0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">包含(企业Java bean)EJB应用程序的JAR文件(EJB-JARs)</li><li id="0420" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Web ARchive (WAR)文件，包含实现Web功能的类，如servlets和JSP。</li></ul><p id="f478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这种架构也有问题，上层类加载器(而不是分支中的加载器)之间的类共享会导致版本冲突。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/09/top-5-java-ee-courses-to-learn-online.html"><div class="er es mb"><img src="../Images/1db05bd2b2b1043f4f898c5f0d9ef15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*Vw_Ac1zkqovCjqhfosyiDQ.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图2——J2EE等级载荷</p></figure><h1 id="e1e9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀OSGi</h1><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mc"><img src="../Images/ff193f5dee8eb561e58fc19a40c3526b.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*0hsNbYxougFgK96FQ2vrPQ.jpeg"/></div></div></figure><p id="a81d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OSGi是Java的模块系统。它定义了一种创建真正模块的方法，以及这些模块在运行时交互的方法。</p><p id="e74e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OSGi的主要思想很简单。传统Java中大多数问题的根源是全局的、扁平的类路径。因此，OSGi采取了不同的方法:<strong class="ih hj">每个模块都有自己的类路径，与所有其他模块的类路径相分离。</strong></p><p id="2d76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这几乎消除了我们之前讨论的所有问题。但是这并没有结束，我们仍然需要我们的模块一起工作，这意味着共享类。OSGi使用<strong class="ih hj">显式导入和导出机制，对如何跨模块共享类有非常具体和定义良好的规则。</strong></p><p id="aac2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，OSGi模块看起来像什么？第一，我们不叫它模块，我们在OSGi叫它<strong class="ih hj"> <em class="jd">捆绑</em> </strong>。事实上，它只是一个JAR文件！但是它包含将它提升为一个包的元数据。元数据包括:</p><ul class=""><li id="2955" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">管束的<em class="jd">名称</em>。</li><li id="a71d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">捆绑包的<em class="jd">版本</em>。</li><li id="47ba" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="jd">进口</em>和<em class="jd">出口的清单。</em></li><li id="e38b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">可选地，关于包需要运行的最低Java版本的信息。</li><li id="630b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">各种人类可读信息，如供应商、版权声明、联系地址等。</li></ul><p id="5684" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些元数据放在JAR文件中一个名为<strong class="ih hj"> MANIFEST的特殊文件中。MF </strong>，它是所有标准JAR文件的一部分，正是为了这个目的。由于<em class="jd">包</em>是JAR文件，它们可以在OSGi运行时之外使用。</p><h2 id="0c93" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">树与图</h2><p id="4924" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在OSGi，它为每个<em class="jd">包提供了一个单独的类路径。这仅仅意味着我们为每个包提供了一个类加载器，并且类加载器可以看到包的JAR文件中的类和资源。然而，为了让包一起工作，应该有一种方法来加载从一个包的类加载器委托给另一个包的类。</em></p><p id="4fb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图1 和图2 的<em class="jd">中，类加载器被安排在一个层次树中，并且类加载请求总是被向上委托给每个类加载器的父类，而这两棵树没有办法进行水平委托。要使一个库对多个分支可用，它必须被提升到这些分支的共同祖先中。</em></p><p id="3c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在OSGi，它是通过使用一个<em class="jd">图来解决的。两个模块之间的依赖关系不是层次关系:没有父、子委托，只有提供者和用户的网络。基于包之间的依赖关系，类加载请求被从一个包委托给另一个包。</em></p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es mh"><img src="../Images/5311bc70db4782c7eb841fc97a8e657c.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*mu1owRfiVvL50AxzI-EvKw.png"/></div><p class="lw lx et er es ly lz bd b be z dx translated">图3 — OSGi类加载器图表</p></figure><p id="4744" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">包之间的链接基于导入和导出的包。</p><p id="a1ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，假设<em class="jd">图3 </em>中的bundle B包含一个名为<code class="du lk ll lm ln b">org.foo</code>的包，它可以通过在其<strong class="ih hj"> MANIFEST.MF. </strong>的exports部分声明它来选择导出该包，然后Bundle A通过在其<strong class="ih hj"> MANIFEST.MF. </strong>的imports部分声明它来选择导入<code class="du lk ll lm ln b">org.foo</code>。现在，OSGi框架会将导入与匹配的导出相匹配:这被称为<strong class="ih hj">解析</strong>过程。一旦导入与导出匹配，所涉及的包就被<strong class="ih hj">连接在一起</strong>用于特定的包名。这意味着当包A中的类加载请求发生在<code class="du lk ll lm ln b">org.foo</code>包中的任何类上时，该请求将立即被委托给包b的类加载器</p><p id="0b74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，如果resolution失败了会发生什么呢？在这种情况下，包A将无法解析，也无法使用。假设我们的两个包A和B构造正确，我们在基于OSGi的应用程序中不会看到任何类似于<code class="du lk ll lm ln b">ClassNotFoundException</code>或<code class="du lk ll lm ln b">NoClassDefFoundError</code>的错误。事实上，它会告诉初创企业有些不对劲。因此，当使用OSGi时，我们可以在之前知道一组包<em class="jd">中的解析错误，我们从不执行应用程序。</em></p><h2 id="b502" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">版本控制和并行版本</h2><p id="a5cd" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">OSGi不仅仅提供基于包名的依赖，它还提供包的版本控制。这允许处理我们使用的库的发布版本中的变化。</p><p id="345e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">包的导出</strong>用<strong class="ih hj">版本属性声明，</strong>但是<strong class="ih hj">导入</strong>声明<strong class="ih hj">版本<em class="jd">范围。</em> </strong>这允许我们有一个依赖于例如从版本1.1.0到版本2.1.0的库的包。如果在该范围内没有任何包导出该包的版本，那么该包将无法解析，我们将收到一条有用的错误消息，告诉我们发生了什么问题。</p><p id="501a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们甚至可以在同一个应用程序中同时拥有同一个库的不同版本。</p><h1 id="be7c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀OSGi建筑</h1><p id="eeaa" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">OSGi平台由两部分组成:<strong class="ih hj"> OSGi框架</strong>和<strong class="ih hj"> OSGi标准服务。</strong></p><h2 id="203f" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">OSGi框架</h2><p id="f7db" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">当您创建基于OSGi的应用程序时，OSGi框架起着至关重要的作用。在OSGi规范中定义了三个概念层。</p><ul class=""><li id="db18" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">模块层— </strong>与打包和共享代码有关</li><li id="0ec0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">生命周期层— </strong>负责提供执行时模块管理和对底层OSGi框架的访问</li><li id="3d1e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">服务层— </strong>关注模块之间的交互和通信，特别是模块中包含的组件。</li></ul><h2 id="d679" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">OSGi标准服务公司</h2><p id="f8f6" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">标准服务为常见任务(如日志记录)定义了可重用的API。</p><h2 id="e026" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">OSGi实施</h2><p id="75c1" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">现在有几个独立实现的OSGi框架，包括四个开源软件。</p><ul class=""><li id="a359" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">春分</li><li id="162a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Knopflerfish</li><li id="5254" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">菲力克斯(男子名)</li><li id="1278" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">看门人</li></ul><h1 id="01d0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀OSGi的第一步</h1><h2 id="7e5b" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">OSGi开发工具</h2><p id="54a6" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">理论上，当构建OSGi包时，除了标准的Java工具之外，不需要任何额外的工具:用于Java源代码编译的<code class="du lk ll lm ln b">javac</code>，用于打包的<code class="du lk ll lm ln b">jar</code>，以及用于创建<strong class="ih hj">清单的文本编辑器。MF </strong>文件。</p><p id="1809" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，使用这些基本工具很费力，因为它们需要大量的工作。因此，在实践中，我们使用像<em class="jd"> Ant </em>或<em class="jd"> Maven、</em>这样的构建工具和像<em class="jd"> Eclipse、NetBeans、</em>或<em class="jd"> IntelliJ这样的ide。</em></p><p id="b596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个阶段，我们将使用Eclipse IDE。但是在稍后的阶段，我们将展示如何使用IntelliJ构建一个OSGi项目。</p><h2 id="9a50" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">获得一个框架</h2><p id="ae5a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">正如我们之前提到的，有四个开源OSGi实现——Equinox、Knopflerfish、Felix和Concierge。在本教程中，我们将主要与<em class="jd">春分点</em>一起工作。下面给出了下载链接:</p><div class="mi mj ez fb mk ml"><a href="http://download.eclipse.org/equinox" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hj fi z dy mq ea eb mr ed ef hh bi translated">Equinox下载Eclipse基金会</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">Eclipse基金会——全球社区、Eclipse IDE、Jakarta EE和超过375个开源项目的所在地…</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">download.eclipse.org</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz lu ml"/></div></div></a></div><p id="5eee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从下载页面下载最新的SDK，解压到类似<code class="du lk ll lm ln b">equinox-SDK</code>的文件夹。我们将这个顶级目录称为<code class="du lk ll lm ln b">EQUINOX_HOME</code>。解压缩后，我们将有一个名为<code class="du lk ll lm ln b">plugins</code>的目录，在那里我们可以找到所有实现Equinox及其支持包的jar。在Eclipse中，底层运行时环境中有Equinox框架。</p><h2 id="f8fc" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">Eclipse中的项目🌓</h2><p id="53f0" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">打开Eclipse IDE，进入<code class="du lk ll lm ln b">New</code> → <code class="du lk ll lm ln b">Project</code> → <code class="du lk ll lm ln b">Plug-in Project</code></p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/05/top-5-courses-to-learn-eclipse-ide-for-java-developers.html"><div class="er es na"><img src="../Images/f3645729037fd39225d178b0e4f95aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Un0R2FjEPzVIi9Q_EmzOjw.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图4 —设置eclipse项目</p></figure><p id="9b95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给出项目名称<code class="du lk ll lm ln b">OSGi Tutorial</code>，选择<code class="du lk ll lm ln b">Equinox</code>作为OSGi框架。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/05/10-free-websites-to-learn-git-online.html"><div class="er es na"><img src="../Images/2a75e238696b35638ca6792c1a233bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6pxqPxmeeh871Tb6gJ2ng.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图5 —设置eclipse项目</p></figure><p id="cd53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后点击<code class="du lk ll lm ln b">Next &gt;</code>，选择执行环境。为此，请选择您安装到计算机中的Java版本。并选择<em class="jd">生成激活器</em>复选框。然后点击<code class="du lk ll lm ln b">Finish</code></p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/07/top-5-websites-to-learn-coding-in-java.html"><div class="er es na"><img src="../Images/f9c1d14f87ad8a45646d019c31da5128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wzp58zq2Cmy8X9nc4MYtHw.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图6 —设置eclipse项目</p></figure><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/10/133-java-interview-questions-answers-from-last-5-years.html"><div class="er es na"><img src="../Images/c1601039dd6bbde201a92d65b5cacf88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6asucgiE1oiTYS9yKEPuzA.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图7 —项目概述</p></figure><h2 id="9309" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">你好，世界！</h2><p id="de7a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">为了保持长久以来的传统，我们在OSGi的第一个节目将是简单地打印“你好，世界！”到控制台。但是，大多数此类程序在打印邮件后会立即退出。但我们将延续这一传统，不仅在启动时打印“你好”，而且在关闭时打印“再见”。</p><p id="91ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的项目中，转到<code class="du lk ll lm ln b">src</code> → <code class="du lk ll lm ln b">osgi_tutorial</code> → <code class="du lk ll lm ln b">Activator.java</code>文件并将其重命名为<code class="du lk ll lm ln b">HelloWorldActivator.java</code>，然后用以下代码片段替换代码。</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="6b91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们将<code class="du lk ll lm ln b">Activator.java</code>更改为<code class="du lk ll lm ln b">HelloWorldActivator.java</code>，我们应该在<strong class="ih hj">清单中更改它。MF </strong>文件也是。转到<strong class="ih hj">货单。MF </strong>文件并将<code class="du lk ll lm ln b">osgi_tutorial.Activator</code>改为<code class="du lk ll lm ln b">osgi_tutorial.HelloWorldActivator</code></p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/08/top-5-spring-data-jpa-courses-for-java.html"><div class="er es nd"><img src="../Images/0a312e9d57640cb1a482ca21fa07a4cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4Ss12nKziRAtR3hIuuqMg.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图8-更改清单。MF文件</p></figure><p id="5e5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得注意的是，您可以查看<strong class="ih hj">清单。MF </strong>文件也使用底部选项卡窗格。自从制造了<strong class="ih hj">之后。MF </strong>是OSGi项目最重要的部分，更好地了解所有与<strong class="ih hj">清单相关的选项。MF </strong>文件编辑。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es nd"><img src="../Images/ce9259bfb074b23f636867d6c3742370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijYWixoAOL4b8qHMZsANlg.png"/></div></div><p class="lw lx et er es ly lz bd b be z dx translated">图9-清单。MF文件</p></figure><p id="0b70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在点击左侧窗格中的<em class="jd"> OSGi教程</em>并右键点击<code class="du lk ll lm ln b">Run As</code> → <code class="du lk ll lm ln b">OSGi Framework</code></p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://medium.com/javarevisited/12-advanced-spring-framework-courses-for-java-programmers-a273f6e4448c"><div class="er es ne"><img src="../Images/84f7feea5774edee97f98f9d6c3be7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfAngyaJ5FFU22gCL45ZIA.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图10 —运行OSGi项目</p></figure><p id="ece5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你这样做的时候，你会在控制台中得到一串错误信息，就像这样。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/06/5-websites-to-learn-sql-online-for-free.html"><div class="er es ne"><img src="../Images/a361f534d7f967b6ac9d0e04893f0873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oe709eZn0xSLzqd_3wvj3Q.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图11 —控制台输出</p></figure><p id="b57f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，检查您是否正在使用<code class="du lk ll lm ln b">osgi</code>控制台。如果您正在使用<code class="du lk ll lm ln b">osgi</code>控制台，您会在控制台中看到类似<code class="du lk ll lm ln b">osgi &gt;</code>的内容。键入<code class="du lk ll lm ln b">ss</code>查看项目中运行的所有包。你会看到类似这样的id。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es ne"><img src="../Images/dca9527e58abea6d05b36d01d36034bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y04uYpsddAkaWt_uum2NMg.png"/></div></div><p class="lw lx et er es ly lz bd b be z dx translated">图12-查看所有束的ss</p></figure><p id="b976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到id为<code class="du lk ll lm ln b">2</code>的out <code class="du lk ll lm ln b">OSGi_Tutotial_1.0.0.qualifier</code>现在您可以通过键入<code class="du lk ll lm ln b">stop 2</code>来停止它，并通过在<code class="du lk ll lm ln b">osgi</code>控制台中键入<code class="du lk ll lm ln b">start 2</code>来再次启动它。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/02/spring-security-interview-questions-answers-java.html"><div class="er es ne"><img src="../Images/75f92a267f6f62d7b9ac817c57784822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMPzUGp2A48Up8wZaQHfTw.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图13 —开始和停止项目</p></figure><p id="e74b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所注意到的，这个<code class="du lk ll lm ln b">start</code>和<code class="du lk ll lm ln b">stop</code>与我们在<code class="du lk ll lm ln b">HelloWorldActivator.java</code>文件中编写的方法相关。</p><h2 id="3ff0" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">捆绑包生命周期</h2><p id="ff66" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">有人提到OSGi捆绑包有一个生命周期，但是这个生命周期到底是什么呢？</p><p id="ad2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<code class="du lk ll lm ln b">OSGi_Tutorial</code>包从<code class="du lk ll lm ln b">install</code>命令开始，并进入<code class="du lk ll lm ln b">INSTALLED</code>状态。然后随着<code class="du lk ll lm ln b">start</code>命令，它转换到<code class="du lk ll lm ln b">ACTIVE</code>状态。虽然我们看不到两种状态之间的直接联系，但是bundles只有在<code class="du lk ll lm ln b">RESOLVED</code>状态下才能启动。然而，当我们试图启动一个<code class="du lk ll lm ln b">INSTALLED</code>包时，框架会在开始启动它之前先尝试解决它。<code class="du lk ll lm ln b">RESOLVED</code>表示满足该包的约束。在被解析后，它通过<code class="du lk ll lm ln b">STARTING</code>进入<code class="du lk ll lm ln b">ACTIVATE</code>状态。<code class="du lk ll lm ln b">STARTING</code>状态是一个瞬态。</p><p id="5d1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当执行<code class="du lk ll lm ln b">stop</code>命令时，束转变到<code class="du lk ll lm ln b">RESOLVED</code>状态，同时经过瞬态<code class="du lk ll lm ln b">STOPPING</code></p><p id="1631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要获得更多关于生命周期的信息，请查看下图。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es nf"><img src="../Images/8f61b9e8208cd091ed7a0fe8c43f2914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*eQ27p8NWCxZAKlrdGJsWqg.png"/></div><p class="lw lx et er es ly lz bd b be z dx translated">图14 —捆绑包生命周期</p></figure><p id="18e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<code class="du lk ll lm ln b">HelloWorldActivator.java</code>文件中的<code class="du lk ll lm ln b">BundleContext</code>允许我们做多件事情，</p><ul class=""><li id="f658" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">查找系统范围的配置。</li><li id="eb3a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">通过ID找到另一个已安装的包。</li><li id="4f51" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">获取所有已安装软件包的列表。</li><li id="937c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">以编程方式安装新的软件包。</li><li id="597e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">注册和取消注册捆绑包监听器。</li><li id="a10f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">注册和取消注册服务侦听器。</li></ul><p id="845d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此简单地改变<code class="du lk ll lm ln b">Activator</code>类我们可以做几件事。</p><h1 id="9148" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀捆绑依赖关系</h1><p id="646e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">正如我们前面指出的，管理依赖关系是实现模块化的关键。这在Java和许多其他语言中也是一个大问题，因为只有少数语言提供构建大型应用程序所需的模块系统。JAVA中的默认模块系统是以JAR为中心的“类路径”模型，失败主要不是因为它不能管理依赖关系，而是把它们留给机会。</p><p id="4a08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OSGi通过管理依赖关系去掉了偶然因素，因此它们是<em class="jd">显式的、声明性的、</em>和<em class="jd">版本化的。</em></p><ul class=""><li id="479e" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj"> Explicit — </strong>包的依赖关系是公开的，任何人都可以看到，而不是隐藏在类文件的代码路径中，等待在运行时被发现。</li><li id="512d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">声明性— </strong>依赖关系以简单、静态、文本的形式指定，以便于检查。一个工具可以计算出需要哪一组包来满足特定包的依赖关系，而不需要实际安装或运行它们中的任何一个。</li><li id="e579" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">版本化— </strong>库随着时间而变化，仅仅依赖一个库而不考虑它的版本是不够的。因此，OSGi允许所有的包间依赖关系指定一个版本范围，甚至允许同一包的多个版本同时存在和使用。</li></ul><h1 id="2dc6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀做好准备，OSGi来了！</h1><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es ng"><img src="../Images/9baa0dd910a180debff938111cf540dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xyk3PTegHeNmn4OGerZJOQ.jpeg"/></div></div></figure><p id="9f21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们对OSGi有了一个了解，让我们试着用IntelliJ创建一个使用OSGi的<em class="jd"> Maven项目。</em>我们在这里使用IntelliJ的原因是为了表明OSGi是独立于IDE的。</p><p id="4ed7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用IntelliJ plus OSGi创建一个名为<code class="du lk ll lm ln b">book-inventroy</code>的项目。</p><p id="0415" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个项目中，<em class="jd">读者(消费者)</em>请求阅读一本书，<em class="jd">图书提供者(生产者)</em>找到那本书(生成)并让读者阅读。现在，为了映射上述场景，我们需要不同的模块。因此，<strong class="ih hj">阅读器模块</strong>将具有像<em class="jd">请求图书、查看图书详情等功能。</em>和<strong class="ih hj">提供者</strong>模块将具有<em class="jd">生成书籍、更新书籍等功能。</em></p><p id="be35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建OSGi项目最重要的任务是编写清单。上面我们讲过的MF 文件。在大多数情况下，从头开始编写并不容易。因此，我们使用<strong class="ih hj"> Maven捆绑插件</strong>来完成这个任务。现在让我们动手做一些编码工作。</p><p id="9e5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进入<code class="du lk ll lm ln b">New Project</code> → <code class="du lk ll lm ln b">Maven</code>新建一个<a class="ae js" rel="noopener" href="/javarevisited/6-best-maven-courses-for-beginners-in-2020-23ea3cba89"> Maven项目</a>。并选择<code class="du lk ll lm ln b">Next</code></p><figure class="lp lq lr ls fd lt er es paragraph-image"><a href="https://javarevisited.blogspot.com/2015/01/difference-between-maven-ant-jenkins-and-hudson.html#axzz6cKi4RVpi"><div class="er es nh"><img src="../Images/943b974b7d1c125378b9e95987f16d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hB5dFA9UKrXTSgV6VfbMDQ.png"/></div></a><p class="lw lx et er es ly lz bd b be z dx translated">图15 —新的maven项目</p></figure><p id="9487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于该项目，我们将给出以下细节:</p><p id="6ec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b"><strong class="ih hj">groupId: </strong>org.wso2.carbon<br/><strong class="ih hj">artifactId: </strong>book-inventory<br/><strong class="ih hj">version: </strong>1.0-SNAPSHOT<br/><strong class="ih hj">packaging:</strong> pom<br/><strong class="ih hj">name:</strong> WSO2 Carbon-Book Inventory</code></p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es nh"><img src="../Images/a6ed34b8baaf0aa13a5094a0cb7e4d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LemDCMz_-rES_w5xqhkvyg.png"/></div></div><p class="lw lx et er es ly lz bd b be z dx translated">图16 —账面库存项目</p></figure><p id="f733" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于<code class="du lk ll lm ln b">book-inventory</code>是我们的父模块，我们可以删除自动生成的<code class="du lk ll lm ln b">src</code>文件夹。我们这样做是因为我们没有导出<em class="jd">父</em>模块。这就是我们将包装命名为<code class="du lk ll lm ln b">pom</code>的原因</p><p id="9a8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在创建了<em class="jd">父</em>模块后，我们应该创建两个子模块，<code class="du lk ll lm ln b">org.wso2.carbon.book.reader</code>和<code class="du lk ll lm ln b">org.wso2.carbon.book.provider</code>要创建这些模块，右键单击<em class="jd">父</em>项目，选择<code class="du lk ll lm ln b">Add New</code> → <code class="du lk ll lm ln b">Module</code>添加完这两个子模块后，项目将如下所示(忽略<code class="du lk ll lm ln b">pom.xml</code>文件)。)</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es ne"><img src="../Images/159c481ec38949676314251d82d13604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSJjGMn42L2Hn8zc_uVaGA.png"/></div></div><p class="lw lx et er es ly lz bd b be z dx translated">图17 —项目结构</p></figure><blockquote class="ni nj nk"><p id="5ce1" class="if ig jd ih b ii ij ik il im in io ip nl ir is it nm iv iw ix nn iz ja jb jc hb bi translated">当向项目添加子模块时，父项目<code class="du lk ll lm ln b">pom.xml</code>应该用<code class="du lk ll lm ln b">&lt;modules&gt;</code>更新，子模块<code class="du lk ll lm ln b">pom.xml</code>将有<code class="du lk ll lm ln b">&lt;parent&gt;</code>标签。如果您使用的是IDE，它会自动生成它们。</p></blockquote><p id="de1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">book-inventory</code>的最终<code class="du lk ll lm ln b">pom.xml</code>看起来会是这样的:</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="aee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">图书供应商</strong></p><p id="7be1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">org.wso2.carbon.book.provider</code>将具有以下规格</p><p id="1ed9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b"><strong class="ih hj">artifactId: </strong>org.wso2.carbon.book.provider<br/><strong class="ih hj">packaging: </strong>bundle<br/><strong class="ih hj">plugin: </strong>maven-bundle-plugin, maven-scr-plugin<br/><strong class="ih hj">dependency: </strong>org.apache.felix.scr.ds-annotations, org.eclipse.osgi.services, org.eclipse.osgi<br/><strong class="ih hj">name: </strong>WSO2 Carbon-Book Provider</code></p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="151d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里使用了<code class="du lk ll lm ln b">&lt;packaging&gt;bundle&lt;/packaging&gt;</code>,因为我们需要将它捆绑进来，您可以看到我们正在使用<code class="du lk ll lm ln b">maven-bundle-plugin</code></p><p id="4816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du lk ll lm ln b">maven-bundle-plugin</code>中，我们确定了以下内容:</p><ul class=""><li id="fbba" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">捆绑符号名称</li><li id="4158" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">捆绑包名称</li><li id="92d4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">出口包装</li><li id="899d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">进口包装</li><li id="5e0f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">私人包装</li></ul><p id="f025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，你可以看到，</p><pre class="lp lq lr ls fd no ln np nq aw nr bi"><span id="fb6d" class="kw ju hi ln b fi ns nt l nu nv">&lt;private-package&gt;org.wso2.carbon.book.provider.internal&lt;/private-package&gt;<br/>&lt;Export-Package&gt;<br/>    !org.wso2.carbon.book.provider.internal,<br/>    org.wso2.carbon.book.provider.*<br/>&lt;/Export-Package&gt;</span></pre><p id="d216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们不希望<code class="du lk ll lm ln b">internal</code>包被导出。</p><p id="e02e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始创建与🧑相关的文件🏻‍💻</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es nw"><img src="../Images/9969dab8e4028b5580b1290b1121f7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*leBlA-ihmBMM42BiPBDoNw.png"/></div></div><p class="lw lx et er es ly lz bd b be z dx translated">图18 —项目结构</p></figure><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="a8a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将在注册表中注册图书提供商创建的服务，以便在其他组件中使用它。这是通过<code class="du lk ll lm ln b">BookProviderServiceComponent.java</code>完成的，类似于我们上面讨论的在Eclipse中创建OSGi项目的<code class="du lk ll lm ln b">Activator</code>。</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="c909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">图书阅读器</strong></p><p id="c3bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">org.wso2.carbon.book.reader</code>将具有以下规格。</p><p id="b6dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lk ll lm ln b"><strong class="ih hj">artifactId: </strong>org.wso2.carbon.book.reader<br/><strong class="ih hj">packaging: </strong>bundle<br/><strong class="ih hj">plugin: </strong>maven-bundle-plugin, maven-src-plugin<br/><strong class="ih hj">dependency: </strong>org.apache.felix.src.ds-annotations, org.eclipse.osgi.services, org.eclipse.osgi, org.wso2.carbon.book.provider<br/><strong class="ih hj">name:</strong> WSO2 Carbon-Book Reader</code></p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="3e4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您可以看到，提供程序是导入的。</p><pre class="lp lq lr ls fd no ln np nq aw nr bi"><span id="ab9c" class="kw ju hi ln b fi ns nt l nu nv">&lt;Import-Package&gt;<br/>    org.osgi.framework; version="${osgi.framework.imp.pkg.version.range}",<br/>    org.osgi.service.component; version="${osgi.service.component.imp.pkg.version.range}",<br/>    <strong class="ln hj">org.wso2.carbon.book.provider.*</strong>; version="${project.version}"<br/>&lt;/Import-Package&gt;</span></pre><p id="d4ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个子模块中，我们将有以下文件结构。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es nx"><img src="../Images/ca92292b62768feb07bef4a1fdf2ecba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*O18jprrB3WvM1yy1d_7KGQ.png"/></div><p class="lw lx et er es ly lz bd b be z dx translated">图19 —项目结构</p></figure><p id="0f26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面给出了文件的代码片段。</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="8f13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，在终端上键入<code class="du lk ll lm ln b">maven clean install -DskipTests</code>或简单地键入<code class="du lk ll lm ln b">maven clean install</code>来构建各自的jar。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es ny"><img src="../Images/25598ccb7a19598db3083f53ee79c998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCXqqgtF_mGTn9RtuB3yLA.png"/></div></div><p class="lw lx et er es ly lz bd b be z dx translated">图20 —在终端中成功构建</p></figure><p id="30ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，你可以在<code class="du lk ll lm ln b">org.wso2.carbon.book.reader</code>和<code class="du lk ll lm ln b">org.wso2.carbon.book.provider</code>中看到一个新生成的文件夹，名为<code class="du lk ll lm ln b">target</code>，在这些文件夹中有jar<code class="du lk ll lm ln b">org.wso2.carbon.book.reader-1.0-SNAPSHOT.jar</code>和<code class="du lk ll lm ln b">org.wso2.carbon.book.provider-1.0-SNAPSHOT.jar</code>，如果你解压它们，你可以看到它们里面的文件。它们包含代码和<strong class="ih hj">清单。MF </strong>文件和<strong class="ih hj"> OSGI-INF </strong>文件。</p><h1 id="48ff" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀WSO2身份服务器</h1><p id="a555" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">现在我们将运行我们在WSO2平台中创建的OSGi项目。去<a class="ae js" href="https://wso2.com/identity-server/" rel="noopener ugc nofollow" target="_blank">https://wso2.com/identity-server/</a>下载<strong class="ih hj">最新</strong> IS版本。解压缩后，你会得到一个文件夹。我们将称之为<code class="du lk ll lm ln b">&lt;IS_HOME&gt;</code></p><p id="3ffc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到<code class="du lk ll lm ln b">&lt;IS_HOME&gt;/repository/components/dropins</code>并将<code class="du lk ll lm ln b">org.wso2.carbon.book.reader-1.0-SNAPSHOT.jar</code>和<code class="du lk ll lm ln b">org.wso2.carbon.book.provider-1.0-SNAPSHOT.jar</code>粘贴在里面。然后通过控制台进入<code class="du lk ll lm ln b">&lt;IS_HOME&gt;/bin</code>并启动身份服务器。</p><p id="3855" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在Linux/macOS中→</strong>T13】</p><p id="4fc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">窗口中的<strong class="ih hj"/>→<code class="du lk ll lm ln b">wso2server.bat -DosgiConsole</code></p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es nz"><img src="../Images/50f7879b0584ac0f7ac5b05cdf0e032a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWo1Iex0s6rGjZH0-68mlw.png"/></div></div><p class="lw lx et er es ly lz bd b be z dx translated">图21 —启动wso2-is</p></figure><p id="ea21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到，我们的包正在被激活并正常工作。</p><p id="78fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要停止<code class="du lk ll lm ln b">wso2-is</code>，只需按下<code class="du lk ll lm ln b">CTRL+C</code>。</p><h1 id="fafa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀OSGi命令</h1><p id="1a26" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">有几个我们应该熟悉的OSGi命令。</p><ul class=""><li id="142b" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du lk ll lm ln b">ss</code> →用捆绑包id列出服务器中的捆绑包。</li><li id="0cc6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lk ll lm ln b">ss &lt;name&gt;</code> →在捆绑包中搜索给定的名称并列出来。</li><li id="6a20" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lk ll lm ln b">ls</code> →列出服务。</li><li id="94a5" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lk ll lm ln b">b &lt;id&gt;</code> →显示捆绑信息。</li><li id="6b68" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lk ll lm ln b">diag &lt;id&gt;</code> →显示未满足的捆绑约束。</li></ul><h1 id="7752" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🚀参考</h1><p id="e652" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">这些是我为了创作这篇文章而读过的书。</p><ul class=""><li id="7454" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">实践中的OSGi—</strong>巴特利特</li><li id="d37f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj"> OSGi和Equinox——创建高度模块化的Java系统</strong> —杰夫·麦卡弗，保罗·范德雷，西蒙·阿切尔</li><li id="7c19" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">行动中的OSGi——理查德·霍尔、卡尔·保罗、斯图尔特·麦卡洛克、大卫·萨维奇</li></ul><p id="02ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是关于如何在IntelliJ或Eclipse上与OSGi一起工作的全部内容。下面给出了IntelliJ项目的链接。</p><div class="mi mj ez fb mk ml"><a href="https://github.com/nipunaupeksha/osgi-book-inventory" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hj fi z dy mq ea eb mr ed ef hh bi translated">GitHub-nipunapeksha/OSGi-book-inventory</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">在GitHub上创建一个帐户，为nipunaupeksha/OSGi-book-inventory的开发做出贡献。</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">github.com</p></div></div><div class="mu l"><div class="oa l mw mx my mu mz lu ml"/></div></div></a></div><p id="9234" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！🧑🏻‍💻😇</p></div></div>    
</body>
</html>