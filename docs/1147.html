<html>
<head>
<title>Why you should consider Graphql for your next Microservice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该考虑将Graphql用于您的下一个微服务</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/why-you-should-consider-graphql-for-your-next-microservice-1e1f689c43b6?source=collection_archive---------2-----------------------#2021-04-14">https://medium.com/javarevisited/why-you-should-consider-graphql-for-your-next-microservice-1e1f689c43b6?source=collection_archive---------2-----------------------#2021-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/91bdd542cd0bf0c91b039998bfec9ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Vt5EL9yyI4oZwYzjpy0-g.png"/></div></div></figure><div class=""/><p id="9c4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您使用微服务时，REST是当前的首选架构。尽管如此，Rest架构带来了一些固有的问题，可能会降低开发周期和整个应用程序的性能。脸书意识到REST架构的这些问题，作为解决方案，他创建了GraphQL架构。GraphQL于2015年由脸书公开，自发布以来，它已被网飞、Shopify、Paypal等其他巨头采用。</p><p id="3f3f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">什么是GraphQL？</strong></p><p id="8b02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据GraphQL的官方文档，</p><blockquote class="jo jp jq"><p id="a8b1" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。</p></blockquote><p id="5395" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与定义混淆？最好首先理解为什么需要GraphQL，而不是让上面的定义自动对你有意义。</p><p id="33f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设你正在开发一个简单的博客网站，比如Medium，你为每个作者设计的主页如下图所示。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/05/top-5-courses-to-learn-graphql-in-2019.html#axzz6AGTrQ8NN"><div class="er es jv"><img src="../Images/14747179f335711aa54435574a4b975f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*978BBHdwTKAcgk6t2CZcww.png"/></div></a><p class="ka kb et er es kc kd bd b be z dx translated">图1:作者主页</p></figure><p id="4e7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要填充作者主页上的信息，您需要调用下面的Rest APIs</p><ol class=""><li id="5088" class="ke kf ht is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated"><em class="jr"> /users/ &lt; id &gt; </em>:该API将检索作者姓名和作者简介部分。</li><li id="32bf" class="ke kf ht is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated"><em class="jr">/users/&lt;id&gt;/posts</em>:该API将检索作者发布的帖子</li><li id="68be" class="ke kf ht is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated"><em class="jr">/users/&lt;id&gt;/followers</em>:这个API将检索我们用户的关注者。</li></ol><p id="f866" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经发现了<a class="ae ks" href="http://javarevisited.blogspot.sg/2015/08/difference-between-soap-and-restfull-webservice-java.html#axzz4qvs40Rha" rel="noopener ugc nofollow" target="_blank"> REST架构</a>的1个问题；如您所见，即使是填充1个页面，我们也要调用3个不同的API，对于每个请求，我们都会有一些网络延迟。因此，应用程序的性能会受到影响。接下来，在调用request来获取用户信息之后，我们将从服务器获得如下响应:</p><pre class="jw jx jy jz fd kt ku kv kw aw kx bi"><span id="ae65" class="ky kz ht ku b fi la lb l lc ld">{<br/>  id: 1,<br/>  name: "First Last",<br/>  dateCreated: "01/01/2020",<br/>  aboutMe: "Hi, I am First",<br/>  dateOfBirth: "01/01/1990"<br/>}</span></pre><p id="4858" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对GetPosts API的响应将是这样的:</p><pre class="jw jx jy jz fd kt ku kv kw aw kx bi"><span id="78cb" class="ky kz ht ku b fi la lb l lc ld">{<br/> "posts":{[<br/>   {<br/>     id: 1<br/>     title: "Title 1"<br/>     contents: "contents cotens"<br/>     claps: 2<br/>     comments:[<br/>          postedby:<br/>          comment:"very infomative"<br/>       ]<br/>    },<br/>   {<br/>     id: 2<br/>     title: "Title 2"<br/>     contents: "contents contents"<br/>     claps: 4<br/>     comments:[<br/>          postedby:<br/>          comment:"very infomative"<br/>       ]<br/>    }, <br/>   }<br/>]}}</span></pre><p id="761f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对追随者获取列表API的响应如下:</p><pre class="jw jx jy jz fd kt ku kv kw aw kx bi"><span id="60b6" class="ky kz ht ku b fi la lb l lc ld">[<br/>  {<br/>    id: 2,<br/>    name: "First Last",<br/>    dateCreated: "01/01/2020",<br/>    aboutMe: "Hi, I am First",<br/>    dateOfBirth: "01/01/1990"<br/>  }<br/>]</span></pre><p id="caa9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的回复中，您可以发现另一个关于<a class="ae ks" rel="noopener" href="/javarevisited/why-spring-is-the-best-framework-for-developing-rest-apis-in-java-784590e484a4">REST API</a>的问题，我们在回复中获得了比我们实际需要的更多的信息。这个问题也就是通常所说的过度抓取。在用户信息响应中，您可以看到我们只需要姓名和关于我，其余字段对我们没有用处。</p><p id="059a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，在文章API中，我们也只要求文章标题和内容，其余的字段都是浪费。我们正在以字段的形式下载额外的数据，我们甚至不打算使用。</p><p id="ca94" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想知道<strong class="is hu">为什么我们不创建一个Rest API，包含页面所需的所有字段，如用户信息、帖子和关注者，我们在技术上可以做到这一点</strong>。尽管如此，我们永远不应该这样做，因为它将我们的前端和后端紧密耦合，如果前端有任何变化，它将需要后端的变化。</p><p id="c0ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总而言之，到目前为止讨论的Rest API的问题有:</p><p id="fff7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1)我们需要调用多个端点来收集所需的信息。</p><p id="8cb6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2) <a class="ae ks" rel="noopener" href="/javarevisited/top-5-books-to-learn-web-services-in-java-soap-rest-22d92adbefc1"> Rest API </a>给出了比实际需要更多的数据，所有这些信息都需要由客户端下载。</p><p id="047b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看当我们的服务器支持<a class="ae ks" rel="noopener" href="/javarevisited/top-5-graphql-tutorials-and-courses-for-beginners-fb5543506fc2?source=---------75------------------"> graphQL查询</a>时，同样的情况将如何运行。</p><figure class="jw jx jy jz fd hk er es paragraph-image"><a href="https://dev.to/javinpaul/5-best-courses-to-learn-graphql-in-2020-2fo5"><div class="er es le"><img src="../Images/1427ad5833b0156b4386a565e9273b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*vT8bZojapdcA_SlAqxuNbA.png"/></div></a></figure><p id="d126" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">挺甜蜜的。我们设法在一个请求中做了同样的事情，为此我们调用了3个不同的rest APIs，而且，作为响应，我们只得到必需的字段。这对你来说可能看起来很小，但是说我们的博客网站已经变得很受欢迎，数百万作者正试图访问他们的主页；在这种情况下，graphQL的工作速度将明显快于Rest。</p><p id="c13f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，GraphQL的早期定义对您有意义吗？我想现在已经很清楚了，GraphQL客户端可以向服务器请求所需的确切信息，对吗？</p><p id="e989" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">GraphQL优于Rest的优势</strong> <br/> <em class="jr"> 1)避免过度提取和提取不足</em>:Rest API最大的问题之一是过度提取和提取不足，使用graph QL很容易解决。正如我们在上面的例子中看到的，我们必须为Rest调用多个端点，因为我们无法从一个Rest API中获得所有信息，而且我们获得的数据也比我们需要的多。</p><p id="93a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2) <em class="jr">前端快速产品迭代:</em>假设未来我们需要在前端增加<em class="jr"> </em>更多的数据；我们可以通过更改GraphQL查询轻松实现这一点。在使用GraphQL的情况下，我们最好永远不要改变端点。</p><p id="2c93" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更好的开发体验:如果你曾经测试过Rest API，你知道为了创建Rest API文档，我们需要一些像swagger这样的工具，而GraphQL的文档是自动生成的。不像<a class="ae ks" rel="noopener" href="/javarevisited/21-spring-mvc-rest-interview-questions-answers-for-beginners-and-experienced-developers-21ad3d4c9b82"> Rest </a>，使用像<a class="ae ks" rel="noopener" href="/javarevisited/7-best-courses-to-learn-postman-tool-for-web-service-and-api-testing-f225c138fa5a?source=---------13------------------"> postman </a>这样的测试工具，你不知道对一个特定端点的请求会是什么样子；在GraphQL中，我们有<a class="ae ks" href="https://github.com/graphql/graphiql" rel="noopener ugc nofollow" target="_blank">graph QL</a>，它显示了带有您正在运行的请求的模式信息的文档，使开发人员的工作变得更加容易。</p><p id="610a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">结论<br/> </strong>本文只是对GraphQL的一个基本介绍。我们已经讨论了为什么GraphQL比Rest更好。这是否意味着graphQL将完全取代Rest？任何事物都有它的优点和缺点，GraphQL也有它的缺点，就像在GraphQL中实现缓存是困难的，并且它增加了应用程序的复杂性。目前，我们可以假设Rest和GraphQL都将存在，好消息是您也可以在同一个微服务中实现GraphQL和Rest端点。</p><p id="765e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">页（page的缩写）s:如果你对SpaceX感兴趣，他们已经公开了他们的GraphQL API，从中你可以获得很多信息，比如他们最近的太空任务，他们火箭的规格，等等。您可以在这里查看API <a class="ae ks" href="https://api.spacex.land/graphql/" rel="noopener ugc nofollow" target="_blank">并将其作为一个平台来学习GraphQL查询是如何工作的。</a></p></div></div>    
</body>
</html>