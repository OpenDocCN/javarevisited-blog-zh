<html>
<head>
<title>Spring Boot — Black Box Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot —黑盒测试</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-boot-black-box-testing-3a6954591ae?source=collection_archive---------3-----------------------#2022-11-22">https://medium.com/javarevisited/spring-boot-black-box-testing-3a6954591ae?source=collection_archive---------3-----------------------#2022-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="19a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将向你展示</p><ol class=""><li id="72e2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">白盒测试和黑测试有什么区别？</li><li id="6ba8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">后者有什么好处？</li><li id="7dc2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如何在您的Spring Boot应用程序中实现它？</li><li id="1cd7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如何配置OpenAPI生成器来简化代码和减少重复？</li></ol><p id="834f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在<a class="ae jr" href="https://github.com/SimonHarmonicMinor/spring-boot-black-box-testing-example" rel="noopener ugc nofollow" target="_blank">这个库</a>中找到代码示例。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es js"><img src="../Images/1c2c4d5daac3e18daacb288d564b497e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*V6I1tpwe4J2qLrXAHI_mHA.png"/></div></figure><h1 id="e2a7" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">领域</h1><p id="0fac" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们正在开发一个餐厅自动化系统。有两个域类。<code class="du ld le lf lg b">Fridge</code>和<code class="du ld le lf lg b">Product</code>。一个冰箱可以有许多产品，而一个产品属于一个冰箱。请看下面的类声明。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="6e35" class="ll kb hi lg b be lm ln l lo lp">@Entity<br/>@Table(name = "fridge")<br/>public class Fridge {<br/>    @Id<br/>    @GeneratedValue(strategy = IDENTITY)<br/>    private Long id;<br/><br/>    private String name;<br/><br/>    @OneToMany(fetch = LAZY, mappedBy = "fridge")<br/>    private List&lt;Product&gt; products = new ArrayList&lt;&gt;();<br/>}<br/><br/>@Entity<br/>@Table(name = "product")<br/>public class Product {<br/>    @Id<br/>    @GeneratedValue(strategy = IDENTITY)<br/>    private Long id;<br/><br/>    @Enumerated(STRING)<br/>    private Type type;<br/><br/>    private int quantity;<br/><br/>    @ManyToOne(fetch = LAZY)<br/>    @JoinColumn(name = "fridge_id")<br/>    private Fridge fridge;<br/><br/>    public enum Type {<br/>        POTATO, ONION, CARROT<br/>    }<br/>}</span></pre><blockquote class="lq lr ls"><p id="8f29" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated"><em class="hi">我正在使用</em><a class="ae jr" href="https://spring.io/projects/spring-data-jpa" rel="noopener ugc nofollow" target="_blank"><em class="hi">Spring Data JPA</em></a><em class="hi">作为持久性框架。因此，那些类都是</em><a class="ae jr" href="https://hibernate.org/" rel="noopener ugc nofollow" target="_blank"><em class="hi">Hibernate</em></a><em class="hi">实体。</em></p></blockquote><h1 id="78b2" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">白盒测试</h1><p id="80c7" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">这种类型的测试假设我们知道一些实现细节，并可能与它们交互。系统中有4个REST API端点:</p><ol class=""><li id="b7ff" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">创造一个新的<code class="du ld le lf lg b">Fridge</code>。</li><li id="dbeb" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">添加新的<code class="du ld le lf lg b">Product</code>。</li><li id="bbc6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">改变<code class="du ld le lf lg b">Product</code>数量。</li><li id="0102" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">从<code class="du ld le lf lg b">Fridge</code>上拆下<code class="du ld le lf lg b">Product</code>。</li></ol><p id="61c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们想测试改变<code class="du ld le lf lg b">Product</code>量的那个。请看下面的测试示例。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="96d9" class="ll kb hi lg b be lm ln l lo lp">@SpringBootTest(webEnvironment = RANDOM_PORT)<br/>class ProductControllerWhiteBoxTest extends IntegrationSuite {<br/>    @Autowired<br/>    private FridgeRepository fridgeRepository;<br/>    @Autowired<br/>    private ProductRepository productRepository;<br/>    @Autowired<br/>    private TestRestTemplate rest;<br/><br/>    @BeforeEach<br/>    void beforeEach() {<br/>        productRepository.deleteAllInBatch();<br/>        fridgeRepository.deleteAllInBatch();<br/>    }<br/><br/>    @Test<br/>    void shouldUpdateProductQuantity() {<br/>        final var fridge = fridgeRepository.save(Fridge.newFridge("someFridge"));<br/>        final var productId = productRepository.save(Product.newProduct(POTATO, 10, fridge)).getId();<br/><br/>        assertDoesNotThrow(() -&gt; rest.put("/api/product/{productId}?newQuantity={newQuantity}", null, Map.of(<br/>            "productId", productId,<br/>            "newQuantity", 20<br/>        )));<br/><br/>        final var product = productRepository.findById(productId).orElseThrow();<br/>        assertEquals(20, product.getQuantity());<br/>    }<br/>}</span></pre><p id="ce3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一步一步地检查这段代码。<br/>我们注入存储库来操作数据库中的行。然后<code class="du ld le lf lg b">TestRestTemplate</code>开始发挥作用。这个bean用于发送HTTP请求。然后您可以看到<code class="du ld le lf lg b">@BeforeEach</code>回调删除了数据库中的所有行。因此，每个测试都是确定性的。最后，这是测试本身:</p><ol class=""><li id="a77e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">我们创建一个新的<code class="du ld le lf lg b">Fridge</code>。</li><li id="fb99" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">然后我们创建一个数量为<code class="du ld le lf lg b">10</code>的新<code class="du ld le lf lg b">Product</code>，它属于新创建的<code class="du ld le lf lg b">Fridge</code>。</li><li id="39f9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">之后，我们调用REST端点将<code class="du ld le lf lg b">Product</code>数量从<code class="du ld le lf lg b">10</code>增加到<code class="du ld le lf lg b">20</code>。</li><li id="9649" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">最终，我们从数据库中选择相同的<code class="du ld le lf lg b">Product</code>，并检查数量是否增加。</li></ol><p id="ccfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试工作正常。无论如何，有些细微差别应该被考虑进去:</p><ol class=""><li id="46fe" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">尽管测试验证了整个系统的行为(也称为功能测试),但是在实现细节(即数据库)上存在耦合。</li><li id="2948" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">测试验证的不是实际的用例。如果有人想与我们的服务交互，他们将不能直接在数据库中插入和更新行。</li></ol><p id="0f56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，如果我们想从用户的角度测试系统，我们只能使用服务公开的公共API。</p><h1 id="3868" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">黑盒测试</h1><p id="4722" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">这种类型的测试意味着系统实现细节上的松散耦合。所以只能依赖公共API(即REST API)。</p><p id="6ef3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看之前的白盒测试示例。怎么才能重构成黑盒那种？看下面的<code class="du ld le lf lg b">@BeforeEach</code>实现。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="d9b8" class="ll kb hi lg b be lm ln l lo lp">@BeforeEach<br/>void beforeEach() {<br/>    productRepository.deleteAllInBatch();<br/>    fridgeRepository.deleteAllInBatch();<br/>}</span></pre><p id="2487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">黑盒测试不应该直接与持久性提供者交互。这意味着应该有一个单独的REST端点来清除所有数据。请看下面的代码片段。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="b503" class="ll kb hi lg b be lm ln l lo lp">@RestController<br/>@RequiredArgsConstructor<br/>@Profile("qa")<br/>public class QAController {<br/>    private final FridgeRepository fridgeRepository;<br/>    private final ProductRepository productRepository;<br/><br/>    @DeleteMapping("/api/clearData")<br/>    @Transactional<br/>    public void clearData() {<br/>        productRepository.deleteAllInBatch();<br/>        fridgeRepository.deleteAllInBatch();<br/>    }<br/>}</span></pre><p id="01cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了一个特殊的控制器，它封装了所有的清算数据逻辑。如果测试只依赖于这个端点，那么随着应用程序的增长，我们可以安全地进行更改和重构方法。我们的黑盒测试不会失败。<code class="du ld le lf lg b">@Profile(“qa”)</code>注释至关重要。我们不想公开一个可以删除生产甚至开发环境中所有用户数据的端点。因此，如果<code class="du ld le lf lg b">qa</code> <a class="ae jr" href="https://www.baeldung.com/spring-profiles" rel="noopener ugc nofollow" target="_blank">配置文件</a>是活动的，我们就注册这个端点。我们只会在测试中使用它。</p><blockquote class="lq lr ls"><p id="de01" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated"><em class="hi"/><code class="du ld le lf lg b"><em class="hi">qa</em></code><em class="hi">缩写代表</em> <a class="ae jr" href="https://www.techtarget.com/searchsoftwarequality/definition/quality-assurance" rel="noopener ugc nofollow" target="_blank"> <em class="hi">质保</em> </a> <em class="hi">。</em></p></blockquote><p id="6662" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们应该重构测试方法本身。再看看下面它的实现。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="ffdd" class="ll kb hi lg b be lm ln l lo lp">@Test<br/>void shouldUpdateProductQuantity() {<br/>    final var fridge = fridgeRepository.save(Fridge.newFridge("someFridge"));<br/>    final var productId = productRepository.save(Product.newProduct(POTATO, 10, fridge)).getId();<br/><br/>    assertDoesNotThrow(() -&gt; rest.put("/api/product/{productId}?newQuantity={newQuantity}", null, Map.of(<br/>        "productId", productId,<br/>        "newQuantity", 20<br/>    )));<br/><br/>    final var product = productRepository.findById(productId).orElseThrow();<br/>    assertEquals(20, product.getQuantity());<br/>}</span></pre><p id="13b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有3个操作应该替换为直接REST API调用。这些是:</p><ol class=""><li id="701d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">创造新的<code class="du ld le lf lg b">Fridge</code>。</li><li id="67e8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">创建新的<code class="du ld le lf lg b">Product</code>。</li><li id="b3ee" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">检查<code class="du ld le lf lg b">Product</code>数量是否增加。</li></ol><p id="559c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看下面的整个黑盒测试例子。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="ace8" class="ll kb hi lg b be lm ln l lo lp">@SpringBootTest(webEnvironment = RANDOM_PORT)<br/>@ActiveProfiles("qa")<br/>class ProductControllerBlackBoxTest extends IntegrationSuite {<br/>    @Autowired<br/>    private TestRestTemplate rest;<br/><br/>    @BeforeEach<br/>    void beforeEach() {<br/>        rest.delete("/api/qa/clearData");<br/>    }<br/><br/>    @Test<br/>    void shouldUpdateProductQuantity() {<br/>        // create new Fridge<br/>        final var fridgeResponse =<br/>            rest.postForEntity("/api/fridge?name={fridgeName}", null, FridgeResponse.class, Map.of(<br/>                "fridgeName", "someFridge"<br/>            ));<br/>        assertTrue(fridgeResponse.getStatusCode().is2xxSuccessful(), "Error during creating new Fridge: " + fridgeResponse.getStatusCode());<br/>        // create new Product<br/>        final var productResponse = rest.postForEntity(<br/>            "/api/product/fridge/{fridgeId}",<br/>            new ProductCreateRequest(<br/>                POTATO,<br/>                10<br/>            ),<br/>            ProductResponse.class,<br/>            Map.of(<br/>                "fridgeId", fridgeResponse.getBody().id()<br/>            )<br/>        );<br/>        assertTrue(productResponse.getStatusCode().is2xxSuccessful(), "Error during creating new Product: " + productResponse.getStatusCode());<br/><br/>        // call the API that should be tested<br/>        assertDoesNotThrow(<br/>            () -&gt; rest.put("/api/product/{productId}?newQuantity={newQuantity}",<br/>                null,<br/>                Map.of(<br/>                    "productId", productResponse.getBody().id(),<br/>                    "newQuantity", 20<br/>                ))<br/>        );<br/><br/>        // get the updated Product by id<br/>        final var updatedProductResponse = rest.getForEntity(<br/>            "/api/product/{productId}",<br/>            ProductResponse.class,<br/>            Map.of(<br/>                "productId", productResponse.getBody().id()<br/>            )<br/>        );<br/>        assertTrue(<br/>            updatedProductResponse.getStatusCode().is2xxSuccessful(),<br/>            "Error during retrieving Product by id: " + updatedProductResponse.getStatusCode()<br/>        );<br/>        // check that the quantity has been changed<br/>        assertEquals(20, updatedProductResponse.getBody().quantity());<br/>    }<br/>}</span></pre><p id="3825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与白盒测试相比，黑盒测试的优势在于:</p><ol class=""><li id="6321" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">该测试检查用户检索预期结果的路径。因此，验证行为变得更加健壮。</li><li id="2505" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">黑盒测试对重构非常稳定。只要API契约保持不变，测试就不会中断。</li><li id="e336" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果您不小心破坏了向后兼容性(例如，向现有的REST端点添加一个新的强制参数)，黑盒测试将会失败，您将在产品被部署到任何环境之前确定问题的方式。</li></ol><p id="2d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，您可能已经注意到了代码中的一个小问题。这个测试相当麻烦。很难阅读和维护。如果我不加入解释性的注释，你可能会花太多时间去弄清楚发生了什么。此外，不同的场景可能会调用相同的端点，这会导致代码重复。</p><p id="1f49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是有解决方案。</p><h1 id="91a9" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">OpenAPI和代码生成</h1><p id="c49c" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">Spring Boot带来了出色的open API T4支持。您所要做的就是添加两个依赖项。看看下面的<a class="ae jr" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>配置。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="334a" class="ll kb hi lg b be lm ln l lo lp">implementation 'org.springframework.boot:spring-boot-starter-actuator'<br/>implementation 'org.springdoc:springdoc-openapi-ui:1.6.12'</span></pre><p id="37df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加完这些依赖项后，<code class="du ld le lf lg b">GET /v3/api-docs</code>端点就可以使用OpenAPI规范了。</p><blockquote class="lq lr ls"><p id="dbad" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated"><em class="hi"/><a class="ae jr" href="https://springdoc.org/" rel="noopener ugc nofollow" target="_blank"><em class="hi">spring doc</em></a><em class="hi">库附带了大量注释来精确地调优REST API规范。无论如何，这超出了本文的范围。</em></p></blockquote><p id="76f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们有OpenAPI规范，这意味着我们可以生成Java类来以类型安全的方式调用端点。更令人兴奋的是，我们可以在我们的黑盒测试中应用那些生成的类！</p><p id="cda9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们定义即将到来的OpenAPI Java客户端的需求:</p><ol class=""><li id="9c1c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">生成的类应该放入<code class="du ld le lf lg b">.gitignore</code>中。否则，如果您的项目中有<a class="ae jr" href="https://checkstyle.sourceforge.io/" rel="noopener ugc nofollow" target="_blank"> Checkstyle </a>、<a class="ae jr" href="https://pmd.github.io/" rel="noopener ugc nofollow" target="_blank"> PMD </a>或<a class="ae jr" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank">sonar cube</a>，那么生成的类可能会违反一些规则。此外，如果你不把它们放到<code class="du ld le lf lg b">.gitignore</code>中，那么每个拉请求可能会变得很大，因为事实上，即使是最轻微的修改也会导致生成的类发生很多变化。</li><li id="4bce" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">每个pull请求构建都应该保证生成的类总是最新的，符合实际的OpenAPI规范。</li></ol><p id="f270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何在构建阶段获得OpenAPI规范本身？最简单的方法是编写一个单独的测试，创建Spring上下文的web部分，调用<code class="du ld le lf lg b">/v3/api-docs</code>端点，并将检索到的规范放入<code class="du ld le lf lg b">build</code>文件夹(如果你是Maven用户，那么它将是<code class="du ld le lf lg b">target</code>文件夹)。看看下面的代码示例。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="8cc0" class="ll kb hi lg b be lm ln l lo lp">@SpringBootTest(<br/>    webEnvironment = RANDOM_PORT<br/>)<br/>@AutoConfigureTestDatabase<br/>@ActiveProfiles("qa")<br/>public class OpenAPITest {<br/>    @Autowired<br/>    private TestRestTemplate rest;<br/><br/>    @Test<br/>    @SneakyThrows<br/>    void generateOpenApiSpec() {<br/>        final var response = rest.getForEntity("/v3/api-docs", String.class);<br/>        assertTrue(response.getStatusCode().is2xxSuccessful(), "Unexpected status code: " + response.getStatusCode());<br/>        // the specification will be written to 'build/classes/test/open-api.json'<br/>        Files.writeString(<br/>            Path.of(getClass().getResource("/").getPath(), "open-api.json"),<br/>            response.getBody()<br/>        );<br/>    }<br/>}</span></pre><blockquote class="lq lr ls"><p id="d3a1" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated"><em class="hi"/><code class="du ld le lf lg b"><em class="hi">@AutoConfigureTestDatabase</em></code><em class="hi">配置内存数据库(如</em> <a class="ae jr" href="https://www.h2database.com/" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> H2 </em> </a> <em class="hi">)，如果类路径中有内存数据库的话。由于数据库提供者不影响结果OpenAPI规范，我们可以通过不使用</em><a class="ae jr" href="https://www.testcontainers.org/" rel="noopener ugc nofollow" target="_blank"><em class="hi">test containers</em></a><em class="hi">来使测试运行得更快一些。</em></p></blockquote><p id="d93f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了结果规范。我们如何基于它生成Java类呢？我们有另一个Gradle插件。看看下面的<code class="du ld le lf lg b">build.gradle</code>配置。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="271b" class="ll kb hi lg b be lm ln l lo lp">plugins {<br/>    ...<br/>    id "org.openapi.generator" version "6.2.0"<br/>}<br/><br/>...<br/><br/>openApiGenerate {<br/>    inputSpec = "$buildDir/classes/java/test/open-api.json".toString()<br/>    outputDir = "$rootDir/open-api-java-client".toString()<br/>    apiPackage = "com.example.demo.generated"<br/>    invokerPackage = "com.example.demo.generated"<br/>    modelPackage = "com.example.demo.generated"<br/>    configOptions = [<br/>            dateLibrary    : "java8",<br/>            openApiNullable: "false",<br/>    ]<br/>    generatorName = 'java'<br/>    groupId = "com.example.demo"<br/>    globalProperties = [<br/>            modelDocs: "false"<br/>    ]<br/>    additionalProperties = [<br/>            hideGenerationTimestamp: true<br/>    ]<br/>}</span></pre><blockquote class="lq lr ls"><p id="363e" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">在这篇文章中，我将向你展示如何配置相应的 <a class="ae jr" href="https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-gradle-plugin" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Gradle插件</em> </a> <em class="hi">。不管怎样，还有</em> <a class="ae jr" href="https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-maven-plugin" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Maven插件</em> </a> <em class="hi">也是一样，方法不会有太大不同。</em></p></blockquote><p id="115d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于OpenAPI生成器插件有一个重要的细节。它创建整个Gradle/Maven/SBT项目(包含<code class="du ld le lf lg b">build.gradle</code>、<code class="du ld le lf lg b">pom.xml</code>和<code class="du ld le lf lg b">build.sbt</code>文件)，而不仅仅是Java类。因此，我们将<code class="du ld le lf lg b">outputDir</code>属性设置为<code class="du ld le lf lg b">$rootDir/open-api-java-client</code>。因此，生成的Java类进入Gradle子项目。</p><p id="494d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还应该将<code class="du ld le lf lg b">open-api-java-client</code>目录标记为<code class="du ld le lf lg b">settings.gradle</code>中的子项目。请看下面的代码片段。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="1a42" class="ll kb hi lg b be lm ln l lo lp">rootProject.name = 'demo'<br/>include 'open-api-java-client'</span></pre><p id="35f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要生成OpenAPI Java客户端，您只需运行这些Gradle命令:</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="61fb" class="ll kb hi lg b be lm ln l lo lp">gradle test --tests "com.example.demo.controller.OpenAPITest.generateOpenApiSpec"<br/>gradle openApiGenerate</span></pre><h1 id="ae29" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">应用Java客户端</h1><p id="a9a1" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">现在让我们尝试一下我们全新的Java客户端。为了方便起见，我们将创建一个单独的<code class="du ld le lf lg b">@TestComponent</code>。请看下面的代码片段。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="9996" class="ll kb hi lg b be lm ln l lo lp">@TestComponent<br/>public class TestRestController {<br/>    @Autowired<br/>    private Environment environment;<br/><br/>    public FridgeControllerApi fridgeController() {<br/>        return new FridgeControllerApi(newApiClient());<br/>    }<br/><br/>    public ProductControllerApi productController() {<br/>        return new ProductControllerApi(newApiClient());<br/>    }<br/><br/>    public QaControllerApi qaController() {<br/>        return new QaControllerApi(newApiClient());<br/>    }<br/><br/>    private ApiClient newApiClient() {<br/>        final var apiClient = new ApiClient();<br/>        apiClient.setBasePath("http://localhost:" + environment.getProperty("local.server.port", Integer.class));<br/>        return apiClient;<br/>    }<br/>}</span></pre><p id="0243" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以重构我们的黑盒测试。看看下面的最终版本。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="77bf" class="ll kb hi lg b be lm ln l lo lp">@SpringBootTest(webEnvironment = RANDOM_PORT)<br/>@ActiveProfiles("qa")<br/>@Import(TestRestControllers.class)<br/>class ProductControllerBlackBoxGeneratedClientTest extends IntegrationSuite {<br/>    @Autowired<br/>    private TestRestControllers rest;<br/><br/>    @BeforeEach<br/>    @SneakyThrows<br/>    void beforeEach() {<br/>        rest.qaController().clearData();<br/>    }<br/><br/>    @Test<br/>    void shouldUpdateProductQuantity() {<br/>        final var fridgeResponse = assertDoesNotThrow(<br/>            () -&gt; rest.fridgeController()<br/>                .createNewFridge("someFridge")<br/>        );<br/>        final var productResponse = assertDoesNotThrow(<br/>            () -&gt; rest.productController()<br/>                .createNewProduct(<br/>                    fridgeResponse.getId(),<br/>                    new ProductCreateRequest()<br/>                        .quantity(10)<br/>                        .type(POTATO)<br/>                )<br/>        );<br/><br/>        assertDoesNotThrow(<br/>            () -&gt; rest.productController()<br/>                .updateProductQuantity(productResponse.getId(), 20)<br/>        );<br/><br/>        final var updatedProduct = assertDoesNotThrow(<br/>            () -&gt; rest.productController()<br/>                .getProductById(productResponse.getId())<br/>        );<br/>        assertEquals(20, updatedProduct.getQuantity());<br/>    }<br/>}</span></pre><p id="9d90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，该测试更具声明性。此外，API契约变成静态类型，参数验证在编译时进行！</p><h1 id="693a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><code class="du ld le lf lg b">.gitignore</code>警告和单独的测试源</h1><p id="ad93" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我说过我们应该把生成的类放到<code class="du ld le lf lg b">.gitignore</code>中。然而，如果您将<code class="du ld le lf lg b">open-api-java-client/src</code>目录标记为Git未索引的，那么您会突然意识到您的测试不能在CI环境中编译。原因是生成OpenAPI规范(即<code class="du ld le lf lg b">open-api.json</code>文件)的过程也是一个单独的测试。即使你告诉Gradle直接运行一个单独的测试，它也会编译<code class="du ld le lf lg b">src/test</code>目录中的所有内容。最终，测试不会成功编译。</p><p id="4935" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢天谢地，这个问题很容易解决。Gradle提供了<a class="ae jr" href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html" rel="noopener ugc nofollow" target="_blank">源集</a>。它是一个逻辑组，将代码分成可以独立编译的独立模块。</p><p id="96ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们添加<a class="ae jr" href="https://github.com/unbroken-dome/gradle-testsets-plugin" rel="noopener ugc nofollow" target="_blank"> gradle-testsets </a>插件，并定义一个包含<code class="du ld le lf lg b">OpenAPITest</code>文件的独立测试源。它生成了<code class="du ld le lf lg b">open-api.json</code>规范。看看下面的代码示例。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="71f0" class="ll kb hi lg b be lm ln l lo lp">plugins {<br/>    ...<br/>    id "org.unbroken-dome.test-sets" version "4.0.0"<br/>}<br/><br/>...<br/><br/>testSets {<br/>    openApiGenerator<br/>}<br/><br/>tasks.withType(Test) {<br/>    group = 'verification'<br/>    useJUnitPlatform()<br/>    testLogging {<br/>        showExceptions true<br/>        showStandardStreams = false<br/>        showCauses true<br/>        showStackTraces true<br/>        exceptionFormat "full"<br/>        events("skipped", "failed", "passed")<br/>    }<br/>}<br/><br/>openApiGenerator.outputs.upToDateWhen { false }<br/><br/>tasks.named('openApiGenerate') {<br/>    dependsOn 'openApiGenerator'<br/>}</span></pre><p id="92c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ld le lf lg b">testSets</code>块声明了一个名为<code class="du ld le lf lg b">openApiGenerator</code>的新源集。这意味着Gradle将<code class="du ld le lf lg b">src/openApiGenerator</code>目录视为另一个测试源。</p><p id="2bd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ld le lf lg b">tasks.withType(Test)</code>声明也很重要。我们需要告诉Gradle每一个<code class="du ld le lf lg b">Test</code>类型的任务(也就是<code class="du ld le lf lg b">test</code>任务本身和<code class="du ld le lf lg b">openApiGenerator</code>任务)都应该使用JUnit运行。</p><p id="6dc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了方便起见，我选择了<code class="du ld le lf lg b">upToDateWhen</code>选项。这意味着生成<code class="du ld le lf lg b">open-api.json</code>文件的测试将总是按需运行，而不会被缓存。</p><p id="4fb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一块定义了在生成OpenAPI Java客户端之前，我们应该提前更新规范。</p><p id="47fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们只需要将<code class="du ld le lf lg b">OpenAPITest</code>移动到<code class="du ld le lf lg b">src/openApiGenerator</code>目录中，并对<code class="du ld le lf lg b">build.gradle</code>中的<code class="du ld le lf lg b">openApiGenerate</code>任务做一点小小的改变。请看下面的代码片段。</p><pre class="jt ju jv jw fd lh lg li bn lj lk bi"><span id="580b" class="ll kb hi lg b be lm ln l lo lp">openApiGenerate {<br/>    // 'test' directory should be replaced with 'openApiGenerator'<br/>    inputSpec = "$buildDir/classes/java/openApiGenerator/open-api.json".toString()<br/>    ....<br/>}</span></pre><p id="dfdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，您可以用这两个命令构建整个项目。</p><h1 id="ab60" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="17e5" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">黑盒测试是应用程序开发过程的重要部分。尝试一下，你会注意到测试场景变得更有代表性。此外，黑盒测试也是API的很好的文档。你甚至可以应用<a class="ae jr" href="https://spring.io/guides/gs/testing-restdocs/" rel="noopener ugc nofollow" target="_blank"> Spring REST文档</a>并生成一份对API用户和QA工程师都有用的精美手册。</p><p id="11f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有任何问题或建议，请在下面留下您的评论。感谢阅读！</p><h1 id="0387" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">资源</h1><ol class=""><li id="028e" class="jd je hi ih b ii ky im kz iq lx iu ly iy lz jc ji jj jk jl bi translated"><a class="ae jr" href="https://github.com/SimonHarmonicMinor/spring-boot-black-box-testing-example" rel="noopener ugc nofollow" target="_blank">带有代码示例的存储库</a></li><li id="0efe" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://spring.io/projects/spring-data-jpa" rel="noopener ugc nofollow" target="_blank">春季数据JPA </a></li><li id="81b3" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://hibernate.org/" rel="noopener ugc nofollow" target="_blank">冬眠</a></li><li id="d14d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://www.baeldung.com/spring-profiles" rel="noopener ugc nofollow" target="_blank">弹簧轮廓</a></li><li id="4704" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://www.techtarget.com/searchsoftwarequality/definition/quality-assurance" rel="noopener ugc nofollow" target="_blank">质量保证</a></li><li id="00da" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a></li><li id="39b2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank">格雷尔</a></li><li id="d6df" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">SpringDoc </li><li id="25d1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://checkstyle.sourceforge.io/" rel="noopener ugc nofollow" target="_blank">检查样式</a></li><li id="b40e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://pmd.github.io/" rel="noopener ugc nofollow" target="_blank"> PMD </a></li><li id="4933" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank"> SonarQube </a></li><li id="8b94" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://www.h2database.com/" rel="noopener ugc nofollow" target="_blank"> H2数据库</a></li><li id="f708" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://www.testcontainers.org/" rel="noopener ugc nofollow" target="_blank">测试容器</a></li><li id="3590" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-gradle-plugin" rel="noopener ugc nofollow" target="_blank"> OpenAPI生成器Gradle插件</a></li><li id="e8ba" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-maven-plugin" rel="noopener ugc nofollow" target="_blank"> OpenAPI生成器Maven插件</a></li><li id="f7a9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.SourceSet.html" rel="noopener ugc nofollow" target="_blank">梯度源集合</a></li><li id="88f6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://github.com/unbroken-dome/gradle-testsets-plugin" rel="noopener ugc nofollow" target="_blank"> Gradle testsets插件</a></li><li id="7b43" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><a class="ae jr" href="https://spring.io/guides/gs/testing-restdocs/" rel="noopener ugc nofollow" target="_blank">春假文件</a></li></ol></div></div>    
</body>
</html>