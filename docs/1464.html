<html>
<head>
<title>WebGoat Authentication Bypasses in Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebGoat认证在Spring Boot被绕过</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/webgoat-authentication-bypasses-in-spring-boot-e1a70da0922?source=collection_archive---------1-----------------------#2021-08-12">https://medium.com/javarevisited/webgoat-authentication-bypasses-in-spring-boot-e1a70da0922?source=collection_archive---------1-----------------------#2021-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="69f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果满足适当的条件，用户可以绕过身份验证。你可以在PayPal查看这个例子。然而，在成功之前，它需要创造力和许多尝试。</p><p id="8283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将遵循WebGoat项目中的认证旁路步骤。</p><p id="4bdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于给定的用户名，不是提供密码，而是在之前的注册步骤中询问用户两个问题。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f0b4f215def0a7bbd0fc3a2ec79b2520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIva5IntMs0RUTfQMyIg2w.png"/></div></div></figure><p id="7123" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们提交表单时，我们可以在响应中看到一条验证消息。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://www.java67.com/2012/08/spring-interview-questions-answers.html"><div class="er es jq"><img src="../Images/f8940087c72aa3e402fc3c90e955c192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdKynlVw35AybomTc2iFGA.png"/></div></a></figure><p id="8286" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该请求包括两个安全问题:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/02/spring-security-interview-questions-answers-java.html"><div class="er es jr"><img src="../Images/2089c7db861bd2c00a06d0be7460c0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsW27hzsSKjYbFrqcqtTcQ.png"/></div></a></figure><p id="4b36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在PayPal的例子中，攻击者只是删除了安全问题。我们可以用代理(即:Burp Suite)拦截请求并删除参数。一个更简单的方法是从开发者工具窗口(F12)中删除两个参数:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/06/3-books-and-courses-to-learn-spring-security-in-depth.html"><div class="er es js"><img src="../Images/bfe740db06ee6b677588d75367d4aa01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_Wxwd-Xqx0ckHwI4oWfAw.png"/></div></a></figure><p id="43dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到请求不包含这两个参数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jt"><img src="../Images/0d9cd29baf34060908ae5215c00372c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVVsK2radwHp7ZG8k-5vaw.png"/></div></div></figure><p id="9945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可惜，回应还是一样。所以删除参数没有用，提供一些随机值也没有用。接下来我们可以做的是重命名参数的名称。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ju"><img src="../Images/a9037628a8a215ceb6ff093444cc9ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gideSOrkZ442O7TPimNI0w.png"/></div></div></figure><p id="c445" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次我们很幸运，我们收到了成功的消息。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jv"><img src="../Images/88fff7a8fc491f64c300b887ba05579c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yoDb3DqwYH2Z_Lpk3jlXSg.png"/></div></div></figure><p id="108e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该缺陷是由导致验证通过的不良实现(本项目的目的)造成的。下面的<em class="jw"> if条件</em>可以翻译为:如果有一个名为`<strong class="ih hj"> secQuestion0` </strong>的问题，并且答案是<strong class="ih hj">而不是来自商店的</strong>，则验证失败。</p><pre class="jf jg jh ji fd jx jy jz ka aw kb bi"><span id="65b7" class="kc kd hi jy b fi ke kf l kg kh">private static final Map&lt;String, String&gt; userSecQuestions = new HashMap&lt;&gt;();</span><span id="b1da" class="kc kd hi jy b fi ki kf l kg kh">//...</span><span id="804d" class="kc kd hi jy b fi ki kf l kg kh">public boolean verifyAccount(Integer userId, HashMap&lt;String, String&gt; submittedQuestions) {</span><span id="b169" class="kc kd hi jy b fi ki kf l kg kh">//...</span><span id="9914" class="kc kd hi jy b fi ki kf l kg kh">if (<strong class="jy hj">submittedQuestions.containsKey("secQuestion0")</strong> &amp;&amp; !submittedQuestions.get("secQuestion0").equals(secQuestionStore.get(verifyUserId).get("secQuestion0"))) {            return false;        }</span><span id="bff1" class="kc kd hi jy b fi ki kf l kg kh">//...</span></pre><p id="9132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常对于这种情况的建议是<em class="jw">为</em> <em class="jw">正</em>。一个更好的选择是，只有当答案与存储库中给定问题的答案匹配时，才通过验证(返回true)。这种心态在更多情况下是有用的，因为很难维护一个<em class="jw">不允许列表。</em>默认情况下，如果<em class="jw">允许条件</em>不满足，答案应该默认为false(不允许)</p></div></div>    
</body>
</html>