<html>
<head>
<title>The missing Java data structures no one ever told you about — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有人告诉过你的缺失的Java数据结构—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/the-missing-java-data-structures-no-one-ever-told-you-about-part-2-f484a588cce3?source=collection_archive---------1-----------------------#2021-08-17">https://medium.com/javarevisited/the-missing-java-data-structures-no-one-ever-told-you-about-part-2-f484a588cce3?source=collection_archive---------1-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>中的多读取器集合实现。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/e1bf1d199765a50e154ba50ab5bf8b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hQf__PtUvYDn-yKT"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">凯文·布茨在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="5cb5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">实践中的Java并发</h1><p id="9113" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">每个Java开发人员都应该阅读Brian Goetz等人的《<a class="ae jd" href="https://jcip.net/" rel="noopener ugc nofollow" target="_blank">Java Concurrency in Practice</a>》(又名JCIP)。艾尔。JCIP是我最喜欢的Java书籍之一。如果我在学习或回忆Java中的并发概念或问题时需要一些帮助，我会立即参考这本书。我最近打开了这本书，阅读第83-84页的同步集合和“隐藏迭代器”。</p><p id="bda3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我在<a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>中解释<code class="du kx ky kz la b">MultiReader</code>集合的存在、目的和好处时，“隐藏迭代器”将是我在这篇博客中进一步讨论的内容。</p><p id="7fa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:JCIP于2006年发布，比Java 8和lambdas、Streams一起发布早了8年。</p><h1 id="7bc8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">对同步包装器的不满</h1><p id="40cf" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">JDK中有一些包装类，提供对集合的同步访问，比如<code class="du kx ky kz la b">List</code>、<code class="du kx ky kz la b">Set</code>和<code class="du kx ky kz la b">Map</code>。创建这些包装器的方法可以在<code class="du kx ky kz la b">Collections</code>类中找到。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">在JDK中创建同步集合包装</p></figure><p id="8303" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同步包装类是“有条件线程安全的”。这意味着无论何时使用外部迭代器对集合进行迭代，开发人员都需要手动对集合进行<code class="du kx ky kz la b">synchronize</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">SynchronizedList的条件线程安全示例</p></figure><p id="2b8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在所有可以使用同步集合的地方手动操作<code class="du kx ky kz la b">synchronize</code>是非常具有挑战性的，尤其是在将集合传递给库代码的时候。在JDK、第三方库代码和应用程序代码中到处都有“隐藏的迭代器”。在2006年JCIP的书中描述的“隐藏迭代器”包括像<code class="du kx ky kz la b">hashCode</code>、<code class="du kx ky kz la b">equals</code>、<code class="du kx ky kz la b">removeAll</code>、<code class="du kx ky kz la b">retainAll</code>和<code class="du kx ky kz la b">containsAll</code>这样的方法。自从Java 8发布以来，这个列表一直在增长。</p><h2 id="d864" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">Java 8之后的同步包装器</h2><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lr"><img src="../Images/2915fc1cface17622ff760e41de00cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yi8EF_uLTDRZlD2V"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@reddalec?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Redd </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e2aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当Java 8发布时，引入了一组新的“隐藏迭代器”,但没有明确记录在<code class="du kx ky kz la b">Collections</code>类Javadoc中。Javadoc已经更新，并且从Java 9开始明确提到了它们。</p><h2 id="6bc4" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">Java 8 Javadoc for<a class="ae jd" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedList-java.util.List-" rel="noopener ugc nofollow" target="_blank">synchronized list</a>:</h2><blockquote class="ls lt lu"><p id="42d3" class="if ig lv ih b ii ij ik il im in io ip lw ir is it lx iv iw ix ly iz ja jb jc hb bi translated">迭代时，用户必须手动同步返回的列表</p></blockquote><h2 id="b545" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">Java 9 Javadoc for<a class="ae jd" href="https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#synchronizedList-java.util.List-" rel="noopener ugc nofollow" target="_blank">synchronized list</a>:</h2><blockquote class="ls lt lu"><p id="e8cc" class="if ig lv ih b ii ij ik il im in io ip lw ir is it lx iv iw ix ly iz ja jb jc hb bi translated">当用户通过<code class="du kx ky kz la b">Iterator</code>、<code class="du kx ky kz la b">Spliterator</code>或<code class="du kx ky kz la b">Stream</code>遍历返回的列表时，必须手动同步</p></blockquote><p id="899c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何时候开发者从一个同步的集合中创建一个<code class="du kx ky kz la b">Stream</code>或<code class="du kx ky kz la b">Spliterator</code>时，他们应该首先获取一个显式锁，否则他们可能会遇到一个<code class="du kx ky kz la b">ConcurrentModificationException</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">带同步列表的安全流使用示例</p></figure><h1 id="f139" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">更人性化的同步包装器</h1><p id="0380" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Eclipse集合为库中提供的所有可变集合提供了同步包装器。Eclipse集合中的每个可变集合都可以通过调用方法<code class="du kx ky kz la b">asSynchronized</code>来返回该类型的同步等价物。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">在Eclipse集合中创建空的同步集合包装器</p></figure><p id="e8f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Eclipse集合中的同步包装器与JDK中的同步包装器具有相同的基本问题。在没有对对象进行显式锁定的情况下，使用<code class="du kx ky kz la b">iterator</code>、<code class="du kx ky kz la b">spliterator</code>、<code class="du kx ky kz la b">stream</code>、<code class="du kx ky kz la b">parallelStream</code>仍然是不安全的。Eclipse集合同步包装器有一些显著的区别。</p><h2 id="45a2" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">通过丰富的API提供更安全的迭代机会</h2><p id="2816" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Eclipse集合同步包装器(例如<code class="du kx ky kz la b"><a class="ae jd" href="https://www.eclipse.org/collections/javadoc/10.4.0/org/eclipse/collections/impl/list/mutable/SynchronizedMutableList.html" rel="noopener ugc nofollow" target="_blank">SynchronizedMutableList</a></code>)上有许多方法，这些方法在方法内部加锁，并为开发人员执行不同的功能。这是一个丰富的、人性化的API设计在提高开发人员生产力和线程安全方面胜过最小API设计的例子。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lz"><img src="../Images/2a10009c32b73ff5433257dc68740dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4-JtzJUneNSEGxmo"/></div></div><p class="jq jr et er es js jt bd b be z dx translated"><a class="ae jd" href="https://unsplash.com/@shyshkina?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tetiana SHYSHKINA </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同步包装器可以安全地执行大多数可用的方法。我想也许对于<code class="du kx ky kz la b">asLazy</code>和<code class="du kx ky kz la b">asParallel</code>会有例外。我惊讶地发现，<code class="du kx ky kz la b">SynchronizedMutableList</code>上的<code class="du kx ky kz la b">asParallel</code>方法返回一个<code class="du kx ky kz la b"><a class="ae jd" href="https://www.eclipse.org/collections/javadoc/10.4.0/org/eclipse/collections/impl/lazy/parallel/list/SynchronizedParallelListIterable.html" rel="noopener ugc nofollow" target="_blank">SynchronizedParallelListIterable</a></code>。我仍然建议对你写的任何多线程代码进行实战测试，不要假设事情是“安全的”。</p><h2 id="1b09" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">陌生的危险</h2><p id="d34e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">即使在像<code class="du kx ky kz la b">SyncrhonizedMutableList</code>这样的类上使用了所有线程安全的方法，我仍然谨慎地使用同步包装器。我不相信方法<code class="du kx ky kz la b">iterator</code>、<code class="du kx ky kz la b">spliterator</code>、<code class="du kx ky kz la b">stream</code>和<code class="du kx ky kz la b">parallelStream</code>会在某个很难找到的代码路径中被悄悄调用，并且在遇到可怕的<code class="du kx ky kz la b">ConcurrentModificationException</code>之前不会被发现。这就是为什么我们没有停留在仅仅在Eclipse集合中提供一个更高效的同步包装器。我想要一个更强的线程安全保证。</p><h1 id="7c1a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">是时候来点不同的了</h1><p id="83a0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这些年来，我已经多次向不同的Java开发人员解释了同步集合和“条件线程安全”带来的挑战。当Java开发人员告诉我他们不熟悉如何安全地使用同步集合中的<code class="du kx ky kz la b">iterator</code>时，我不再感到惊讶。</p><p id="9834" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约在2007年的某个时候，我决定看看是否有一种方法可以构建一个类似于同步集合但可以安全地用于迭代器的包装器，这样我就可以摆脱向Java开发人员阅读规范的工作了。</p><h2 id="a8de" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">我失败了……非常失败……而且一次又一次。</h2><p id="6b2c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在没有找到任何方法通过创建线程安全迭代器来保护开发人员不必阅读规范之后，我决定是时候尝试一些不同的东西了。</p><blockquote class="ls lt lu"><p id="8be3" class="if ig lv ih b ii ij ik il im in io ip lw ir is it lx iv iw ix ly iz ja jb jc hb bi translated">“唯一的制胜之道就是不玩。”</p><p id="17cc" class="if ig lv ih b ii ij ik il im in io ip lw ir is it lx iv iw ix ly iz ja jb jc hb bi translated">-WOPR，战争游戏</p></blockquote><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ma"><img src="../Images/c3bca1a9542e64e365a9f18dc6842be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WuJfi2LG8KA2us6J"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@jamie452?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰米街</a>上传于<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h2 id="910d" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">“路被堵死了。”— LOTR，王者归来</h2><p id="9b49" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我认为唯一安全的解决方案是创建快速失败的包装类，并在<code class="du kx ky kz la b">iterator</code>、<code class="du kx ky kz la b">spliterator</code>、<code class="du kx ky kz la b">stream</code>和<code class="du kx ky kz la b">parallelStream</code>方法上抛出一个<code class="du kx ky kz la b">UnsupportedOperationException</code>。抛出后，<code class="du kx ky kz la b">UnsupportedOperationException</code>解释了开发人员如何通过集合包装器本身的方法使用显式锁来解决这个问题。规范将在运行时立即显示给开发人员，而不会让他们困惑为什么在处理多线程时会得到<code class="du kx ky kz la b">ConcurrentModificationException</code>。在包装类上调用<code class="du kx ky kz la b">iterator</code>、<code class="du kx ky kz la b">spliterator</code>、<code class="du kx ky kz la b">stream</code>和<code class="du kx ky kz la b">parallelStream</code>时，无论执行的代码是单线程还是多线程，都会立即失败。</p><h1 id="35b6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">输入多读者收藏</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mb"><img src="../Images/02212e78a5f96ced6a88cc7c576a465e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcdTeSztaGMlaTvsjYLfvg.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">MultiReaderBag/List/Set接口及其实现</p></figure><p id="9450" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Eclipse Collections有三个用于多阅读器集合的接口:<code class="du kx ky kz la b">MultiReaderBag</code>、<code class="du kx ky kz la b">MultiReaderList</code>、<code class="du kx ky kz la b">MultiReaderSet</code>。对应的实现有<code class="du kx ky kz la b">MultiReaderHashBag</code>、<code class="du kx ky kz la b">MultiReaderFastList</code>和<code class="du kx ky kz la b">MultiReaderHashSet</code>。在<code class="du kx ky kz la b">Lists</code>、<code class="du kx ky kz la b">Sets</code>和<code class="du kx ky kz la b">Bags</code>工厂类中有<code class="du kx ky kz la b">multiReader</code>工厂，如下所示。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">创建多读者收藏</p></figure><p id="7ee7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多读取器集合使用一个<code class="du kx ky kz la b">ReentrantReadWriteLock</code>并允许在一个集合上获得读锁和写锁。多个读取器可以同时获得锁，获得锁的单个写入器将阻塞所有其他读取器和写入器。</p><p id="bbd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以锁定语义确定后，我必须弄清楚如何处理客户端锁定，并允许安全使用外部迭代器，如<code class="du kx ky kz la b">iterator</code>和<code class="du kx ky kz la b">stream</code>，以及隐藏迭代器，如<code class="du kx ky kz la b">equals</code>、<code class="du kx ky kz la b">hashCode</code>、<code class="du kx ky kz la b">addAll</code>、<code class="du kx ky kz la b">removeAll</code>、<code class="du kx ky kz la b">retainAll</code>和<code class="du kx ky kz la b">containsAll</code>。</p><h2 id="a8fe" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">双重锁定机制</h2><p id="6c68" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">每个MultiReader集合有两个方法:<code class="du kx ky kz la b">withReadLockAndDelegate</code>和<code class="du kx ky kz la b">withWriteLockAndDelegate</code>。两种方法都将名为<code class="du kx ky kz la b">Procedure</code>的<code class="du kx ky kz la b">FunctionalInterface</code>作为参数。<code class="du kx ky kz la b">Procedure</code>接收一个参数，它是后备集合的类型。下面是一些使用<code class="du kx ky kz la b">equals</code>和<code class="du kx ky kz la b">stream</code>读锁和<code class="du kx ky kz la b">iterator.remove()</code>写锁的例子。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">多读者列表示例</p></figure><h2 id="957c" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">失败得狠，失败得快</h2><p id="2f10" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">以下代码显示了当您尝试将<code class="du kx ky kz la b">iterator</code>与<code class="du kx ky kz la b">MultiReaderList</code>一起使用时会发生什么，无论代码是单线程还是多线程。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">MultiReaderList在迭代器示例中引发</p></figure><p id="840a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是在<code class="du kx ky kz la b">MultiReaderList</code>上调用<code class="du kx ky kz la b">iterator</code>时失败的样子。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mc"><img src="../Images/1e08e6e75a5a84a7d09352db5508671b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAmHEsJa2hd5wmP2LlPwSA.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">由于在String.join()中调用迭代器，引发了UnspportedOperationException</p></figure><p id="d721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你也使用<code class="du kx ky kz la b">stream</code>，这段代码将会失败。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">MultiReaderList在流示例中引发</p></figure><p id="0447" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du kx ky kz la b">MultiReaderList</code>上调用<code class="du kx ky kz la b">stream</code>会抛出一个类似的<code class="du kx ky kz la b">UnsupportedOperationException</code>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es md"><img src="../Images/447d5be0a13fc586903f9fb5c99af11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*feQ3LstB8OGuPX8oRB79bg.png"/></div></div><p class="jq jr et er es js jt bd b be z dx translated">由于调用流而导致UnsupportedOperationException</p></figure><p id="a9c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个例子都可以使用<code class="du kx ky kz la b">withReadLockAndDelegate</code>来实现。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">对stream使用withReadLockAndDelegate的MultiReaderList</p></figure><p id="fadc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种特殊情况下，有一种更好、更安全的替代方法，使用直接在<code class="du kx ky kz la b">MultiReaderList</code>上可用的<code class="du kx ky kz la b">makeString</code>方法，它在方法中使用一个读锁。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">带有makeString的MultiReaderList</p></figure><h2 id="34ad" class="ld jv hi bd jw le lf lg ka lh li lj ke iq lk ll ki iu lm ln km iy lo lp kq lq bi translated">一个重要的教训，几乎被遗忘</h2><p id="d414" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当我们在Eclipse集合中设计和构建惰性和并行迭代抽象时，我们已经实现了MultiReader集合。这是在Java 8和Java Streams出现之前。对于多读取器集合，我们不能使用<code class="du kx ky kz la b">iterator</code>来实现任何<code class="du kx ky kz la b">Lazy</code>或<code class="du kx ky kz la b">ParallelIterable</code>类。我们必须实现并测试我们的抽象，以确保它们不依赖于<code class="du kx ky kz la b">iterator</code>。这导致了框架中一个非常重要的设计早期决策，这个决策一直延续到今天，并成为Eclipse集合开发文化的一部分。</p><blockquote class="ls lt lu"><p id="7e64" class="if ig lv ih b ii ij ik il im in io ip lw ir is it lx iv iw ix ly iz ja jb jc hb bi translated">比起外部迭代器，更喜欢内部迭代器</p></blockquote><p id="dbc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正是因为这个重要的教训和设计决策，下面的代码对<code class="du kx ky kz la b">asLazy</code>和<code class="du kx ky kz la b">asParallel</code>两种情况都适用，不需要客户端锁定。方法<code class="du kx ky kz la b">iterator</code>永远不会被调用。被调用的内部迭代器自己获取锁。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div><p class="jq jr et er es js jt bd b be z dx translated">在多读者列表中使用asLazy和asParallel</p></figure><p id="e4c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当开发人员使用Java流时，他们可能认为他们在支持<code class="du kx ky kz la b">Stream</code>的集合上使用了内部迭代器。他们不是。他们使用外部迭代器，如<code class="du kx ky kz la b">spliterator</code>或<code class="du kx ky kz la b">iterator</code>。当处理同步集合时，外部迭代器需要客户端锁定。</p><h1 id="78da" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">一些最终想法和额外的代码示例</h1><p id="fbbf" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我以前从未写过关于多阅读器集合的文章。我唯一能找到的关于多阅读器集合的文章是在公司Kata 的<a class="ae jd" href="https://github.com/eclipse/eclipse-collections-kata/blob/master/docs/company-kata/slides.md#thread-safe-collections" rel="noopener ugc nofollow" target="_blank">结尾。我很感激我开始了这个博客系列。我正在分享我14年前学到的经验，当时我第一次试图解决同步集合中条件线程安全的挑战。我希望分享这些例子和教训是有帮助的。</a></p><p id="7107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我现在计划在Eclipse Collections kata repo中创建一个专门用于多阅读器集合的代码kata，以便为后代保留多阅读器集合的经验。</p><p id="235f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，请欣赏以下要点中一些更复杂的多线程代码示例！</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="869e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lv">我是</em><a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="lv">Eclipse Collections</em></a><em class="lv">OSS项目在</em><a class="ae jd" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="lv">Eclipse Foundation</em></a><em class="lv">的项目负责人。</em> <a class="ae jd" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="lv">月食收藏</em> </a> <em class="lv">是开投</em> <a class="ae jd" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="lv">投稿</em> </a> <em class="lv">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p><p id="1639" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他<strong class="ih hj"> Java编程文章</strong>你可能喜欢的:<br/><a class="ae jd" rel="noopener" href="/javarevisited/9-things-java-programmers-should-learn-in-2018-3f0b2207dfc4">Java程序员应该学会的10件事</a> <a class="ae jd" rel="noopener" href="/javarevisited/5-essential-frameworks-every-java-developer-should-learn-6ed83315f1fb"> </a> <br/> <a class="ae jd" href="https://javarevisited.blogspot.com/2019/10/the-java-developer-roadmap.html" rel="noopener ugc nofollow" target="_blank">完整的Java开发者路线图</a> <br/> <a class="ae jd" rel="noopener" href="/javarevisited/top-10-free-interactive-programming-courses-from-educative-for-beginners-to-learn-in-2021-713cbf96d4eb">我最喜欢的初学者免费编程课程</a> <br/> <a class="ae jd" rel="noopener" href="/javarevisited/10-free-data-science-online-courses-for-beginners-a5fe78c2cb7b"> 10门免费数据结构与算法课程</a> <br/> <a class="ae jd" rel="noopener" href="/javarevisited/7-best-courses-to-learn-data-structure-and-algorithms-d5379ae2588"> 7门最适合初学者的数据结构与算法课程</a> <br/> <a class="ae jd" rel="noopener" href="/hackernoon/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0"> 50+数据结构与算法面试问题【T47</a></p></div></div>    
</body>
</html>