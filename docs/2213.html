<html>
<head>
<title>Is The Thread-per-Request Model a Good Thing After Project Loom?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Project Loom之后，请求线程模型是个好东西吗？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/is-the-thread-per-request-model-a-good-thing-after-project-loom-6d08012839e8?source=collection_archive---------1-----------------------#2022-06-27">https://medium.com/javarevisited/is-the-thread-per-request-model-a-good-thing-after-project-loom-6d08012839e8?source=collection_archive---------1-----------------------#2022-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2014/07/top-50-java-multithreading-interview-questions-answers.html"><div class="er es if"><img src="../Images/5ca6fea2f294f655c0c029fe8b5da6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*meX67S6zrzLeHqhYmqvuFQ.jpeg"/></div></a></figure><p id="c253" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Java服务器应用程序通常倾向于多线程。这种多线程特性允许Java应用程序同时为多个用户服务，而不是按顺序服务。</p><h1 id="f2e9" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">每请求线程模型</h1><p id="08c3" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">几年前，对于实现web服务器的<a class="ae kn" href="https://javarevisited.blogspot.com/2015/06/how-to-create-http-server-in-java-serversocket-example.html" rel="noopener ugc nofollow" target="_blank">,首先，人们可能会考虑旋转新线程来处理新请求的可能性——每个请求一个线程的<em class="ko">模型。但是，硬件限制将只允许它们在JVM崩溃并出现<a class="ae kn" href="https://javarevisited.blogspot.com/2011/09/javalangoutofmemoryerror-permgen-space.html" rel="noopener ugc nofollow" target="_blank"> OutOfMemoryError </a>之前运行这么多线程。在这一点上，这种想法无疑是可笑的。此外，就线程带来的内存开销和创建线程所花费的时间(1 ms)而言，创建线程的成本很高。</em></a></p><h1 id="1e5b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">线程池</h1><p id="a7fd" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">人们可能会进一步考虑将线程池化并使用这些<a class="ae kn" href="https://javarevisited.blogspot.com/2013/07/how-to-create-thread-pools-in-java-executors-framework-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">池化线程</a>来服务请求的可能性。线程池似乎是一个足够好的选择，因为通常来说，将昂贵的资源放在一起是一个好主意。<code class="du kp kq kr ks b"><a class="ae kn" href="https://javarevisited.blogspot.com/2017/02/difference-between-executor-executorservice-and-executors-in-java.html" rel="noopener ugc nofollow" target="_blank">ExecutorService</a></code>做同样的事情——它共享线程。正如我们之前所知道的，我们可以创建和共享多少线程是有限制的；线程多不代表性能好。</p><p id="45f9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在他的书<a class="ae kn" rel="noopener" href="/javarevisited/is-java-concurrency-in-practice-still-valid-8bb54fc3fb7f">"<em class="ko">Java Concurrency in Practice</em>，"</a>中，Brian Goetz给出了下面的公式来为给定的机器和应用程序找到理想的线程池大小。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="e49c" class="lb jl hi ks b fi lc ld l le lf"><strong class="ks hj">Number of threads = Number of Available Cores * (1 + Wait time / Service time)</strong></span></pre><p id="477f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ko">等待时间</em>是应用程序等待通过网络访问的远程资源的时间，<em class="ko">服务时间</em>是CPU忙于计算结果的时间。以下是一台<strong class="io hj">双核</strong>机器的理想线程池大小，该机器连接到一个微服务，该微服务在<strong class="io hj">25毫秒</strong>内做出响应，并花费<strong class="io hj">10毫秒</strong>的CPU时间来计算响应。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="a8ca" class="lb jl hi ks b fi lc ld l le lf">2 * (1 + (25 / 10)) = 7</span></pre><p id="8ccd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个应用程序的池中最好只有七个线程。<a class="ae kn" rel="noopener" href="/javarevisited/7-best-webflux-and-reactive-spring-boot-courses-for-java-programmers-33b7c6fa8995">异步库和框架</a>可以通过以交错方式在不同线程中运行每个请求阶段来改善情况。JEP 425评论说这种风格-</p><blockquote class="lg lh li"><p id="a3ac" class="im in ko io b ip iq ir is it iu iv iw lj iy iz ja lk jc jd je ll jg jh ji jj hb bi translated">与Java平台不一致，因为应用程序的并发单元——异步管道——不再是平台的并发单元。</p></blockquote><h1 id="7508" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">项目织机和虚拟线程</h1><p id="ee12" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Project Loom引入了名为<strong class="io hj">虚拟线程</strong>的轻量级用户模式线程作为<code class="du kp kq kr ks b"><a class="ae kn" href="https://www.java67.com/2013/01/difference-between-callable-and-runnable-java.html" rel="noopener ugc nofollow" target="_blank">java.lang.Thread</a></code>的实例。到目前为止，我们讨论的线程只是平台线程的一层薄薄的包装。平台线程很庞大，并且依赖于操作系统。</p><p id="2c1f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kn" rel="noopener" href="/javarevisited/10-best-places-to-learn-java-online-for-free-ce5e713ab5b2"> Java </a>不自由改进它们，操作系统直接把这些线程分配给处理器。另一方面，JDK的调度程序将虚拟线程分配给平台线程，操作系统照常将虚拟线程分配给处理器。</p><h2 id="14c8" class="lb jl hi bd jm lm ln lo jq lp lq lr ju ix ls lt jy jb lu lv kc jf lw lx kg ly bi translated">虚拟线程如何工作</h2><p id="2b13" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我们都知道阻塞线程是邪恶的，会对应用程序的性能产生负面影响。好吧，在这种情况下不会。当一个虚拟线程在I/O上阻塞或者在<a class="ae kn" href="https://javarevisited.blogspot.com/2015/01/what-is-rtjar-in-javajdkjre-why-its-important.html" rel="noopener ugc nofollow" target="_blank"> JDK </a>中的一些阻塞操作，比如<code class="du kp kq kr ks b">BlockingQueue.take()</code>，它会自动从平台线程中卸载。</p><p id="91e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">JDK的调度程序可以在这个现在空闲的平台线程上安装和运行其他虚拟线程。当阻塞操作准备完成时，它将虚拟线程提交回调度器，调度器将虚拟线程安装在可用的平台线程上以恢复执行。</p><p id="2238" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此平台线程不必与卸载虚拟线程的平台线程相同。因此，我们现在可以构建具有高吞吐量的高并发应用程序，而无需消耗更多的线程(默认情况下，虚拟线程的<a class="ae kn" href="https://javarevisited.blogspot.com/2016/12/difference-between-thread-and-executor.html" rel="noopener ugc nofollow" target="_blank">执行器</a>将使用与可用处理器数量一样多的平台线程)。</p><h2 id="e298" class="lb jl hi bd jm lm ln lo jq lp lq lr ju ix ls lt jy jb lu lv kc jf lw lx kg ly bi translated">带有虚拟线程的每请求线程模型？</h2><p id="b546" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">不应该共享虚拟线程，因为它们不是昂贵的资源。人们可以创建数百万个来处理网络操作。它们应该按需旋转，并在任务完成后被杀死，因此适合短期任务。</p><p id="ead1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虚拟线程的这些属性提供了接近最佳的CPU利用率，并在吞吐量而不是速度方面显著提高了性能。现在我们已经有了所有的支持数据，可以有把握地说，Java服务器应用程序中的每个请求的虚拟线程模型比池化平台线程更安全、更高效。</p><p id="25c9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">关于虚拟线程的更多信息在下面的文章中。</p><ol class=""><li id="22f5" class="lz ma hi io b ip iq it iu ix mb jb mc jf md jj me mf mg mh bi translated"><a class="ae kn" rel="noopener" href="/javarevisited/how-i-spun-up-5-million-virtual-threads-without-stalling-the-jvm-1188d806e6bd">我是如何在不停止JVM的情况下启动500万个虚拟线程的</a>。</li></ol></div></div>    
</body>
</html>