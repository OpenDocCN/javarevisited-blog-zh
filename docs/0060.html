<html>
<head>
<title>Building a Java Edge Detection Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Java边缘检测应用程序</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/building-a-java-edge-detection-application-6147b68e5d79?source=collection_archive---------0-----------------------#2019-04-30">https://medium.com/javarevisited/building-a-java-edge-detection-application-6147b68e5d79?source=collection_archive---------0-----------------------#2019-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="eeef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，你会看到不同类型的过滤器，以及如何将它们应用到不同的图像。此外，我们将探索神经网络如何使用卷积或边缘检测。</p><h1 id="997e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">过滤器的类型</h1><p id="3fa5" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">下图显示了过滤器的类型:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><a href="https://www.amazon.com/Hands-Java-Learning-Computer-Vision/dp/1789613965?tag=javamysqlanta-20"><div class="er es kg"><img src="../Images/a0ac41e3b7f2e4a00fcaf688dec2b8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*M0DlK1GGoCnSG20FmMuN0A.png"/></div></a></figure><ul class=""><li id="cdb2" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc kt ku kv kw bi translated">Sobel :这个滤镜只是在中间增加了一点点权重或值</li><li id="6106" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">除了增加中间的重量，这个滤镜还增加了两边的重量</li></ul><p id="95a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所见，零点位于垂直、Sobel和Scharr滤波器的中间一列。因此，我们可以说，Sobel和Scharr测量左侧和右侧之间的差异，因此，在某种程度上，他们是垂直滤波器。</p><p id="492c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能已经猜到，这些过滤器也有水平版本:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/229589db946d9c14669ef1c575fb51d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*jXhh2a0jApKbRuHaCFKynA.png"/></div></figure><p id="ad1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">水平滤镜基本上是垂直滤镜的翻转版本。列变成行。它看起来像一个右翻转的版本，将所有的列转换为行。</p><h1 id="5925" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">基本编码</h1><p id="d45d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在，让我们快速看一下进行卷积的Java代码，然后用我们已经看到的六种过滤器类型构建Java应用程序，当然还有一些不同的图像。</p><p id="4629" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是主类，<code class="du lc ld le lf b">EdgeDetection</code>:</p><pre class="kh ki kj kk fd lg lf lh li aw lj bi"><span id="7705" class="lk je hi lf b fi ll lm l ln lo">package ramo.klevis.ml;</span><span id="8a60" class="lk je hi lf b fi lp lm l ln lo">import javax.imageio.ImageIO;</span><span id="580d" class="lk je hi lf b fi lp lm l ln lo">import java.awt.*;</span><span id="ea2f" class="lk je hi lf b fi lp lm l ln lo">import java.awt.image.BufferedImage;</span><span id="8e40" class="lk je hi lf b fi lp lm l ln lo">import java.io.File;</span><span id="4d86" class="lk je hi lf b fi lp lm l ln lo">import java.io.IOException;</span><span id="39dd" class="lk je hi lf b fi lp lm l ln lo">import java.util.HashMap;</span><span id="dcca" class="lk je hi lf b fi lp lm l ln lo">public class EdgeDetection {</span></pre><p id="f751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从定义六个过滤器及其值开始，这是我们在上一节中看到的:</p><pre class="kh ki kj kk fd lg lf lh li aw lj bi"><span id="e7ce" class="lk je hi lf b fi ll lm l ln lo">public static final String HORIZONTAL_FILTER = “Horizontal Filter”;</span><span id="9cf4" class="lk je hi lf b fi lp lm l ln lo">public static final String VERTICAL_FILTER = “Vertical Filter”;</span><span id="0f95" class="lk je hi lf b fi lp lm l ln lo">public static final String SOBEL_FILTER_VERTICAL = “Sobel Vertical Filter”;</span><span id="b884" class="lk je hi lf b fi lp lm l ln lo">public static final String SOBEL_FILTER_HORIZONTAL = “Sobel Horizontal Filter”;</span><span id="60ac" class="lk je hi lf b fi lp lm l ln lo">public static final String SCHARR_FILTER_VETICAL = “Scharr Vertical Filter”;</span><span id="766a" class="lk je hi lf b fi lp lm l ln lo">public static final String SCHARR_FILTER_HORIZONTAL = “Scharr Horizontal Filter”;</span><span id="51cd" class="lk je hi lf b fi lp lm l ln lo">private static final double[][] FILTER_VERTICAL = {{1, 0, -1}, {1, 0, -1}, {1, 0, -1}};</span><span id="63e0" class="lk je hi lf b fi lp lm l ln lo">private static final double[][] FILTER_HORIZONTAL = {{1, 1, 1}, {0, 0, 0}, {-1, -1, -1}};</span><span id="7680" class="lk je hi lf b fi lp lm l ln lo">private static final double[][] FILTER_SOBEL_V = {{1, 0, -1}, {2, 0, -2}, {1, 0, -1}};</span><span id="3e6e" class="lk je hi lf b fi lp lm l ln lo">private static final double[][] FILTER_SOBEL_H = {{1, 2, 1}, {0, 0, 0}, {-1, -2, -1}};</span><span id="54b2" class="lk je hi lf b fi lp lm l ln lo">private static final double[][] FILTER_SCHARR_V = {{3, 0, -3}, {10, 0, -10}, {3, 0, -3}};</span><span id="e21a" class="lk je hi lf b fi lp lm l ln lo">private static final double[][] FILTER_SCHARR_H = {{3, 10, 3}, {0, 0, 0}, {-3, -10, -3}};</span></pre><p id="a812" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们定义我们的主方法，<code class="du lc ld le lf b">detectEdges()</code>:</p><pre class="kh ki kj kk fd lg lf lh li aw lj bi"><span id="8410" class="lk je hi lf b fi ll lm l ln lo">private final HashMap&lt;String, double[][]&gt; filterMap;</span><span id="6309" class="lk je hi lf b fi lp lm l ln lo">public EdgeDetection() {</span><span id="05fb" class="lk je hi lf b fi lp lm l ln lo">filterMap = buildFilterMap();</span><span id="1278" class="lk je hi lf b fi lp lm l ln lo">}</span><span id="5c25" class="lk je hi lf b fi lp lm l ln lo">public File detectEdges(BufferedImage bufferedImage, String selectedFilter) throws IOException {</span><span id="22b0" class="lk je hi lf b fi lp lm l ln lo">double[][][] image = transformImageToArray(bufferedImage);</span><span id="e63a" class="lk je hi lf b fi lp lm l ln lo">double[][] filter = filterMap.get(selectedFilter);</span><span id="6a6d" class="lk je hi lf b fi lp lm l ln lo">double[][] convolvedPixels = applyConvolution(bufferedImage.getWidth(),</span><span id="ca38" class="lk je hi lf b fi lp lm l ln lo">bufferedImage.getHeight(), image, filter);</span><span id="cf47" class="lk je hi lf b fi lp lm l ln lo">return createImageFromConvolutionMatrix(bufferedImage, convolvedPixels);</span><span id="8f1a" class="lk je hi lf b fi lp lm l ln lo">}</span></pre><p id="7337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lc ld le lf b">detectEdges</code>暴露于图形用户界面，以便检测边缘，并且它接受两个输入:彩色图像<code class="du lc ld le lf b">bufferedImage</code>和用户选择的过滤器<code class="du lc ld le lf b">selectedFilter</code>。它使用<code class="du lc ld le lf b">transformImageToArray()</code>函数将其转换成三维矩阵。我们将其转换成三维矩阵，因为我们有一个RGB颜色的图像。</p><p id="fe20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每种颜色——红色、绿色和蓝色——我们构建了一个二维矩阵<a class="ae lq" href="http://www.java67.com/2014/10/how-to-create-and-initialize-two-dimensional-array-java-example.html" rel="noopener ugc nofollow" target="_blank">:</a></p><pre class="kh ki kj kk fd lg lf lh li aw lj bi"><span id="9c07" class="lk je hi lf b fi ll lm l ln lo">private double[][][] transformImageToArray(BufferedImage bufferedImage) {</span><span id="a7d5" class="lk je hi lf b fi lp lm l ln lo">int width = bufferedImage.getWidth();</span><span id="02f1" class="lk je hi lf b fi lp lm l ln lo">int height = bufferedImage.getHeight();</span><span id="587a" class="lk je hi lf b fi lp lm l ln lo">double[][][] image = new double[3][height][width];</span><span id="4366" class="lk je hi lf b fi lp lm l ln lo">for (int i = 0; i &lt; height; i++) {</span><span id="6849" class="lk je hi lf b fi lp lm l ln lo">for (int j = 0; j &lt; width; j++) {</span><span id="8eb5" class="lk je hi lf b fi lp lm l ln lo">Color color = new Color(bufferedImage.getRGB(j, i));</span><span id="3106" class="lk je hi lf b fi lp lm l ln lo">image[0][i][j] = color.getRed();</span><span id="2af8" class="lk je hi lf b fi lp lm l ln lo">image[1][i][j] = color.getGreen();</span><span id="70cc" class="lk je hi lf b fi lp lm l ln lo">image[2][i][j] = color.getBlue();</span><span id="94fd" class="lk je hi lf b fi lp lm l ln lo">}</span><span id="637e" class="lk je hi lf b fi lp lm l ln lo">}</span><span id="23e8" class="lk je hi lf b fi lp lm l ln lo">return image;</span><span id="99ba" class="lk je hi lf b fi lp lm l ln lo">}</span></pre><p id="7b47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时候，第三维被称为<strong class="ih hj">灵魂通道</strong>，或者<strong class="ih hj">通道</strong>。在这种情况下，我们有三个通道，但通过卷积，我们会发现数量相当多的通道并不少见。</p><p id="9331" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们准备应用卷积:</p><pre class="kh ki kj kk fd lg lf lh li aw lj bi"><span id="c6ac" class="lk je hi lf b fi ll lm l ln lo">private double[][] applyConvolution(int width, int height, double[][][] image, double[][] filter) {</span><span id="0a71" class="lk je hi lf b fi lp lm l ln lo">Convolution convolution = new Convolution();</span><span id="5099" class="lk je hi lf b fi lp lm l ln lo">double[][] redConv = convolution.convolutionType2(image[0], height, width, filter, 3, 3, 1);</span><span id="549a" class="lk je hi lf b fi lp lm l ln lo">double[][] greenConv = convolution.convolutionType2(image[1], height, width, filter, 3, 3, 1);</span><span id="d090" class="lk je hi lf b fi lp lm l ln lo">double[][] blueConv = convolution.convolutionType2(image[2], height, width, filter, 3, 3, 1);</span><span id="97ee" class="lk je hi lf b fi lp lm l ln lo">double[][] finalConv = new double[redConv.length][redConv[0].length];</span><span id="0a24" class="lk je hi lf b fi lp lm l ln lo">for (int i = 0; i &lt; redConv.length; i++) {</span><span id="3d5e" class="lk je hi lf b fi lp lm l ln lo">for (int j = 0; j &lt; redConv[i].length; j++) {</span><span id="14e7" class="lk je hi lf b fi lp lm l ln lo">finalConv[i][j] = redConv[i][j] + greenConv[i][j] + blueConv[i][j];</span><span id="7111" class="lk je hi lf b fi lp lm l ln lo">}</span><span id="4a7c" class="lk je hi lf b fi lp lm l ln lo">}</span><span id="c22d" class="lk je hi lf b fi lp lm l ln lo">return finalConv;</span><span id="9cf8" class="lk je hi lf b fi lp lm l ln lo">}</span></pre><p id="a3c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们对每种基本颜色分别应用卷积:</p><ul class=""><li id="c15f" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc kt ku kv kw bi translated">使用<code class="du lc ld le lf b">convolution.convolutionType2(image[0], height, width, filter, 3, 3, 1);</code>，我们应用红色的二维矩阵</li><li id="b2a9" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">用<code class="du lc ld le lf b">convolution.convolutionType2(image[1], height, width, filter, 3, 3, 1);</code>，我们应用绿色的二维矩阵</li><li id="3a61" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">使用<code class="du lc ld le lf b">convolution.convolutionType2(image[2], height, width, filter, 3, 3, 1);</code>，我们应用蓝色的二维矩阵</li></ul><p id="3540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后用<code class="du lc ld le lf b">double[][]</code>，我们得到三种颜色的三个二维矩阵，也就是说它们是卷积的。</p><p id="9224" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的卷积矩阵<code class="du lc ld le lf b">double[][] finalConv</code>，将是<code class="du lc ld le lf b">redConv[i][j] + greenConv[i][j] + blueConv[i][j];</code>的加法。我们将在构建应用程序时讨论更多细节，但是现在，我们一起添加这些的原因是因为我们不再对颜色感兴趣，或者至少对原始形式不感兴趣，但是我们<strong class="ih hj">对边缘感兴趣。</strong></p><p id="94d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，正如我们将看到的，在输出图像中，边缘等高级特征将是黑白的，因为我们将三种颜色卷积加在一起。</p><p id="95de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了<code class="du lc ld le lf b">double[][] convolvedPixels</code>，在<code class="du lc ld le lf b">detectEdges()</code>中定义的二维卷积像素，我们需要在<code class="du lc ld le lf b">createImageFromConvolutionMatrix()</code>中显示它:</p><pre class="kh ki kj kk fd lg lf lh li aw lj bi"><span id="8285" class="lk je hi lf b fi ll lm l ln lo">private File createImageFromConvolutionMatrix(BufferedImage originalImage, double[][] imageRGB) throws IOException {</span><span id="2874" class="lk je hi lf b fi lp lm l ln lo">BufferedImage writeBackImage = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), BufferedImage.TYPE_INT_RGB);</span><span id="7b42" class="lk je hi lf b fi lp lm l ln lo">for (int i = 0; i &lt; imageRGB.length; i++) {</span><span id="1661" class="lk je hi lf b fi lp lm l ln lo">for (int j = 0; j &lt; imageRGB[i].length; j++) {</span><span id="fa7a" class="lk je hi lf b fi lp lm l ln lo">Color color = new Color(fixOutOfRangeRGBValues(imageRGB[i][j]),</span><span id="ec9f" class="lk je hi lf b fi lp lm l ln lo">fixOutOfRangeRGBValues(imageRGB[i][j]),</span><span id="32c5" class="lk je hi lf b fi lp lm l ln lo">fixOutOfRangeRGBValues(imageRGB[i][j]));</span><span id="869c" class="lk je hi lf b fi lp lm l ln lo">writeBackImage.setRGB(j, i, color.getRGB());</span><span id="e2e3" class="lk je hi lf b fi lp lm l ln lo">}</span><span id="8732" class="lk je hi lf b fi lp lm l ln lo">}</span><span id="de9e" class="lk je hi lf b fi lp lm l ln lo">File outputFile = new File(“EdgeDetection/edgesTmp.png”);</span><span id="3385" class="lk je hi lf b fi lp lm l ln lo">ImageIO.write(writeBackImage, “png”, outputFile);</span><span id="ff82" class="lk je hi lf b fi lp lm l ln lo">return outputFile;</span><span id="769b" class="lk je hi lf b fi lp lm l ln lo">}</span></pre><p id="437b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要将这些像素转换成图像。我们使用<code class="du lc ld le lf b">fixOutOfRangeRGBValues(imageRGB[i][j]), fixOutOfRangeRGBValues(imageRGB[i][j]));</code>来实现。</p><p id="35cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在唯一想看到的是方法，<code class="du lc ld le lf b">fixOutOfRangeRGBValues</code>:</p><pre class="kh ki kj kk fd lg lf lh li aw lj bi"><span id="e94d" class="lk je hi lf b fi ll lm l ln lo">private int fixOutOfRangeRGBValues(double value) {</span><span id="9e60" class="lk je hi lf b fi lp lm l ln lo">if (value &lt; 0.0) {</span><span id="8651" class="lk je hi lf b fi lp lm l ln lo">value = -value;</span><span id="9e0b" class="lk je hi lf b fi lp lm l ln lo">}</span><span id="27ed" class="lk je hi lf b fi lp lm l ln lo">if (value &gt; 255) {</span><span id="8e29" class="lk je hi lf b fi lp lm l ln lo">return 255;</span><span id="e2fc" class="lk je hi lf b fi lp lm l ln lo">} else {</span><span id="e0eb" class="lk je hi lf b fi lp lm l ln lo">return (int) value;</span><span id="d1cc" class="lk je hi lf b fi lp lm l ln lo">}</span><span id="25cb" class="lk je hi lf b fi lp lm l ln lo">}</span></pre><p id="8f28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这需要像素的绝对值，因为，正如我们看到的，有时当差异不是从黑到白，而是从白到黑时，我们会有负值。</p><p id="dff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们来说，这并不重要，因为我们只想检测边缘，所以我们将绝对值(大于<code class="du lc ld le lf b">255</code>的值)作为最大值，因为Java和其他类似的语言，如<a class="ae lq" href="http://www.java67.com/2019/03/5-free-c-net-courses-to-learn-online.html" rel="noopener ugc nofollow" target="_blank"> C# </a>，不能处理超过255的RGB格式。我们简单的把它写成edge，<code class="du lc ld le lf b">.png</code>文件<code class="du lc ld le lf b">EdgeDetection/edgesTmp.png</code>。</p><p id="a18a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们用一些例子来看看这个应用程序。</p><p id="1ea0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试试水平过滤器:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/0b84ded06b8419c9d410406dcc4def84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*rV1bBnGFr3o8LguiCYsdZw.png"/></div></figure><p id="0dac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个边缘相当窄；此图像有足够的像素:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/151c465034f386875dc57b6379e1e388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*BcW95Jq8WtBzIP-jS0QzKw.png"/></div></figure><p id="3013" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试试<strong class="ih hj">垂直滤镜</strong>，它给我们一些看起来像边缘的东西:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/9ef5c1195ef0e1b114670a8b902b9f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*9btapTQegGX4DUBiValeEA.png"/></div></figure><p id="a755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在一个更复杂的图像上尝试一个垂直滤镜。正如您在下面的屏幕截图中看到的，所有垂直线都被检测到:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/d5d186f9698cc942676031fef718060f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*TnDXW8JPStK-tjI1pf8Y3w.png"/></div></figure><p id="8c81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们用<strong class="ih hj">水平滤镜</strong>看同样的图像:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/88bd3c8a6f9680e2bc9b1a68f7b150be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*uI48jSFuF173pGpVqLeNcA.png"/></div></figure><p id="72fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">水平滤镜没有检测到任何垂直边缘，但它实际上检测到了水平边缘。</p><p id="b448" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看<code class="du lc ld le lf b"><strong class="ih hj">Sobel Horizontal Filter</strong></code>做了什么:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/fdccf170626c7052dd764089f496af96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*l2iDfFdjKG6J4PfY_maTUA.png"/></div></figure><p id="a40a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它只是增加了一点光，这是因为增加更多的重量意味着你让这些边缘更宽一点。</p><p id="d744" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来看看<code class="du lc ld le lf b"><strong class="ih hj">Sobel Vertical Filter</strong></code>:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/88d4ab2fdc8ac5b324775736f1e2d553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*pn3qtePf3Owt6hcZ6y-VjA.png"/></div></figure><p id="d54b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，这应该更亮。</p><p id="2fa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里是<code class="du lc ld le lf b"><strong class="ih hj">Scharr Vertical Filter</strong></code>:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/1e2d38183110c5bd07e8d86337a356e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*bx0O6C9DvOEyhjqURsJNtg.png"/></div></figure><p id="19f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">毫不奇怪，<strong class="ih hj"> Scharr垂直滤镜</strong>增加了更多重量，所以我们看到了更多明亮的边缘。边缘更宽，对从一边到另一边的颜色变化更敏感——水平滤镜不会有任何不同。</p><p id="357d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的蝴蝶彩色图像中，水平滤镜是这样的:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/914ec4fa09d9c313d86c72795477cfaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*lMGoQeQW9HqCFT0KQRt7YA.png"/></div></figure><p id="aba2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看<code class="du lc ld le lf b"><strong class="ih hj">Sobel Horizontal Filter</strong></code>:</p><p id="9f6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍微亮一点。让我们看看等价的<code class="du lc ld le lf b"><strong class="ih hj">Scharr Horizontal Filter</strong></code>是做什么的:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/e62e693bacb290ec7e0c8b53dec6afce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*DaYl7QOTSI3AHU4jfcnkFQ.png"/></div></figure><p id="ff5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也亮了不少。让我们也试试<code class="du lc ld le lf b"><strong class="ih hj">Scharr Vertical Filter</strong></code>:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/31fe631f3f3b34045619674b5f8057e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*esAgLVVsMK1x9IL_uUnFLg.png"/></div></figure><p id="4b54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请随意在您自己的图像上尝试它，因为如果您找到一个实际上执行更好的滤镜，这不会很奇怪——有时，滤镜的结果取决于图像。</p><p id="e8f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在的问题是如何为我们的<a class="ae lq" href="https://click.linksynergy.com/deeplink?id=JVFxdTr9V80&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fdeeplearning%2F" rel="noopener ugc nofollow" target="_blank">神经网络</a>找到最佳滤波器。是Sobel滤波器，还是对变化敏感的Scharr滤波器，或者是非常简单的滤波器，例如垂直或水平滤波器？</p><p id="4d3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，答案并不简单，正如我们提到的，这部分取决于图像、它们的颜色和低水平。那么我们为什么不让神经网络来选择过滤器呢？神经网络不是最擅长预测事物的吗？神经网络将不得不学习哪个过滤器对于它试图预测的问题是最好的。</p><p id="a21a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，神经网络将学习我们在神经元的隐藏层中看到的经典方法——在密集层中。这个会完全一样，只是运算不是简单的乘法运算；这将是卷积乘法。但这些只是神经网络必须学习的正常权重:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/bd8d3ff9b83909659a7e45d529f76cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*tacBx37_3I5IksdcM87xsg.png"/></div></figure><p id="3114" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不给出这些值，而是让神经网络找到这些权重。</p><p id="f278" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个基本概念，它使深度神经网络能够检测更专业的特征，如边缘检测，甚至更高级的特征，如眼睛、汽车车轮和人脸。我们将看到，卷积层越深入，检测到的高级特征就越多。</p><p id="e5ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你觉得这篇文章很有见地，也很有趣。如果你想用Java实现更多这样的计算机视觉项目，你必须检查一下 <a class="ae lq" href="https://www.amazon.com/Hands-Java-Learning-Computer-Vision/dp/1789613965?tag=javamysqlanta-20" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="lr">计算机视觉的动手Java深度学习</em> </strong> </a> <em class="lr">。克莱维斯·拉莫写的</em></p><figure class="kh ki kj kk fd kl er es paragraph-image"><a href="https://www.amazon.com/Hands-Java-Learning-Computer-Vision/dp/1789613965?tag=javamysqlanta-20"><div class="er es ls"><img src="../Images/30a9027b120bb44a6791ac367a987165.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*64HJVyYzePuOjdUn7gQAAQ.png"/></div></a></figure><p id="3494" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lq" href="https://www.amazon.com/Hands-Java-Learning-Computer-Vision/dp/1789613965?tag=javamysqlanta-20" rel="noopener ugc nofollow" target="_blank"> <em class="lr">面向计算机视觉的动手Java深度学习</em> </a> <em class="lr">将带您了解用Java高效训练深度神经网络以完成计算机视觉相关任务的过程。</em></p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="9617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他有用的<strong class="ih hj">数据科学与机器学习</strong>资源<br/> <a class="ae lq" href="https://click.linksynergy.com/deeplink?id=JVFxdTr9V80&amp;mid=40328&amp;murl=https%3A%2F%2Fwww.coursera.org%2Flearn%2Fmachine-learning" rel="noopener ugc nofollow" target="_blank">机器学习by吴恩达</a> <br/> <a class="ae lq" href="https://click.linksynergy.com/deeplink?id=JVFxdTr9V80&amp;mid=40328&amp;murl=https%3A%2F%2Fwww.coursera.org%2Flearn%2Fai-for-everyone" rel="noopener ugc nofollow" target="_blank"> AI为大家</a> by <a class="ma mb ge" href="https://medium.com/u/592ce2a67248?source=post_page-----6147b68e5d79--------------------------------" rel="noopener" target="_blank">吴恩达</a> <br/> <a class="ae lq" href="https://javarevisited.blogspot.com/2018/10/top-8-python-libraries-for-data-science-machine-learning.html" rel="noopener ugc nofollow" target="_blank"> Top 8 Python机器学习库</a> <br/> <a class="ae lq" href="http://www.java67.com/2018/09/top-5-free-R-programming-courses-for-Data-Science-Machine-Learning-Programmers.html" rel="noopener ugc nofollow" target="_blank"> 5门免费课程学习机器学习用R编程</a><br/><a class="ae lq" href="http://www.java67.com/2018/02/5-free-python-online-courses-for-beginners.html" rel="noopener ugc nofollow" target="_blank">2018年5门免费课程学习Python</a><br/><a class="ae lq" href="https://hackernoon.com/top-5-data-science-and-machine-learning-course-for-programmers-e724cfb9940a" rel="noopener ugc nofollow" target="_blank">Top 5数据科学与机器学习课程</a> <br/> <a class="ae lq" href="https://hackernoon.com/top-5-tensorflow-and-ml-courses-for-programmers-8b30111cad2c" rel="noopener ugc nofollow" target="_blank"> 课程</a><br/><a class="ae lq" href="http://www.java67.com/2018/01/top-10-web-mobile-and-big-data-framework-libraries-technologies-programmers-should-learn-in-2018.html" rel="noopener ugc nofollow" target="_blank">2018年程序员可以学习的10项技术</a> <br/> <a class="ae lq" href="http://javarevisited.blogspot.sg/2018/03/top-5-courses-to-learn-python-in-2018.html" rel="noopener ugc nofollow" target="_blank">更好地学习Python的前5门课程</a> <br/> <a class="ae lq" href="https://cloud.google.com/blog/products/gcp/how-a-japanese-cucumber-farmer-is-using-deep-learning-and-tensorflow" rel="noopener ugc nofollow" target="_blank">一个日本黄瓜农如何利用深度学习和TensorFlow </a></p><p id="8ec6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> P. S. </strong> — —如果你需要一些免费资源来入手，可以查看一下这个免费课程<a class="ae lq" href="http://bit.ly/2DNKMdZ" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="lr">学习机器学习算法、软件、深度学习</em> </strong> </a>来开始你的准备。</p></div></div>    
</body>
</html>