<html>
<head>
<title>Architecture of a Reactive Spring Boot Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应式Spring Boot应用程序的体系结构</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/architecture-of-a-reactive-spring-boot-application-197bbfe3af78?source=collection_archive---------0-----------------------#2022-10-20">https://medium.com/javarevisited/architecture-of-a-reactive-spring-boot-application-197bbfe3af78?source=collection_archive---------0-----------------------#2022-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">典型弹簧靴反应式应用中的元件。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d0f98fdedc54f1a4d98d0c61355e5701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbDKIZ8e_GM2g1ZVkv2qiA.jpeg"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">由<a class="ae jt" href="https://unsplash.com/@jsnbrsc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰森·布里斯科</a>在<a class="ae jt" href="https://unsplash.com/s/photos/architecture-modern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6698" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring boot支持在引擎盖下使用project reactor构建反应式应用程序，这意味着与传统的非反应式Spring Boot应用程序相比，反应式spring boot应用程序的架构略有改变。在这篇文章中，我想谈谈反应式Spring Boot应用程序的不同组成部分，每一层的术语和不同选项。</p><h1 id="912e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">路由器功能</h1><p id="b3c0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">路由器函数定义了应用程序的入口点。它定义了应用程序公开的路由(也称为API ),这些路由反过来又作为单独的入口点。除了API(由路径和HTTP动词组成)，它还指定了请求的处理，即当接收到与特定API匹配的请求时会发生什么。通常，API请求的处理是由链中的下一个组件完成的，即处理程序。</p><h1 id="b608" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">处理者</h1><p id="a1d7" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Handler方法处理ServerRequest对象并返回ServerResponse对象(在反应式应用程序的情况下，Handler方法将返回一个<code class="du kx ky kz la b">Mono&lt;ServerResponse&gt;</code>)。处理程序不需要执行将传入的ServerRequest转换为<code class="du kx ky kz la b">Mono&lt;ServerResponse&gt;</code>的所有步骤，但是它是使用其他组件和服务进行处理的组件。</p><h1 id="03c4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">其他组件</h1><p id="4b2d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">处理程序下面是应用程序中的所有其他组件，即应用程序中可以在整个应用程序中重用的其他beans。这一层中的组件通常相互交换使用。所有其他组件中的大多数通常属于以下类别之一:</p><h2 id="ed00" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">服务</h2><p id="274f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果API请求的处理需要与多个组件对话，并且可以跨代码库重用，那么我喜欢创建一个服务类，它成为代码中的一个单独的位置，在这里所有这些组件可以组合起来并用于生成输出。服务类有助于隔离测试某些处理步骤，并有助于代码重用和维护。服务类可以使用本节中的其他类，包括客户端、计算单元、其他服务、储存库和计算类。</p><h2 id="8e22" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated"><em class="lp">客户端</em></h2><p id="4fd5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当一个组件负责对其他服务/第三方API进行API调用时，我喜欢将这样的类称为客户端(因为它们是它们进行API调用的那些服务的客户端)。在反应式Spring的情况下，您可能会使用Spring的WebClient来进行API调用。本质上不需要创建一个专门用于与其他API通信的组件。我喜欢这样把它们分开，因为:</p><ul class=""><li id="b630" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated">彻底测试这个组件的错误和快乐路径场景变得很容易。</li><li id="7f27" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">特定API的所有错误处理都可以在该组件中以隔离的方式发生。</li><li id="d659" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">将来对第三方API所做的任何更改都意味着与该API交互的客户端将是唯一需要更改的组件。</li></ul><p id="4079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它有助于为应用程序与之交互的每个第三方API提供一个客户端类，如果以这种方式建模，客户端类可以使用实用程序类、计算类和存储库(很少使用其他服务/客户端类)</p><h2 id="18b8" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated"><em class="lp">实用程序/助手类</em></h2><p id="7ded" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">无论您正在构建什么样的应用程序，您都有可能至少拥有一个负责所有验证的组件(例如)。有时，可能有多个验证器来验证应用程序处理的不同数据集。虽然验证器是一种实用程序类，但是还有其他类型属于这一类别(这不是唯一的列表):</p><ul class=""><li id="4ff7" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated">变压器(例如:dto/svo-&gt;实体，反之亦然)</li><li id="1dec" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">格式化程序(例如:在数据被发送到表示层之前在数据上运行)</li><li id="dae6" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">错误处理程序</li></ul><p id="b38a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果实用程序类可以分解成需要验证的数据(大多数情况下都可以这样做)，那么实用程序类可能不需要依赖于应用程序中的任何其他类(除了其他实用程序类)。</p><h2 id="3081" class="lb jv hi bd jw lc ld le ka lf lg lh ke iq li lj ki iu lk ll km iy lm ln kq lo bi translated">贮藏室ˌ仓库</h2><p id="4c72" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">存储库是spring接口/类，它们定义了与数据存储(可能是关系数据库、文档存储等)交互的契约(有时是实现)。这些与之前描述的任何组件都不相同，因为spring-data-jpa提供了一个选项来定义标记为存储库的接口中的函数/方法，这些方法的实现由spring负责(也称为<a class="ae jt" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details" rel="noopener ugc nofollow" target="_blank">查询方法</a>)。定义存储库组件最简单的选择是从spring-data的CrudRepository扩展。</p><p id="8ffb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储库类就像客户端一样，通常存在到实体(或数据库中的表)的一对一映射。仓库<em class="me">通常</em>不依赖于任何其他spring组件。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="aae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">博文中提到的组件只是提供一个总体示例，并没有涵盖所有可能的场景。Spring Boot的反应式堆栈与非反应式堆栈的不同之处不仅在于可用于处理请求的操作符，还在于处理请求的方式。我希望这篇文章为您的Spring Boot支持的反应式应用程序提供一个良好的开端！</p></div></div>    
</body>
</html>