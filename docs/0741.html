<html>
<head>
<title>Everyday I’m Shovelling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每天我都在铲东西</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/everyday-im-shovelling-1c79b6d568d7?source=collection_archive---------1-----------------------#2020-10-20">https://medium.com/javarevisited/everyday-im-shovelling-1c79b6d568d7?source=collection_archive---------1-----------------------#2020-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0a58" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何使用Java和Spring Boot rabbit MQ铲子</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ba90883485d817bf0606efae58923f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KLhtqxjcYM-adTr7AxBTSA.jpeg"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">在<a class="ae jn" href="https://unsplash.com/s/photos/bulldozer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jn" href="https://unsplash.com/@pixelcrook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Samuel Horn af Rantzien </a>拍摄的照片</p></figure><p id="70d4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文简要地解释了RabbitMQ铲子的概念，为什么您可能想要使用它们，以及如何在Spring Boot Java应用程序中设置铲子。</p><blockquote class="kk kl km"><p id="fb74" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">只是想看一些代码？该示例项目可在<a class="ae jn" href="https://github.com/basdgrt/rabbitmq-shovel-example" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p></blockquote></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="29da" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">概念</h1><p id="e0ca" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">RabbitMQ sloter是一个简单而强大的核心RabbitMQ插件，可以不断地将消息从源(队列)移动到目的地(交换、主题、队列等)，其中源和目的地可以位于不同的rabbit MQ集群中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/baee6c49e7d11965f9c3e5e1ed6a2ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TacsvNurbkOdV89_L0MBOg.png"/></div></div></figure><p id="460e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">官方<a class="ae jn" href="https://www.rabbitmq.com/shovel.html" rel="noopener ugc nofollow" target="_blank">文档</a>用一句话抓住了精髓:</p><blockquote class="lw"><p id="f599" class="lx ly hi bd lz ma mb mc md me mf kj dx translated">一个<!-- -->铲的行为就像一个编写良好的客户端应用程序，它连接到它的源和目的地，消费和重新发布消息，并在两端使用确认来应对故障。</p></blockquote><p id="2ee1" class="pw-post-body-paragraph jo jp hi jq b jr mg ij jt ju mh im jw jx mi jz ka kb mj kd ke kf mk kh ki kj hb bi translated">这就是它的全部，一个铲子持续可靠地将信息从一个来源移动到一个目的地。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="6a70" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">为什么要用铲子？</h1><p id="26d9" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">通过允许源和目的地在不同的RabbitMQ集群中，铲子促进了不同团队的集群和应用程序之间的松散耦合。</p><p id="0fcc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果团队B需要使用位于团队A集群上的队列中的消息，并且他们的应用程序会直接监听团队A的队列(紧耦合),那么当团队A决定关闭集群进行维护时，团队B的应用程序可能会中断。</p><p id="d7f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果团队B使用铲子将消息从团队A的队列移动到他们自己集群上的队列，他们可以让他们的应用程序监听他们自己集群上的队列。这是一件好事，因为它允许两个集群的所有者对他们的RabbitMQ环境进行维护，而不必担心意外破坏另一个团队的应用程序。</p><p id="7f77" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，如果其中一个集群关闭，铲子将无法在其源和目的地之间移动消息，但一旦两个集群都启动并再次运行，它就会恢复连接。</p><p id="ecba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除了降低维护风险之外，还有一些其他优势，因为铲子可以在集群之间传输消息，这些优势包括:</p><ul class=""><li id="0658" class="ml mm hi jq b jr js ju jv jx mn kb mo kf mp kj mq mr ms mt bi translated">运行不同版本的RabbitMQ</li><li id="3e9c" class="ml mm hi jq b jr mu ju mv jx mw kb mx kf my kj mq mr ms mt bi translated">使用不同的消息传递协议</li><li id="da3d" class="ml mm hi jq b jr mu ju mv jx mw kb mx kf my kj mq mr ms mt bi translated">拥有不同的用户和虚拟主机</li></ul></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="d73c" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">用铲子和爪哇Spring Boot</h1><p id="e151" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在这个循序渐进的示例中，我们将构建一个Spring Boot应用程序，该应用程序创建一个源和目标队列，并用铲子在它们之间移动消息。为了简单起见，源队列和目的队列将位于同一个RabbitMQ集群中。</p><h2 id="6965" class="mz kz hi bd la na nb nc le nd ne nf li jx ng nh lk kb ni nj lm kf nk nl lo nm bi translated">设置一个RabbitMQ环境，并启用铲子插件</h2><p id="3c40" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">建立RabbitMQ环境最简单的方法是通过Docker。然而，由于默认的RabbitMQ映像不支持not插件，我们需要使用自定义映像。在这个<a class="ae jn" href="https://hub.docker.com/repository/docker/bdg91/rabbitmq-shovel" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>存储库上有一个启用了铲子插件的图像。要运行此图像:</p><pre class="iy iz ja jb fd nn no np nq aw nr bi"><span id="4d36" class="mz kz hi no b fi ns nt l nu nv">docker run --name rabbitmq-shovel --rm -d -it --hostname my-rabbit -p 15672:15672 -p 5672:5672 bdg91/rabbitmq-shovel:latest</span></pre><p id="23ad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">启动后，RabbitMQ管理界面在<a class="ae jn" href="http://localhost:15672" rel="noopener ugc nofollow" target="_blank"> http://localhost:15672 </a>、<strong class="jq hj">T5，您可以使用默认用户名<em class="kn"> guest </em>登录，默认密码为<em class="kn"> guest。</em></strong></p><h2 id="5ecb" class="mz kz hi bd la na nb nc le nd ne nf li jx ng nh lk kb ni nj lm kf nk nl lo nm bi translated">创建新的Spring Boot项目</h2><p id="42b6" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">使用<a class="ae jn" href="https://start.spring.io" rel="noopener ugc nofollow" target="_blank"> Spring initializr </a>创建一个新的Spring Boot项目，将<em class="kn"> Spring for RabbitMQ </em>作为唯一的依赖<em class="kn">。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nw"><img src="../Images/abef0692dff5d44e5243d9b1e7ff9bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mLX0jkz7tUElkF-ytF3vw.png"/></div></div></figure><h2 id="6f77" class="mz kz hi bd la na nb nc le nd ne nf li jx ng nh lk kb ni nj lm kf nk nl lo nm bi translated">源队列和目标队列</h2><p id="d2f0" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">添加一个配置类来声明源队列和目标队列。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><h2 id="53a1" class="mz kz hi bd la na nb nc le nd ne nf li jx ng nh lk kb ni nj lm kf nk nl lo nm bi translated">生产者</h2><p id="fe63" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">生产者负责将消息放入我们的源队列。在这种情况下，消息只是一个字符串值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><p id="e522" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了在我们的源队列中获取一些消息，我们在应用程序启动后调用了<em class="kn"> produceMessages </em>方法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><h2 id="2064" class="mz kz hi bd la na nb nc le nd ne nf li jx ng nh lk kb ni nj lm kf nk nl lo nm bi translated">消费者</h2><p id="28dc" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">消费者负责从目标队列中读取消息，它记录它处理的每条消息的内容。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><p id="55f7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了让我们的消费者监听目的地队列，我们必须将以下配置添加到<em class="kn"> RabbitMqConfiguration </em>类中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><h2 id="c030" class="mz kz hi bd la na nb nc le nd ne nf li jx ng nh lk kb ni nj lm kf nk nl lo nm bi translated">无铲试运行</h2><p id="097f" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">如果我们现在启动我们的应用程序，并登录到RabbitMQ管理界面，我们将看到源队列和目标队列，在源队列中有10条消息。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nz"><img src="../Images/391b018c2e9f6b2004a1f13a55ade481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SInFPXKw9ZpVty_V3ubRfw.png"/></div></div></figure><p id="aef4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为我们的消费者只监听目的地队列，所以这10条消息不会去任何地方。</p><h2 id="a9bc" class="mz kz hi bd la na nb nc le nd ne nf li jx ng nh lk kb ni nj lm kf nk nl lo nm bi translated">创造一把铲子</h2><p id="59e5" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">用Java创建RabbitMQ铲子最简单的方法是使用RabbitMQ HTTP API的Java客户端<a class="ae jn" href="https://github.com/rabbitmq/hop" rel="noopener ugc nofollow" target="_blank"> Hop </a>。要使用Hop，我们需要将以下依赖项添加到项目中:</p><pre class="iy iz ja jb fd nn no np nq aw nr bi"><span id="e6e5" class="mz kz hi no b fi ns nt l nu nv">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;<br/>  &lt;artifactId&gt;http-client&lt;/artifactId&gt;<br/>  &lt;version&gt;3.8.0.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;<br/>  &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br/>  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br/>  &lt;version&gt;2.11.3&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="c24d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Hop允许您使用一个名为Client的类与RabbitMQ服务器进行交互。让我们在我们的<em class="kn"> RabbitMqConfiguration </em>类中实例化一个。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><p id="07b0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们使用客户端在<em class="kn"> ApplicationInitializer </em>类中创建我们的铲子，这样它将在应用程序启动后被创建。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nx ny l"/></div></figure><p id="b436" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于我们的源和目的地位于同一个群集中，因此<em class="kn">源Uri </em>和<em class="kn">目的地Uri </em>相等。在现实世界的例子中，<em class="kn"> sourceUri </em>和/或<em class="kn"> destinationUri </em>可能会指向不同的集群。</p><h2 id="1c8e" class="mz kz hi bd la na nb nc le nd ne nf li jx ng nh lk kb ni nj lm kf nk nl lo nm bi translated">用铲子试运行</h2><p id="2212" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">如果我们启动我们的应用程序，铲将所有消息从源队列移动到目的地队列。一旦消息到达目的地队列，它们就被我们的消费者使用，消费者将在控制台中为它处理的每个消息写一个日志消息。</p><pre class="iy iz ja jb fd nn no np nq aw nr bi"><span id="3e6c" class="mz kz hi no b fi ns nt l nu nv">c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 0]<br/>c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 1]<br/>c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 2]<br/>c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 3]<br/>c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 4]<br/>c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 5]<br/>c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 6]<br/>c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 7]<br/>c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 8]<br/>c.g.b.rabbitmq.message.MessageConsumer   : Received: [message 9]</span></pre><p id="c4cf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们创建的铲子可以通过<em class="kn">管理&gt;铲子状态在<a class="ae jn" href="http://localhost:15672" rel="noopener ugc nofollow" target="_blank">管理界面</a>中找到。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oa"><img src="../Images/101095a42f46c0fe9990b3207d20ad38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQpBoeRn9fjAtJR_9fWsJQ.png"/></div></div></figure><p id="7713" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完整且稍加修饰的源代码可在<a class="ae jn" href="https://github.com/basdgrt/rabbitmq-shovel-example" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="92cb" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">结论</h1><p id="6bf4" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">当您需要可靠且持续地将消息从一个集群中的源移动到另一个集群中的目的地时，rabbit MQ sloter是一个非常棒且易于使用的工具。它只需要几行代码就可以完成，而创建一个以同样可靠和一致的方式做同样事情的客户端应用程序则需要大量的工作。</p></div></div>    
</body>
</html>