<html>
<head>
<title>HiveMQ Cloud, part 2 — Using MQTT and Raspberry Pi to Visualize Sensor Data on a TilesFX Dashboard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HiveMQ云，第2部分—使用MQTT和Raspberry Pi在TilesFX仪表板上可视化传感器数据</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/hivemq-cloud-part-2-using-mqtt-and-raspberry-pi-to-visualize-sensor-data-on-a-tilesfx-dashboard-4189a3a5d4c?source=collection_archive---------3-----------------------#2021-12-14">https://medium.com/javarevisited/hivemq-cloud-part-2-using-mqtt-and-raspberry-pi-to-visualize-sensor-data-on-a-tilesfx-dashboard-4189a3a5d4c?source=collection_archive---------3-----------------------#2021-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d4a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" rel="noopener" href="/javarevisited/hivemq-cloud-part-1-mqtt-on-raspberry-pi-send-sensor-data-to-hivemq-cloud-with-java-and-pi4j-a92f0082a6fd">的上一篇文章</a>中，我们在Raspberry Pi上开始了对HiveMQ Cloud和Java的探索。我们创建了一个应用程序，将各种传感器的测量结果发送到HiveMQ Cloud MQTT代理。使用在线websocket客户端，我们验证了消息的转换，并且可以看到数据被发布到这个在线消息队列。</p><p id="7d64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将进行下一步，订阅这些主题，以在使用JavaFX创建的仪表板中接收数据。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><h1 id="4a6f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">关于JavaFX</h1><p id="ba7b" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">JavaFX是一组图形和媒体包，使开发人员能够设计、创建、测试、调试和部署在不同平台上一致运行的富客户端应用程序。</p><p id="8537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/javarevisited/7-best-java-fx-online-courses-for-beginners-9e774ba6f996"> JavaFX </a>由太阳微系统公司创建，后来成为甲骨文公司的一部分，现在是<a class="ae jd" href="https://openjfx.io/" rel="noopener ugc nofollow" target="_blank"> openjfx.io </a>上的一个开源项目。商业支持可以通过<a class="ae jd" href="https://gluonhq.com/" rel="noopener ugc nofollow" target="_blank">GluonHQ</a>获得，gluohq也是项目的主要维护者，有很多贡献者(包括Oracle)的支持。GitHub 上有<a class="ae jd" href="https://github.com/openjdk/jfx" rel="noopener ugc nofollow" target="_blank">的源代码。从版本11开始，JavaFX模块移出了Oracle JDK。Java的发布周期类似于6个月，JavaFX的开发速度提高了，推动了新特性的发展。</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2020/06/top-5-courses-to-learn-java-fx-in-2020.html#axzz6u4HTHz4Z"><div class="er es ko"><img src="../Images/e8d36cd6999fc38266b51dca4eabd91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pZoBG5KRNNUKcNjY.png"/></div></a><p class="kr ks et er es kt ku bd b be z dx translated">JavaFX版本历史</p></figure><p id="be75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/javarevisited/6-free-courses-to-learn-servlet-jsp-and-java-fx-in-2020-best-of-lot-720201c84f63"> JavaFX </a>允许快速构建用户界面，同时使用您作为Java开发人员已经知道的语言和工具。这可以用CSS语法进行样式化，并且非常灵活和可扩展，甚至允许您绘制自己的布局元素，正如您在上面的历史图表中所看到的，可以在<a class="ae jd" href="https://github.com/FDelporte/JavaOnRaspberryPi/tree/master/Chapter_04_Java/javafx-timeline" rel="noopener ugc nofollow" target="_blank"> GitHub上获得，作为我的书<a class="ae jd" href="https://webtechie.be/books/" rel="noopener ugc nofollow" target="_blank">“在Raspberry Pi上开始使用Java”</a>的来源</a>的一部分。</p><h1 id="5df9" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">树莓Pi上的JavaFX</h1><p id="258e" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">JavaFX可以通过两种方式安装在Raspberry Pi上:</p><ul class=""><li id="d5b3" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">通过安装捆绑了JavaFX的JDK。Azul和BellSoft提供了这样的版本。</li><li id="2d2d" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">通过使用可从GluonHQ网站下载的最新版本单独安装它。</li></ul><p id="d5ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我个人更喜欢第二种方法，因为您肯定会使用最新的JavaFX运行时，包括嵌入式设备的所有改进。由于这是一个快速发展的市场，有很多正在发生的变化，如改进的渲染和直接渲染模式(DRM，也称为Kiosk模式)。关于这个主题的更多信息可以在<a class="ae jd" href="https://foojay.io/today/javafx-running-in-kiosk-mode-on-the-raspberry-pi/" rel="noopener ugc nofollow" target="_blank">“在Raspberry Pi上以Kiosk模式运行的JavaFX】中找到。</a></p><h1 id="e08b" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">TilesFX库</h1><p id="5525" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">这个伟大的库是由<a class="ae jd" href="https://twitter.com/hansolo_" rel="noopener ugc nofollow" target="_blank">杰瑞特·格伦瓦德</a>开发的，它提供了构建仪表板的瓦片。查看<a class="ae jd" href="https://harmoniccode.blogspot.com/" rel="noopener ugc nofollow" target="_blank">的博客</a>以获得更多JavaFX示例！</p><p id="e64f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在GitHub 上找到<a class="ae jd" href="https://github.com/HanSolo/tilesfx" rel="noopener ugc nofollow" target="_blank">tiles FX的源代码，它可以作为</a><a class="ae jd" href="https://mvnrepository.com/artifact/eu.hansolo/tilesfx" rel="noopener ugc nofollow" target="_blank"> Maven依赖项</a>获得。作为TilesFX源代码的一部分，提供了一个演示应用程序来展示如何使用所有可用的图块。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/71e0f8a547efee0911a52f6403b88a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XG5syvd96_2FrZSK.png"/></div></div><p class="kr ks et er es kt ku bd b be z dx translated">TilesFX演示应用程序</p></figure><h1 id="f1ae" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">Java项目</h1><p id="45bf" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">让我们创建一个JavaFX应用程序，用我们在上一部分中创建的应用程序来可视化我们推送到HiveMQ Cloud的所有传感器值。</p><h1 id="8d99" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">属国</h1><p id="c4dd" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">与消息发送者相比，该项目需要一些不同的依赖项。当然，我们再次使用HiveMQ MQTT客户端。但是对于图形用户界面部分，我们需要一些JavaFX库(在应用程序中只使用了controls，其他的由TilesFX引用)和TilesFX库本身。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="3d53" class="lt jm hi lp b fi lu lv l lw lx">&lt;dependency&gt;<br/>   &lt;groupId&gt;com.hivemq&lt;/groupId&gt;<br/>   &lt;artifactId&gt;hivemq-mqtt-client&lt;/artifactId&gt;<br/>   &lt;version&gt;${hivemq.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.openjfx&lt;/groupId&gt;<br/>   &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;<br/>   &lt;version&gt;${javafx.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.openjfx&lt;/groupId&gt;<br/>   &lt;artifactId&gt;javafx-media&lt;/artifactId&gt;<br/>   &lt;version&gt;${javafx.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.openjfx&lt;/groupId&gt;<br/>   &lt;artifactId&gt;javafx-web&lt;/artifactId&gt;<br/>   &lt;version&gt;${javafx.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;eu.hansolo&lt;/groupId&gt;<br/>   &lt;artifactId&gt;tilesfx&lt;/artifactId&gt;<br/>   &lt;version&gt;${tilesfx.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><h1 id="258f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">GitHub上的完整代码</h1><p id="993f" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">这个应用程序的源代码<a class="ae jd" href="https://github.com/FDelporte/HiveMQ-examples" rel="noopener ugc nofollow" target="_blank">可以在GitHub上找到，与前一篇文章</a>在同一个存储库中。</p><h2 id="d0d2" class="lt jm hi bd jn ly lz ma jr mb mc md jv iq me mf jz iu mg mh kd iy mi mj kh mk bi translated">启动JavaFX应用程序</h2><p id="c724" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们需要从JavaFX应用程序扩展，在这种情况下，我们在start-method中配置HiveMQ客户端。这也可以在一个单独的类中完成，但是对于这个概念验证来说，很容易使用client-reference将它提供给子对象。</p><p id="875b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于主题的维护，这里也定义了这些主题。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="c3e0" class="lt jm hi lp b fi lu lv l lw lx">public class HiveMqClient extends Application {<br/>   private static final Logger logger = <br/>      LogManager.getLogger(HiveMqClient.class.getName());</span><span id="3f6a" class="lt jm hi lp b fi ml lv l lw lx">   public static final String TOPIC_MOTION = "crowpi/motion";<br/>   public static final String TOPIC_NOISE = "crowpi/noise";<br/>   public static final String TOPIC_SENSORS = "crowpi/sensors";<br/>   public static final String TOPIC_TILT = "crowpi/tilt";<br/>   public static final String TOPIC_TOUCH = "crowpi/touch";</span><span id="d63d" class="lt jm hi lp b fi ml lv l lw lx">   private static final String HIVEMQ_SERVER = <br/>      "ID_OF_YOUR_INSTANCE.s1.eu.hivemq.cloud";</span><span id="c931" class="lt jm hi lp b fi ml lv l lw lx">   private static final String HIVEMQ_USER = "YOUR_USERNAME";<br/>   private static final String HIVEMQ_PASSWORD = "YOUR_PASSWORD";<br/>   private static final int HIVEMQ_PORT = 8883;</span><span id="97c3" class="lt jm hi lp b fi ml lv l lw lx">   @Override<br/>   public void start(Stage stage) {<br/>      logger.info("Starting up...");<br/>      Mqtt5AsyncClient client = MqttClient.builder()<br/>         .useMqttVersion5()<br/>         .identifier("JavaFX_" + UUID.randomUUID())<br/>         .serverHost(HIVEMQ_SERVER)<br/>         .serverPort(HIVEMQ_PORT)<br/>         .sslWithDefaultConfig()<br/>         .buildAsync();</span><span id="5973" class="lt jm hi lp b fi ml lv l lw lx">      client.connectWith()<br/>         .simpleAuth()<br/>         .username(HIVEMQ_USER)<br/>         .password(HIVEMQ_PASSWORD.getBytes())<br/>         .applySimpleAuth()<br/>         .send()<br/>         .whenComplete((connAck, throwable) -&gt; {<br/>             if (throwable != null) {<br/>                logger.error("Could not connect to HiveMQ: {}",<br/>                   throwable.getMessage());<br/>             } else {<br/>                logger.info("Connected to HiveMQ: {}", <br/>                    connAck.getReasonCode());<br/>             }<br/>         });</span><span id="c84c" class="lt jm hi lp b fi ml lv l lw lx">       var scene = new Scene(new DashboardView(client), 1024, 620);<br/>       stage.setScene(scene);<br/>       stage.show();<br/>   }</span><span id="8fdf" class="lt jm hi lp b fi ml lv l lw lx">   public static void main(String[] args) {<br/>       launch();<br/>   }<br/>}</span></pre><h2 id="2ba4" class="lt jm hi bd jn ly lz ma jr mb mc md jv iq me mf jz iu mg mh kd iy mi mj kh mk bi translated">可视化仪表板中的数据</h2><p id="d6cc" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在DashboardView中，我们定义了要添加到屏幕中的所有图块。请看看所有瓷砖的完整来源。在这里你可以找到其中两个的代码:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="7b67" class="lt jm hi lp b fi lu lv l lw lx">public class DashboardView extends FlowGridPane {<br/>   private static final Logger logger = <br/>      LogManager.getLogger(DashboardView.class.getName());</span><span id="b49d" class="lt jm hi lp b fi ml lv l lw lx">   private final ObjectMapper mapper = new ObjectMapper();<br/>   private final Tile gaucheTemperature;<br/>   private final Tile gaucheDistance;<br/>   private final Tile gaucheLight;<br/>   private final Tile percentageHumidity;</span><span id="34e2" class="lt jm hi lp b fi ml lv l lw lx">   public DashboardView(Mqtt5AsyncClient client) {<br/>      super(5, 2); <br/>      logger.info("Creating dashboard view");</span><span id="a827" class="lt jm hi lp b fi ml lv l lw lx">      setHgap(5);<br/>      setVgap(5);<br/>      setAlignment(Pos.CENTER);<br/>      setCenterShape(true);<br/>      setPadding(new Insets(5));<br/>      setBackground(new Background(<br/>          new BackgroundFill(Color.web("#101214"), <br/>          CornerRadii.EMPTY, Insets.EMPTY)));</span><span id="ad06" class="lt jm hi lp b fi ml lv l lw lx">      ...</span><span id="135b" class="lt jm hi lp b fi ml lv l lw lx">      gaucheTemperature = TileBuilder.create()<br/>         .skinType(Tile.SkinType.GAUGE)<br/>         .prefSize(TILE_WIDTH, TILE_HEIGHT)<br/>         .title("Temperature")<br/>         .unit("°C")<br/>         .threshold(21)<br/>         .maxValue(50)<br/>         .build();</span><span id="cc3e" class="lt jm hi lp b fi ml lv l lw lx">      ...</span><span id="890b" class="lt jm hi lp b fi ml lv l lw lx">      getChildren().addAll(<br/>         clockTile,<br/>         gaucheTemperature,<br/>         percentageHumidity,<br/>         gaucheDistance,<br/>         gaucheLight,<br/>         new TiltStatusTile(client, TOPIC_TILT),<br/>         new SensorSwitchTile(client, TOPIC_TOUCH, <br/>             "Touch sensor", "Show if the sensor is touched"),<br/>         new SensorSwitchTile(client, TOPIC_MOTION, <br/>              "Motion sensor", "Show if motion is detected"),<br/>         new NoiseTextTile(client, TOPIC_NOISE));</span><span id="b7dc" class="lt jm hi lp b fi ml lv l lw lx">      ...<br/>   }</span><span id="b90b" class="lt jm hi lp b fi ml lv l lw lx">   ...<br/>}</span></pre><p id="4d11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">戈谢温</p><p id="e67c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">温度是由CrowPi间隔发送的传感器值之一。订阅传感器主题后，我们将收到这些数据。通过使用与发送者应用程序中相同的传感器类，我们可以很容易地将接收到的字符串映射到Java对象。</p><p id="156d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GaucheTemperature-tile和我们在构造函数中初始化的其他tile现在可以用接收到的数据进行更新。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="8474" class="lt jm hi lp b fi lu lv l lw lx">...</span><span id="b16f" class="lt jm hi lp b fi ml lv l lw lx">client.toAsync().subscribeWith()<br/>   .topicFilter(TOPIC_SENSORS)<br/>   .qos(MqttQos.AT_LEAST_ONCE)<br/>   .callback(this::handleSensorData)<br/>   .send();</span><span id="9964" class="lt jm hi lp b fi ml lv l lw lx">...</span><span id="9c2b" class="lt jm hi lp b fi ml lv l lw lx">private void handleSensorData(Mqtt5Publish message) {<br/>   var sensorData = new String(message.getPayloadAsBytes());</span><span id="6744" class="lt jm hi lp b fi ml lv l lw lx">   logger.info("Sensor data: {}", sensorData);</span><span id="af03" class="lt jm hi lp b fi ml lv l lw lx">   try {<br/>      var sensor = mapper.readValue(sensorData, Sensor.class);<br/>      gaucheTemperature.setValue(sensor.getTemperature());<br/>      percentageHumidity.setValue(sensor.getHumidity());<br/>      gaucheDistance.setValue(sensor.getDistance());<br/>      gaucheLight.setValue(sensor.getLight());<br/>   } catch (JsonProcessingException ex) {<br/>      logger.error("Could not parse the data to JSON: {}",<br/>         ex.getMessage());<br/>   }<br/>}</span></pre><p id="3ffb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">传感器开关</p><p id="1ac4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当传感器的状态改变时，其他数据由发布者发送。例如，当触摸或释放触摸传感器时，我们将接收到特定主题的真或假。为了能够容易地处理这一点，创建了从Tile类扩展的附加组件。</p><p id="a05f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SensorSwitchTile包含一个SWITCH-tile，其活动状态根据每个接收到的消息中的值而改变。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="867d" class="lt jm hi lp b fi lu lv l lw lx">public class SensorSwitchTile extends BaseTile {<br/>   private final Tile statusTile;</span><span id="434d" class="lt jm hi lp b fi ml lv l lw lx">   public SensorSwitchTile(Mqtt5AsyncClient client, String topic, <br/>      String title, String description) {<br/>      super(client, topic);</span><span id="6234" class="lt jm hi lp b fi ml lv l lw lx">      statusTile = TileBuilder.create()<br/>         .skinType(SkinType.SWITCH)<br/>         .prefSize(TILE_WIDTH, TILE_HEIGHT)<br/>         .title(title)<br/>         .description(description)<br/>         .build();</span><span id="9586" class="lt jm hi lp b fi ml lv l lw lx">      getChildren().add(statusTile);<br/>   }</span><span id="0e63" class="lt jm hi lp b fi ml lv l lw lx">   @Override<br/>   public void handleMessage(Mqtt5Publish message) {<br/>      var sensorData = new String(message.getPayloadAsBytes());<br/>      logger.info("Boolean sensor data: {}", sensorData);<br/>      try {<br/>         var sensor = mapper.readValue(sensorData, <br/>            BooleanValue.class);</span><span id="a7e9" class="lt jm hi lp b fi ml lv l lw lx">         Platform.runLater(() -&gt; {<br/>            statusTile.setActive(sensor.getValue());<br/>         });<br/>      } catch (JsonProcessingException ex) {<br/>         logger.error("Could not parse the data to JSON: {}",<br/>            ex.getMessage());<br/>      }<br/>   }<br/>}</span></pre><p id="63f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主题的订阅在BaseTile类中处理，以避免重复代码。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="7fcf" class="lt jm hi lp b fi lu lv l lw lx">public class BaseTile extends Pane {<br/>   protected static final Logger logger = <br/>      LogManager.getLogger(BaseTile.class.getName());</span><span id="1cdf" class="lt jm hi lp b fi ml lv l lw lx">   protected final ObjectMapper mapper = new ObjectMapper();</span><span id="33fd" class="lt jm hi lp b fi ml lv l lw lx">   public static final int TILE_WIDTH = 200;<br/>   public static final int TILE_HEIGHT = 300;</span><span id="9862" class="lt jm hi lp b fi ml lv l lw lx">   public BaseTile(Mqtt5AsyncClient client, String topic) {<br/>      client.toAsync().subscribeWith()<br/>         .topicFilter(topic)<br/>         .qos(MqttQos.AT_LEAST_ONCE)<br/>         .callback(this::handleMessage)<br/>         .send();<br/>   }</span><span id="7a60" class="lt jm hi lp b fi ml lv l lw lx">   /**<br/>   * Method to be overridden in each tile<br/>   */<br/>   protected void handleMessage(Mqtt5Publish message) {<br/>      logger.warn("Message not handled: {}", <br/>         message.getPayloadAsBytes());<br/>   }<br/>}</span></pre><p id="48ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，订阅HiveMQ云消息只需要很少的代码。</p><h1 id="15d0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">构建和运行应用程序</h1><h2 id="ed75" class="lt jm hi bd jn ly lz ma jr mb mc md jv iq me mf jz iu mg mh kd iy mi mj kh mk bi translated">在开发人员电脑上</h2><p id="8949" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">与之前的应用程序中的GPIO接口相比，这个项目没有调用任何Raspberry Pi特定的函数，所以我们可以在任何PC上运行它。此外，您可以选择使用包含JavaFX运行时依赖项的JDK，或者单独下载。这两种方法在<a class="ae jd" href="https://foojay.io/today/starting-a-javafx-project-with-gluon-tools/" rel="noopener ugc nofollow" target="_blank">“用Gluon工具启动JavaFX项目”</a>中有更详细的描述。</p><p id="9056" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，当从IntelliJ IDEA开始时，Maven依赖项将为您处理所有这一切。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mm"><img src="../Images/9fbdd68224a5d31db95eb509a03adb8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9mvu_GhvAs1gjVZC.png"/></div></div></figure><h2 id="659d" class="lt jm hi bd jn ly lz ma jr mb mc md jv iq me mf jz iu mg mh kd iy mi mj kh mk bi translated">树莓派</h2><p id="cfa7" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">为了在Raspberry Pi 4上运行这个应用程序，我从一个新的SD卡开始，使用标准的Raspberry Pi操作系统(32位)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mn"><img src="../Images/ad6738aebf1b569e6f51abb9925012ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3TfhuMptrKpaIKwX.png"/></div></div></figure><p id="c9fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是Raspberry Pi操作系统的“最小”版本，不包括Java，但这可以通过在终端中运行<code class="du mo mp mq lp b">sudo apt install openjdk-11-jdk</code>快速修复。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="be92" class="lt jm hi lp b fi lu lv l lw lx">$ java -version<br/>bash: java: command not found<br/>$ sudo apt update<br/>$ sudo apt install openjdk-11-jdk<br/>$ java -version<br/>openjdk version "11.0.13" 2021-10-19<br/>OpenJDK Runtime Environment (build 11.0.13+8-post-Raspbian-1deb11u1)<br/>OpenJDK Server VM (build 11.0.13+8-post-Raspbian-1deb11u1, mixed mode)</span></pre><p id="4451" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不错！现在我们已经可以在Raspberry Pi上运行Java代码了。但是对于JavaFX，我们需要专门为Raspberry Pi编译的运行时。胶子通过他们的网站gluonhq.com/products/javafx提供这些版本。我们只需要下载一个文件，将其解压缩，并放在一个我们在启动应用程序时会引用的位置。</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="336d" class="lt jm hi lp b fi lu lv l lw lx">$ wget -O openjfx.zip https://gluonhq.com/download/javafx-17-ea-sdk-linux-arm32/ <br/>$ unzip openjfx.zip <br/>$ sudo mv javafx-sdk-17/ /opt/javafx-sdk-17/</span></pre><p id="b12c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这个dashboard应用程序是一个Maven项目，我们仍然需要安装它，然后我们可以获得完整的项目并在Raspberry Pi上构建它。请遵循以下步骤:</p><pre class="je jf jg jh fd lo lp lq lr aw ls bi"><span id="1166" class="lt jm hi lp b fi lu lv l lw lx">$ sudo apt install maven <br/>$ git clone https://github.com/FDelporte/HiveMQ-examples.git <br/>$ cd HiveMQ-examples/javafx-ui-hivemq <br/>$ mvn package <br/>$ cd target/distribution <br/>$ bash run.sh</span></pre><p id="30f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mo mp mq lp b">run.sh</code>脚本将编译后的应用程序jar与特定于平台的JavaFX运行时相结合，并启动应用程序。</p><h1 id="ffcf" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结论</h1><p id="a959" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">TilesFX只是您可以在应用程序中使用的许多开源库之一，或者您可以创建自己的组件。杰瑞特·格伦瓦德和其他作家在foojay.io 的多篇文章中解释了这种方法。</p><p id="d4bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用JavaFX，您可以快速开发漂亮的用户界面，并与HiveMQ Cloud相结合，这将产生一个很好的仪表板应用程序来可视化传感器数据。</p><p id="1d5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过在Raspberry Pi上运行该应用程序，您可以以非常低的价格获得一个始终在线的仪表板屏幕。</p></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><p id="b293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="my">本文应HiveMQ的要求而写，最初发表于HiveMQ的博客</em><a class="ae jd" href="https://www.hivemq.com/blog/mqtt-raspberrypi-part02-visualizing-sensor-data-on-a-tilesfx-dashboard/" rel="noopener ugc nofollow" target="_blank"><em class="my"/></a><em class="my">。</em></p></div></div>    
</body>
</html>