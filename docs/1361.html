<html>
<head>
<title>Spring Transaction Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring事务管理</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-transaction-management-95ab4b2cf513?source=collection_archive---------2-----------------------#2021-07-05">https://medium.com/javarevisited/spring-transaction-management-95ab4b2cf513?source=collection_archive---------2-----------------------#2021-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6be3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇简短的文章中，我们将讨论事务性注释。Spring使用@Transactional注释来提供事务管理。</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://www.java67.com/2019/06/core-spring-professional-50-topics-guide-java-developers.html"><div class="er es jd"><img src="../Images/2ad6e299e10eb0d634fcc8345ea37b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGLXWHGsMZgAcJTcrjRosA.jpeg"/></div></a><p class="jl jm et er es jn jo bd b be z dx translated">照片由<a class="ae jp" href="https://unsplash.com/@naipo_de" rel="noopener ugc nofollow" target="_blank"> naipo.de </a> <strong class="bd jq"> </strong>发自<a class="ae jp" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> unsplash </a></p></figure><p id="8a1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事务概念的属性</p><ul class=""><li id="582a" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated"><em class="ka">原子</em></li><li id="66be" class="jr js hi ih b ii kb im kc iq kd iu ke iy kf jc jw jx jy jz bi translated"><em class="ka">一致</em></li><li id="7b18" class="jr js hi ih b ii kb im kc iq kd iu ke iy kf jc jw jx jy jz bi translated"><em class="ka">隔离</em></li><li id="9c34" class="jr js hi ih b ii kb im kc iq kd iu ke iy kf jc jw jx jy jz bi translated"><em class="ka">耐用</em></li></ul><h2 id="b954" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">事务和回滚</h2><p id="4bb8" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在同一个进程中执行一个或多个SQL查询称为事务。</p><p id="c78b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回滚对于确保数据完整性和所有事务不可分非常重要。如果任何操作失败，则所有其他操作都会回滚。</p><pre class="je jf jg jh fd lf lg lh li aw lj bi"><span id="6cc2" class="kg kh hi lg b fi lk ll l lm ln">@Override<br/>@Transactional<br/>public Response doReservation<em class="ka">(</em>Request request<em class="ka">) {<br/>  </em>return doReservation<br/>      .initialize<em class="ka">()<br/>      </em>.before<em class="ka">(</em>request<em class="ka">)<br/>      </em>.completeReservation<em class="ka">(</em>request<em class="ka">)<br/>      </em>.callPaymentProvider<em class="ka">(</em>request<em class="ka">)<br/>      </em>.result<em class="ka">(</em>request<em class="ka">)</em>;<br/><em class="ka">}</em></span></pre></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="ced9" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">传播类型</h2><pre class="je jf jg jh fd lf lg lh li aw lj bi"><span id="5ca7" class="kg kh hi lg b fi lk ll l lm ln">@Override<br/>@Transactional<em class="ka">(</em>propagation = Propagation.<em class="ka">REQUIRES_NEW)<br/></em>public Response persistUser<em class="ka">(</em>CreateUserRequest request<em class="ka">) {<br/>  </em>Response response = new Response<em class="ka">&lt;&gt;()</em>;<br/>  UserEntity userEntity = this.mapper.map<em class="ka">(request, ...)</em>;<br/><br/>  this.userEntityRepository.save<em class="ka">(</em>userEntity<em class="ka">)</em>;<br/>  this.notificationService.sendEmail<em class="ka">(</em>request<em class="ka">)</em>;<br/><br/>  return response.initializationSuccess<em class="ka">()</em>;<br/><em class="ka">}</em></span></pre><p id="7193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">传播</strong>:决定是否使用已有事务，或者是否停止当前事务，打开一个新事务。定义我们的业务逻辑的事务边界。<em class="ka">必需的</em>是默认传播。</p><h2 id="e3fe" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">所需传播</h2><p id="d966" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">如果有活动事务，则使用它，否则它会打开一个新事务。</p><h2 id="664b" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">支持传播</h2><p id="caa0" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">如果有活动的事务，它将使用它，否则将在没有事务的情况下运行。</p><h2 id="4637" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">必需_新传播</h2><p id="7843" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">如果有活动的事务，使其挂起并打开一个新的事务。</p><h2 id="228e" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">强制传播</h2><p id="9d29" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">如果事务之前已经启动，则使用它。如果没有事务，它会抛出一个异常。</p><pre class="je jf jg jh fd lf lg lh li aw lj bi"><span id="fb41" class="kg kh hi lg b fi lk ll l lm ln">throw IllegalTransactionStateException;</span></pre><h2 id="edca" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">从不传播</h2><p id="5d76" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">如果有事务，它会抛出一个异常。</p><h2 id="bfbc" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">不支持的传播</h2><p id="7ee2" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">它挂起现有的事务，如果它不存在事务，它在没有事务的情况下工作。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="d4f7" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">只读的</h2><p id="e7f0" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">默认情况下，In @Transactional readOnly为false。如果我们使用readOnly = true，我们可以执行只包含读取操作的搜索和获取过程。</p><pre class="je jf jg jh fd lf lg lh li aw lj bi"><span id="6b20" class="kg kh hi lg b fi lk ll l lm ln">@Transactional<em class="ka">(</em>readOnly = true)</span></pre></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="e086" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">超时</h2><p id="d9e0" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">它保证事务在一定时间内(秒)发生，否则会回滚。@Transactional(timeout = 30)将事务超时设置为30秒。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="0f35" class="kg kh hi bd jq ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">回滚到</h2><p id="d51c" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">它决定是否根据指定的类执行回滚操作。</p><pre class="je jf jg jh fd lf lg lh li aw lj bi"><span id="03ae" class="kg kh hi lg b fi lk ll l lm ln">@Transactional<em class="ka">(</em>rollbackFor = ProvideExceptionHandler.class<em class="ka">)</em></span></pre></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><blockquote class="lv lw lx"><p id="1235" class="if ig ka ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><strong class="ih hj">使用@Transactional注释的注意事项。</strong></p></blockquote><pre class="je jf jg jh fd lf lg lh li aw lj bi"><span id="7707" class="kg kh hi lg b fi lk ll l lm ln">@Override<br/>@Transactional<br/>public void updateTaskName<em class="ka">(</em>Long taskId<em class="ka">) {<br/>  </em>TaskEntity taskEntity = this.taskEntityRepository.findById<em class="ka">(</em>taskId<em class="ka">)<br/>      </em>.orElseThrow<em class="ka">(() </em>-&gt; new ProvideExceptionHandler<em class="ka">(</em>""<em class="ka">))</em>;<br/><br/>  taskEntity.setTaskName<em class="ka">(</em>"name updated"<em class="ka">)</em>;<br/><br/>  if <em class="ka">(</em>this.validateUpdate<em class="ka">()) {<br/>    </em>this.taskEntityRepository.save<em class="ka">(</em>taskEntity<em class="ka">)</em>;<br/>  <em class="ka">}<br/>}</em></span></pre><p id="bd0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的方法中，task实体从数据库中检索task id，如果validateUpdate()为true，它将对象保存到数据库中。那么如果validate updateMethod返回false，持久化操作会发生吗？</p><p id="6cf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是，持续操作发生。因为实体对象内的所有更改都会在方法结束时自动反映在数据库中。</p><p id="6832" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们检查一个需要注意的不同案例。</p><pre class="je jf jg jh fd lf lg lh li aw lj bi"><span id="193a" class="kg kh hi lg b fi lk ll l lm ln">@Override<br/>@Transactional<br/>public void updateTaskName<em class="ka">(</em>Long taskId<em class="ka">) {<br/>  </em>TaskEntity taskEntity = this.taskEntityRepository.findById<em class="ka">(</em>taskId<em class="ka">)<br/>      </em>.orElseThrow<em class="ka">(() </em>-&gt; new ProvideExceptionHandler<em class="ka">(</em>""<em class="ka">))</em>;<br/><br/>  taskEntity.setTaskName<em class="ka">(</em>"name updated"<em class="ka">)</em>;<br/><br/>  if <em class="ka">(</em>this.validateUpdate<em class="ka">()) {<br/>    </em>throw new <strong class="lg hj">ProvideExceptionHandler</strong><em class="ka">()</em>;<br/>  <em class="ka">}<br/>}</em></span></pre><p id="3835" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们假设if块内部的条件为真。</p><pre class="je jf jg jh fd lf lg lh li aw lj bi"><span id="64ca" class="kg kh hi lg b fi lk ll l lm ln">public class ProvideExceptionHandler extends Exception <em class="ka">{<br/><br/>}</em></span></pre><p id="c8f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回滚没有实现，因为回滚需要抛出一个“未检查的异常”。</p><p id="060c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们修复回滚的方法。</p><pre class="je jf jg jh fd lf lg lh li aw lj bi"><span id="a1ca" class="kg kh hi lg b fi lk ll l lm ln">@Override<br/>@Transactional<em class="ka">(</em>rollbackFor = ProvideExceptionHandler.class<em class="ka">)<br/></em>public void updateTaskName<em class="ka">(</em>Long taskId<em class="ka">) </em>throws CustomException <em class="ka">{<br/>  </em>TaskEntity taskEntity = this.taskEntityRepository.findById<em class="ka">(</em>taskId<em class="ka">)<br/>      </em>.orElseThrow<em class="ka">(() </em>-&gt; new ProvideExceptionHandler<em class="ka">(</em>""<em class="ka">))</em>;<br/><br/>  taskEntity.setTaskName<em class="ka">(</em>"Updated name"<em class="ka">)</em>;<br/><br/>  if <em class="ka">(</em>this.validateUpdate<em class="ka">()) {<br/>    </em>throw new ProvideExceptionHandler<em class="ka">()</em>;<br/>  <em class="ka">}<br/>}</em></span></pre><p id="4280" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们讨论了Spring事务性注释，下一篇短文再见。</p></div></div>    
</body>
</html>