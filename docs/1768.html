<html>
<head>
<title>Spring Data — Power of Domain Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Data —领域事件的力量</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-data-power-of-domain-events-62cb212a42a2?source=collection_archive---------0-----------------------#2021-11-27">https://medium.com/javarevisited/spring-data-power-of-domain-events-62cb212a42a2?source=collection_archive---------0-----------------------#2021-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1099" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://martinfowler.com/eaaDev/DomainEvent.html" rel="noopener ugc nofollow" target="_blank">领域事件</a>是来自<a class="ae jd" href="https://en.wikipedia.org/wiki/Domain-driven_design" rel="noopener ugc nofollow" target="_blank">领域驱动设计</a>的想法之一。一旦你熟悉了这种技术，你就不会再愿意离开它了。因此，在本文中，我将向您展示一个应用程序开发的示例。随着新需求的出现，我们正在一步一步地进行这个过程。这将使我们清楚地了解领域事件的价值。</p><p id="abcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的栈是Java 11 + Spring Boot + Hibernate。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/01/how-to-learn-spring-core-spring-mvc-boot-security-framework.html"><div class="er es je"><img src="../Images/cc98de91b8669696c06554b1e849abc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/0*rk1x4adsmnsRTLdJ.png"/></div></a></figure><p id="dd90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们正在创建图书销售服务。作者可以出售他们的书，而顾客可以购买。</p><p id="6c3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们定义主要的业务实体。<code class="du jm jn jo jp b">Book</code>本身。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="9460" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而<code class="du jm jn jo jp b">BookSale</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="9995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个<code class="du jm jn jo jp b">Book</code>实例有名称、作者、创建日期、最后更新日期、价格和所有销售清单。</p><blockquote class="js jt ju"><p id="b8b4" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><em class="hi">为了简单起见，我们假设书籍只有一个作者，所有的价格都有相同的货币。</em></p></blockquote><p id="3e03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，最小畴模型是接地的。是时候实现业务需求了。</p><h1 id="015b" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">1.每个图书销售商都应该登记</h1><p id="6a72" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这就是我们系统的全部想法。</p><p id="aa68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是第一次尝试。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="1547" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您经常使用<a class="ae jd" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring </a>，您可能会多次看到类似的代码片段。我们在这里建立的设计架构可以被描述为<a class="ae jd" href="https://martinfowler.com/bliki/AnemicDomainModel.html" rel="noopener ugc nofollow" target="_blank">贫血领域模型</a>。</p><p id="a17f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着我们将绝大多数业务逻辑放在服务层内部。而实体只是作为简单的数据结构，带有getters和setters。</p><p id="b331" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多作者将这种风格归类为反模式。但这是为什么呢？这种方法似乎很自然，不是吗？此外，在我们的案例中，业务逻辑并不复杂。那么，在这样一个原始的例子中没有问题。至少目前是这样。</p><h1 id="fdb9" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">2.每卖出100本书，就应该通知作者</h1><p id="2faa" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们想让作者知道他们的书正在销售。</p><p id="b479" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何实现这个特性？好吧，天真的方法是将功能放在<code class="du jm jn jo jp b">sellBook</code>方法中。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="dcf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先出现的是在调用<code class="du jm jn jo jp b">emailService.send</code>方法时，仍在处理<a class="ae jd" href="https://javarevisited.blogspot.com/2021/08/spring-transactional-example-how-to.html" rel="noopener ugc nofollow" target="_blank">事务</a>。首先，这是一种性能损失。第二，事务最终可能会回滚。在这种情况下，我们不想发送任何电子邮件。</p><p id="e3d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过应用<a class="ae jd" href="https://www.baeldung.com/spring-programmatic-transaction-management" rel="noopener ugc nofollow" target="_blank">程序化事务</a>来解决这个问题。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="ffe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是还有一个问题。这种方法打破了<a class="ae jd" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则(SRP) </a>和<a class="ae jd" href="https://javarevisited.blogspot.com/2015/07/strategy-design-pattern-and-open-closed-principle-java-example.html" rel="noopener ugc nofollow" target="_blank">开闭原则(OCP) </a>。更好的选择是<a class="ae jd" href="https://javarevisited.blogspot.com/2011/11/decorator-design-pattern-java-example.html" rel="noopener ugc nofollow" target="_blank">装饰图案</a>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="763b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jm jn jo jp b">EmailNotifierBookSaleService</code>注入<code class="du jm jn jo jp b">BookSaleService</code>接口。在生产环境中，这个将是<code class="du jm jn jo jp b">BookSaleServiceImpl</code>实现(限定符注释<a class="ae jd" href="https://www.baeldung.com/spring-qualifier-annotation" rel="noopener ugc nofollow" target="_blank">指向那个)。但是在测试环境中，我们可以使用stub或mock。</a></p><p id="5060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那看起来确实好多了。该功能由两个服务分担。它们中的每一个都可以单独测试。</p><h1 id="0bcb" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">3.每本书的更新都应该存档</h1><p id="9489" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">分析师已经决定，每一个可能的图书更新(包括图书销售)都应该存档。这里是<code class="du jm jn jo jp b">BookArchive</code>实体。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="0b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何跟踪图书销售？嗯，我们可以直接将功能添加到<code class="du jm jn jo jp b">BookSaleServiceImpl</code>中，但是我们已经指出这是一种糟糕的方式。所以，另一个装修工进来了。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="8ab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应该指出一些重要的细节。<br/><code class="du jm jn jo jp b">sellBook</code>方法用<code class="du jm jn jo jp b">@Transactional</code>包裹。原因是归档记录应该在与<code class="du jm jn jo jp b">BookSale</code>本身相同的事务中创建。如果主操作失败，我们不想存储任何档案。</p><blockquote class="js jt ju"><p id="537d" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><em class="hi">在执行过程中，</em> <code class="du jm jn jo jp b"><em class="hi">bookRepository.findById(id)</em></code> <em class="hi">方法被调用两次。但是因为有一个事务，</em><a class="ae jd" rel="noopener" href="/javarevisited/top-5-hibernate-online-training-courses-for-beginners-and-advance-java-programmers-469460596b2b?source=---------9------------------"><em class="hi">Hibernate</em></a><em class="hi">在第二次调用时从持久性上下文返回</em> <a class="ae jd" href="https://vladmihalcea.com/jpa-hibernate-first-level-cache/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">缓存的实例</em> </a> <em class="hi">。因此，没有额外的数据库往返。</em></p></blockquote><p id="7f17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二点是<code class="du jm jn jo jp b">@ActualBookSaleServiceQualifier</code>。<code class="du jm jn jo jp b">EmailNotifierBookSaleService</code>不启动任何事务。这意味着<code class="du jm jn jo jp b">origin</code>必须是<code class="du jm jn jo jp b">BookSaleServiceImpl</code>类型。因此，我们必须编辑<code class="du jm jn jo jp b">EmailNotifierBookSaleService</code>以避免两次注射<code class="du jm jn jo jp b">BookSaleServiceImpl</code>。</p><p id="538b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是当前流程的模式。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/01/top-5-hibernate-and-jpa-courses-for-java-programmers-learn-online.html"><div class="er es lc"><img src="../Images/adaa380c352961def1da69a34a8b8c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-AJxb9TM5wSqH-VZ.png"/></div></a><p class="ld le et er es lf lg bd b be z dx translated">图书销售请求流程</p></figure><p id="5c7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果系统不复杂，这种方法可能就足够了。但是图书销售应用程序可以是一个巨大的企业解决方案。你看，我们才开始发展，但已经有两个装饰。此外，包装的顺序也很重要。这就是为什么我们不得不改变限定词。</p><p id="38e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">似乎有点过于复杂了，不是吗？嗯，这还不是结束。</p><h1 id="36d6" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">4.管理员应该能够更新一本书的名称和描述。应该通过电子邮件通知作者每一次更新</h1><p id="7fc8" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这也很有道理。例如，可能会有错别字。该要求可以分为三个不同的功能:</p><ol class=""><li id="cce1" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">图书信息更新</li><li id="ba1a" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">图书归档</li><li id="7a65" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">通过电子邮件通知</li></ol><p id="6528" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但问题是。如果我们继续遵循和以前一样的方法，将会有带有业务逻辑的主服务和两个额外的装饰器。似曾相识，不是吗？每次新的需求到来时，我们都必须用新的装饰者来包装服务层。</p><p id="8267" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有什么问题？嗯，一些先前实现的功能必须重复。比如图书存档。不管这本书到底发生了什么，都应该创建新的档案记录。因为这是分析师需要的。邮件也是如此。不同的是他们发送的频率。</p><p id="4478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，有什么更好的解决办法呢？这就是领域事件出现的时刻。但首先，我们必须做一些重构。</p><h1 id="2999" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">没有贫血的领域模型</h1><p id="9159" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">到目前为止，我们有什么样的要求？只有他们两个。图书销售请求及其信息更新。让我们稍微重写一下<code class="du jm jn jo jp b">Book</code>实体。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="9192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想关注一下<code class="du jm jn jo jp b">sell</code>和<code class="du jm jn jo jp b">changeInfo</code>的方法。第一个注册新书销售。第二个更新了书的名字和描述。</p><p id="6fd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">似乎到目前为止什么都没有改变。我们只是组合了可以通过setters调用执行的功能。嗯，是真的。但是让我们继续前进。现在让我们重构一下<code class="du jm jn jo jp b">BookSaleServiceImpl</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="270e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码看起来不再像命令列表。商业案例现在是<em class="jv">透明的</em>。此外，<code class="du jm jn jo jp b">Book.sell</code>方法可以在不同的应用服务中重用。但是商业规则保持不变。</p><p id="d1d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新图书信息的服务看起来很熟悉。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><h1 id="492f" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">领域事件介绍</h1><p id="02ce" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">现在让我们跳到图书归档案例。如果每次图书更新都发布一个触发图书归档的事件，会怎么样？嗯，<a class="ae jd" rel="noopener" href="/javarevisited/7000-free-pluralsight-courses-to-build-in-demand-tech-skills-without-leaving-your-house-40edb50a8cf2"> Spring </a>确实有<code class="du jm jn jo jp b">ApplicationEventPublisher</code> bean，允许通过<code class="du jm jn jo jp b"><a class="ae jd" href="https://www.baeldung.com/spring-events" rel="noopener ugc nofollow" target="_blank">@EventListener</a></code>用法发布事件和订阅事件。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="e8dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然它有助于我们分离销售和存档过程，但它也迫使我们不要忘记发布任何图书变化。</p><p id="bf77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以提供<code class="du jm jn jo jp b">ApplicationEventPublisher</code>作为更新方法的代表。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="000c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那更好。但是无论如何，我们必须将这个<code class="du jm jn jo jp b">ApplicationEventPublisher</code>实例注入到每个以某种方式与<code class="du jm jn jo jp b">Book</code>交互的服务中。</p><p id="570e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有没有更好的解决办法？当然可以。拥抱<code class="du jm jn jo jp b"><a class="ae jd" href="https://www.baeldung.com/spring-data-ddd" rel="noopener ugc nofollow" target="_blank">@DomainEvents</a></code>。</p><h1 id="58e4" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">@DomainEvents</h1><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="c938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当客户端调用<code class="du jm jn jo jp b">sell</code>或<code class="du jm jn jo jp b">changeInfo</code>方法时，一个<code class="du jm jn jo jp b">BookUpdated</code>事件被添加到<code class="du jm jn jo jp b">domainEvents</code>列表中。正如你可能猜到的，没有直接出版。那么，事件如何到达事件侦听器呢？当我们调用<code class="du jm jn jo jp b">Repository.save</code>方法<a class="ae jd" rel="noopener" href="/javarevisited/top-15-java-and-spring-framework-courses-from-udemy-best-of-lot-d7b965b62a9f">时，Spring </a>通过寻找<code class="du jm jn jo jp b">@DomainEvents</code>注释来收集事件。然后正在进行清理(<code class="du jm jn jo jp b">@AfterDomainEventPublication</code>)。</p><p id="adb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以简化它。<a class="ae jd" rel="noopener" href="/javarevisited/12-advanced-spring-framework-courses-for-java-programmers-a273f6e4448c"> Spring </a>提供了已经包含所需功能的<code class="du jm jn jo jp b">AbstractAggregateRoot</code>类。这是一个不太冗长的选项。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="ac43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们忘记了电子邮件事件。这可能很容易被称为“T1”或“T2”。但那不会是<em class="jv">面向领域的</em>。你看，发邮件只是一个实现细节。可能有很多其他的选择。登录、向<a class="ae jd" rel="noopener" href="/javarevisited/top-10-apache-kafka-online-training-courses-and-certifications-621f3c13b38c">卡夫卡</a>发送消息、触发作业等。关注业务用例而不是功能行为是很重要的。</p><p id="c796" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，正确的做法是宣布<code class="du jm jn jo jp b">BookSold</code>和<code class="du jm jn jo jp b">BookChangedInfo</code>事件。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><h1 id="806a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">捕捉事件</h1><p id="86ad" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated"><code class="du jm jn jo jp b">@EventListener</code>注释是跟踪Spring事件的一种简单方便的方式。但是有一个警告。我们不仅仅需要捕捉事件。我们希望监听器在事务生命周期的特定时刻被调用。</p><p id="db07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，归档应该在事务提交之前完成。如果主请求或归档本身出现问题，整个事务都必须回滚。</p><p id="25fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，应该在事务提交后立即发送电子邮件。如果请求没有成功进行，没有必要通知任何人。</p><p id="d78f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注释不够强大，无法满足我们的需求。但是不用担心。<code class="du jm jn jo jp b">@TransactionalEventListener</code>来救援了！</p><p id="49a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同之处在于注释提供了<code class="du jm jn jo jp b">phase</code>属性。它声明了事务生命周期中必须调用我们侦听器的时刻。有四种可能的值。</p><ol class=""><li id="4ede" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated"><code class="du jm jn jo jp b">BEFORE_COMMIT</code></li><li id="4566" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><code class="du jm jn jo jp b">AFTER_COMMIT</code> -默认的一个</li><li id="8ee5" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><code class="du jm jn jo jp b">AFTER_ROLLBACK</code></li><li id="d4d3" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><code class="du jm jn jo jp b">AFTER_COMPLETION</code></li></ol><p id="e1c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前三个选项不言自明。<code class="du jm jn jo jp b">AFTER_COMPLETION</code>是<code class="du jm jn jo jp b">AFTER_ROLLBACK</code>和<code class="du jm jn jo jp b">AFTER_COMMIT</code>的组合。</p><p id="0231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，这就是图书存档的实现方式。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><blockquote class="js jt ju"><p id="2909" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><code class="du jm jn jo jp b"><em class="hi">BookArchive.createNew</em></code> <em class="hi">只是封装了之前已经描述过的创建新的</em> <code class="du jm jn jo jp b"><em class="hi">BookArchive</em></code> <em class="hi">实例的逻辑。</em></p></blockquote><p id="1d9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看到了吗？小菜一碟！捕获<code class="du jm jn jo jp b">BookChangedInfo</code>和<code class="du jm jn jo jp b">BookSold</code>是相似的。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><blockquote class="js jt ju"><p id="3349" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><em class="hi">关于</em> <code class="du jm jn jo jp b"><em class="hi">@TransactionalEventListener</em></code> <em class="hi">还有一个重要的细节。有时您需要在</em> <code class="du jm jn jo jp b"><em class="hi">AFTER_COMMIT</em></code> <em class="hi">阶段调用新事务中的命令。如果是这样，请确保您将</em> <code class="du jm jn jo jp b"><a class="ae jd" href="https://www.baeldung.com/spring-transactional-propagation-isolation" rel="noopener ugc nofollow" target="_blank"><em class="hi">@Transactional(propagation = REQUIRES_NEW)</em></a></code>也设为<em class="hi">。</em> <code class="du jm jn jo jp b"><em class="hi">REQUIRES_NEW</em></code> <em class="hi">参数至关重要。因为以前的事务资源可能还没有被清除。所以，我们必须确保春天是一个新的开始。</em></p></blockquote><p id="c8b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以摆脱那些装修工了。这是第一次设置和最终架构的对比。</p><h2 id="7b7d" class="lv ka hi bd kb lw lx ly kf lz ma mb kj iq mc md kn iu me mf kr iy mg mh kv mi bi translated">第一次尝试</h2><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://www.java67.com/2019/09/top-5-courses-to-learn-system-design.html"><div class="er es lc"><img src="../Images/3446c4a119286bf821b9d67efd133ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*67vmAFyCOJPId-XE.png"/></div></a></figure><h2 id="12c4" class="lv ka hi bd kb lw lx ly kf lz ma mb kj iq mc md kn iu me mf kr iy mg mh kv mi bi translated">最终的建筑</h2><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2019/03/5-courses-programmers-can-join-to-learn.html"><div class="er es lc"><img src="../Images/7cc26277a813b6f318240baca501d9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-oPXOwDrvoaFV1pX.png"/></div></a></figure><p id="1e94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一种方法将所有业务逻辑放在服务层中，而域类充当简单的数据结构。这种模式称为<a class="ae jd" href="https://martinfowler.com/eaaCatalog/transactionScript.html" rel="noopener ugc nofollow" target="_blank">事务脚本</a>。如果您的系统很小并且不复杂，那么跨这种模式设计架构是很好的。但是当它成长的时候，就变得难以维持了。</p><blockquote class="js jt ju"><p id="9351" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><em class="hi">顺便说一下，你可能不需要</em> <a class="ae jd" rel="noopener" href="/javarevisited/5-best-spring-data-jpa-courses-for-java-developers-45e6438be3c9"> <em class="hi">春天数据</em> </a> <em class="hi">和</em> <a class="ae jd" rel="noopener" href="/javarevisited/top-5-books-to-learn-hibernate-for-java-developers-b2cb4b16ccd6?source=---------14------------------"> <em class="hi">冬眠</em> </a> <em class="hi">，如果你应用了事务脚本模式。由于所有的业务规则都绑定到服务上，Hibernate会带来开销，没有那么多好处。相反，你可以试着使用</em><a class="ae jd" href="https://jdbi.org/" rel="noopener ugc nofollow" target="_blank"><em class="hi">JDBI</em></a><em class="hi"/><a class="ae jd" href="https://www.jooq.org/" rel="noopener ugc nofollow" target="_blank"><em class="hi">JOOQ</em></a><em class="hi">甚至普通的</em><a class="ae jd" rel="noopener" href="/javarevisited/top-5-courses-to-learn-jdbc-and-database-connectivity-for-java-developers-free-and-best-of-lot-7945156fcc3?source=extreme_sidebar---------0-2----------------------"><em class="hi">JDBC</em></a><em class="hi">。</em></p></blockquote><p id="6ada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的架构把它颠倒过来。领域实体封装业务逻辑，服务充当瘦包装器(富领域模型)。无论谁与<code class="du jm jn jo jp b">Book</code>实体交互，业务规则都保持不变。所有附加功能都是由域事件驱动的。这让我们可以无限扩展系统。领域事件可以触发各种业务操作。将消息放入队列，执行审计操作，通知用户，应用<a class="ae jd" href="https://martinfowler.com/bliki/CQRS.html" rel="noopener ugc nofollow" target="_blank"> CQRS </a>模式，等等。</p><h1 id="e99d" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="39e8" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在我看来，Hibernate结合<a class="ae jd" href="https://javarevisited.blogspot.com/2021/08/top-5-spring-data-jpa-courses-for-java.html" rel="noopener ugc nofollow" target="_blank"> Spring Data </a>是为了和域事件一起使用。好处是值得的。我很好奇你是如何在你的项目中应用持久性的？您喜欢贫血的还是丰富的领域模型？请在下面留下你的评论。感谢阅读！</p><h1 id="745f" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">资源</h1><ol class=""><li id="609b" class="lh li hi ih b ii kx im ky iq mj iu mk iy ml jc lm ln lo lp bi translated"><a class="ae jd" href="https://martinfowler.com/eaaDev/DomainEvent.html" rel="noopener ugc nofollow" target="_blank">域事件</a></li><li id="217b" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Domain-driven_design" rel="noopener ugc nofollow" target="_blank">领域驱动设计</a></li><li id="3646" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://martinfowler.com/bliki/AnemicDomainModel.html" rel="noopener ugc nofollow" target="_blank">贫血域模型</a></li><li id="46c3" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://www.baeldung.com/spring-programmatic-transaction-management" rel="noopener ugc nofollow" target="_blank">程序化交易</a></li><li id="8101" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a></li><li id="a8b8" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle#:~:text=In%20object%2Doriented%20programming%2C%20the,without%20modifying%20its%20source%20code." rel="noopener ugc nofollow" target="_blank">开闭原理(OCP) </a></li><li id="f9a0" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener ugc nofollow" target="_blank">装饰图案</a></li><li id="3081" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://www.baeldung.com/spring-qualifier-annotation" rel="noopener ugc nofollow" target="_blank">弹簧限定词注释</a></li><li id="b43e" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://javarevisited.blogspot.com/2017/03/difference-between-first-and-second-level-cache-in-Hibernate.html" rel="noopener ugc nofollow" target="_blank">休眠一级缓存</a></li><li id="e97e" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://www.baeldung.com/spring-events" rel="noopener ugc nofollow" target="_blank">春季事件监听器</a></li><li id="825d" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://www.baeldung.com/spring-data-ddd" rel="noopener ugc nofollow" target="_blank">春域事件</a></li><li id="d875" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://www.baeldung.com/spring-transactional-propagation-isolation" rel="noopener ugc nofollow" target="_blank"> Spring事务传播和隔离</a></li><li id="a5ee" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://martinfowler.com/eaaCatalog/transactionScript.html" rel="noopener ugc nofollow" target="_blank">交易脚本模式</a></li><li id="ae17" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://jdbi.org/" rel="noopener ugc nofollow" target="_blank"> JDBI </a></li><li id="eb43" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://www.jooq.org/" rel="noopener ugc nofollow" target="_blank"> JOOQ </a></li><li id="f054" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://martinfowler.com/bliki/CQRS.html" rel="noopener ugc nofollow" target="_blank"> CQRS模式</a></li></ol></div></div>    
</body>
</html>