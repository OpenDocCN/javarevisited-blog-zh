<html>
<head>
<title>How To Initialize A Singleton With Double-Checked Locking in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Java中初始化带有双重检查锁定的单例</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/how-to-initialize-a-singleton-with-double-checked-locking-in-java-dfa641e1d63b?source=collection_archive---------3-----------------------#2021-04-20">https://medium.com/javarevisited/how-to-initialize-a-singleton-with-double-checked-locking-in-java-dfa641e1d63b?source=collection_archive---------3-----------------------#2021-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/099dcf0774d650d40fbc2e159e3c966a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kaegkAWir4-dO-ZX"/></div></div><p class="iq ir et er es is it bd b be z dx translated">Emile Perron 在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6b90" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们都在努力理解Java 中的<a class="ae iu" rel="noopener" href="/javarevisited/8-best-multithreading-and-concurrency-courses-for-experienced-java-developers-8acfd3b25094">并发。即使您的代码在您的系统上看起来运行良好，但并发性错误是不请自来的，代码仍然可能在任何时候被破坏和失败。</a></p><p id="b202" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我们将看看在Java中初始化单例类的方法之一。单例应该由多个线程使用，并且只需创建一个实例。</p><p id="126b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们先来看看当它被一个单独的线程使用时是如何完成的。然后，我们可以找到问题并纠正它们，以便它可以在多线程环境中工作。</p><h2 id="9fc1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">在单线程环境中初始化单例</h2><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="ac6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这对于单线程应用程序来说非常好。但是，如果两个或更多的线程同时进入if块呢？在这种情况下，它们肯定会成功，因为“实例”尚未初始化。这导致了Singleton类的多个对象的创建。</p><p id="9e34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决此类并发问题<a class="ae iu" href="https://www.java67.com/2012/12/producer-consumer-problem-with-wait-and-notify-example.html" rel="noopener ugc nofollow" target="_blank">的最常见方法之一是使用synchronized关键字。如果任何代码被包装在一个同步的块中或者使用一个</a><a class="ae iu" href="https://www.java67.com/2013/01/difference-between-synchronized-block-vs-method-java-example.html" rel="noopener ugc nofollow" target="_blank">同步的方法</a>，你可以限制只能访问一个线程。其他线程将不得不等待，直到当前线程退出同步块。</p><h2 id="72b3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">创建对象时使用同步</h2><p id="af8a" class="pw-post-body-paragraph iv iw hi ix b iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js hb bi translated">那么，如何将<a class="ae iu" href="https://javarevisited.blogspot.com/2020/04/difference-between-atomic-volatile-and-synchronized-in-java-multi-threading.html" rel="noopener ugc nofollow" target="_blank"> synchronized关键字</a>应用到上面的代码中，以便当多个线程试图创建实例时，只允许一个线程访问if块内部。</p><p id="1913" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中一种方法是让整个方法同步。</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="4ee0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很好，但是从性能的角度来看，这是一个大禁忌。如果正确地创建了实例，我们实际上不需要限制对它的访问，因为If条件失败，实例被返回。</p><p id="3c45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的解决方案是仅在创建实例时限制访问。您可能会考虑这样做:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="0a59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅仅在创建对象时锁定类是行不通的。假设线程A和B都进入了if块，假设线程A获得了一个锁并创建了一个新对象。退出后，线程B获取一个锁并创建另一个对象。</p><p id="6d2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是<a class="ae iu" href="https://javarevisited.blogspot.com/2014/05/double-checked-locking-on-singleton-in-java.html#axzz6j8KhisSX" rel="noopener ugc nofollow" target="_blank">双重检查锁</a>发挥作用的地方。这个错误可以通过在synchronized块中放置另一个if条件来避免。因此，即使两个线程访问第一个if块，一个线程获得锁并创建对象，另一个线程仍然会检查对象是否被创建。</p><p id="ef6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是双重检查锁定的实现方式:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="7f23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们的代码最终的样子。</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="e5eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看起来很好，不是吗？但是等等。这段代码还有一个bug。</p><p id="c4b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设一个线程创建了一个实例，另一个线程发现这个实例不为空并返回它。但是为什么这会产生问题呢？这与<a class="ae iu" rel="noopener" href="/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686?source=---------8------------------"> JVM </a>允许发布部分初始化的对象这一事实有关。线程A可能会为实例对象分配一些内存空间，而不会完全初始化它。线程B可能会看到实例不为空，并返回部分构造的实例，这可能会导致微妙的错误。解决方案是让实例变得易变。</p><p id="cd1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是如何用<a class="ae iu" href="https://www.java67.com/2015/09/thread-safe-singleton-in-java-using-double-checked-locking-pattern.html" rel="noopener ugc nofollow" target="_blank">双重检查锁定</a>初始化单例:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure></div></div>    
</body>
</html>