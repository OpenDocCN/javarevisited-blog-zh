# Hibernate 不是面向对象的，不要强迫它

> 原文：<https://medium.com/javarevisited/hibernate-isnt-object-oriented-don-t-try-to-make-it-oop-631c53253099?source=collection_archive---------3----------------------->

![](img/5f41ddb327bf97684f756e23550d53c1.png)

我们使用 Hibernate/JPA。我喜欢。但是我完全理解那些像这个家伙一样极度讨厌它的人。还有其他人，比如[弗拉德·米哈尔恰](https://vladmihalcea.com/)，他在 Hibernate 方面非常出色，但老实说，只是看了他的一些帖子就让我感到头疼……我们通常选择 Hibernate 来避免痛苦……

我认为 Hibernate 有几个核心问题，它们都可以归结为人们对它过于“聪明”。

# 您必须了解并查看 SQL

如果您选择 Hibernate 来避免 SQL，那么您就犯了一个大错误。这将是你的性能和可靠性死亡的点。您必须调试 SQL，并检查/验证 hibernate 生成的查询是否有意义。

Hibernate 是一个有漏洞的抽象。这是故意的。Hibernate 希望您了解 SQL，这样您就可以充分利用它的功能和性能。这很糟糕，但是完全抽象的选择更糟糕。

# 你不能使用正确的面向对象程序设计

在我们当前的项目中，一位非常有才华的工程师说服我们使用一种非常面向对象的继承架构，在表中的各种层次结构之间使用复杂的连接语义。我们仍在清理该架构的混乱，并承受连接带来的性能损失。

SQL 不是 OOP。SQL 不擅长连接，使用对象范例可以有效地强制进行大量连接。

更好的方法是提供一个巨大的表和一个包含所有字段的巨大对象。是的，这很难看，但是查询会简单而快速。维护会非常容易。我们仍然可以使用适当的数据传输对象和服务层将所有内容封装到其他层。

# 关系是地狱

在 hibernate 中，让关系在所有情况下都能正常执行和工作是最困难的事情之一。尤其是当你的对象图开始变深的时候。如果你有一个深度对象图，我建议你完全重新考虑它。

一个常见的错误是使用懒惰的关系来解决性能问题。可惜，这恰恰隐藏了核心问题。更好的解决方案是尽可能统一对象，并通过简化模式来减少实体的数量。

# 灵活使用模式

这与我先前的观点有关。减少关系意味着改变模式以匹配简化的对象图。是的，在 Hibernate 中，您可以将任何模式映射到几乎任何对象图…

不要。

有这么多边缘案例，不值得。

使模式和对象图尽可能简单。用整体式对象构建宽桌子。是的，我知道这很糟糕。这也会让你在以后的道路上免于麻烦。

# 尝试不变性

在我们的数据库中，我们尽可能避免实体突变。实体被创建和删除。很少修改。这解决了人们在事务冲突等方面的许多问题。这可能并不适用于所有情况，但通常情况下，它可以相当好地工作，并解决许多并发问题。

# 使用龙目语或科特林语

一些人经历了一些龙目岛和[冬眠](/javarevisited/top-5-books-to-learn-hibernate-for-java-developers-b2cb4b16ccd6?source=---------14------------------)的问题，所以小心行事。我在一个项目中使用它(不是全部),它在压力下似乎工作得很好。冗长的节省是美妙的。dto 和实体简洁易读。这是一个很好的工具。

我还没有在我的 Hibernate 项目中使用过 [Kotlin](/javarevisited/top-5-courses-to-learn-kotlin-in-2020-dfc3fa7706d8) ，但是我的朋友们使用过。移除 setter/getter 样板文件(正如我们在 Java 中看到的 record 特性)的价值是巨大的。

# 那么为什么要使用 Hibernate 呢？

此时，你可能会说很多开发人员都在说的话:为什么不直接使用 [SQL](/hackernoon/top-5-sql-and-database-courses-to-learn-online-48424533ac61) 或者通过像 [jooq](https://www.jooq.org) 这样的抽象。

这些都是正确的，但是 [Hibernate](/javarevisited/8-best-spring-and-hibernate-training-courses-for-java-developers-acf09aa0e244) 仍然带来了很多好处:

*   它可能不是我们绘图板上的完美 OOP 模型，但它仍然是一个具有方法和功能的对象。
*   很容易将其与缓存解决方案集成，并通过注释(事务、隔离等)定义复杂的行为。).
*   使用 Hibernate 时重用代码比手工编写 SQL 更容易。
*   它是数据库中立的。例如，我们在 hsql 上调试，但在 MySQL 上运行生产。
*   最后，网上有很多帮助。当你遇到问题时，通常很容易找到解决办法。

如果你愿意，选择低级 SQL 路线也是可以的。这不是我大多数项目的发展方向。但是如果你把 Hibernate 和其他 ORM 工具相比，它还是很棒的。

# TL；速度三角形定位法(dead reckoning)

我认为 Hibernate 很棒，尽管它不是万灵药。您需要将您对 Hibernate 的期望与现实保持一致。不要期待面向对象。不要指望浏览 SQL。为问题做好准备，和 Hibernate 一起工作会很愉快。