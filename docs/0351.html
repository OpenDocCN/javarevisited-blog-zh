<html>
<head>
<title>Compiler-generated classes, methods and fields in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中编译器生成的类、方法和字段</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/compiler-generated-classes-methods-and-fields-in-java-343dde2cce61?source=collection_archive---------0-----------------------#2020-03-19">https://medium.com/javarevisited/compiler-generated-classes-methods-and-fields-in-java-343dde2cce61?source=collection_archive---------0-----------------------#2020-03-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0d07" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">看看编译器在什么情况下可以生成什么。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ca0a7fc66b63c4d2550c7f50291e0533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dXfqvjwEHtCF8a14"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/photos/tdsG7cUNrOo" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h1 id="e905" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="38d5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">当我们用Java编写程序时，我们创建一些类、方法、字段，并将所有这些放入我们的源代码— <code class="du lc ld le lf b">.java</code>文件中。这些文件用<code class="du lc ld le lf b">javac </code> (Java编译器)编译成<code class="du lc ld le lf b">.class</code>文件后，我们得到了一堆Java字节码。<br/>事实证明，不仅我们在源代码中创建类、方法和字段，编译器本身也可以在需要时创建它们。<br/>在本文中，我们将尝试进入编译器生成的主题，了解什么是合成和桥接、访问标志，从官方文档中了解一些新的东西，也许还有更多。让我们开始吧。</p><h1 id="cfda" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">综合定义</h1><p id="29cc" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">类、方法和字段可以是合成的，这意味着它不会出现在源代码中(因此是由编译器生成的)。<br/>参考<a class="ae jn" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.8" rel="noopener ugc nofollow" target="_blank">参考</a></p><p id="618d" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">基本上就这么简单。如果某些东西是由编译器生成的(不在源代码中)，那么编译器必须将这些生成的东西标记为合成的。</p><blockquote class="ll lm ln"><p id="6d23" class="kg kh lo ki b kj lg ij kl km lh im ko lp li kr ks lq lj kv kw lr lk kz la lb hb bi translated"><strong class="ki hj">注意</strong>:这种规则也有例外，比如默认构造函数——它不会被标记为合成的。在<a class="ae jn" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.8" rel="noopener ugc nofollow" target="_blank">规范</a>中可以找到例外的完整列表。</p></blockquote><h2 id="751d" class="ls jp hi bd jq lt lu lv ju lw lx ly jy kp lz ma ka kt mb mc kc kx md me ke mf bi translated">嵌套类</h2><p id="dcf0" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">编译器使用synthetic的经典例子是嵌套类(包含对父类的引用)。首先我们来看看内部(静态)类和生成的字节码。<br/>我们的例子将是:</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="cd9a" class="ls jp hi lf b fi mk ml l mm mn">class Main {</span><span id="55d9" class="ls jp hi lf b fi mo ml l mm mn">    static Child {</span><span id="4916" class="ls jp hi lf b fi mo ml l mm mn">    }<br/>}</span></pre><p id="932e" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">接下来我们用<code class="du lc ld le lf b">javac Main.java<br/></code>进行编译，会产生两个文件:<code class="du lc ld le lf b">Main.class</code>和<code class="du lc ld le lf b">Main$Child.class</code>。<br/>为了查看生成的代码，我们将使用<code class="du lc ld le lf b">javap</code> : <code class="du lc ld le lf b">javap -v Main\$Child.class</code></p><p id="6c72" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">生成结果的一部分将是:</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="2e30" class="ls jp hi lf b fi mk ml l mm mn">{<br/>  Main$Child();<br/>    descriptor: ()V<br/>    flags:<br/>    Code:<br/>      stack=1, locals=1, args_size=1<br/>         0: aload_0<br/>         1: invokespecial #1   // Method java/lang/Object."&lt;init&gt;":()V<br/>         4: return</span></pre><p id="1cfb" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">这里我们看到的是用默认构造函数(<code class="du lc ld le lf b">&lt;init&gt;</code>)声明的类。不会。任何对主类的引用都由子类保存(因为它是静态的)。</p><p id="ba91" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">如果我们移除静态修改器并重复该过程，我们将会看到:</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="07cf" class="ls jp hi lf b fi mk ml l mm mn">class Main$Child<br/>...<br/>{<br/>  final Main this$0;<br/>    descriptor: LMain;<br/>    flags: ACC_FINAL, ACC_SYNTHETIC</span><span id="b2ca" class="ls jp hi lf b fi mo ml l mm mn">  Main$Child(Main);<br/>    descriptor: (LMain;)V<br/>    flags:<br/>    Code:<br/>      stack=2, locals=2, args_size=2<br/>         0: aload_0<br/>         1: aload_1<br/>         2: putfield      #1     // Field this$0:LMain;<br/>         5: aload_0<br/>         6: invokespecial #2     // Method java/lang/Object."&lt;init&gt;":()V<br/>         9: return</span></pre><p id="7f86" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">正如我们看到的，我们现在有了对父类的<code class="du lc ld le lf b">this$0</code>引用，它在构造函数内部传递。<br/>还要注意那个字段有<code class="du lc ld le lf b">ACC_SYNTHETIC </code>标志，这表明这个字段是合成的——是由编译器生成的。</p><p id="4e8e" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">这种对父类的引用不是为了以防万一而添加的，它在嵌套类想要访问父类的实例方法和字段(包括私有方法和字段)的情况下很有用。</p><p id="adad" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">例如:</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="f18b" class="ls jp hi lf b fi mk ml l mm mn">class Main {</span><span id="ec90" class="ls jp hi lf b fi mo ml l mm mn">    private void foo() {}</span><span id="ed79" class="ls jp hi lf b fi mo ml l mm mn">    class Child {<br/>    <br/>        private void bar() {<br/>            foo();<br/>        }<br/>    }<br/>}</span></pre><p id="1b1a" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">这里我们将使用带有<code class="du lc ld le lf b"> -p</code>标志的<code class="du lc ld le lf b">javap </code>来查看私有成员:</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="f35a" class="ls jp hi lf b fi mk ml l mm mn">class Main$Child<br/>...<br/>{<br/>  final Main this$0;<br/>    descriptor: LMain;<br/>    flags: ACC_FINAL, ACC_SYNTHETIC</span><span id="0d4e" class="ls jp hi lf b fi mo ml l mm mn">  Main$Child(Main);<br/>    descriptor: (LMain;)V<br/>    flags:<br/>    Code:<br/>      stack=2, locals=2, args_size=2<br/>         0: aload_0<br/>         1: aload_1<br/>         2: putfield      #1     // Field this$0:LMain;<br/>         5: aload_0<br/>         6: invokespecial #2     // Method java/lang/Object."&lt;init&gt;":()V<br/>         9: return<br/>      LineNumberTable:<br/>        line 4: 0</span><span id="6056" class="ls jp hi lf b fi mo ml l mm mn">  private void bar();<br/>    descriptor: ()V<br/>    flags: ACC_PRIVATE<br/>    Code:<br/>      stack=1, locals=1, args_size=1<br/>         0: aload_0<br/>         1: getfield      #1          // Field this$0:LMain;<br/>         4: invokestatic  #3          // Method Main.access$000:(LMain;)V<br/>         7: return</span></pre><p id="66a0" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">在这里，我们不仅看到合成字段，而且我们的私有方法<code class="du lc ld le lf b">bar </code>也在引用父方法来调用方法<code class="du lc ld le lf b">acess$000</code>。但这是什么？让我们来看看Main类的字节码:</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="6614" class="ls jp hi lf b fi mk ml l mm mn">class Main<br/>...<br/>{<br/>  Main();<br/>    descriptor: ()V<br/>    flags:<br/>    Code:<br/>      stack=1, locals=1, args_size=1<br/>         0: aload_0<br/>         1: invokespecial #2      // Method java/lang/Object."&lt;init&gt;":()V<br/>         4: return<br/>      LineNumberTable:<br/>        line 1: 0</span><span id="1442" class="ls jp hi lf b fi mo ml l mm mn">  private void foo();<br/>    descriptor: ()V<br/>    flags: ACC_PRIVATE<br/>    Code:<br/>      stack=0, locals=1, args_size=1<br/>         0: return<br/>      LineNumberTable:<br/>        line 2: 0</span><span id="00fd" class="ls jp hi lf b fi mo ml l mm mn">  static void access$000(Main);<br/>    descriptor: (LMain;)V<br/>    flags: ACC_STATIC, ACC_SYNTHETIC<br/>    Code:<br/>      stack=1, locals=1, args_size=1<br/>         0: aload_0<br/>         1: invokespecial #1                  // Method foo:()V<br/>         4: return</span></pre><p id="877f" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">这里我们看到不仅有私有的foo方法，还有静态方法<code class="du lc ld le lf b">access$000</code>，它也有<code class="du lc ld le lf b">ACC_SYNTHETIC </code>标志——所以它也是合成的。它是由编译器为子类生成的，以便能够访问私有方法foo。</p><h2 id="f5b5" class="ls jp hi bd jq lt lu lv ju lw lx ly jy kp lz ma ka kt mb mc kc kx md me ke mf bi">$</h2><p id="5551" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">特别需要注意生成代码中<code class="du lc ld le lf b">$</code>符号的用法。它被大量使用，尤其是对于由编译器生成的东西。因此，不建议在类、方法、字段等中使用<code class="du lc ld le lf b">$</code>符号。java源代码中的名字。</p><h2 id="8ac4" class="ls jp hi bd jq lt lu lv ju lw lx ly jy kp lz ma ka kt mb mc kc kx md me ke mf bi translated">匿名类</h2><p id="9d13" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">下一个例子我们将看看匿名类。我们将尝试创建一些runnable，看看字节码中会有什么。</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="7400" class="ls jp hi lf b fi mk ml l mm mn">class Main {</span><span id="4c50" class="ls jp hi lf b fi mo ml l mm mn">    void foo() {<br/>        new Runnable() {</span><span id="2782" class="ls jp hi lf b fi mo ml l mm mn">            public void run() {}<br/>        };<br/>    }<br/>}</span></pre><p id="8e39" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">我们会看到会有两个<code class="du lc ld le lf b">.class</code>文件:<code class="du lc ld le lf b">Main.class</code>和<code class="du lc ld le lf b">Main$1.class</code>。第二个是为我们的匿名<code class="du lc ld le lf b">Runnable </code>创建的，在里面我们会看到以下内容:</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="2132" class="ls jp hi lf b fi mk ml l mm mn">class Main$1 implements java.lang.Runnable<br/>...<br/>{<br/>  final Main this$0;<br/>    descriptor: LMain;<br/>    flags: ACC_FINAL, ACC_SYNTHETIC</span><span id="4ca9" class="ls jp hi lf b fi mo ml l mm mn">  Main$1(Main);<br/>    descriptor: (LMain;)V<br/>    flags:<br/>    Code:<br/>      stack=2, locals=2, args_size=2<br/>         0: aload_0<br/>         1: aload_1<br/>         2: putfield      #1     // Field this$0:LMain;<br/>         5: aload_0<br/>         6: invokespecial #2     // Method java/lang/Object."&lt;init&gt;":()V<br/>         9: return<br/>      LineNumberTable:<br/>        line 4: 0</span><span id="1201" class="ls jp hi lf b fi mo ml l mm mn">  public void run();<br/>    descriptor: ()V<br/>    flags: ACC_PUBLIC<br/>    Code:<br/>      stack=0, locals=1, args_size=1<br/>         0: return</span></pre><p id="9ef9" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">这里我们看到同样的画面:匿名类在一个合成字段中保持对父类的引用。</p><h2 id="392c" class="ls jp hi bd jq lt lu lv ju lw lx ly jy kp lz ma ka kt mb mc kc kx md me ke mf bi translated">类型擦除和桥接方法</h2><p id="6363" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在Java中使用泛型有一个重要的限制:泛型在运行时不可用。在编译时删除关于泛型的所有信息的过程称为类型擦除。<br/>这意味着如果你在生成的字节码中使用in代码<code class="du lc ld le lf b">List&lt;String&gt;</code>，它将变成没有任何泛型的<code class="du lc ld le lf b">List </code>。应用这一点，让我们想象一下在下面的情况下会发生什么。我们将创建一些类，并使其与相同类型的类具有可比性。</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="f90b" class="ls jp hi lf b fi mk ml l mm mn">class MyInt implements Comparable&lt;MyInt&gt; {</span><span id="978f" class="ls jp hi lf b fi mo ml l mm mn">    public int compareTo(MyInt other) {<br/>        return 0; // TODO: implement<br/>    }<br/>}</span></pre><p id="2ff1" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">如果我们应用类型擦除，这将意味着我们的类将有效地拥有方法<code class="du lc ld le lf b">compareTo(MyInt other)</code>，同时在没有任何类型信息的情况下实现Comparable(这意味着我们正在使用<code class="du lc ld le lf b">Object</code>)。在这种情况下，由于我们没有<code class="du lc ld le lf b">compareTo(Object other)</code>方法，似乎没有什么会起作用。<br/>这里来帮助特殊类型的合成——桥方法。</p><p id="4fa5" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">如果我们反编译我们的<code class="du lc ld le lf b">MyInt.class</code>:</p><pre class="iy iz ja jb fd mg lf mh mi aw mj bi"><span id="1662" class="ls jp hi lf b fi mk ml l mm mn">class MyInt extends java.lang.Object implements java.lang.Comparable&lt;MyInt&gt;<br/>...<br/>{<br/>  MyInt();<br/>    descriptor: ()V<br/>    flags:<br/>    Code:<br/>      stack=1, locals=1, args_size=1<br/>         0: aload_0<br/>         1: invokespecial #1   // Method java/lang/Object."&lt;init&gt;":()V<br/>         4: return<br/>      LineNumberTable:<br/>        line 1: 0</span><span id="8312" class="ls jp hi lf b fi mo ml l mm mn">public int compareTo(MyInt);<br/>    descriptor: (LMyInt;)I<br/>    flags: ACC_PUBLIC<br/>    Code:<br/>      stack=1, locals=2, args_size=2<br/>         0: iconst_0<br/>         1: ireturn<br/>      LineNumberTable:<br/>        line 4: 0</span><span id="c9a4" class="ls jp hi lf b fi mo ml l mm mn">public int compareTo(java.lang.Object);<br/>    descriptor: (Ljava/lang/Object;)I<br/>    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC<br/>    Code:<br/>      stack=2, locals=2, args_size=2<br/>         0: aload_0<br/>         1: aload_1<br/>         2: checkcast     #2      // class MyInt<br/>         5: invokevirtual #3      // Method compareTo:(LMyInt;)I<br/>         8: ireturn</span></pre><p id="99ea" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">我们在这里看到，除了我们的<code class="du lc ld le lf b">compareTo(MyInt)</code>方法之外，我们还有用<code class="du lc ld le lf b">ACC_SYNTHETIC</code>标记的<code class="du lc ld le lf b">compareTo(javalang.Object)</code>方法，这意味着它是合成的。而且它还有<code class="du lc ld le lf b">ACC_BRIDGE </code>旗。<br/>桥接方法所做的是处理类型擦除方法，并在检查提供的值类型后(由<code class="du lc ld le lf b">checkcast</code>)将调用重定向到方法的原始类型版本。</p><h1 id="ae60" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">结论</h1><p id="acd5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">合成和桥接是非常强大的概念，它们允许我们拥有一些功能，如果我们没有它们，拥有它们会有问题。其他语言如Kotlin在某些特性上也依赖于synthetic，尤其是在增加Java兼容性时。例如方法中的默认参数。希望这篇文章对你有用。</p><p id="cc63" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">编码快乐！</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="67e6" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated"><em class="lo">感谢阅读！<br/>如果你喜欢这篇文章，你可以点击</em> <strong class="ki hj"> <em class="lo">来喜欢它👏按钮</em> </strong> <em class="lo">(最多50次！)，也可以</em> <strong class="ki hj"> <em class="lo">分享</em> </strong> <em class="lo">这篇文章来帮助别人。</em></p><p id="5556" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated"><em class="lo">有什么反馈，随时在</em><a class="ae jn" href="https://twitter.com/krossovochkin" rel="noopener ugc nofollow" target="_blank"><em class="lo">Twitter</em></a><em class="lo"/><a class="ae jn" href="https://www.facebook.com/vasya.drobushkov" rel="noopener ugc nofollow" target="_blank"><em class="lo">Facebook</em></a>上联系我</p><div class="mw mx ez fb my mz"><a href="https://twitter.com/krossovochkin" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">瓦西亚·德罗布什科夫</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">Vasya Drobushkov的最新推文(@krossovochkin)。你想看到奇迹吗，孩子？成为…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">twitter.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jh mz"/></div></div></a></div></div></div>    
</body>
</html>