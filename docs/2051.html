<html>
<head>
<title>Spring Kafka: Queues &amp; Pub-Sub Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Kafka:队列和发布订阅实现</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-kafka-queues-pub-sub-implementation-a26d403ffd78?source=collection_archive---------1-----------------------#2022-04-10">https://medium.com/javarevisited/spring-kafka-queues-pub-sub-implementation-a26d403ffd78?source=collection_archive---------1-----------------------#2022-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e168" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">春天卡夫卡入门指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/03/spring-boot-kafka-example-single-and-multiple-consumers.html"><div class="er es ix"><img src="../Images/69ebe307eab2befcf3884649b6299bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CvX_Q_QvP-9G_Wg6"/></div></a><p class="jf jg et er es jh ji bd b be z dx translated">在<a class="ae jj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jj" href="https://unsplash.com/@fin777?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Deb Dowd </a>拍摄的照片</p></figure><h2 id="66a6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">简介</strong></h2><p id="b056" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">在这个快速教程中，我们将从创建最简单的设置开始——仅够生成和使用来自<em class="lb"> Kafka Broker </em>的消息。</p><p id="bd6b" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">然后，我们将看到在这两种方法中消费消息是多么简单，例如<em class="lb">队列</em>和<em class="lb">发布订阅</em>。</p><p id="583e" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">之后，我们将探索一些操作方法、常见问题和核心概念——这对于更复杂的场景可能是必要的。</p><p id="3d1e" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">所以，事不宜迟，现在让我们开始在本地建立<a class="ae jj" rel="noopener" href="/javarevisited/top-10-apache-kafka-online-training-courses-and-certifications-621f3c13b38c">卡夫卡</a>。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="0d4c" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">阿帕奇卡夫卡快速入门</strong></h2><p id="69eb" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">我们可以在这里看到官方指南:<a class="ae jj" href="https://kafka.apache.org/quickstart" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/quickstart</a>。</p><p id="3976" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">然而，为了简明起见，我们可以单独执行下面的步骤(这些步骤足够了):</p><ol class=""><li id="cfda" class="lo lp hi kk b kl lc ko ld jv lq jz lr kd ls la lt lu lv lw bi translated">下载阿帕奇卡夫卡<a class="ae jj" href="https://www.apache.org/dyn/closer.cgi?path=/kafka/3.1.0/kafka_2.13-3.1.0.tgz" rel="noopener ugc nofollow" target="_blank">这里</a></li><li id="fc3b" class="lo lp hi kk b kl lx ko ly jv lz jz ma kd mb la lt lu lv lw bi translated">提取并cd入其中:<br/> 2.1 tar -xzf卡夫卡_ 2.13–3 . 1 . 0 . tgz<br/>2.2 CD卡夫卡_ 2.13–3 . 1 . 0</li><li id="42ab" class="lo lp hi kk b kl lx ko ly jv lz jz ma kd mb la lt lu lv lw bi translated">启动Kafka环境<br/> 3.1 <strong class="kk hj">运行Zookeeper:</strong>bin/Zookeeper-server-start . sh config/Zookeeper . properties<br/>3.2<strong class="kk hj">运行Kafka代理:</strong>bin/Kafka-server-start . sh config/server . properties</li></ol><p id="966a" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">有了这个，Kafka broker现在就可以运行了！我们需要做的下一件事是设置生产者和消费者。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="4eb0" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">在Spring Boot创造生产者和消费者服务</strong></h2><p id="ee15" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">虽然可以使用单个服务来产生和消费事件；然而，为了更有趣，我们将创建两个独立的项目——一个用于<em class="lb">生产者</em>，一个用于<em class="lb">消费者</em>。</p><p id="5300" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">首先，让我们为两个项目在pom.xml上添加这种依赖关系:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="9206" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">此外，对于生产者服务，让我们添加这个依赖关系:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="081d" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">接下来，让我们创建一个简单的<em class="lb">MessageProducerController</em>，它使用主题名“test-topic”向<a class="ae jj" href="https://javarevisited.blogspot.com/2021/12/5-free-courses-to-learn-apache-kafka.html" rel="noopener ugc nofollow" target="_blank"> Kafka Broker </a>发送消息:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="aba1" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">转到消费者服务，为了简单起见，让我们使用相同的“测试主题”在主类上创建一个监听器方法:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="9d78" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">现在我们有了最基本的设置，让我们试着创建一个到/send-message端点的<a class="ae jj" href="https://javarevisited.blogspot.com/2016/10/difference-between-put-and-post-in-restful-web-service.html" rel="noopener ugc nofollow" target="_blank"> POST请求</a>:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="2749" class="jk jl hi mf b fi mj mk l ml mm">curl -X POST http://localhost:8080/send-message \<br/>--header 'Content-Type: application/json' \<br/>--data '{"message": "sample message"}'</span></pre><p id="ab5c" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">如果我们要检查消费者服务的日志，我们可以验证我们确实处理了消息。</p><p id="f244" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">然而，在这一点上，我们仅仅触及了表面——我们还不知道代理如何存储或处理消息。到目前为止，我们刚刚消费了它。</p><p id="e577" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">在深入研究之前，最好先看看实现广为人知的概念有多简单，比如卡夫卡<a class="ae jj" href="https://javarevisited.blogspot.com/2018/04/top-5-apache-kafka-course-to-learn.html" rel="noopener ugc nofollow" target="_blank">中的<em class="lb">队列</em>和<em class="lb">发布订阅</em>。</a></p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="f5a4" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">卡夫卡中的队列和酒馆</strong></h2><p id="9610" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated">从队列开始，假设我们有多个消费者，但是我们只希望每条消息处理一次。然后，我们用相同的值设置消费者的groupIds。</p><p id="ac3c" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">另一方面，对于发布-订阅，如果我们想要处理每个消费者的消息，我们为每个消费者的groupId设置一个惟一的值。</p><p id="3507" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">这两种情况都有一个例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="6640" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">注意<em class="lb"> : </em>在我们当前的设置中，我们还没有为“测试主题”创建配置；因此，如果只有一个分区，但同一个组有两个用户，其中一个用户将会空闲。我们还没有触及分区的概念，所以稍后会详细介绍。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="5793" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">常见问题解答/操作方法/概念</strong></h2><p id="c581" class="pw-post-body-paragraph ki kj hi kk b kl km ij kn ko kp im kq jv kr ks kt jz ku kv kw kd kx ky kz la hb bi translated"><strong class="kk hj"> 1。Kafka Broker如何存储消息？</strong></p><p id="92f0" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated"><strong class="kk hj">简答:</strong>穿越日志。</p><p id="f240" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">Kafka broker使用主题名(以及作为命名约定的分区号)创建一个目录。然后，它在该目录中创建一个日志文件。</p><p id="470e" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">要找到这些日志所在的位置，我们可以检查config/server.properties，然后查找"<em class="lb"> log.dir </em>"属性。</p><p id="67d6" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated"><strong class="kk hj"> 2。消费者如何知道下一步要处理什么消息？</strong></p><p id="cced" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated"><strong class="kk hj">简答:</strong>通过偏移</p><p id="9191" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">使用我们的简单实现，我们可以尝试在每次处理消息时检查偏移量。</p><p id="1016" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">以下是使用终端进行检查的快速方法:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="7e69" class="jk jl hi mf b fi mj mk l ml mm">bin/kafka-run-class.sh kafka.tools.GetOffsetShell — broker-list localhost:9092 — topic test-topic</span></pre><p id="0e30" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated"><strong class="kk hj"> 3。什么是分区？为什么要用？</strong></p><p id="d82f" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">简短回答:一个分区保存日志。用例:可伸缩性(并行)和高可用性(冗余)</p><p id="8e18" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">如前所述，代理通过日志存储事件/消息——这些日志位于特定的分区中。</p><p id="33a6" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">拥有多个分区允许多个用户并行处理消息。</p><p id="3f19" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">为了实现高可用性，如果我们有多个代理实例，那么我们可以相对于代理实例的数量来设置主题的复制——这将导致代理的追随者实例的分区复制。</p><p id="8f20" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated"><strong class="kk hj"> 4。如何将一个主题配置为具有多个分区和复制？</strong></p><p id="0eb2" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">这里有一个<a class="ae jj" href="https://javarevisited.blogspot.com/2022/02/how-to-fix-autowired-no-qualifying-bean.html" rel="noopener ugc nofollow" target="_blank">样品豆</a>。其中参数分别表示主题名称、分区数量和复制数量。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="ef21" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated"><strong class="kk hj"> 5。如何发送/产生自定义事件/消息？</strong></p><p id="2bc5" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">为此，我们需要创建一个生产者配置。以下是使用JsonSerializer.class的大多数用例的示例:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="062c" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated"><strong class="kk hj"> 6。如何接收/消费自定义事件/消息？此外，我们如何处理反序列化错误？在这种失败的情况下，偏移量会发生什么变化？</strong></p><p id="1a97" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">为此，我们需要创建一个消费者配置。下面是一个示例配置，我们在Kafka侦听器容器上添加了一个自定义错误处理程序，同时还将AckMode配置为MANUAL_IMMEDIATE，以便只更新“acknowledge”方法调用的偏移量:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc md l"/></div></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="5479" class="pw-post-body-paragraph ki kj hi kk b kl lc ij kn ko ld im kq jv le ks kt jz lf kv kw kd lg ky kz la hb bi translated">我们做到了！和往常一样，源代码可以在<a class="ae jj" href="https://github.com/emyasa/medium-articles/tree/master/spring-boot-kafka" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>