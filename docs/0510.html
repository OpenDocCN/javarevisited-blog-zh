<html>
<head>
<title>Visitor Design Pattern — I’m happy you are back</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">访问者设计模式——很高兴你回来了</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/glad-to-see-you-are-back-an-article-about-the-visitor-design-pattern-4a2b9843ddba?source=collection_archive---------8-----------------------#2020-06-15">https://medium.com/javarevisited/glad-to-see-you-are-back-an-article-about-the-visitor-design-pattern-4a2b9843ddba?source=collection_archive---------8-----------------------#2020-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fdd7946b6721471aa3e87bea858ff794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9483CumtyyT6Hl3VsxNxOA.jpeg"/></div></div><p class="iq ir et er es is it bd b be z dx translated">敲门的访客</p></figure><p id="01f9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">在做某些单调乏味、困难或我们已经筋疲力尽的任务时；我们常常希望有一个无私的人伸出援助之手，让他们变得更容易。有时在这种情况下，我们会准备接受任何人的帮助，甚至是陌生的访客……</em></p><p id="d76d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">visitor是一种行为设计模式，旨在不改变类的原始实现的情况下，向类中添加或删除功能。它可以帮助利用复杂性，还允许将关注点分开。也是非侵入性的，因为只需调用一个方法，就可以让客户选择是否允许访问者访问并提供支持。</p><p id="0547" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们来看一下UML:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-java-design-pattern-courses-for-developers.html"><div class="er es jt"><img src="../Images/3300239dc5d0d0d3beb34b2870ea3f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/0*B8d3JOsIz3xoPYBA.png"/></div></a></figure><p id="a384" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">原始类中唯一需要的修改是添加一个接受访问者的方法。<br/>该方法将仅由客户端调用，并且访问该类的访问者也将由客户端提供。<a class="ae jy" rel="noopener" href="/javarevisited/7-best-online-courses-to-learn-object-oriented-design-pattern-in-java-749b6399af59">访问者</a>只有一个访问方法，该方法采用了必须访问的类的具体实现。如果你使用Visitable接口作为visit方法中的一个参数是没有错的，但是你将限制访问者只能看到接口中的内容(在某些场合可能是可取的)。</p><p id="e18b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们看一个例子。<br/>这里是<em class="js">visible</em>接口和几个实现:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="be6e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们在上面的代码中看到的，访问者被传递到accept方法的参数中，该参数用于触发访问。</p><p id="0db0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们来看看游客这边</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="8042" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在访问者端，<code class="du kb kc kd ke b">FormulaOnePitOperation </code>的功能可以在不改变任何原始代码的情况下进行修改。此外，在上面的例子中需要注意的另一件事是，由于我们使用接口作为参数，我们可能会被限制为只能使用在它上面定义的东西。</p><p id="6b59" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有时这就足够了，不需要访问具体的类，但是请注意<a class="ae jy" href="https://javarevisited.blogspot.com/2017/07/top-5-books-to-learn-uml-unified-modelling-language-java.html" rel="noopener ugc nofollow" target="_blank"> UML图</a>鼓励使用具体的实现(在我个人看来，我认为没有太大的区别，因为具体类上的方法不能公开)</p><p id="98db" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在最后是客户端类:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="ee0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于客户端没有太多要说的，它只是像往常一样使用类，唯一的区别是现在可以根据需要传递访问者来帮助添加某些任务。我在开始时提到visitor是一种非侵入式模式，我想说的是，如果客户不愿意的话，没有什么可以强制要求他调用Visitor。</p><p id="1213" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种模式的一个小缺点是，accept()和visit()这两种方法在它们的参数中都有硬连线的依赖关系，这使得它们很难进行单元测试。</p><p id="0fbe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有一段时间了。很高兴看到你回来了。</p><p id="482e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">原载于</em><a class="ae jy" href="http://javing.blogspot.com/2014/01/its-been-while-glad-to-see-you-are-back.html" rel="noopener ugc nofollow" target="_blank">http://javing . blogspot . com/2014/01/its-been-while-glad-to-see-you-are-back . html</a></p></div></div>    
</body>
</html>