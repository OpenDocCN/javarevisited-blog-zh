<html>
<head>
<title>Java algorithms: Merge k Sorted Lists (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java算法:合并k排序列表(LeetCode)</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-algorithms-merge-k-sorted-lists-leetcode-84c99000bfd7?source=collection_archive---------0-----------------------#2021-07-24">https://medium.com/javarevisited/java-algorithms-merge-k-sorted-lists-leetcode-84c99000bfd7?source=collection_archive---------0-----------------------#2021-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3f2409130d680ad8ce7f132b36683a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nxpx-XSDa2OpZHRd"/></div></div><p class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="4d88" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">任务描述:</h1><p id="a257" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">给你一个<code class="du kr ks kt ku b">k</code>链表<code class="du kr ks kt ku b">lists</code>的数组，每个链表按升序排序。</p><p id="5cee" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">将所有的链表合并成一个排序后的链表并返回。</p><p id="351f" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated"><strong class="jv hj">例1: </strong></p><pre class="lb lc ld le fd lf ku lg lh aw li bi"><span id="3cfd" class="lj iw hi ku b fi lk ll l lm ln"><strong class="ku hj">Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]<br/><strong class="ku hj">Output:</strong> [1,1,2,3,4,4,5,6]<br/><strong class="ku hj">Explanation:</strong> The linked-lists are:<br/>[<br/>  1-&gt;4-&gt;5,<br/>  1-&gt;3-&gt;4,<br/>  2-&gt;6<br/>]<br/>merging them into one sorted list:<br/>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span></pre><h1 id="204c" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">解决方案:</h1><p id="1c0c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在开始解决这个问题之前，让我们回忆一下链表是什么。</p><figure class="lb lc ld le fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/07/top-10-linked-list-coding-questions-and.html#axzz6fY0boe26"><div class="er es lo"><img src="../Images/e225e752523373a30c91c4925fe1f878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iLj3Xf2Spe7AUryp"/></div></a></figure><p id="c5f2" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated"><a class="ae iu" rel="noopener" href="/javarevisited/top-20-linked-list-coding-problems-from-technical-interviews-90b64d2df093">链表</a>是由通过两个(双链表)指针中的一个(单链表)互相连接的节点组成的数据结构。每个节点通常包含一些值和指向下一个节点的指针。第一个节点称为头，最后一个节点称为尾。Tail作为下一个指针通常为空。</p><p id="770a" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">在这个任务中，我们正在处理<a class="ae iu" href="http://www.java67.com/2016/02/how-to-sort-linkedlist-in-java-example.html" rel="noopener ugc nofollow" target="_blank">排序链表</a>。这意味着每个节点中的所有值都被排序。每个列表中的每个节点的值都小于或等于它所指向的节点的值。为了形象化，这里有一个排序链表的例子。</p><figure class="lb lc ld le fd ij er es paragraph-image"><a href="http://www.java67.com/2016/02/how-to-sort-linkedlist-in-java-example.html"><div class="er es lo"><img src="../Images/d7ca51680bd01a42fe4daf9b1a17625a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vjeT7KEFYCtdF9Bn"/></div></a></figure><p id="0a7d" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">理解了什么是排序链表，我们就可以解决这个问题的更简单的版本。你如何合并两个排序的链表？</p><figure class="lb lc ld le fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/03/how-to-reverse-linked-list-in-java-using-iteration-and-recursion.html#axzz6e8hmwujv"><div class="er es lp"><img src="../Images/f41a1096107e4fa0b8d1f76848976b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Us-jCNE_rognXM91"/></div></a></figure><p id="3a64" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">答案是——非常简单。比较每个列表的标题。选择具有最小值的节点。将它附加到您的答案中，并将指针调整到您从中挑选出一个节点的列表中的下一个节点。这样做，直到其中一个头不等于null。一旦你达到这一点，你可以简单地把剩下的附在你的答案上。</p><figure class="lb lc ld le fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2013/05/find-if-linked-list-contains-loops-cycle-cyclic-circular-check.html#axzz5jI43Qiwi"><div class="er es lq"><img src="../Images/b8ca720408755ad93717a56ef4510105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WGUK-RRQDIxIMRyz"/></div></a></figure><p id="43d1" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">现在我们已经接近解决实际的问题了。从更简单的任务中，我们看到了解决方案的关键——通过调整指针，取值最小的节点并将其附加到答案上。</p><p id="e52e" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">有了一个K个排序列表头的<a class="ae iu" rel="noopener" href="/javarevisited/20-array-coding-problems-and-questions-from-programming-interviews-869b475b9121">数组</a>，我们可以遍历它，每次都选择一个具有最小值的节点。这将解决问题，但时间复杂性是可怕的。</p><p id="a5f5" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">更好的方法是取每个列表的头，并将其添加到优先级队列中。优先级队列是另一个<a class="ae iu" rel="noopener" href="/javarevisited/top-10-free-data-structure-and-algorithms-courses-for-beginners-best-of-lot-ad807cc55f7a?source=grid_home---------0-2-----------------18---ce729948_f262_4982_a7a1_a5058c8fe9fa--">数据结构</a>，它提供在O(1)常数时间内获得最小或最大值。并且在O(log n)时间内添加或删除该值，这对于我们的任务来说已经足够好了。根据存储元素的方式，优先级队列通常被称为二进制堆。我可以在以后的文章中描述它。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a216" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">在第8行中，我们创建了一个“虚拟”节点，作为我们的临时头。它将帮助我们通过调用dummy.next很容易地返回排序链表的真正头部</p><p id="0fe5" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">在第13–15行，我们创建了一个<a class="ae iu" href="https://javarevisited.blogspot.com/2013/10/what-is-priorityqueue-data-structure-java-example-tutorial.html#axzz6f4s58Ml9" rel="noopener ugc nofollow" target="_blank">优先级队列</a>。我们需要对其中的元素进行排序。为此，我们提供了比较器。</p><p id="8484" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">在第17–23行，我们将所有非空的头添加到优先级队列中。</p><p id="2f3e" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">在第25–42行，我们有包含主逻辑的主while循环。我们通过从我们的<a class="ae iu" href="http://www.java67.com/2015/07/how-to-use-priorityqueue-in-java-example.html" rel="noopener ugc nofollow" target="_blank">优先级队列</a>的顶部移除具有最小值的节点来更新当前节点。然后我们通过从当前节点获取下一个节点来更新下一个指针。我们还需要更新prev指针。你可以把prev指针看作是指向我们正在构建的链表的临时尾部的指针。最后但同样重要的是，如果下一个链接不为空，我们必须将其推回优先级队列。</p><figure class="lb lc ld le fd ij er es paragraph-image"><a href="https://www.java67.com/2020/07/how-to-get-first-and-last-element-of-linkedlist-in-java.html"><div class="er es lp"><img src="../Images/93c3244d3a6fa561dd4b5661717b83a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DqDptMHP060vuf_M"/></div></a></figure><p id="3b58" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">在给定的示例1中执行了前面的步骤后，我们将得到如下所示的状态。我故意没有把它弄平。向你展示从初始状态到结束状态的转变</p><figure class="lb lc ld le fd ij er es paragraph-image"><a href="https://www.java67.com/2018/06/data-structure-and-algorithm-interview-questions-programmers.html"><div class="er es lt"><img src="../Images/104540eb1e3355d7d0c867cbcbd2c0d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bn2Y2WD_rScrpXcc"/></div></a></figure><p id="4e0c" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">上面列出的算法给出了下面的结果。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/4e54a48b21c195695af3973f96f6dda9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*RLYu9B5PLmPSQKkNXkWcVg.png"/></div></figure><p id="5d36" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">我们的解决方案的时间复杂度是O(N log K ),其中N -是所有列表中的节点总数，K -是我们拥有的排序链表的数量。</p><p id="d7b1" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">我们的解决方案的空间复杂度是O(N ),其中N -是创建答案的节点总数加上O(K ),其中K -是我们拥有的排序链表的数量。根据大O符号，我们可以省略O(K ),因为就元素数量而言，它可能等于或小于O(N)。</p><p id="5f77" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">我希望这篇文章能帮助你理解隐藏在这个困难任务背后的逻辑。感谢阅读！期待您的反馈。回头见，✌</p><p id="8e84" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">其他<strong class="jv hj">你可能喜欢的数据结构和算法问题</strong></p><div class="lv lw ez fb lx ly"><a rel="noopener follow" target="_blank" href="/javarevisited/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">50大数据结构和算法程序员面试问题</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">准备编程工作面试？这里有50多个数据结构和算法问题，你可以练习…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm io ly"/></div></div></a></div><div class="lv lw ez fb lx ly"><a rel="noopener follow" target="_blank" href="/javarevisited/25-software-design-interview-questions-to-crack-any-programming-and-technical-interviews-4b8237942db0"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">破解任何编程和技术面试的25个软件设计面试问题</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">常见系统设计问题和有用资源的链接</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">medium.com</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm io ly"/></div></div></a></div><div class="lv lw ez fb lx ly"><a rel="noopener follow" target="_blank" href="/javarevisited/top-21-string-programming-interview-questions-for-beginners-and-experienced-developers-56037048de45"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">面向初学者和有经验的开发人员的21个字符串编程面试问题</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">除了数组、二叉树和链表数据结构，字符串是编程工作中的另一个热门话题…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">medium.com</p></div></div><div class="mh l"><div class="mo l mj mk ml mh mm io ly"/></div></div></a></div><p id="d834" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">如果你不是Medium会员，我强烈推荐你加入Medium，阅读来自真实领域的伟大作家的伟大故事。你可以<strong class="jv hj">在这里加入介质</strong><a class="ae iu" rel="noopener" href="/@somasharma_81597/membership"><strong class="jv hj"/></a></p></div></div>    
</body>
</html>