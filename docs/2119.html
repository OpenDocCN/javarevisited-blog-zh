<html>
<head>
<title>Dependency Injection with Factory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/dependency-injection-with-factory-1c24cc54b0d4?source=collection_archive---------1-----------------------#2022-05-18">https://medium.com/javarevisited/dependency-injection-with-factory-1c24cc54b0d4?source=collection_archive---------1-----------------------#2022-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9ac2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个可供考虑的选择</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/32cef23104458d545ea11ceb3d4d2569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sa9mD2dOOOWnRB3o"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4ec3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">简介</strong></p><p id="aa78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Java中，我们有不同的初始化对象的方法。它可以是普通初始化、依赖注入或工厂模式。</p><p id="632d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jt" rel="noopener" href="/javarevisited/10-best-online-courses-to-learn-spring-framework-in-2020-f7f73599c2fd"> Spring框架</a>中，依赖注入是基本的方面，通常用于允许组件的松散耦合，而不需要知道每个组件的依赖关系。</p><p id="1f90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样地，<a class="ae jt" href="https://javarevisited.blogspot.com/2011/12/factory-design-pattern-java-example.html" rel="noopener ugc nofollow" target="_blank">工厂模式</a>也促进了组件的松散耦合，因为它将了解的需求委托给了工厂。</p><p id="e70a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">依赖注入vs工厂模式</strong></p><p id="1220" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">依赖注入和工厂模式的区别在于实例的生命周期管理。</p><p id="9117" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于依赖注入，生命周期管理由框架在代码之外处理。</p><p id="a288" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于工厂模式，生命周期管理由应用程序中的程序员处理。</p><p id="82f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是工厂依赖注入？</strong></p><p id="1e65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于实现仍然是<a class="ae jt" href="https://javarevisited.blogspot.com/2012/12/inversion-of-control-dependency-injection-design-pattern-spring-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">依赖注入</a>和工厂模式的对象创建决策逻辑。</p><p id="9bd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个例子。假设我们有两个类，InstanceDelivery和ScheduledDelivery，它们在创建订单时执行不同的逻辑。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="ef63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">只是依赖注入</strong></p><p id="38e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了刚刚的<a class="ae jt" href="https://www.java67.com/2012/08/spring-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank">依赖注入</a>，它的好处是显而易见的。</p><ul class=""><li id="1fe4" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">首先，使用构造函数注入创建对象很简单。</li><li id="549f" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">其次，对于具有多个实例的类，对象的创建更加透明。例如，ScheduledDelivery类依赖于Scheduler类。</li></ul><p id="3233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，构造函数注入也有缺点。</p><ul class=""><li id="b5f2" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">首先，它会导致一种叫做长参数表的代码味道。在这个例子中，只有两种交付模式(即时和预定)，所以看起来可以接受。但是如果有10种交付方式呢？</li><li id="79f0" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">第二，无论何时引入了额外的交付模式，构造函数签名都容易发生变化。看起来构造函数签名的改变不会影响任何依赖注入的代码。然而，如果你在单元测试中注入一个模仿对象，它们将影响DeliveryService类的单元测试。</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="d9f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">只是工厂模式</strong></p><p id="b69f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于工厂模式，对象的创建不像依赖注入那样简单。</p><ul class=""><li id="fcb2" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">首先，您需要知道每个类的依赖关系，在其中创建一个对象可能会很乏味。</li><li id="02b6" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">其次，DeliveryService类的单元测试更难构建，因为DeliveryFactory不可模仿。</li></ul><p id="d7b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，工厂模式的好处是减少了依赖构造函数注入导致的长参数列表。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="4fdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">依赖注入与工厂</strong></p><p id="8e4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过工厂的依赖注入，它结合了两者的优点，同时消除了缺点。</p><ul class=""><li id="45d4" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">首先，对象的创建是透明的。</li><li id="e5e3" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">第二，长参数表从很多减少到1个。</li><li id="bbc3" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">第三，不太容易改变构造函数签名。</li><li id="5722" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">第四，<a class="ae jt" rel="noopener" href="/javarevisited/top-10-courses-to-learn-eclipse-junit-and-mockito-for-java-developers-4de1e8d62b96">单元测试</a>更容易，因为它是可模仿的。</li></ul><p id="9bd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基础实现仍然是依赖注入，其中DeliveryService和DeliveryFactory使用构造函数注入。DeliveryFactory中的getInstance实现了对象创建决策逻辑来返回所需的对象。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="899a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong></p><p id="dcab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅仅依赖注入或者仅仅工厂模式实现都没有错。工厂的依赖注入增加了另一种选择，使你的代码更加整洁和有组织。当您有两个以上的服务类时，这种技术更合适，并且随着它的发展，这种技术的好处会更大。最终，使用任何适合用例的设计模式都是很重要的。</p><p id="ae5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">短读到此为止。谢谢你的时间</p></div></div>    
</body>
</html>