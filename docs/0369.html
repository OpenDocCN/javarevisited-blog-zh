<html>
<head>
<title>Data Types, Common Algorithms, Time Complexity, and Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据类型、常用算法、时间复杂度和数据结构</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/data-types-common-algorithms-time-complexity-and-data-structures-23a06a68a355?source=collection_archive---------0-----------------------#2020-04-04">https://medium.com/javarevisited/data-types-common-algorithms-time-complexity-and-data-structures-23a06a68a355?source=collection_archive---------0-----------------------#2020-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4f61b1a3ab11da10d8f7c2a9312e1de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywcuKXku5cGSgtNRe6Lz9w.png"/></div></div></figure><ul class=""><li id="b1e3" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">原始数据类型——包括<code class="du ji jj jk jl b">byte</code>、<code class="du ji jj jk jl b">short</code>、<code class="du ji jj jk jl b">int</code>、<code class="du ji jj jk jl b">long</code>、<code class="du ji jj jk jl b">float</code>、<code class="du ji jj jk jl b">double</code>、<code class="du ji jj jk jl b">boolean</code>和<code class="du ji jj jk jl b">char</code></li><li id="9aac" class="iq ir hi is b it jm iv jn ix jo iz jp jb jq jd je jf jg jh bi translated">复合(非基元)数据类型——例如<code class="du ji jj jk jl b">String</code>、<code class="du ji jj jk jl b">arrays</code>和<code class="du ji jj jk jl b">classes</code>(当您将基元组合成包含或合并它们的单个“实体”时)。</li></ul><h1 id="0d1a" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">常见算法</h1><h2 id="db73" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf iz ky kz kj jb la lb kn lc bi translated">1.分步解决</h2><p id="c54d" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">我们首先将问题分成子问题，然后将它们组合在一起，得到问题的最终解决方案。该算法分两步处理:</p><ul class=""><li id="388b" class="iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh bi translated">Divide:我们将输入数组分成两半。轴心是数组的中点。递归地执行该步骤，直到不再有半数组要划分。</li><li id="80c8" class="iq ir hi is b it jm iv jn ix jo iz jp jb jq jd je jf jg jh bi translated">征服:我们从下到上对分割后的数组进行排序合并，最终得到排序后的数组。</li></ul><p id="3791" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated">以下面的“<a class="ae lx" href="https://www.java67.com/2018/03/mergesort-in-java-algorithm-example-and.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">归并排序</strong> </a>”为例，我们可以看到数组被递归减半，直到大小变为1。一旦大小变为1，合并和排序就开始了。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2017/06/difference-between-stable-and-unstable-algorithm.html#axzz6dXsEfLvJ"><div class="er es ly"><img src="../Images/5cf33e5163bb325dd1ed7259b6bd7fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wouQUO28UYkYakr7YUKO8A.png"/></div></a></figure><p id="52d1" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated"><strong class="is hj">Java代码:</strong></p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/935b038468cfb7fc4710ca77ca3ab875.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bD8o66D6kd0rXHg32E7ucg.png"/></div></div><p class="me mf et er es mg mh bd b be z dx translated">Java中的合并排序</p></figure><h2 id="8eae" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf iz ky kz kj jb la lb kn lc bi translated">2.递归</h2><p id="6e6a" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">如果你想学习递归，汉诺塔是一个经典的问题。</p><p id="c8fc" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated"><strong class="is hj">Java中的代码:</strong></p><figure class="lz ma mb mc fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2012/12/recursion-in-java-with-example-programming.html#axzz6ieZZarMY"><div class="er es mi"><img src="../Images/fa3874edc2ad85843c3485295d369422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lr8Z8G3zbNw61vXV4I625A.png"/></div></a><p class="me mf et er es mg mh bd b be z dx translated">爪哇的河内塔</p></figure><h2 id="a249" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf iz ky kz kj jb la lb kn lc bi translated">3.贪婪算法</h2><p id="6252" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">例如，考虑<strong class="is hj">最小硬币数</strong>问题。给定一个值V，如果我们要兑换V，我们有无限量的台湾货币。进行兑换最少需要多少硬币？</p><p id="582f" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated"><strong class="is hj">Java中的代码:</strong></p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/aad3d087ac0656ec28e2155eb0da467b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0zrRRA6Q8JUXuEmv0sQhg.png"/></div></div></figure><h2 id="d81e" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf iz ky kz kj jb la lb kn lc bi translated">4.动态规划</h2><p id="5454" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated"><a class="ae lx" href="https://javarevisited.blogspot.com/2021/03/top-dynamic-programming-problems-for-coding-interviews.html" rel="noopener ugc nofollow" target="_blank">动态规划</a>的主要思想是保存子问题的结果，以便我们在将来可以简单地使用这些结果，而不是重新计算这些值。</p><p id="dc35" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated">我们就拿<a class="ae lx" href="https://www.java67.com/2019/03/nth-fibonacci-number-in-java-coding.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">斐波那契数列</strong> </a>这个简单的例子来说:求Fn = Fn-1 + Fn-2定义的第n个斐波那契数对于n &gt; 1，F0 = 0，F1 = 1</p><p id="db0f" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated"><strong class="is hj">Java代码:</strong></p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/2e5cbfac2c248befa2ac879ff422729a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*pNTpAwnN24BqDGNDZue-rA.png"/></div></figure><h2 id="54d3" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf iz ky kz kj jb la lb kn lc bi translated"><strong class="ak"> 5。迭代</strong></h2><p id="57c0" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">问题:<a class="ae lx" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" rel="noopener ugc nofollow" target="_blank"> LeetCode #104。<strong class="is hj">二叉树的最大深度</strong>T7】</a></p><p id="1ee4" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated">Java中求深度的迭代版本如下:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/5d1351c9a93ed84496be59adf26b797b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*vhNpGwgGUAmkjR8Pxzob6w.png"/></div><p class="me mf et er es mg mh bd b be z dx translated">深度优先搜索</p></figure><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/ed4ad7a3eb9122a4239f6f9290db27ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*Y8gue7N78ee5rTlnhZnQmQ.png"/></div><p class="me mf et er es mg mh bd b be z dx translated">BFS</p></figure><h2 id="a636" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf iz ky kz kj jb la lb kn lc bi translated">6.列举</h2><p id="548a" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">枚举(或enum)是用户定义的数据类型。它主要用于给整型常量命名，这些名字使得程序易于阅读和维护。<strong class="is hj">回溯</strong>是一种典型的枚举策略。回溯是一种不用尝试所有可能性就能解决<strong class="is hj">约束满足问题</strong>的方法。n皇后问题是经典的回溯问题。问题是在一个n×n的棋盘上放置n个皇后，这样就不会有两个皇后互相攻击。这意味着没有两个皇后在同一行、同一列或同一对角线上。</p><p id="3d6b" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated">问题:<a class="ae lx" href="https://leetcode.com/problems/n-queens/" rel="noopener ugc nofollow" target="_blank"> LeetCode #51。n皇后</a></p><p id="d6f8" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated">Java代码:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/e4135092159427c8c0897b6f42e98739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJ3zT5xA_waPmujC5aPDeQ.png"/></div></div><p class="me mf et er es mg mh bd b be z dx translated">来源:<a class="ae lx" href="https://zgljl2012.com/leetcode-51-n-queens/" rel="noopener ugc nofollow" target="_blank">https://zgljl2012.com/leetcode-51-n-queens/</a></p></figure><h1 id="ace2" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">大O符号</h1><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/e788f43edc4ccc2f57e035425dc5dd03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8TXZNp_5DGSOiE0e.jpg"/></div></div><p class="me mf et er es mg mh bd b be z dx translated">来源:<a class="ae lx" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com/</a></p></figure><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/f6c8bd3619dd64b7cc7e9b35f0671aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OTJOQp2Fvab0EDzGYR93A.png"/></div></div><p class="me mf et er es mg mh bd b be z dx translated">常见排序算法</p></figure><h1 id="b3bd" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">静态和动态数据结构</h1><p id="619c" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">以下材料来自<a class="ae lx" href="http://www.ayomaonline.com/academic/static-vs-dynamic-data-structures/" rel="noopener ugc nofollow" target="_blank">http://www . ayomaonline . com/academic/static-vs-dynamic-data-structures/</a>❤️，特此致谢</p><h2 id="4d8c" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf iz ky kz kj jb la lb kn lc bi translated">静态数据结构:数组，列表</h2><p id="d4be" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">正如静态这个词所暗示的一样，<a class="ae lx" href="https://www.java67.com/2019/07/top-10-online-courses-to-learn-data-structure-and-algorithms-in-java.html" rel="noopener ugc nofollow" target="_blank">静态数据结构</a>是用来存储静态“数据集”的。然而，一个静态的“数据集”，并不意味着我们不能改变元素的赋值。它是分配给“数据”的内存大小，是静态的。因此，有可能改变静态结构的内容，但不增加分配给它的内存空间。</p><h2 id="dea8" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf iz ky kz kj jb la lb kn lc bi translated">动态数据结构:堆栈、队列、堆、树、链表</h2><p id="d86f" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">动态数据结构旨在便于运行时<a class="ae lx" href="https://www.java67.com/2013/08/ata-structures-in-java-programming-array-linked-list-map-set-stack-queue.html" rel="noopener ugc nofollow" target="_blank">数据结构</a>的改变。可以改变元素的赋值，就像静态结构一样。A</p><p id="2ad3" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated">同样，在动态结构中，初始分配的内存大小不是问题。可以添加新元素、删除现有元素或对数据集进行任何类型的操作，而无需考虑最初分配的内存空间。</p><h2 id="edff" class="kp js hi bd jt kq kr ks jx kt ku kv kb ix kw kx kf iz ky kz kj jb la lb kn lc bi translated">静态数据结构与动态数据结构</h2><p id="c5d8" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">静态数据结构被给定了一个固定的内存区域，它可以在其中操作。不可能在运行时扩展这个固定大小。因此，每个元素的位置都是固定的，并且为程序所知。</p><p id="6feb" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi translated">动态数据结构也有它可以操作的区域。然而，这个区域的大小是灵活的，不像静态数据结构那样是固定的。通过添加或删除<a class="ae lx" rel="noopener" href="/javarevisited/top-10-free-data-structure-and-algorithms-courses-for-beginners-best-of-lot-ad807cc55f7a?source=grid_home---------0-2-----------------18---ce729948_f262_4982_a7a1_a5058c8fe9fa--">数据结构</a>中的元素，可以根据需要扩大或缩小区域。</p><h1 id="47b6" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">公共数据结构操作</h1><p id="65f0" class="pw-post-body-paragraph ld le hi is b it lf lg lh iv li lj lk ix ll lm ln iz lo lp lq jb lr ls lt jd hb bi translated">从下面的图表可以看出动态和静态数据结构在时间复杂度上的巨大差异。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/b5aaca2fb2b53850f77cd9942b273de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWzR4dB6RjRUxq0WCuEd4g.png"/></div></div><p class="me mf et er es mg mh bd b be z dx translated">来源:来源:【https://www.bigocheatsheet.com/ T2】</p></figure><p id="1a86" class="pw-post-body-paragraph ld le hi is b it iu lg lh iv iw lj lk ix lu lm ln iz lv lp lq jb lw ls lt jd hb bi">—</p><h1 id="8f33" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">另外，我想通过这里的掌声和你交流。所以如果你喜欢这个故事，请奖励我1-3👏(PS按住点击👏不用动手指就能连续鼓掌。);如果你在关注我，也期待我访问你的故事，请给我5分👏让我去know️ ❤ ️</h1></div></div>    
</body>
</html>