<html>
<head>
<title>Contract Integration Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合同集成测试</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/contract-integration-testing-23537b33729?source=collection_archive---------1-----------------------#2022-07-25">https://medium.com/javarevisited/contract-integration-testing-23537b33729?source=collection_archive---------1-----------------------#2022-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近我写了一篇关于在CI环境中使用Testcontainers用法实现<a class="ae jd" href="https://dev.to/kirekov/e2e-testing-in-ci-environment-with-testcontainers-1403" rel="noopener ugc nofollow" target="_blank"> E2E测试的文章。今天我想补充一个小细节。我们将讨论契约，以及为什么为它们编写集成测试很重要。代码示例是用Java编写的，但是您可以将建议的解决方案应用于任何编程语言。</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/07/top-5-websites-to-learn-coding-in-java.html"><div class="er es je"><img src="../Images/7a01bb4d709a3ed454074af8a89e4c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*QtcYvX2XLjwVs261.png"/></div></a><p class="jm jn et er es jo jp bd b be z dx translated">Meme文章封面</p></figure><blockquote class="jq jr js"><p id="8afd" class="if ig jt ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated"><em class="hi">如果你还没有看过我写的关于E2E考试</em>  <em class="hi">的</em> <a class="ae jd" href="https://dev.to/kirekov/e2e-testing-in-ci-environment-with-testcontainers-1403" rel="noopener ugc nofollow" target="_blank"> <em class="hi">的文章，我强烈建议你先看完再继续。在这篇文章中，将会有许多基于前一个项目的经验的建议和讨论。</em></a></p></blockquote><h1 id="0cf7" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">E2E测试陷阱</h1><p id="de67" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">你看，E2E测试是令人难以置信的。这是软件项目中最高的质量保证标准。同时，您应该考虑几个细微差别:</p><ol class=""><li id="9ced" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">E2E测试很难。编写有意义且可维护的E2E测试需要大量的技能。</li><li id="a121" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">自动运行E2E测试也不是那么简单。虽然我在前一篇文章中提出了解决方案，但它不能被称为微不足道。</li><li id="c985" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">微服务越多，编写新的E2E测试就越难。</li><li id="8161" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">每次软件产品随着新的微服务增长，你必须相应地更新环境(例如<a class="ae jd" href="https://www.testcontainers.org/" rel="noopener ugc nofollow" target="_blank"> Testcontainers配置</a>)以确保测试仍然有效。</li><li id="7a63" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">如果产品包含太多的微服务，为整个系统编写一个可靠的E2E测试几乎是不可能的。</li></ol><p id="2fab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，E2E测试一直工作到软件项目变得庞大和复杂。那么，我们该怎么办？</p><h1 id="744d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">合同集成测试</h1><p id="9103" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">首先，再看一下上一篇文章中的系统图。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://www.java67.com/2018/05/top-20-system-design-interview-questions-answers-programming.html"><div class="er es lo"><img src="../Images/5873aea55813703b567e377c13630a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VrgAdqEoSPDU8jwy.png"/></div></a><p class="jm jn et er es jo jp bd b be z dx translated">系统结构</p></figure><p id="b716" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个业务场景可以用以下步骤来描述:</p><ol class=""><li id="3f3e" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">用户通过<a class="ae jd" rel="noopener" href="/javarevisited/10-best-java-web-services-rest-soap-and-api-courses-for-beginners-724a8f51298d"> REST API </a>向<code class="du lp lq lr ls b">API-Service</code>发送消息。</li><li id="ba75" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">然后<code class="du lp lq lr ls b">API-Service</code>将消息传输到RabbitMQ集群。</li><li id="c57d" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><code class="du lp lq lr ls b">Gain-Service</code>消费消息，用来自缓存的附加信息丰富它(即<a class="ae jd" href="https://javarevisited.blogspot.com/2022/03/spring-boot-redis-example-in-java.html" rel="noopener ugc nofollow" target="_blank"> Redis </a>)，最后将结果消息再次推送到RabbitMQ。</li></ol><p id="037c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们这里有什么合同？看看下面的模式。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/02/top-5-courses-to-learn-redis.html"><div class="er es lo"><img src="../Images/bfc0703f9354d9fdfdb59f3c11465994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h9QpwUTu9PhrkqVx.png"/></div></a><p class="jm jn et er es jo jp bd b be z dx translated">合同图表</p></figure><p id="1ed2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用淡绿色椭圆形突出显示了这些合同:</p><ol class=""><li id="3b28" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated"><code class="du lp lq lr ls b">RabbitUserMsgPush</code> -将用户的消息从<code class="du lp lq lr ls b">API-Service</code>推送到RabbitMQ。</li><li id="eadd" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><code class="du lp lq lr ls b">RabbitUserMsgConsume</code>——将用户的消息从RabbitMQ拉至<code class="du lp lq lr ls b">Gain-Service</code>。</li><li id="3e77" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><code class="du lp lq lr ls b">RedisCacheRepo</code> -从<code class="du lp lq lr ls b">Gain-Service</code>视角读取和更新Redis数据。</li><li id="0da4" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><code class="du lp lq lr ls b">RabbitGainMsgPush</code> -将获得的消息从<code class="du lp lq lr ls b">Gain-Service</code>推送到RabbitMQ</li></ol><p id="0ed9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为什么需要合同？尽管额外的层增加了额外的复杂性，契约也帮助我们摆脱了<code class="du lp lq lr ls b">API-Service</code>和<code class="du lp lq lr ls b">Gain-Service</code>中的集成测试。看看下面的例子。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/01/10-unit-testing-and-integration-tools-for-java-programmers.html"><div class="er es lo"><img src="../Images/d8c0b550502e8da12ff1ea147c02072c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VUPQfHvh3aqZC6cI.png"/></div></a><p class="jm jn et er es jo jp bd b be z dx translated">分离单元和集成测试</p></figure><p id="f90e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们已经讨论过的，<code class="du lp lq lr ls b">UserMsgPush</code>是契约。有两种实现:<code class="du lp lq lr ls b">RabbitUserMsgPush</code>和<code class="du lp lq lr ls b">InMemoryUserMsgPush</code>。现在里斯科夫替代原则开始发挥作用。如果简化定义，用一个接口实现替换另一个接口实现不会破坏软件的正确性。在这种情况下，我们不必让RabbitMQ参与测试<code class="du lp lq lr ls b">API-Service</code>！因为<code class="du lp lq lr ls b">InMemoryUserMsgPush</code>就足够了。所以，这就是好处:</p><ol class=""><li id="b219" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">我们只能用单元测试来覆盖<code class="du lp lq lr ls b">API-Service</code>。</li><li id="c7b4" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">集成测试只封装在<code class="du lp lq lr ls b">RabbitUserMsgPush</code>场景中。</li><li id="f028" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">我们可以用另一个实现替换<code class="du lp lq lr ls b">UserMsgPush</code>的一个实现，而不需要接触<code class="du lp lq lr ls b">RabbitUserMsgPush</code>中的测试。</li></ol><p id="2665" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">似乎合同测试是银弹。首先，我们减少了集成测试的数量，简化了服务中的质量场景。其次，我们完全摆脱了E2E测试，它很难编写、执行和维护。不幸的是，契约测试也有缺点。</p><h1 id="77cd" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">合同的缺点</h1><h2 id="4f6e" class="lt jy hi bd jz lu lv lw kd lx ly lz kh iq ma mb kl iu mc md kp iy me mf kt mg bi translated">不必要的代码复杂性</h2><p id="d94a" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">微服务通常没有太多代码。他们通常只提供一个操作。例如，<code class="du lp lq lr ls b">API-Service</code>通过<a class="ae jd" rel="noopener" href="/javarevisited/top-10-rest-interview-questions-for-java-and-spring-developers-1611e3b78029"> REST API </a>接受一条消息，并将其推送到RabbitMQ。就是这样。因此，额外的层、接口和抽象可能看起来像噪音。如果我可以直接进行操作，为什么我必须使用facade来操作呢？</p><p id="8241" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然抽象是有用的，但是它们的丰富会使代码比它应该的更复杂。</p><h2 id="bda8" class="lt jy hi bd jz lu lv lw kd lx ly lz kh iq ma mb kl iu mc md kp iy me mf kt mg bi translated">缺乏本地实验</h2><p id="f39b" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">集成测试的主要优点是它允许我们在提交拉请求之前执行本地实验。例如，假设您需要调整服务所依赖的外部设施的一些属性。这些可以是:</p><ol class=""><li id="6d51" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">减小数据库连接池的大小。</li><li id="9486" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">在<a class="ae jd" href="https://javarevisited.blogspot.com/2018/04/top-5-apache-kafka-course-to-learn.html" rel="noopener ugc nofollow" target="_blank">中改变连载策略卡夫卡制作人</a>。</li><li id="4ccc" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">重整SQL语句以提高效率。</li></ol><p id="2e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在您正在处理的服务中有集成测试，您可以只调整所需的设置并在本地运行测试来验证行为。但是如果服务依赖于合同，这个任务就变得有趣了。您有几种方法:</p><ol class=""><li id="9eec" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">以这样一种方式更改协定，即将更新的属性作为参数传递。因此，您在检查场景有效性的契约中添加了额外的集成测试。但是在这种情况下，契约暴露了太多关于其实现的细节。这打破了抽象的整个概念，使得用一个实现替换另一个实现更加困难。</li><li id="cfda" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">将所需属性的更改封装为合同中的集成场景。在这里，您不会将实现细节泄露给契约的用户，但是您也使您的测试变得更加复杂。因为您必须验证可能的属性值的不同组合。</li><li id="aaa3" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">将所需的集成测试直接添加到服务代码库中。所以，你不会把合同搞得太复杂，对吧？的确，但是现在服务直接依赖于特定的契约实现。我们引入了从服务中完全移除集成测试的合同。又来了。</li></ol><h1 id="e7fa" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">向后兼容性</h1><p id="e31a" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">正如我在<a class="ae jd" href="https://dev.to/kirekov/e2e-testing-in-ci-environment-with-testcontainers-1403" rel="noopener ugc nofollow" target="_blank">的上一篇文章</a>中所写的，E2E测试的主要优点是它们检查向后兼容性问题。遗憾的是，合同没有提供这种功能。</p><p id="572f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如看下面的<code class="du lp lq lr ls b">RabbitUserMsgPush</code>契约实现。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mh mi l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">犹太人买卖合同</p></figure><p id="1929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，传递的有效负载被序列化为JSON。假设我们决定应用二进制协议(例如Protobuf)。看看下面改装过的<code class="du lp lq lr ls b">RabbitUserMsgPush</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mh mi l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">拉比合同</p></figure><p id="445b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很方便。因为我们可以在根本不修改业务逻辑的情况下更改契约的实现。不会出错的，不是吗？每个合同都定义了生产者和消费者。如果我们在消费者的合同之前更新生产者的合同会怎么样？这意味着消费者将无法反序列化消息并会失败。</p><p id="1f8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我们不能在分布式环境中轻易打破向后兼容性。我们可能不知道其他客户仍在使用的以前的合同版本。E2E测试跟踪这些违规行为。但是由于契约的实现隔离，后一种方法不能提供这样的好处。</p><p id="e963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看下面应用这些变化的正确方法。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mh mi l"/></div><p class="jm jn et er es jo jp bd b be z dx translated">拉比们推动不同的合同</p></figure><p id="375f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们使用不同的序列化策略将有效负载推入两个队列。消费者不会被卡住，因为它会继续读取之前的队列，直到它的合同被更新。其次，我们应用<a class="ae jd" href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern" rel="noopener ugc nofollow" target="_blank">责任链设计模式</a>来区分不同的序列化策略。在这种情况下，我们可以分别测试它们。</p><blockquote class="jq jr js"><p id="b694" class="if ig jt ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated"><em class="hi">为了方便，我创造了</em> <code class="du lp lq lr ls b"><em class="hi">NoOpUserMsgPush</em></code> <em class="hi">。这是最后一个不工作的链元素。因此，我们不必检查</em> <code class="du lp lq lr ls b"><em class="hi">next</em></code> <em class="hi">元素是否出现在每个实现中。</em></p></blockquote><p id="f217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在契约中保持向后兼容是可能的，但是需要额外的努力。您还可以将描述特定操作调用数量的<a class="ae jd" href="https://prometheus.io/docs/concepts/metric_types/#counter" rel="noopener ugc nofollow" target="_blank">计数器指标</a>(即推送JSON和Protobuf消息)显示到<a class="ae jd" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>中。这将有助于您注意到何时所有消费者都得到更新，生产者可以安全地消除冗余功能。</p><h2 id="9eaa" class="lt jy hi bd jz lu lv lw kd lx ly lz kh iq ma mb kl iu mc md kp iy me mf kt mg bi translated">微服务的单一语言</h2><p id="a767" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">合同只不过是一段普通的代码。所以，你不能在用Golang创建的微服务中应用用Java写的契约。如果您需要为系统的不同部分使用不同的技术和语言，那么实现静态类型的契约可能会成为一个挑战。市场上有一些解决方案。例如，<a class="ae jd" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>和<a class="ae jd" href="https://www.asyncapi.com/" rel="noopener ugc nofollow" target="_blank"> AsyncAPI </a>规范可以根据提供的配置生成代码片段。无论如何，这些方法都有局限性。</p><h1 id="3c33" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">结论</h1><p id="4297" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">合同是强大的。在某些情况下，它们可以使你的代码更容易测试。另一方面，它们也带来了应该考虑的可维护性案例。要不要用合同，由你自己决定。但在我看来，它们不能完全取代E2E测试。</p><p id="e532" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我想告诉你的关于合同集成测试的全部内容。如果您有任何问题或建议，请在下面留下您的评论。感谢阅读！</p></div></div>    
</body>
</html>