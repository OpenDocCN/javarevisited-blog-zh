<html>
<head>
<title>HiveMQ Cloud, part 1 — MQTT on Raspberry Pi, Send Sensor Data to HiveMQ Cloud with Java and Pi4J</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HiveMQ Cloud，第1部分Raspberry Pi上的MQTT，使用Java和Pi4J将传感器数据发送到HiveMQ Cloud</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/hivemq-cloud-part-1-mqtt-on-raspberry-pi-send-sensor-data-to-hivemq-cloud-with-java-and-pi4j-a92f0082a6fd?source=collection_archive---------0-----------------------#2021-12-11">https://medium.com/javarevisited/hivemq-cloud-part-1-mqtt-on-raspberry-pi-send-sensor-data-to-hivemq-cloud-with-java-and-pi4j-a92f0082a6fd?source=collection_archive---------0-----------------------#2021-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7e72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几年前，我用运行在Raspberry Pi上的MQTT服务器(Mosquitto)做了第一次实验，为我儿子的鼓室连接Arduino和Raspberry Pi。完整的过程在我的书<a class="ae jd" href="https://webtechie.be/books/" rel="noopener ugc nofollow" target="_blank">“树莓Pi上的Java入门”</a>中有描述。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/b5e0ec46279258f7b713bf2fa26308ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*2iaMFEg1bn_g4I2Pisvujg.jpeg"/></div><p class="jm jn et er es jo jp bd b be z dx translated">图书封面“在树莓Pi上开始使用Java”</p></figure><p id="e6a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一系列的文章中，我们将采用一种不同的在线MQTT兼容服务方式:<a class="ae jd" href="https://www.hivemq.com/mqtt-cloud-broker/" rel="noopener ugc nofollow" target="_blank"> HiveMQ Cloud </a>。最大的优势:不需要永远在线的服务器，我们必须自己管理自己。是的，Mosquitto运行在廉价的Raspberry Pi上，但如果我们将它用作分发数据的“中枢”,我们仍然需要保持它的正常运行。</p><p id="faff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有一大优势:HiveMQ Cloud最多100台设备完全免费！即使对最热情的制造商来说，这也是一大堆微控制器或计算机！</p><p id="5684" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HiveMQ网站上有许多编程语言的示例代码。在这篇文章和接下来的文章中，我们将重点讨论几个关于Raspberry Pi和Java的例子。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jq jr l"/></div></figure><h1 id="e2b9" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">设置HiveMQ云帐户</h1><p id="4d54" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">先说我们免费的HiveMQ云账号。转到<a class="ae jd" href="https://auth.hivemq.cloud" rel="noopener ugc nofollow" target="_blank"> auth.hivemq.cloud </a> &gt;“立即注册”并创建一个登录名。登录后，您将看到您的集群。通过点击“管理集群”按钮，您将被定向到包含HiveMQ云实例详细信息的视图。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/4638e6aa9013ef6a1ef3b3c88aff13b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qI68zFyb3DQpRR1t.png"/></div></div></figure><p id="5803" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到“访问管理”部分，为我们将在应用程序中使用的凭证创建一个用户名和密码。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es la"><img src="../Images/dd103983903ac39725c3194559ce60e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0lSljHYwF9EOk6C5.png"/></div></div></figure><h1 id="cda2" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">关于树莓派</h1><p id="e293" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">树莓派不仅仅是一台适合所有人的小型廉价电脑。不，最新的版本4已经发展成为一个强大的机器，可以在许多情况下取代全尺寸的台式机或笔记本电脑。</p><p id="533c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Raspberry Pi项目的最初目标是构建一台所有人都能负担得起的廉价PC。第一个版本可以直接连接到电视上，为那些买不起显示器的人提供一台电脑。现在不同版本的Raspberry Pi已经上市，这取决于你的预算、你需要的连接、处理器、内存容量等等。</p><p id="723a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2019年，树莓Pi 4发布，搭载1.5 GHz 64位四核ARM处理器。该主板提供1、2、4或8GB内存。价格从25到90€不等。</p><p id="376a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个系列中，我将使用Raspberry Pi 4，但您也可以使用其他类型的电路板。使用第一代Raspberry Pi Zero(2021年11月发布的新款)或更老的全尺寸主板时，唯一需要注意的是使用ARMv6兼容的Java JDK或运行时。更多信息参见<a class="ae jd" href="https://webtechie.be/post/2020-08-27-azul-zulu-java-11-and-gluon-javafx-11-on-armv6-raspberry-pi/" rel="noopener ugc nofollow" target="_blank">“如何在采用ARMv6处理器的Raspberry Pi板上安装和使用Java 11和Java FX 11”</a>。</p><p id="2f7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Raspberry Pi的“神奇部分”是40引脚接头，它允许您连接各种电子组件，如led、按钮、传感器、伺服系统、继电器、屏幕……这正是我们在本文中想要用来将传感器数据发送到HiveMQ Cloud的。</p><h1 id="876d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">树莓派上的Java</h1><p id="3202" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">当你开始使用一个新的Raspberry Pi时，你需要将操作系统“烧录”到SD卡上。在树莓派网站的<a class="ae jd" href="https://www.raspberrypi.com/software/" rel="noopener ugc nofollow" target="_blank">软件页面，可以找到“成像仪”工具。使用此工具，您可以刻录一个预定义的操作系统版本，或者选择从另一个网站下载的映像。如果选择“Raspberry Pi OS(其他)”&gt;“Raspberry Pi OS Full(32位)”，你将拥有一个完整的Linux桌面环境，并带有额外的编程工具。</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lb"><img src="../Images/3e5d366638c9c83f3093ecf1ed280644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5lPkfKYLOLJiXXKx.png"/></div></div></figure><p id="0803" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且对我们更重要的是，Java也是预装的！当你打开终端并用<code class="du lc ld le lf b">java -versions</code>检查版本时，你会得到这个结果(取决于Raspberry Pi OS的构建):</p><pre class="jf jg jh ji fd lg lf lh li aw lj bi"><span id="160c" class="lk jt hi lf b fi ll lm l ln lo">$ java -version<br/>openjdk version "11.0.12" 2021-07-20<br/>OpenJDK Runtime Environment (build 11.0.12+7-post-Raspbian-2deb10u1)<br/>OpenJDK Server VM (build 11.0.12+7-post-Raspbian-2deb10u1, mixed mode)</span></pre><p id="2396" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着我们已经为在我们的Raspberry Pi上开发和运行Java应用程序做好了充分准备！</p><h1 id="b14f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Pi4J</h1><p id="e1c5" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">Pi4J项目(始于2012年)旨在将Java编程与电子学结合起来。通过在项目中使用Pi4J依赖性，连接到Raspberry Pi的GPIO引脚(通用输入/输出)的电子组件可以作为Java代码中的对象进行控制。Pi4J使用本地库来控制GPIOs，因此作为程序员，您不需要完全了解与硬件通信相关的所有“魔法”。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lp"><img src="../Images/e56bf4da9d7cd8e437783eb7b683bdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6QnbuVVVgFWHhBLg.jpg"/></div></div></figure><h2 id="1a0e" class="lk jt hi bd ju lq lr ls jy lt lu lv kc iq lw lx kg iu ly lz kk iy ma mb ko mc bi translated">历史</h2><p id="74fe" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">2021年初发布了Pi4J的两个新版本:</p><ul class=""><li id="63e7" class="md me hi ih b ii ij im in iq mf iu mg iy mh jc mi mj mk ml bi translated">2021年1月发布的1.3版本增加了对最新的Raspberry Pi板(4400和Compute 4)的支持</li><li id="254e" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">2021年3月发布的1.4版本针对Java 11，并移除了对其他板和组件的支持</li></ul><p id="bea7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">V1的全部历史可以在Pi4J网站上找到。</p><p id="390c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自2019年以来，Pi4J的全新版本2的工作一直在进行，以带来模块和改进的架构。这使得项目更容易维护、测试和发布。2021年8月，这个新版本首次发布，这也是我们将在这里使用的版本。</p><h2 id="1757" class="lk jt hi bd ju lq lr ls jy lt lu lv kc iq lw lx kg iu ly lz kk iy ma mb ko mc bi translated">证明文件</h2><p id="f21c" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">与这个V2一起，一个新的<a class="ae jd" href="https://pi4j.com" rel="noopener ugc nofollow" target="_blank">文档网站发布了</a>，在那里你可以找到很多关于电子学以及如何在Raspberry Pi上使用Java和JavaFX的信息。</p><h1 id="9e3e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Java项目</h1><p id="c9f6" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我们将创建的第一个应用程序是一个数据发布器，完整的源代码可以在<a class="ae jd" href="https://github.com/FDelporte/HiveMQ-examples" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。我们将从不同的传感器读取数据，并将它们的值发送到HiveMQ Cloud。因为每个“制造者”对一个项目都有自己的想法和愿望，所以我们不会关注组件和布线，而是使用一个非常适合这个演示项目的简单的初学者工具包:CrowPi。这种预连线套件使开始电子编程变得非常容易，因为所有组件都是预组装和连线的。所以至少这是一件你不需要担心或者会搞砸的事情；-).</p><div class="jf jg jh ji fd ab cb"><figure class="mr jj ms mt mu mv mw paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/1c9a18ce44c51fe6a4d030a986ae4d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*B-mPclRHcNae5_cOdVd0zg.jpeg"/></div></figure><figure class="mr jj mx mt mu mv mw paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/79c5fd70235eace90579dbd7ab1a7323.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*lcniOdlX2tgfKViHFrwK_w.jpeg"/></div></figure><figure class="mr jj my mt mu mv mw paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/05101796ce3882c08e8b6bb226ccb101.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*g1A2dVnqvYZ7ak8h-bWeYQ.jpeg"/></div><p class="jm jn et er es jo jp bd b be z dx mz di na nb translated">CrowPi版本1和2</p></figure></div><h1 id="0c70" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">基于FHNW的CrowPi项目</h1><p id="7291" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">来自瑞士FHNW大学的学生为CrowPi创建了一个完整的Java项目来演示如何用Java控制这个工具包中的所有组件。他们的部分文档已被翻译并可在<a class="ae jd" href="https://pi4j.com/getting-started/crowpi/" rel="noopener ugc nofollow" target="_blank"> Pi4J网站</a>上获得，德语原版文档可在<a class="ae jd" href="https://fhnw-ip5-ip6.github.io/CrowPiGoesJavaTutorial/de/" rel="noopener ugc nofollow" target="_blank">“CrowPi Goes Java”</a>上找到。对于每个组件，他们创建了一个单独的应用程序，因此如何使用他们的代码作为自己项目的基础变得非常清楚。</p><p id="3129" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文中的概念验证应用程序使用了“CrowPi Goes Java”项目的某些部分，这些部分被重构以适合一个独立的应用程序，以便同时从不同的传感器读取数据，或者监听它们的更改事件并将数据发布到HiveMQ。</p><h1 id="8a23" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Maven pom.xml</h1><p id="67f9" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">Pi4J库使用模块化方法，为Raspberry Pi构建一个项目会生成一个包含所有必需文件的目录。正因为如此，pom文件看起来有点让人不知所措。</p><p id="8b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">依赖关系包含:</p><ul class=""><li id="e73e" class="md me hi ih b ii ij im in iq mf iu mg iy mh jc mi mj mk ml bi translated">HiveMQ MQTT客户端来发布数据</li><li id="f02e" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">Pi4J核心和这个项目所需的插件</li><li id="1d7e" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">SLF4J是Pi4J使用的日志框架</li><li id="0a6d" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">杰克逊和雅加达。JSON用于JSON数据生成，简化数据传输</li></ul><p id="8264" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用多个插件，采取以下步骤:</p><ul class=""><li id="84c8" class="md me hi ih b ii ij im in iq mf iu mg iy mh jc mi mj mk ml bi translated">编译Java项目</li><li id="6c23" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">定义可执行类</li><li id="6f1e" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">在发行目录中创建<code class="du lc ld le lf b">jar</code></li><li id="7a6e" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">在分发目录中复制一个<code class="du lc ld le lf b">run.sh</code>脚本</li><li id="e580" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">在同一目录中添加运行时依赖项</li></ul><h1 id="aa4b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">密码</h1><p id="a0ca" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">为了使代码易于理解，每个功能都被分成了自己的类。<code class="du lc ld le lf b">HiveMqSender.java</code>是主类，所有的东西都在这里初始化，应用程序也在这里启动。</p><pre class="jf jg jh ji fd lg lf lh li aw lj bi"><span id="0f49" class="lk jt hi lf b fi ll lm l ln lo">public class HiveMqSender {<br/><br/>    // Logger helper provided by Pi4J<br/>    private static Console console;<br/>    // Sends data to HiveMQ Cloud<br/>    private static HiveMqManager hiveMqManager;<br/>    // Initializes the sensors and reads the values<br/>    private static SensorManager sensorManager;<br/><br/>    public static void main(String[] args) {<br/>        console = new Console();<br/>        hiveMqManager = new HiveMqManager(console);<br/>        sensorManager = new SensorManager(console, hiveMqManager);<br/><br/>        while (true) {<br/>            try {<br/>                Thread.sleep(500);<br/>            } catch (InterruptedException e) {<br/>                e.printStackTrace();<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h2 id="908d" class="lk jt hi bd ju lq lr ls jy lt lu lv kc iq lw lx kg iu ly lz kk iy ma mb ko mc bi translated">发布到HiveMQ主题</h2><p id="146d" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在文件<code class="du lc ld le lf b">HiveMqManager.java</code>中，我们找到了连接HiveMQ Cloud和发布消息所需的所有代码。</p><p id="017f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用MQTT第5版客户端，与第3版相比，它提供了多项改进，详见<a class="ae jd" href="https://www.hivemq.com/blog/mqtt5-essentials-part1-introduction-to-mqtt-5/" rel="noopener ugc nofollow" target="_blank">“了解新的MQTT 5协议— MQTT 5基础第1部分”</a>以及该系列的后续文章。是的，你也会在那篇文章中发现，为什么没有第4版。:-)</p><p id="ba6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多亏了builder方法，我们可以非常容易地配置客户端和连接。由于HiveMQ Cloud需要一个安全的连接，我们需要使用<code class="du lc ld le lf b">sslWithDefaulftConfig()</code>并在连接中应用身份验证。</p><pre class="jf jg jh ji fd lg lf lh li aw lj bi"><span id="b4eb" class="lk jt hi lf b fi ll lm l ln lo">public class HiveMqManager {<br/><br/>    private static final String HIVEMQ_SERVER = "ID_OF_YOUR_INSTANCE.s1.eu.hivemq.cloud";<br/>    private static final String HIVEMQ_USER = "YOUR_USERNAME";<br/>    private static final String HIVEMQ_PASSWORD = "YOUR_PASSWORD";<br/><br/>    private static Console console;<br/>    private static Mqtt5AsyncClient client;<br/><br/>    public HiveMqManager(Console console) {<br/>        this.console = console;<br/><br/>        client = MqttClient.builder()<br/>                .useMqttVersion5()<br/>                .identifier("Java_" + UUID.randomUUID())<br/>                .serverHost(HIVEMQ_SERVER)<br/>                .serverPort(8883)<br/>                .sslWithDefaultConfig()<br/>                .buildAsync();<br/><br/>        client.connectWith()<br/>                .simpleAuth()<br/>                .username(HIVEMQ_USER)<br/>                .password(HIVEMQ_PASSWORD.getBytes())<br/>                .applySimpleAuth()<br/>                .send()<br/>                .whenComplete((connAck, throwable) -&gt; {<br/>                    if (throwable != null) {<br/>                        console.println("Could not connect to HiveMQ: " + throwable.getMessage());<br/>                    } else {<br/>                        console.println("Connected to HiveMQ: " + connAck.getReasonCode());<br/>                    }<br/>                });<br/>    }<br/>}</span></pre><p id="b918" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让我们的传感器更容易发送数据，我们用一个<code class="du lc ld le lf b">sendMessage</code>方法扩展了这个类。为了查看我们的消息是否成功发布，或者哪里出错了，我们使用了<code class="du lc ld le lf b">whenComplete</code>方法。</p><pre class="jf jg jh ji fd lg lf lh li aw lj bi"><span id="43b3" class="lk jt hi lf b fi ll lm l ln lo">public void sendMessage(String topic, String message) {<br/>    client.publishWith()<br/>            .topic(topic)<br/>            .payload(message.getBytes())<br/>            .qos(MqttQos.EXACTLY_ONCE)<br/>            .send()<br/>            .whenComplete((mqtt5Publish, throwable) -&gt; {<br/>                if (throwable != null) {<br/>                    console.println("Error while sending message: " + throwable.getMessage());<br/>                } else {<br/>                    console.println("Message sent to '" + topic + "': " + message);<br/>                }<br/>            });<br/>}</span></pre><h2 id="36fc" class="lk jt hi bd ju lq lr ls jy lt lu lv kc iq lw lx kg iu ly lz kk iy ma mb ko mc bi translated">从传感器读取数据</h2><p id="0fe7" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">所有传感器都在<code class="du lc ld le lf b">SensorsManager.java</code>类中初始化。每个传感器被实现为一个<code class="du lc ld le lf b">Component</code>。它们中的一些以由<code class="du lc ld le lf b">TimerTask</code>开始的<code class="du lc ld le lf b">SendMeasurements</code>的间隔被读取。其他的通过监听器发送改变，例如<code class="du lc ld le lf b">SoundSensor</code>的<code class="du lc ld le lf b">onNoise</code>。</p><pre class="jf jg jh ji fd lg lf lh li aw lj bi"><span id="f201" class="lk jt hi lf b fi ll lm l ln lo">public class SensorManager {<br/><br/>    private static final String TOPIC_MOTION = "crowpi/motion";<br/>    private static final String TOPIC_NOISE = "crowpi/noise";<br/>    private static final String TOPIC_TOUCH = "crowpi/touch";<br/>    private static final String TOPIC_TILT = "crowpi/tilt";<br/>    private static final String TOPIC_SENSORS = "crowpi/sensors";<br/><br/>    private static final String VALUE_TRUE = "{\"value\":true}";<br/>    private static final String VALUE_FALSE = "{\"value\":false}";<br/><br/>    public SensorManager(Console console, HiveMqManager hiveMqManager) {<br/>        Context pi4j = CrowPiPlatform.buildNewContext();<br/><br/>        PirMotionSensorComponent motionSensor = new PirMotionSensorComponent(console, pi4j);<br/>        motionSensor.onMovement(() -&gt; hiveMqManager.sendMessage(TOPIC_MOTION, VALUE_TRUE));<br/>        motionSensor.onStillstand(() -&gt; hiveMqManager.sendMessage(TOPIC_MOTION, VALUE_FALSE));<br/><br/>        SoundSensorComponent soundSensor = new SoundSensorComponent(console, pi4j);<br/>        soundSensor.onNoise(() -&gt; hiveMqManager.sendMessage(TOPIC_NOISE, VALUE_TRUE));<br/>        soundSensor.onSilence(() -&gt; hiveMqManager.sendMessage(TOPIC_NOISE, VALUE_FALSE));<br/><br/>        TouchSensorComponent touchSensor = new TouchSensorComponent(console, pi4j);<br/>        touchSensor.onTouch(() -&gt; hiveMqManager.sendMessage(TOPIC_TOUCH, VALUE_TRUE));<br/>        touchSensor.onRelease(() -&gt; hiveMqManager.sendMessage(TOPIC_TOUCH, VALUE_FALSE));<br/><br/>        TiltSensorComponent tiltSensor = new TiltSensorComponent(console, pi4j);<br/>        tiltSensor.onTiltLeft(() -&gt; hiveMqManager.sendMessage(TOPIC_TILT, "{\"value\":\"left\"}"));<br/>        tiltSensor.onTiltRight(() -&gt; hiveMqManager.sendMessage(TOPIC_TILT, "{\"value\":\"right\"}"));<br/>        tiltSensor.onShake(() -&gt; hiveMqManager.sendMessage(TOPIC_TILT, "{\"value\":\"shaking\"}"));<br/><br/>        HumiTempComponent dht11 = new HumiTempComponent(console, pi4j);<br/>        LightSensorComponent lightSensor = new LightSensorComponent(console, pi4j);<br/>        UltrasonicDistanceSensorComponent distanceSensor = new UltrasonicDistanceSensorComponent(console, pi4j);<br/><br/>        Timer timer = new Timer();<br/>        TimerTask task = new SendMeasurements(hiveMqManager, dht11, lightSensor, distanceSensor);<br/>        timer.schedule(task, 10_000, 5_000);<br/>    }<br/><br/>    private static class SendMeasurements extends TimerTask {<br/>        private final HiveMqManager hiveMqManager;<br/>        private final HumiTempComponent dht11;<br/>        private final LightSensorComponent lightSensor;<br/>        private final UltrasonicDistanceSensorComponent distanceSensor;<br/><br/>        public SendMeasurements(HiveMqManager hiveMqManager,<br/>                                HumiTempComponent dht11,<br/>                                LightSensorComponent lightSensor,<br/>                                UltrasonicDistanceSensorComponent distanceSensor) {<br/>            this.hiveMqManager = hiveMqManager;<br/>            this.dht11 = dht11;<br/>            this.lightSensor = lightSensor;<br/>            this.distanceSensor = distanceSensor;<br/>        }<br/><br/>        @Override<br/>        public void run() {<br/>            var sensor = new Sensor(dht11.getTemperature(), dht11.getHumidity(),<br/>                    lightSensor.readLight(2), distanceSensor.measure());<br/>            hiveMqManager.sendMessage(TOPIC_SENSORS, sensor.toJson());<br/>        }<br/>    }<br/>}</span></pre><h2 id="6cbb" class="lk jt hi bd ju lq lr ls jy lt lu lv kc iq lw lx kg iu ly lz kk iy ma mb ko mc bi translated">Pi4J的配置</h2><p id="711d" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">正如您在前面的类中看到的，Pi4J上下文是用<code class="du lc ld le lf b">CrowPiPlatform.buildNewContext()</code>初始化的。Pi4J使用插件结构，因此易于维护和扩展附加功能。在大多数情况下，我们可以依靠<code class="du lc ld le lf b">Pi4J.newAutoContext()</code>进行初始化，但是因为我们明确需要PiGpio插件的功能，所以我们使用一个助手类来确保Pi4J加载正确的插件。PiGpio是Pi4J用来处理Gpio的本地库(用C编写)。</p><pre class="jf jg jh ji fd lg lf lh li aw lj bi"><span id="890b" class="lk jt hi lf b fi ll lm l ln lo">public static Context buildNewContext() {<br/>    // Initialize PiGPIO<br/>    var piGpio = PiGpio.newNativeInstance();<br/><br/>    // Build Pi4J context with this platform and PiGPIO providers<br/>    return Pi4J.newContextBuilder()<br/>            .noAutoDetect()<br/>            .add(new CrowPiPlatform())<br/>            .add(<br/>                    PiGpioDigitalInputProvider.newInstance(piGpio),<br/>                    PiGpioDigitalOutputProvider.newInstance(piGpio),<br/>                    PiGpioPwmProvider.newInstance(piGpio),<br/>                    PiGpioI2CProvider.newInstance(piGpio),<br/>                    PiGpioSerialProvider.newInstance(piGpio),<br/>                    PiGpioSpiProvider.newInstance(piGpio)<br/>            )<br/>            .build();<br/>}</span></pre><h2 id="53b3" class="lk jt hi bd ju lq lr ls jy lt lu lv kc iq lw lx kg iu ly lz kk iy ma mb ko mc bi translated">传感器代码</h2><p id="62f6" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">如果你正在寻找一个特定的传感器，看一看这个项目的全部源代码或者Pi4J CrowPi项目。</p><p id="c0f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们来看看其中的一个组件:声音传感器。这是一个简单的<code class="du lc ld le lf b">DigitalInput</code>传感器，它的所有代码都在<code class="du lc ld le lf b">SoundSensorComponent.java</code>中实现。我们只需要实现一些方法来处理引脚在低电平(静音)和高电平(检测到声音)之间的变化。</p><p id="7108" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">pin由以下代码部分初始化:</p><pre class="jf jg jh ji fd lg lf lh li aw lj bi"><span id="29f1" class="lk jt hi lf b fi ll lm l ln lo">protected DigitalInputConfig buildDigitalInputConfig(Context pi4j, int address, long debounce) {<br/>    return DigitalInput.newConfigBuilder(pi4j)<br/>            .address(address)<br/>            .id("BCM" + address)<br/>            .name("SoundSensor")<br/>            .pull(PullResistance.PULL_UP)<br/>            .debounce(debounce)<br/>            .build();<br/>}</span></pre><p id="6c8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Pi4J还提供了一个构建器模式来配置GPIOs。对于这个属于<code class="du lc ld le lf b">DigitalInput</code>的传感器，我们需要配置:</p><ul class=""><li id="b8d4" class="md me hi ih b ii ij im in iq mf iu mg iy mh jc mi mj mk ml bi translated">地址:它所连接的引脚CrowPi上的BCM 24</li><li id="7af4" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">唯一的ID，因此Pi4J可以在它的生命周期内处理它</li><li id="b456" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">名称:供我们自己参考，例如在测井中</li><li id="fe79" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">拉高或拉低:需要如何处理状态变化</li><li id="f880" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">去抖:状态变化之间的间隔，以避免状态变化之间过快的“乒乓”</li></ul><h1 id="8da8" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">CrowPi OS</h1><p id="f143" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">你可以在任何装有Java的Raspberry Pi操作系统上运行这个项目，但是当你在CrowPi上运行它时，你可以通过使用Pi4J项目的一部分<a class="ae jd" href="https://pi4j.com/getting-started/crowpi/crowpi-os/" rel="noopener ugc nofollow" target="_blank"> CrowPi操作系统</a>来启动它(再次感谢FHNW大学)。</p><p id="9507" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CrowPi中的一些传感器(距离和湿度)需要非常严格的时间来获得可靠的数据结果。这在Linux系统上很难实现，无论是Python还是Java。在Linux中可以进行一些调整来改善结果，这些是默认在<a class="ae jd" href="https://pi4j.com/getting-started/crowpi/crowpi-os/" rel="noopener ugc nofollow" target="_blank"> CrowPi Os </a>中提供的，CrowPi Os基于Raspberry Pi OS，但对CrowPi进行了一些额外的改进。</p><p id="3d96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是即使做了这些调整，结果也不是100%可靠。这种传感器更适合Arduino或Raspberry Pi Pico等微控制器。也可以使用实时操作系统，如Cherie Tan的<a class="ae jd" href="https://all3dp.com/2/rtos-raspberry-pi-real-time-os/" rel="noopener ugc nofollow" target="_blank">“Raspberry Pi实时操作系统(RTOS):选择哪个”</a>所述。</p><p id="c6b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一点:该项目使用倾斜传感器，需要通过CrowPi板上的dip开关来启用:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es nc"><img src="../Images/c34b82c6dbb8b69515134c7dedd0f36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qp1V_XW-eOnB3vb9.png"/></div></div></figure><h1 id="d7df" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在Raspberry Pi上构建和运行</h1><p id="ab09" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您可以在PC上开发一个Java项目，并将jar文件复制到Raspberry Pi。或者复制源代码并在板上编译。或者当然在Raspberry Pi本身上开发(例如使用Visual Studio代码)。各有利弊。在<a class="ae jd" href="https://pi4j.com/getting-started/" rel="noopener ugc nofollow" target="_blank">Pi4J-网站的“入门”部分</a>中，提供了每种方法的更多信息。</p><p id="58bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您只想运行这个示例应用程序，最简单的方法可能是安装Maven，下载源代码并在Raspberry Pi上构建和运行。如果您想快速入门，您可以克隆代码并在几行代码中运行它:</p><pre class="jf jg jh ji fd lg lf lh li aw lj bi"><span id="de3c" class="lk jt hi lf b fi ll lm l ln lo">$ sudo apt install maven <br/>$ git clone https://github.com/FDelporte/HiveMQ-examples.git <br/>$ cd HiveMQ-examples/java-to-hivemq <br/>$ mvn package <br/>$ cd target/distribution <br/>$ sudo bash run.sh</span></pre><p id="488c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一些启动记录之后，您将看到不同传感器的预定消息和事件，例如在运动和噪声传感器事件下面。</p><pre class="jf jg jh ji fd lg lf lh li aw lj bi"><span id="4b8c" class="lk jt hi lf b fi ll lm l ln lo">Message sent to 'crowpi/sensors': {"temperature":12.0,"humidity":154.0,"light":170.0,"distance":159.57}<br/>Message sent to 'crowpi/sensors': {"temperature":12.0,"humidity":154.0,"light":169.16666666666669,"distance":168.88}<br/>Message sent to 'crowpi/motion': {"value":true}<br/>Message sent to 'crowpi/sensors': {"temperature":12.0,"humidity":154.0,"light":169.16666666666669,"distance":167.44}<br/>Message sent to 'crowpi/motion': {"value":false}<br/>Message sent to 'crowpi/sensors': {"temperature":12.0,"humidity":154.0,"light":163.33333333333334,"distance":167.77}<br/>Message sent to 'crowpi/noise': {"value":false}<br/>Message sent to 'crowpi/noise': {"value":true}</span></pre><h1 id="dbd4" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">WebSocket测试页面</h1><p id="7d5d" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我们的应用程序的日志显示数据被发布到HiveMQ Cloud，但是我们希望在继续创建客户端之前进行确认…幸运的是，有一个websocket客户端，我们可以使用它非常容易地进行这个测试！前往<a class="ae jd" href="http://www.hivemq.com/demos/websocket-client/" rel="noopener ugc nofollow" target="_blank">hivemq.com/demos/websocket-client/</a>，用你的证件填写所有字段。确保选中<code class="du lc ld le lf b">SSL</code>复选框！当所有内容都正确填写后，点击<code class="du lc ld le lf b">Connect</code>按钮，你会在顶部看到一个绿色的<code class="du lc ld le lf b">connected</code>指示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es nd"><img src="../Images/3bf39a7a23c992df10fb658c164f2d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3G8FKoEbtjj_b0lV.png"/></div></div></figure><p id="717a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以定义想要订阅的主题，例如“crowpi/motion”、“crowpi/sensors”…一旦从我们的Raspberry Pi推送消息，它们就会显示在这个web测试页面中。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ne"><img src="../Images/8ddb2571ecb5cec315365295aef9f409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/0*PvaBFvNFNVze-20u.png"/></div></figure><p id="0c94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太好了！我们有从我们的Raspberry Pi流向HiveMQ Cloud的数据！！！</p><h1 id="6645" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="ddd4" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">与往常一样，当您将Java与Maven结合起来时，这样的项目可以用最少的代码实现，并且仍然易于理解和管理。Pi4J添加了必要的工具来隐藏处理GPIOs的复杂性，并将电子组件“转换”为Java对象。</p><p id="51af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多亏了HiveMQ云服务，我们可以将多达100台设备的数据免费发布到一个始终在线的免维护消息代理！结合便宜的树莓酱，一个充满机会的世界向所有制造商敞开。</p><p id="0b45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本系列的下一篇文章中，我们将在仪表板中可视化传感器的数据。当然，在Raspberry Pi上再次使用Java(和JavaFX )!</p></div><div class="ab cl nf ng gp nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hb hc hd he hf"><p id="9eed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="nm">本文应HiveMQ的要求而写，最初发表于HiveMQ的博客</em><a class="ae jd" href="https://www.hivemq.com/blog/mqtt-raspberrypi-part01-sensor-data-hivemqcloud-java-pi4j/" rel="noopener ugc nofollow" target="_blank"><em class="nm"/></a><em class="nm">。</em></p></div></div>    
</body>
</html>