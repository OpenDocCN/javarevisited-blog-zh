<html>
<head>
<title>Complete guide to serialization in java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">java序列化完全指南</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/complete-guide-to-serialization-in-java-44b36032157?source=collection_archive---------0-----------------------#2019-12-16">https://medium.com/javarevisited/complete-guide-to-serialization-in-java-44b36032157?source=collection_archive---------0-----------------------#2019-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d7b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://java2blog.com/core-java-tutorial-for-beginners-experienced/" rel="noopener ugc nofollow" target="_blank"> Java </a>提供了一种叫做<a class="ae jd" href="https://java2blog.com/serialization-in-java/" rel="noopener ugc nofollow" target="_blank">序列化</a>的机制，以字节有序或序列的形式持久化Java对象，包括对象的数据以及关于对象类型和存储在对象中的数据类型的信息。</p><p id="1e82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们需要序列化任何<a class="ae jd" href="https://java2blog.com/object-class-java/" rel="noopener ugc nofollow" target="_blank">对象</a>，那么它可以被读取，并使用对象的类型和其他信息进行反序列化，这样我们就可以检索原始对象。</p><p id="7923" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ObjectInputStream和ObjectOutputStream类是包含序列化和反序列化对象的方法的高级流。<br/> ObjectOutputStream有许多序列化对象的方法，但常用的方法是</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="6310" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，ObjectInputStream具有</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><h1 id="f012" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">java中需要序列化吗？</h1><p id="310e" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">当需要通过网络发送数据或存储在文件中时，通常使用序列化。我说的数据是指对象，而不是文本。</p><p id="7153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在的问题是你的网络基础设施和你的硬盘是理解位和字节但不理解Java对象的硬件组件。</p><p id="daa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">序列化是将Java对象的值/状态转换成字节，以便通过网络发送或保存。另一方面，反序列化是将字节码转换成相应的java对象。</p><h1 id="ac5c" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">serialVersionUID的概念:</h1><p id="3a95" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">serialVersionUID用于确保在反序列化过程中加载(在序列化过程中使用的)相同的类。serialVersionUID用于对象的版本控制。你可以在java序列化中的<a class="ae jd" href="http://www.java2blog.com/2013/03/serialversionuid-in-java-serialization.html" rel="noopener ugc nofollow" target="_blank"> serialVersionUID了解更多信息</a></p><p id="2f68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对于java中的序列化:</strong> <br/>步骤是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ko"><img src="../Images/eef3d1598cb0f4ce9c0088c477aacf86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*AOUFs3ukEcOma_p3LzKtmw.jpeg"/></div></figure><p id="38a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">举个例子:</strong> <br/>在src-&gt;org . arpit . javaportsforlearning中创建Employee.java</p><ol class=""><li id="8980" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated"><strong class="ih hj">Employee.java</strong></li></ol><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="fb5e" class="lf jm hi lb b fi lg lh l li lj">As you can see above,if you want to serialize any class then <strong class="lb hj">it must implement Serializable interface which is marker </strong><a class="ae jd" href="https://java2blog.com/interface-in-java-with-example/" rel="noopener ugc nofollow" target="_blank"><strong class="lb hj">interface</strong></a><strong class="lb hj">. </strong><br/>Marker interface in Java is interfaces with no field or methods or in simple word empty interface in java is called marker interface<br/>Create SerializeMain.java in src-&gt;org.arpit.javapostsforlearning</span></pre><p id="4aae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">2.SerializeMain.java</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><h1 id="0bb4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">对于反序列化:</h1><p id="2e6d" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">步骤是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/b012aa0c42ef335bc884396512b44fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*dQtw2Ucfv3KNxzwAWJMP5A.jpeg"/></div></figure><p id="c8ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在src-&gt; org . arpit . javaportsforlearning中创建DeserializeMain.java</p><p id="2b94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">3.DeserializeMain.java</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><h2 id="4543" class="lf jm hi bd jn ll lm ln jr lo lp lq jv iq lr ls jz iu lt lu kd iy lv lw kh lx bi translated">4.运行它:</h2><p id="4f79" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">首先运行SerializeMain.java，然后运行DeserializeMain.java，您将得到以下输出:</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="1232" class="lf jm hi lb b fi lg lh l li lj">Deserialized Employee...<br/>Emp id: 101<br/>Name: Arpit<br/>Department: CS</span></pre><p id="d409" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们序列化了一个employee对象，然后反序列化了它。这看起来很简单，但当涉及到引用对象、继承时，情况可能会非常复杂。因此，我们将一个接一个地看到不同的情况，以及我们如何在不同的场景中应用序列化。</p><h2 id="1a47" class="lf jm hi bd jn ll lm ln jr lo lp lq jv iq lr ls jz iu lt lu kd iy lv lw kh lx bi translated">案例1——如果一个对象引用了其他对象怎么办</h2><p id="d713" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们已经看到了非常简单的序列化情况，现在如果它也是对其他对象的引用呢？</p><p id="172b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那要怎么连载呢？引用对象也会被序列化吗？。</p><p id="9c2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，您不必显式序列化引用对象。当您序列化任何对象时，如果它包含任何其他对象引用，那么Java序列化将序列化该对象的整个对象图。</p><p id="5357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:假设Employee现在可以引用address对象，而address可以引用其他对象(例如Home ),那么当您序列化Employee对象时，所有其他引用对象(例如Address和home)都将被自动序列化。让我们创建地址类并添加地址对象作为对上述雇员类的引用。</p><p id="a322" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Employee.java: </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="ee59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在org . arpit . javaportsforlearning<br/>T3】address . Java:中创建Address.java</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="3f01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在org . arpit . javaportsforlearning中创建SerializeDeserializeMain.java</p><p id="5cf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">serializedeserializemain . Java:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="e3ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">运行它:</strong></p><p id="6f66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您运行SerializeDeserializeMain.java.You .时，您将获得以下输出</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="6227" class="lf jm hi lb b fi lg lh l li lj">java.io.NotSerializableException: org.arpit.javapostsforlearning.Address<br/>    at java.io.ObjectOutputStream.writeObject0(Unknown Source)<br/>    at java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)<br/>    at java.io.ObjectOutputStream.writeSerialData(Unknown Source)<br/>    at java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)<br/>    at java.io.ObjectOutputStream.writeObject0(Unknown Source)<br/>    at java.io.ObjectOutputStream.writeObject(Unknown Source)</span></pre><p id="a752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对出错的地方提出了异议。我忘了说，地址类也必须是可序列化的。因此，您必须通过实现serializable接口来使地址可序列化。</p><p id="f942" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Address.java: </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="deff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">再次运行:</strong></p><p id="5b98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您再次运行SerializeDeserializeMain.java.You .时，您将获得以下输出</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="323f" class="lf jm hi lb b fi lg lh l li lj">Deserialized Employee...<br/>Emp id: 101<br/>Name: Arpit<br/>Department: CS<br/>City :Pune</span></pre><p id="bb67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况2:如果你没有访问引用对象源代码的权限(例如，你没有访问上述地址类的权限)怎么办</strong> <br/>如果你没有访问地址类的权限，那么你将如何在地址类中实现可序列化接口。除此之外还有其他选择吗？是的，你可以创建另一个类来扩展地址并使其可序列化，但是在很多情况下它会失败:</p><ul class=""><li id="47ef" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc ly kx ky kz bi translated">如果类被声明为final怎么办</li><li id="1f75" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">如果类引用了其他不可序列化的对象。</li></ul><p id="6b37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么如何序列化Employee对象呢？所以解决方法是你可以让它暂时消失。如果你不想序列化任何字段，那么就让它成为瞬态的。</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="9bd2" class="lf jm hi lb b fi lg lh l li lj">transient Address address</span></pre><p id="5da3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以在运行程序时，在Employee类中进行地址转换之后。您将得到nullPointerException，因为在反序列化期间，地址引用将为null</p><p id="4e7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">情况3:如果您仍然想要保存引用对象(例如上面的地址对象)的状态，该怎么办:</strong></p><p id="c0c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您使地址成为瞬态的，那么在反序列化期间，它将返回null。但是，如果您仍然希望拥有与序列化地址时相同的状态，该怎么办呢？object.Java序列化提供了一种机制，如果您有带有特定签名的私有方法，那么它们将在序列化和反序列化期间被调用，因此，如果我们提供employee类的writeObject和readObject方法，它们将在Employee对象的序列化和反序列化期间被调用。</p><p id="3c48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Employee.java: </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="f5f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应该记住一点，ObjectInputStream应该按照我们将数据写入ObjectOutputStream相同顺序读取数据。<br/>在org . arpit . javaportsforlearning<br/>T5】address . Java:中创建Address.java</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="36c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在org . arpit . javaportsforlearning中创建SerializeDeserializeMain.java</p><p id="de22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">serializeserializemain . Java:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="372a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">运行它:</strong></p><p id="c5e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您运行SerializeDeserializeMain.java.You .时，您将获得以下输出</p><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="1942" class="lf jm hi lb b fi lg lh l li lj">Deserialized Employee...<br/>Emp id: 101<br/>Name: Arpit<br/>Department: CS<br/>City :Pune</span></pre><p id="54cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在我们得到了与序列化之前相同的地址对象状态。</p><h2 id="bdfb" class="lf jm hi bd jn ll lm ln jr lo lp lq jv iq lr ls jz iu lt lu kd iy lv lw kh lx bi translated">java中序列化的继承:</h2><p id="d140" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">现在我们将看到<a class="ae jd" href="https://java2blog.com/inheritance-java/" rel="noopener ugc nofollow" target="_blank">继承</a>如何影响序列化。因此，超类是否可序列化可能有多种情况。如果不是，那么你将如何处理它，它是如何工作的。</p><p id="42ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">举个例子。</strong> <br/>我们将创建Person.java，它将是雇员的超类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es me"><img src="../Images/265db74a679c3107e72acded97036506.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/0*4HALW780-5BTRhNT.gif"/></div></figure><p id="736e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例四:</strong> <strong class="ih hj">超类可序列化怎么办？如果超类是可序列化的，那么它的所有子类都是可自动序列化的。</strong></p><p id="7dcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例5:如果超类不可序列化怎么办？如果超类是不可序列化的，那么我们必须用完全不同的方式来处理它。</strong></p><ul class=""><li id="fccd" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc ly kx ky kz bi translated">如果超类是不可序列化的，那么它必须没有参数构造函数。</li></ul><p id="286e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Person.java</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="51ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在org . arpit . javaportsforlearning<br/><strong class="ih hj">employee . Java:</strong>中创建Employee.java</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="19a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在org . arpit . javaportsforlearning中创建SerializeDeserializeMain.java</p><p id="2ba9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">serializedeserializemain . Java:</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="e60b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">运行它:</strong></p><p id="e849" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您运行SerializeDeserializeMain.java.You .时，您将获得以下输出</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mf"><img src="../Images/24d9244b34866ac57a29e9a575127304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/0*eejrJal0fB906WKi.gif"/></div></figure><p id="4ae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果超类不可序列化，那么从超类继承的实例变量<a class="ae jd" href="https://java2blog.com/variables-java/" rel="noopener ugc nofollow" target="_blank">的所有值将在反序列化过程中通过调用不可序列化超类的构造函数来初始化。<strong class="ih hj"> </strong>所以这里的名称是从person继承的，所以在反序列化期间，名称被初始化为默认值。</a></p><p id="0820" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例6——如果超类是可序列化的，但你不希望子类是可序列化的</strong> <br/>如果你不希望子类是<code class="du mg mh mi lb b">Serializable</code>那么你需要在<strong class="ih hj">子类</strong>中实现<code class="du mg mh mi lb b">writeObject()</code>和<code class="du mg mh mi lb b">readObject()</code>方法，并需要从这些方法中抛出<strong class="ih hj">NotSerializableException</strong>。</p><p id="6ba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">案例7——你能序列化静态变量吗？</strong> <br/>不，你不能。如你所知，静态变量是在类级别而不是在对象级别，你序列化一个对象，所以你不能序列化静态变量。</p><p id="4fb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想对序列化有更多的控制，可以使用可外部化的接口来代替可序列化的接口。你可以在<a class="ae jd" href="http://www.java2blog.com/2014/02/externalizable-in-java.html" rel="noopener ugc nofollow" target="_blank">Java中的外部化</a>了解更多</p><h1 id="af2c" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">Java序列化教程:</h1><ul class=""><li id="f480" class="kr ks hi ih b ii kj im kk iq mj iu mk iy ml jc ly kx ky kz bi translated"><a class="ae jd" href="http://www.java2blog.com/2013/03/serialization-in-java.html" rel="noopener ugc nofollow" target="_blank">Java中的序列化</a></li><li id="77f9" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="http://www.java2blog.com/2017/02/java-serialization-interview-questions-and-answers.html" rel="noopener ugc nofollow" target="_blank"> Java序列化面试问答</a></li><li id="4435" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="http://www.java2blog.com/2013/03/serialversionuid-in-java-serialization.html" rel="noopener ugc nofollow" target="_blank">Java中的serialversionuid</a></li><li id="58b4" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="http://www.java2blog.com/2013/03/serialversionuid-in-java-serialization.html" rel="noopener ugc nofollow" target="_blank">序列化</a> <a class="ae jd" href="http://www.java2blog.com/2014/02/externalizable-in-java.html" rel="noopener ugc nofollow" target="_blank">可在java中外部化</a></li><li id="efc4" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="http://www.java2blog.com/2016/05/java-transient-keyword-with-example.html" rel="noopener ugc nofollow" target="_blank">Java中的瞬态关键字</a></li><li id="8f1e" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="http://www.java2blog.com/2017/02/difference-between-serializable-and-externalizable-in-java.html" rel="noopener ugc nofollow" target="_blank">Java中可序列化和可外部化的区别</a></li></ul><h1 id="de54" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">总结:</h1><ul class=""><li id="edfd" class="kr ks hi ih b ii kj im kk iq mj iu mk iy ml jc ly kx ky kz bi translated">java中的序列化是将Java对象的值/状态转换成字节，以便通过网络发送或保存。另一方面，反序列化是将字节码转换成相应的java对象。</li><li id="1ae1" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">序列化的好处是整个过程是独立于JVM的，这意味着一个对象可以在一个平台上序列化，而在一个完全不同的平台上反序列化。</li><li id="43be" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">如果你想序列化任何一个类，那么它必须实现可序列化的接口，也就是标记接口。</li><li id="1fcc" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">java中的标记接口是没有字段或方法的接口，或者简单地说，Java中的空接口称为标记接口</li><li id="4b13" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">serialVersionUID 用于确保在反序列化期间加载相同的对象(在序列化期间使用的)。serialVersionUID用于对象的版本控制。</li><li id="cf57" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">当您序列化任何对象时，如果它包含任何其他对象引用，那么Java序列化将序列化该对象的整个对象图。</li><li id="d5dc" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">如果不想序列化任何字段，那么就让它<a class="ae jd" href="https://java2blog.com/java-transient-keyword-with-example/" rel="noopener ugc nofollow" target="_blank">瞬态</a>。</li><li id="b01a" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">如果超类是可序列化的，那么它的子类也是自动可序列化的。</li><li id="c4b5" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">如果超类不可序列化，那么从超类继承的实例变量的所有值将在反序列化过程中通过调用不可序列化超类的<a class="ae jd" href="https://java2blog.com/constructor-java/" rel="noopener ugc nofollow" target="_blank">构造函数</a>来初始化。</li><li id="96b0" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">如果你不想让子类序列化，那么你需要实现writeObject()和readObject()方法，并从这些方法中抛出NotSerializableException。</li><li id="e15a" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated">不能序列化静态变量。</li></ul><h2 id="0d25" class="lf jm hi bd jn ll lm ln jr lo lp lq jv iq lr ls jz iu lt lu kd iy lv lw kh lx bi translated">您可能还喜欢:</h2><ul class=""><li id="1b15" class="kr ks hi ih b ii kj im kk iq mj iu mk iy ml jc ly kx ky kz bi translated"><a class="ae jd" href="https://java2blog.com/java-multithreading-interview-questions-and-answers/" rel="noopener ugc nofollow" target="_blank"> Java多线程面试试题</a>。</li><li id="8625" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="https://java2blog.com/java-interview-questions/" rel="noopener ugc nofollow" target="_blank"> Java面试问题</a></li><li id="55f1" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="https://java2blog.com/java-interview-questions-for-5-years-experience/" rel="noopener ugc nofollow" target="_blank"> Java面试题5年经验</a></li><li id="06a8" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="https://java2blog.com/core-java-interview-questions-and-answers/" rel="noopener ugc nofollow" target="_blank">核心java面试问题</a></li><li id="cab4" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="https://java2blog.com/java-collections-interview-questions/" rel="noopener ugc nofollow" target="_blank"> Java集合面试问题</a></li><li id="7a1d" class="kr ks hi ih b ii lz im ma iq mb iu mc iy md jc ly kx ky kz bi translated"><a class="ae jd" href="https://java2blog.com/java-thread-example/" rel="noopener ugc nofollow" target="_blank"> Java线程示例</a></li></ul><p id="6457" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是java中序列化的全部内容。</p></div></div>    
</body>
</html>