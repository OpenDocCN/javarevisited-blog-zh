<html>
<head>
<title>Patterns of Enterprise Application Architecture — Organizing Domain Logic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">企业应用架构模式——组织领域逻辑</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/patterns-of-enterprise-application-architecture-organizing-domain-logic-50efd9ea3f39?source=collection_archive---------2-----------------------#2022-03-09">https://medium.com/javarevisited/patterns-of-enterprise-application-architecture-organizing-domain-logic-50efd9ea3f39?source=collection_archive---------2-----------------------#2022-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c7fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第2章和第3章概述</p><p id="0b11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">继续我阅读马丁·福勒的《EAA的T2》的旅程，这篇文章将会是关于这本书的第二章和第三章。如果你还没有阅读<a class="ae jm" rel="noopener" href="/javarevisited/patterns-of-enterprise-application-architecture-by-martin-fowler-intro-3b7f68276a67">第一部分</a>的介绍章节，别忘了去看看。</p><p id="1067" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这种格式，我决定不写模式的代码示例。这会让文章变得比它需要的更长，也不符合我的意图<strong class="ih hj">总结</strong>这一章的内容。</p><figure class="jo jp jq jr fd js er es paragraph-image"><a href="https://www.java67.com/2019/09/top-5-courses-to-learn-system-design.html"><div class="er es jn"><img src="../Images/a371a7e4c22f4a43bf552f8acbaff872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YId-Tj_DkeZ1d7kPO4j4kA.jpeg"/></div></a><p class="jv jw et er es jx jy bd b be z dx translated">图一。分层架构</p></figure><h1 id="449f" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">第1章:分层</h1><p id="4bd0" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">本章将分层作为设计复杂软件系统的核心技术。这种技术类似于分层蛋糕中各层的排列，每一层都位于下层之上。</p><p id="083e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在分层系统中，较高层使用和消费较低层公开的服务，而不知道较低层内部如何工作。</p><h2 id="f962" class="lc ka hi bd kb ld le lf kf lg lh li kj iq lj lk kn iu ll lm kr iy ln lo kv lp bi translated">好处:</h2><ol class=""><li id="404a" class="lq lr hi ih b ii kx im ky iq ls iu lt iy lu jc lv lw lx ly bi translated">更容易<em class="lz">连贯</em>理解一个层，而不太了解其他层。</li><li id="0fe7" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">您可以用相同基本服务的替代实现来替代层。</li><li id="4705" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">封装:您最小化了层之间的依赖性，子系统之间的松散耦合。</li><li id="9c48" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">层是标准化的好地方。TCP/IP是标准，因为它们定义了它们的层应该如何操作。</li><li id="4e84" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">互操作性:一旦你构建了一个定义良好的层，你就可以把它用于许多其他的高级服务，例如TCP/IP被FTP、SSH、HTTP所使用。</li></ol><h2 id="423c" class="lc ka hi bd kb ld le lf kf lg lh li kj iq lj lk kn iu ll lm kr iy ln lo kv lp bi translated">缺点:</h2><ol class=""><li id="457a" class="lq lr hi ih b ii kx im ky iq ls iu lt iy lu jc lv lw lx ly bi translated">层不能很好地封装所有的东西，例如，添加一个要在UI上显示的字段意味着将它添加到DB和中间的所有层。</li><li id="b96a" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">额外的层会损害性能。每一层都有额外的延迟和某种形式的数据转换。然而，封装良好的层可以进一步优化，以挤出最后一点性能。</li></ol><p id="9a0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是分层体系结构最难的部分是知道有什么层以及每层应该有什么职责。</p><h1 id="4708" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">企业应用程序中各层的演变。</h1><figure class="jo jp jq jr fd js er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/09/microservices-design-patterns-principles.html"><div class="er es mf"><img src="../Images/a717c71a2f3e6dd0f559ca8bbddc168c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C47jqxnkj4g52zqSjtzCIQ.png"/></div></a><p class="jv jw et er es jx jy bd b be z dx translated">图2:企业架构</p></figure><p id="7e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到90年代，是客户端-服务器系统的兴起。客户机是某种形式的UI，而服务器通常是数据库服务器。对于小而简单的应用程序来说，这种设置很好，但是当应用程序决定使用复杂的领域逻辑时，问题就来了:业务规则、验证、计算等等。</p><p id="c7a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个没有正确解决方案的问题，无论你做什么，你都会遇到以下两个问题中的一个:</p><ol class=""><li id="6e0c" class="lq lr hi ih b ii ij im in iq mg iu mh iy mi jc lv lw lx ly bi translated">将业务逻辑存储在<strong class="ih hj">客户机</strong>中是不方便的，会导致许多重复、错误，并使代码难以处理或理解。此外，无论使用哪种UI供应商/框架，您都会受到束缚。</li><li id="41ce" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">由于有限的结构化机制，将业务逻辑作为<strong class="ih hj">存储过程存储在DB </strong>中是复杂的，这又导致了笨拙的代码。</li></ol><p id="75b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那时<a class="ae jm" rel="noopener" href="/javarevisited/6-best-object-oriented-programming-books-and-courses-for-beginners-d46235cbda49">面向对象</a>世界正在兴起，对这个问题有了答案:进入<strong class="ih hj">三层体系。</strong></p><p id="d50e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你把你的UI和/或DB服务器从逻辑中分离出来，并把它安排在一个中间层，现在称为后端，见图2。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h1 id="dd50" class="jz ka hi bd kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw bi translated">第2章:组织领域逻辑</h1><p id="4d87" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">现在，我们深入探讨如何在给定的三层应用程序中组织领域逻辑的问题。这里作者提到了三种主要模式:</p><h2 id="bcc0" class="lc ka hi bd kb ld le lf kf lg lh li kj iq lj lk kn iu ll lm kr iy ln lo kv lp bi translated">1.交易脚本</h2><p id="7dff" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这可以被认为是存储领域逻辑的最简单的方法。<em class="lz">事务脚本</em>是一个过程，它从UI获取输入，用一些验证和计算来处理它，将数据存储在<a class="ae jm" rel="noopener" href="/javarevisited/top-5-sql-and-database-courses-to-learn-online-48424533ac61"> DB </a>中，并从其他系统调用任何操作。</p><p id="0083" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">工作原理<br/> </strong>这种模式可以被认为是一种(<strong class="ih hj">动作脚本</strong>)方法。我们仍然会在子例程和函数中划分和安排重复的代码和逻辑，但是主要的逻辑安排风格是每个用例或动作一个脚本/方法。例如，一个零售系统会有一个<em class="lz">交易脚本</em>用于结账、向购物车添加东西等等。</p><p id="bd7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lz">事务脚本</em>可以有两种组织方式:<br/> 1 .单个类:其中每个类定义一个相关事务脚本的主题区域。<br/> 2。根据<em class="lz">事务脚本</em>的类:使用<a class="ae jm" href="https://en.wikipedia.org/wiki/Command_pattern#:~:text=Four%20terms%20always%20associated%20with,are%20stored%20in%20the%20command." rel="noopener ugc nofollow" target="_blank">命令模式</a>，你可以为你的命令定义一个超类型，指定一些<em class="lz">事务脚本</em>逻辑适合的执行方法。</p><p id="9e80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">何时使用<br/> </strong>这种模式的荣耀在于简洁。以这种方式组织逻辑只适用于少量的逻辑。随着逻辑变得越来越复杂，这种模式将更难管理，更难扩展，也更难理解。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h2 id="6355" class="lc ka hi bd kb ld le lf kf lg lh li kj iq lj lk kn iu ll lm kr iy ln lo kv lp bi translated">2.表格模块</h2><blockquote class="mv"><p id="d502" class="mw mx hi bd my mz na nb nc nd ne jc dx translated">表模块用数据库中每个表的一个类来组织域逻辑，此类的一个实例将包含对数据进行操作的各种过程。</p></blockquote><p id="3800" class="pw-post-body-paragraph if ig hi ih b ii nf ik il im ng io ip iq nh is it iu ni iw ix iy nj ja jb jc hb bi translated"><em class="lz"> ِTable模块</em>可以定义为处理数据库表或视图中所有行的业务逻辑的单个实例。这种模式的优势在于它允许您将数据和行为打包在一起。</p><p id="ec49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">工作原理</strong></p><p id="af1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从表面上看，<em class="lz">表模块</em>看起来很像一个普通的物体。关键的区别在于，它对正在处理的对象没有身份的概念。要对某个特定的项目做一些有用的事情，您需要事先通过id获取它，例如</p><pre class="jo jp jq jr fd nk nl nm nn aw no bi"><span id="0f2e" class="lc ka hi nl b fi np nq l nr ns">anEmployeeModule.getAddress(long employeeId)</span></pre><p id="3db0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，<em class="lz">表模块</em>与面向表的支持数据结构一起使用。这个表格形式通常是SQL调用的结果，保存在模拟SQL表的<a class="ae jm" href="https://wiki.c2.com/?RecordSet" rel="noopener ugc nofollow" target="_blank">记录集</a>中。</p><p id="034f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单词“Table”不一定表示DB表，这种模式适用于视图或频繁执行的查询。</p><p id="689b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">何时使用<br/> </strong> <em class="lz">表格模块</em>基于表格数据。所以很明显，当您使用<a class="ae jm" href="https://wiki.c2.com/?RecordSet" rel="noopener ugc nofollow" target="_blank">记录集</a>和类似SQL的DB访问数据时，您会用到它。当您的访问模式涉及处理大块数据并对其进行处理时也是如此。聚合、求和以及任何类型的分析都适合这种表示。</p><p id="b3f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种模式不能让你在组织复杂系统时享受到对象的全部力量，实例到实例的关系和多态在这里不能很好地工作。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h2 id="737b" class="lc ka hi bd kb ld le lf kf lg lh li kj iq lj lk kn iu ll lm kr iy ln lo kv lp bi translated">3.领域模型</h2><blockquote class="mv"><p id="43d7" class="mw mx hi bd my mz na nb nc nd ne jc dx translated">领域模型是包含行为和数据的领域的对象模型。</p></blockquote><p id="b1f7" class="pw-post-body-paragraph if ig hi ih b ii nf ik il im ng io ip iq nh is it iu ni iw ix iy nj ja jb jc hb bi translated">企业软件可能会变得非常复杂，包含大量的业务规则、验证逻辑、计算和边缘案例。这种复杂性正是设计对象的目的。领域模型创建了一个相互连接的对象网络，其中每个对象代表一些有意义的个体。</p><p id="a469" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">工作原理<br/> </strong>顾名思义，领域模型模仿了项目正在处理的<strong class="ih hj">数据和业务</strong>，最终，这就是<a class="ae jm" href="https://en.wikipedia.org/wiki/Domain-driven_design" rel="noopener ugc nofollow" target="_blank"> DDD </a>的全部内容。一个OO领域模型通常看起来与DB模型相似，但是仍然有一些不同。</p><p id="ed77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">领域中通常有两种类型的领域模型:</p><ol class=""><li id="236f" class="lq lr hi ih b ii ij im in iq mg iu mh iy mi jc lv lw lx ly bi translated"><strong class="ih hj">丰富的领域模型:</strong>这是当领域模型很复杂并且有很多移动的部分，使用继承、策略和其他著名模式的时候。<br/>这将导致强烈的<a class="ae jm" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch" rel="noopener ugc nofollow" target="_blank">关系阻抗不匹配</a>，并需要一个数据映射器(将在未来章节中讨论，敬请关注:)。</li><li id="3c70" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated"><strong class="ih hj">简单的领域模型</strong>:这适用于小型到中型的领域模型。这种模型看起来非常像数据库模型。这种情况不需要数据映射器，可以只使用活动记录(将在以后的章节中讨论)。</li></ol><p id="6777" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">人们应该小心作者所说的<strong class="ih hj">臃肿的对象问题。</strong>当一个给定的对象有一些边缘用例需要大量代码，而这些代码只在一些罕见的情况下才相关时，就会出现这个问题。</p><p id="271e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一个Order类，它和一些电子商务环境中的任何Order类一样有一些正常的职责，但是它有几个边缘用例，比如当用户在黑色星期五或任何其他需要检查和考虑的奇怪报价时会发生什么。</p><p id="01fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比方说，这个类有300行代码，其中100行在95%的时间里被使用，而剩下的200行，只在5%的时间里被使用。</p><p id="a770" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作者在这里提到，人们试图将这样的行为从类中分离出来，放在一些特定用途的类中。然而，他不鼓励这样的努力，因为它导致一个混乱的结构，很难遵循和很难找到，并将导致相同的逻辑在最后重复。此外，他认为这样的问题并不像预测的那样频繁，所以最好在它发生时处理它，而不是过早地试图解释它。</p><p id="7356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">何时使用它<br/> </strong>作者在这里给出了一些何时使用它的理由，比如当你有复杂且不断变化的业务规则，涉及验证、计算等等。但是我要说的是:由于这本书是在2002年面向对象兴起之初写的，可以肯定地说这种方法现在已经是一种标准了。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h1 id="4ffc" class="jz ka hi bd kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw bi translated">服务层</h1><blockquote class="mv"><p id="4e15" class="mw mx hi bd my mz na nb nc nd ne jc dx translated">服务层定义了应用程序与服务层的边界，服务层建立了一组可用的操作，并协调应用程序在每个操作中的响应。</p></blockquote><figure class="nu nv nw nx ny js er es paragraph-image"><a href="https://medium.com/javarevisited/8-best-online-courses-to-learn-service-oriented-soa-and-microservices-architecture-94c01d6b94e6"><div class="er es nt"><img src="../Images/c47b96c29977d53142d12a8d03ccf417.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/1*t1cOV6xVboDM2XM63VOB8A.gif"/></div></a><p class="jv jw et er es jx jy bd b be z dx translated">https://martinfowler.com/eaaCatalog/serviceLayer.html</p></figure><p id="3bea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理域逻辑的一种常见方式是将其分为两部分:位于底层域模型或表模块之上的服务层。</p><p id="cc2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此设置中，服务层将提供:</p><ol class=""><li id="fd3c" class="lq lr hi ih b ii ij im in iq mg iu mh iy mi jc lv lw lx ly bi translated">应用程序边界的清晰定义。</li><li id="569a" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">清除应用程序上下文的API。</li><li id="bc20" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">这是放置交易控制和安全检查等物品的天然场所。</li><li id="73fd" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">针对每个外部操作/请求的协调应用程序响应。</li></ol><p id="3d59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设计服务层的一个关键决策是<strong class="ih hj">在其中加入多少行为？</strong>要回答这个问题，我们必须绕过一个非常重要的话题。</p><h2 id="c411" class="lc ka hi bd kb ld le lf kf lg lh li kj iq lj lk kn iu ll lm kr iy ln lo kv lp bi translated">各种“商业逻辑”</h2><p id="6395" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这里作者提到，像许多其他设计师一样，他喜欢将“业务逻辑”分为两类:</p><p id="aaf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1- <strong class="ih hj">领域逻辑:</strong>纯粹与领域问题有关的逻辑，例如，在分派之前验证一些订单细节。</p><p id="748f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2- <strong class="ih hj">应用程序逻辑(有时称为工作流逻辑):</strong>与应用程序职责相关的逻辑。例如，当达到特定收入时通知经理，生成某种报告。</p><p id="5e9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将两种类型的逻辑都放在域模型对象中是不可取的，因为这往往不太一致，并且很难在不同的工作流工具中重新实现应用程序逻辑，甚至很难完全重构它以使用外部工具。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="6bf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到<strong class="ih hj">的问题，在服务层中放入多少行为？</strong>作者给出了两种变体:</p><ol class=""><li id="fc7d" class="lq lr hi ih b ii ij im in iq mg iu mh iy mi jc lv lw lx ly bi translated">领域外观:服务层在一种胖领域模型上实现为一组<strong class="ih hj"> <em class="lz">瘦</em> </strong>外观。它建立了一个边界和一组操作，客户端通过这些操作与应用程序进行交互。</li><li id="9b25" class="lq lr hi ih b ii ma im mb iq mc iu md iy me jc lv lw lx ly bi translated">操作脚本:服务层被实现为一组<strong class="ih hj"><em class="lz"/></strong>类，这些类直接实现<em class="lz">应用逻辑</em>，但是委托给<em class="lz">域逻辑</em>的域对象类。</li></ol><h1 id="6ded" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">摘要</h1><p id="9ee9" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">正如我们所看到的，这两章讨论了软件架构中的分层概念，以及如何使用它来以一致和清晰的方式处理组织和构建“业务逻辑”的问题。</p><p id="947e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很想知道你是否喜欢这个实验系列。你喜欢这种格式吗？在评论中分享你的想法！</p></div></div>    
</body>
</html>