<html>
<head>
<title>“Discovering” Microservices in Spring Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Spring Cloud中“发现”微服务</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/discovering-microservices-in-spring-cloud-bdb3f1d344c3?source=collection_archive---------0-----------------------#2020-10-19">https://medium.com/javarevisited/discovering-microservices-in-spring-cloud-bdb3f1d344c3?source=collection_archive---------0-----------------------#2020-10-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6552" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">寻找，你就会找到</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/26704317164b85e1df1806f4d0e4522f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OA5SEyFZQw-O1chCep1BBA.jpeg"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@dallasreedy" rel="noopener ugc nofollow" target="_blank">达拉斯里德</a>在<a class="ae jn" href="https://unsplash.com/photos/F2HTC_CF4Jo" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5802" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你是一名java开发人员，无论时间长短，你都会遇到<a class="ae jn" rel="noopener" href="/javarevisited/10-advanced-spring-boot-courses-for-experienced-java-developers-5e57606816bd?source=collection_home---4------0-----------------------"> spring boot </a>，并且很可能听说过<a class="ae jn" rel="noopener" href="/javarevisited/5-best-courses-to-learn-spring-cloud-and-microservices-1ddea1af7012"> spring cloud </a>。</p><p id="cf09" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Spring Cloud的<a class="ae jn" href="https://spring.io/projects/spring-cloud" rel="noopener ugc nofollow" target="_blank">文档</a>中为我们提供了以下关于Spring Cloud的介绍</p><blockquote class="kk kl km"><p id="e699" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">Spring Cloud为开发人员提供了工具来快速构建分布式系统中的一些常见模式(例如，配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导选举、分布式会话、集群状态)。</p></blockquote><p id="8274" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这一切看起来很棒，听起来甚至更棒。但是你的头几乎开始疼了，“<em class="kn">配置管理、服务发现、断路器、智能路由……”。</em>什么事？它是如何工作的？人生的意义是什么？</p><p id="d148" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">嗯！最后一个我想我回答不了，但是我可以从spring cloud的discovery服务的基础开始，以及你如何在服务之间进行通信。已经够近了，不是吗？</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="2d5e" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated">你需要什么</h2><ul class=""><li id="fc8b" class="lt lu hi jq b jr lv ju lw jx lx kb ly kf lz kj ma mb mc md bi translated">尤里卡服务器</li><li id="b0ea" class="lt lu hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">尤里卡客户</li><li id="731e" class="lt lu hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">耐心(一点点)</li></ul><h2 id="b670" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated">设置尤里卡服务器</h2><p id="02da" class="pw-post-body-paragraph jo jp hi jq b jr lv ij jt ju lw im jw jx mj jz ka kb mk kd ke kf ml kh ki kj hb bi translated">您需要设置一个<a class="ae jn" href="https://javarevisited.blogspot.com/2018/05/the-springbootapplication-annotation-example-java-spring-boot.html" rel="noopener ugc nofollow" target="_blank"> spring boot应用程序</a>，因为发现服务是eureka-server依赖项，</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="c261" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要用<a class="ae jn" href="https://www.java67.com/2018/12/top-5-spring-cloud-annotations-for-java.html" rel="noopener ugc nofollow" target="_blank"> @EnableEurekaServer </a>标记主应用程序类，</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="11b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">并提供尤里卡特有的属性</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="bb18" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，我们说在默认端口8761上运行我们的eureka服务器的spring boot应用程序。当然，这个端口可以是任何开放端口。在这种情况下，我们必须将所有注册服务指向该端口。在这里，我们保持简单。</p><p id="5e72" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们说，“registerWithEureka: false”时，我们不希望这个服务注册到Eureka服务。</p><p id="4903" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过“fetchRegistry: false”，我们禁用了本地注册表信息的缓存。相信我，这样可以省去很多麻烦。</p><p id="9fab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">启动它…..找到了。！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/02/top-5-spring-microservices-courses-with-spring-boot-and-spring-cloud.html"><div class="er es mo"><img src="../Images/cb8b027572d59017cfadcd060b7f4e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oh6MUqaLjleaizwTmJ4XLw.png"/></div></a><p class="jj jk et er es jl jm bd b be z dx translated">春季尤里卡仪表板</p></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="c08e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上一节中，我们看到了如何设置一个eureka服务器。但是，我们的尤里卡服务器的问题是，它没有发现任何东西，因为没有任何东西可以被发现。</p><p id="7f98" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们创建将被我们的eureka服务器发现的客户机。</p><p id="1731" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要创建一个可发现的客户机，我们必须确保用@EnableDiscoveryClient注释服务的主应用程序。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="7424" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这允许eureka服务器发现您的服务并将其注册到eureka服务器。</p><p id="6d6d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有趣的部分来了。一旦我们建立了多个这样的客户端，我们就可以在这些服务之间进行通信了。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="e534" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated">军种间通信</h2><p id="317c" class="pw-post-body-paragraph jo jp hi jq b jr lv ij jt ju lw im jw jx mj jz ka kb mk kd ke kf ml kh ki kj hb bi translated">我们可以通过三种方式在服务之间进行通信，并访问在不同服务中编写的API</p><ul class=""><li id="1623" class="lt lu hi jq b jr js ju jv jx mp kb mq kf mr kj ma mb mc md bi translated">使用Spring云发现客户端</li><li id="d90c" class="lt lu hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">使用ribbon负载平衡rest模板，或者</li><li id="abae" class="lt lu hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">使用假装客户端</li></ul><h2 id="58be" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated">1.Spring云发现客户端</h2><p id="d8a5" class="pw-post-body-paragraph jo jp hi jq b jr lv ij jt ju lw im jw jx mj jz ka kb mk kd ke kf ml kh ki kj hb bi translated">这里，我们将使用DiscoveryClient首先获取服务的所有注册实例，然后使用我们可信任的RestTemplate进行实际的API调用，如下所示。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div><p class="jj jk et er es jl jm bd b be z dx translated">发现客户端</p></figure><p id="33ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这太不理想了。例如，我们不能自动连接<a class="ae jn" href="https://javarevisited.blogspot.com/2017/02/how-to-consume-json-from-restful-web-services-Spring-RESTTemplate-Example.html" rel="noopener ugc nofollow" target="_blank"> RestTemplate </a>，我们必须负责实例化它。这是因为一旦我们用@EnableDiscoveryClient注释了我们的服务，所有的RestTemplates现在都有一个功能区拦截器来修改正在创建的URL。</p><p id="6672" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一个主要问题是我们如何获取服务实例，以及如何手动获取服务请求的实例。这剥夺了我们在服务实例间平衡负载的机会。</p><p id="b73e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是负载平衡rest模板发挥作用的地方。</p><h2 id="572e" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated">2.负载平衡的Rest模板</h2><p id="4e31" class="pw-post-body-paragraph jo jp hi jq b jr lv ij jt ju lw im jw jx mj jz ka kb mk kd ke kf ml kh ki kj hb bi translated">要使用Ribbon aware rest模板，我们需要创建一个带有@LoadBalanced注释的RestTemplate bean，这允许我们在客户端代码中“自动连接”rest template。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="156a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，DiscoveryClient和它之间的唯一区别是，它允许我们使用在eureka服务器上注册的自然服务名与该服务进行通信。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="800e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里“module-two”是被调用方模块的注册名。这干净多了。我们不需要选择需要向哪个服务实例发出请求。<a class="ae jn" rel="noopener" href="/hackernoon/top-5-spring-boot-and-spring-cloud-books-for-java-developers-75df155dcedc?source=---------23------------------">春云</a>会以循环的方式处理服务请求。</p><h2 id="1b62" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated">3.假装客户</h2><p id="f916" class="pw-post-body-paragraph jo jp hi jq b jr lv ij jt ju lw im jw jx mj jz ka kb mk kd ke kf ml kh ki kj hb bi translated">这是ribbon感知负载平衡rest模板的替代方案。为了启用Feign Client，我们需要用@EnableFeignClients注释来注释我们的应用程序类。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="7c7e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后用@FeignClient注释创建一个java接口，并提供被调用方的注册服务名。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="aa59" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这为名为“module-two”的服务定义了一个虚拟客户端。在这里，您可以定义需要从调用方服务访问的所有端点。</p><p id="13c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可能已经注意到，端点的定义正是您在spring控制器中定义端点的方式。这使得我们的客户非常自然，易于阅读和使用。</p><p id="e141" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请随意留下你的想法。我们非常感谢并鼓励任何形式的反馈。</p></div></div>    
</body>
</html>