<html>
<head>
<title>Use SpringBoot and QueryDSL to generate production-grade dynamic filters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SpringBoot和QueryDSL生成生产级动态过滤器</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/dynamic-query-predicate-generation-using-springboot-and-querydsl-fdb0d5d3555b?source=collection_archive---------0-----------------------#2022-09-30">https://medium.com/javarevisited/dynamic-query-predicate-generation-using-springboot-and-querydsl-fdb0d5d3555b?source=collection_archive---------0-----------------------#2022-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dfb9e1ebc583b53c91cff78c52680c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0HNaJHFQnslJAEXo"/></div></div><p class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="38a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我厌倦了为前端应用程序编写多个API端点来向用户显示过滤后的信息，所以我想出了一个通用的解决方案，它可以使用Spring Boot、QueryDSL和<a class="ae iu" rel="noopener" href="/javarevisited/5-best-spring-data-jpa-courses-for-java-developers-45e6438be3c9"> JPA </a>为任何表和任何数据库工作。使用这种方法，前端只需要调用一个端点，并传入列名、想要对该列执行的操作类型和值。</p><p id="9ec7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整的工作代码可以在我的<a class="ae iu" href="https://github.com/Abhi-Codes/querydsl-dynamic-query" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>上找到。</p><h1 id="7202" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">属国</h1><p id="39c8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">您需要将以下内容添加到pom文件中。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="c6e7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">实体</h1><figure class="kw kx ky kz fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2021/05/sql-and-database-phone-interview-questions.html"><div class="er es lc"><img src="../Images/8c5024276badb0de339defcc220f5ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*LQN54QP-MtNOWt7r9H20AQ.png"/></div></a><p class="iq ir et er es is it bd b be z dx translated">ER图</p></figure><p id="4fa5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一张<code class="du ld le lf lg b">Posts</code>表。一个帖子使用一对一映射与一个<code class="du ld le lf lg b">Post Type </code>表相关联。一个<code class="du ld le lf lg b">Post</code>由作者编写，并使用多对一映射与<code class="du ld le lf lg b">Users</code>表相关联。实体映射可以在<a class="ae iu" href="https://github.com/Abhi-Codes/querydsl-dynamic-query/tree/master/src/main/java/com/abhicodes/querydsldynamicquery/entity" rel="noopener ugc nofollow" target="_blank">这里</a>找到。一旦创建了实体，运行<code class="du ld le lf lg b">mvn clean install</code>来生成Q类。</p><h1 id="8e31" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">储存库</strong></h1><p id="ad2a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><code class="du ld le lf lg b">QueryDslPredicateExecutor</code>接口为我们的集合公开了一些非常有用的方法。我们今天要关注的是<code class="du ld le lf lg b">Iterable&lt;T&gt; findAll(Predicate var1)</code>方法。</p><p id="d709" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们今天的代码本质上将归结为允许我们的用户创建一个<code class="du ld le lf lg b">Predicate</code>，这样他们就可以自己搜索整个表。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="562d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建谓词</h1><p id="03f5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在我们有了这个<a class="ae iu" href="https://javarevisited.blogspot.com/2021/10/what-is-spring-data-repository.html" rel="noopener ugc nofollow" target="_blank">库</a>，我们真正需要做的就是允许我们的用户构建他们自己的<code class="du ld le lf lg b">Predicate</code>类来搜索他们想要的任何东西。</p><p id="fd51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个想法可以归结为允许用户创建自己的查询字符串，定义他们希望在表上执行的一系列<code class="du ld le lf lg b">AND</code>操作。我们的工作是解析这个查询并为它们创建<code class="du ld le lf lg b"><a class="ae iu" href="https://javarevisited.blogspot.com/2021/05/java-8-stream-lambda-expression-d.html" rel="noopener ugc nofollow" target="_blank">Predicate</a></code>。以下是查询的格式:</p><blockquote class="lh li lj"><p id="d410" class="iv iw lk ix b iy iz ja jb jc jd je jf ll jh ji jj lm jl jm jn ln jp jq jr js hb bi translated"><strong class="ix hj"> &lt;键&gt; &lt;操作符&gt; &lt;值&gt;，&lt;键&gt; &lt;操作符&gt; &lt;值&gt; </strong></p></blockquote><p id="c564" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Key — </strong>它基本上是来自实体类的字段名，对于嵌套字段，这是一种稍微不同的方法。在Post实体中，有一个<code class="du ld le lf lg b">postType</code>字段。为了在谓词中使用<code class="du ld le lf lg b">PostType</code>实体的<code class="du ld le lf lg b">Id</code>字段，我们需要在谓词中使用<code class="du ld le lf lg b">postType.id</code>，但是点会影响来自控制器的解析，所以我们通过创建映射到<code class="du ld le lf lg b">postType.id</code>的自定义键<code class="du ld le lf lg b">postType</code>来创建自定义映射。</p><p id="7288" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">操作员— </strong></p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="2aab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">值— </strong>它可以是字符串、日期、整数或双精度类型的任何值。</p><blockquote class="lh li lj"><p id="466c" class="iv iw lk ix b iy iz ja jb jc jd je jf ll jh ji jj lm jl jm jn ln jp jq jr js hb bi translated"><strong class="ix hj">用法</strong></p></blockquote><p id="94cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">过滤以显示包含标题<strong class="ix hj"> xyz — </strong> <code class="du ld le lf lg b">title-xyz</code>的博客</p><p id="da1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">过滤以提供动机博客— <code class="du ld le lf lg b">postType:2</code>(动机类型id为2)</p><p id="385e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">过滤以显示在两个日期之间创建的博客— <code class="du ld le lf lg b">createdAt()2022–09–01,2022–09–10</code></p><h1 id="5d56" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">创建搜索标准</strong></h1><p id="08bc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将如下定义单个搜索标准</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="693e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">公共谓词类</h1><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="9705" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先来了解一下上面的类。如您所见，它有一个方法<code class="du ld le lf lg b">getPredicate</code>，该方法将基于传递的SearchCriteria生成一个新的<code class="du ld le lf lg b">BooleanExpression</code>谓词。</p><p id="470b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我使用了QueryDSL <code class="du ld le lf lg b">Path</code>类的实现。这些类包含对您要查询的对象的属性的引用，并且可以给它们比较运算符来构建一个<code class="du ld le lf lg b">Predicate</code>。</p><p id="c0e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，我使用反射来确定被传递的<code class="du ld le lf lg b">Key</code>的类。</p><p id="c95f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续，现在我们需要的是将整个查询字符串解析成一串<code class="du ld le lf lg b">SearchCriteria</code>，然后从整个查询构建一个组合谓词。该类可能如下所示</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="37db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目前，重要的方法是<code class="du ld le lf lg b">from(String search)</code>方法。该方法使用regex从查询字符串创建SearchCriteria。然后构建采用每个标准，使用<code class="du ld le lf lg b">CommonPredicate</code>创建谓词，然后将它们组合在一起作为<code class="du ld le lf lg b">AND</code>操作，返回最终的谓词。这个谓词可以直接发送到我们的存储库！</p><h1 id="2fc4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">与服务和控制器类挂钩</h1><p id="912c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">服务类本质上是将过滤器格式化为搜索标准，从自动生成的谓词中获取BooleanExpression，并将其传递给存储库。</p><p id="d6e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://javarevisited.blogspot.com/2022/05/how-to-return-json-xml-or-thymeleaf-.html" rel="noopener ugc nofollow" target="_blank">控制器</a>类获取从客户端传递来的过滤器，并将它们传递给服务。正如您在下面看到的，我们可以传递多个查询参数来构建查询，客户端需要在该表及其相关表上过滤该查询。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/02/spring-boot-restful-web-service-example-tutorial.html"><div class="er es lo"><img src="../Images/4b2c161e853ce2605a2fda52b2be6738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Co0E8khD3lN_ZCPBM32a_w.png"/></div></a></figure><blockquote class="lh li lj"><p id="18d4" class="iv iw lk ix b iy iz ja jb jc jd je jf ll jh ji jj lm jl jm jn ln jp jq jr js hb bi translated">如果你喜欢这篇文章，请花点时间给我鼓掌👏(可以多次鼓掌)，关注我，甚至给我买杯咖啡<a class="ae iu" href="https://www.buymeacoffee.com/abhiandy" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/abhiandy</a></p></blockquote></div></div>    
</body>
</html>