<html>
<head>
<title>Build REST API with Spring Boot and Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring Boot和科特林构建REST API</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/build-rest-api-with-spring-boot-and-kotlin-e9b622366b68?source=collection_archive---------3-----------------------#2021-03-20">https://medium.com/javarevisited/build-rest-api-with-spring-boot-and-kotlin-e9b622366b68?source=collection_archive---------3-----------------------#2021-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="28da" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解如何使用Spring Boot和科特林构建一个简单的微服务应用程序。从Spring Framework 5.0开始，引入了对Kotlin的专用支持</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/008189774fb1c84300b8dbcf29ef9820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*-qaujr0H-sALV9AT.jpg"/></div></figure><h1 id="a32f" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">1.概观</h1><p id="548f" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在本文中，我们将使用Spring Boot 2.x和Kotlin构建一个REST API。同时，从Spring Framework 5.0开始引入了对Kotlin的专用支持。我们可以在官方的<a class="ae kt" href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions" rel="noopener ugc nofollow" target="_blank"> Spring框架文档</a>中读到支持的特性。</p><p id="4955" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">特别是，应用程序将通过REST API公开数据，并将数据保存在嵌入式H2数据库中。</p><h1 id="2bd7" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">2.用例</h1><p id="5026" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们将为员工信息应用程序构建Restful APIs。<strong class="jz hj">用户可以使用该应用程序</strong>创建、检索、更新和删除员工。雇员有一个id、用户名、名、姓、电子邮件id和出生日期。此外，员工的用户名必须是唯一的。</p><p id="883e" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><strong class="jz hj">我们将使用一个嵌入式H2数据库作为我们的数据源，同时使用</strong> <a class="ae kt" rel="noopener" href="/javarevisited/top-5-hibernate-online-training-courses-for-beginners-and-advance-java-programmers-469460596b2b"> <strong class="jz hj"> JPA </strong> </a> <strong class="jz hj">和</strong><a class="ae kt" rel="noopener" href="/javarevisited/top-5-books-to-learn-hibernate-for-java-developers-b2cb4b16ccd6?source=---------14------------------"><strong class="jz hj">Hibernate</strong></a><strong class="jz hj">来访问数据库</strong>中的数据。</p><h1 id="cf67" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">3.设置</h1><p id="ae6f" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们可以使用Spring Initializer工具创建一个Spring Boot应用程序。此外，我们可以在<a class="ae kt" href="https://theanirban.dev/build-rest-api-spring-boot-kotlin/" rel="noopener ugc nofollow" target="_blank">博客文章</a>中了解创建Spring Boot项目的其他方法。</p><p id="2c8c" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><strong class="jz hj">随后，我们将添加</strong><a class="ae kt" href="https://javarevisited.blogspot.com/2020/08/top-5-courses-to-learn-spring-mvc-for.html#axzz6qnblZnVj" rel="noopener ugc nofollow" target="_blank"><strong class="jz hj"><em class="kz">Spring Web</em></strong></a><strong class="jz hj"/><a class="ae kt" href="https://www.java67.com/2021/01/spring-data-jpa-interview-questions-answers-java.html" rel="noopener ugc nofollow" target="_blank"><strong class="jz hj">Spring Data JPA</strong></a><strong class="jz hj">【H2数据库】</strong><a class="ae kt" rel="noopener" href="/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e"><strong class="jz hj"><em class="kz">Spring Boot</em></strong></a><strong class="jz hj">dev tools作为依赖</strong>。因此，现在我们在<code class="du la lb lc ld b">build.gradle.kts</code>中有了所有基本的依赖关系，这将允许我们与Spring Boot和科特林一起工作:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="8f12" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">Gradle构建文件还包含一些重要的插件:</p><ul class=""><li id="f913" class="lg lh hi jz b ka ku kd kv kg li kk lj ko lk ks ll lm ln lo bi translated"><code class="du la lb lc ld b">kotlin-spring</code>编译器插件是在<code class="du la lb lc ld b">all-open</code>插件之上的一个包装器。<strong class="jz hj"/><code class="du la lb lc ld b"><strong class="jz hj">all-open</strong></code><strong class="jz hj">编译器插件确保</strong><a class="ae kt" rel="noopener" href="/javarevisited/top-5-courses-to-learn-kotlin-in-2020-dfc3fa7706d8?source=---------16------------------"><strong class="jz hj">Kotlin</strong></a><strong class="jz hj">类被注释并且它们的成员是</strong> <code class="du la lb lc ld b"><strong class="jz hj">open</strong></code> <strong class="jz hj">。这使得使用像Spring AOP这样的库变得很方便，这些库要求类是开放的，不像Kotlin类和它们的成员在默认情况下是final。</strong></li><li id="dc61" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">kotlin-jpa</code>编译器插件是<code class="du la lb lc ld b">no-arg</code>插件之上的一个包装器。<strong class="jz hj"/><code class="du la lb lc ld b"><strong class="jz hj">no-arg</strong></code><strong class="jz hj">编译器插件为标注有</strong> <code class="du la lb lc ld b"><strong class="jz hj">Entity</strong></code> <strong class="jz hj">、</strong> <code class="du la lb lc ld b"><strong class="jz hj">MappedSuperclass</strong></code> <strong class="jz hj">和</strong> <code class="du la lb lc ld b"><strong class="jz hj">Embeddable</strong></code> <strong class="jz hj">的类生成一个无参数构造函数。这确保了JPA(Java Persistence API)可以实例化该类，因为它期望为其实体定义一个无参数的构造函数。</strong></li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><h2 id="7b4a" class="lu jg hi bd jh lv lw lx jl ly lz ma jp kg mb mc jr kk md me jt ko mf mg jv mh bi translated">3.1.配置数据库</h2><p id="c6d7" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们必须配置H2数据库属性，以便Spring Boot可以创建数据源。为了定义这样的属性，我们可以使用外部配置。此外，我们可以使用属性文件、YAML文件、环境变量和命令行参数来定义这样的外部配置。</p><p id="1b76" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><strong class="jz hj">一般情况下，</strong><a class="ae kt" rel="noopener" href="/javarevisited/10-advanced-spring-boot-courses-for-experienced-java-developers-5e57606816bd?source=collection_home---4------0-----------------------"><strong class="jz hj"/></a><strong class="jz hj">提供了</strong> <code class="du la lb lc ld b"><strong class="jz hj">application.properties</strong></code> <strong class="jz hj">文件来默认定义此类数据库属性</strong>。属性文件使用键值格式。</p><p id="e3de" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><strong class="jz hj">或者，我们可以使用基于YAML的配置文件，这些文件使用分层数据</strong>。YAML文件大大有助于避免重复的前缀，并且与属性文件相比更具可读性:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="c09d" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">我们也可以使用<code class="du la lb lc ld b">application.yml</code>文件来定义hibernate属性:</p><ul class=""><li id="7e49" class="lg lh hi jz b ka ku kd kv kg li kk lj ko lk ks ll lm ln lo bi translated">我们将<code class="du la lb lc ld b">ddl-auto</code>属性设置为<code class="du la lb lc ld b">update</code>。它将根据应用程序中领域模型的修改来更新数据库模式。<br/>如果我们使用没有任何模式管理器的嵌入式数据库，这个缺省值是<code class="du la lb lc ld b">create-drop</code>。<br/> <strong class="jz hj">如果我们使用Liquibase或Flyway这样的模式管理器，我们应该考虑使用</strong> <code class="du la lb lc ld b"><strong class="jz hj">validate</strong></code> <strong class="jz hj">。</strong>它试图根据我们在应用程序中创建的实体来验证数据库模式，如果模式与实体规范不匹配，就会抛出一个错误。</li><li id="aad8" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">show-sql</code>属性允许记录<a class="ae kt" rel="noopener" href="/javarevisited/7-free-courses-to-learn-database-and-sql-for-programmers-and-data-scientist-e7ae19514ed2"> SQL语句</a>。</li><li id="5af5" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated">属性确保是否在启动时初始化模式。</li><li id="7531" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">dialect</code>属性确保<a class="ae kt" href="https://www.java67.com/2017/02/2-best-books-to-learn-hibernate-for-Java-Developers.html" rel="noopener ugc nofollow" target="_blank"> Hibernate </a>为选择的数据库生成更好的SQL。</li></ul><h1 id="1815" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">4.领域模型— Kotlin数据类</h1><p id="967e" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">领域模型是应用程序的核心部分。我们可以使用数据类创建一个领域模型<code class="du la lb lc ld b">Employee</code>。</p><p id="1017" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><strong class="jz hj">另外，</strong><a class="ae kt" rel="noopener" href="/javarevisited/7-free-courses-to-learn-kotlin-in-2020-327c3872c1e1?source=collection_home---4------2-----------------------"><strong class="jz hj"/></a><strong class="jz hj">中的一个</strong> <code class="du la lb lc ld b"><strong class="jz hj">data class</strong></code> <strong class="jz hj">会自动生成</strong><code class="du la lb lc ld b"><strong class="jz hj">equals/hashCode</strong></code><strong class="jz hj"/><code class="du la lb lc ld b"><strong class="jz hj">toString</strong></code><strong class="jz hj">和</strong> <code class="du la lb lc ld b"><strong class="jz hj">copy</strong></code> <strong class="jz hj">函数。</strong>此外，我们不需要像Java一样定义getter和setter方法:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><ul class=""><li id="0082" class="lg lh hi jz b ka ku kd kv kg li kk lj ko lk ks ll lm ln lo bi translated"><code class="du la lb lc ld b">@Entity</code>注释指定该类是一个实体，并映射到一个数据库表。</li><li id="717e" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">@Table</code>注释指定了用于映射的数据库表的名称。<br/> <strong class="jz hj">如果我们使用</strong> <code class="du la lb lc ld b"><strong class="jz hj">@Table</strong></code> <strong class="jz hj">标注而没有表名，那么</strong><a class="ae kt" rel="noopener" href="/javarevisited/10-best-spring-framework-books-for-java-developers-360284c37036"><strong class="jz hj">Spring</strong></a><strong class="jz hj">会从类名</strong>中生成表名。</li><li id="184b" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">@Id</code>注释指定了实体类中的主键属性。</li><li id="cd27" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">@GeneratedValue</code>注释指定了主键值的生成策略。</li><li id="5039" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">@Column</code>注释指定了持久属性的映射列。如果我们不使用<code class="du la lb lc ld b">@Column</code>注释，那么<a class="ae kt" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-spring-framework-for-java-developers-639db9348d25"> Spring </a>从属性名中生成列名。</li></ul><h1 id="8aad" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">5.贮藏室ˌ仓库</h1><p id="f556" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们将创建一个存储库接口来与数据库进行交互。<strong class="jz hj">此外，</strong> <code class="du la lb lc ld b"><strong class="jz hj">EmployeeRepository</strong></code> <strong class="jz hj">接口将从</strong> <code class="du la lb lc ld b"><strong class="jz hj">JpaRepository</strong></code> <strong class="jz hj">接口</strong>扩展而来。这确保了<code class="du la lb lc ld b">Employee</code>实体上的所有CRUD方法都可用:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><ul class=""><li id="41ef" class="lg lh hi jz b ka ku kd kv kg li kk lj ko lk ks ll lm ln lo bi translated"><code class="du la lb lc ld b">@Repository</code>注释指定该类是一个存储库，代表我们应用程序中的数据访问层。</li></ul><h1 id="a09e" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">6.服务</h1><p id="932d" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在，我们将创建一个服务类来提供业务逻辑。<strong class="jz hj">此外，服务层可以使用JPA </strong>与数据访问层进行交互。</p><p id="e5ae" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">我们通过<code class="du la lb lc ld b">EmployeeService</code>中的构造函数注入<code class="du la lb lc ld b">EmployeeRepository</code>的一个实例:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><ul class=""><li id="ab9a" class="lg lh hi jz b ka ku kd kv kg li kk lj ko lk ks ll lm ln lo bi translated"><code class="du la lb lc ld b">@Service</code>注释指定该类是一个服务。</li><li id="3725" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">getAllEmployees()</code>函数可以获取所有员工的列表。</li><li id="0441" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">getEmployeesById()</code>函数可以根据id提取一个员工。我们提供雇员id作为函数的参数。</li><li id="32ce" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">createEmployee()</code>功能可以创建新员工。我们提供新雇员所需的属性作为函数的参数。</li><li id="855c" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">updateEmployeeById()</code>函数可以根据id更新员工的详细信息。我们提供雇员id和属性作为函数的参数。</li><li id="caf5" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><code class="du la lb lc ld b">deleteEmployeesById()</code>函数可以根据id删除员工。我们提供雇员id作为函数的参数。</li></ul><h1 id="cdb7" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">7.控制器</h1><p id="5b9a" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们在调用底层服务的控制器层中实现所有CRUD操作的API。</p><p id="4142" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">我们定义一个<code class="du la lb lc ld b">EmployeeController</code>作为我们的控制器类。<strong class="jz hj">具体来说，它是一个</strong> <a class="ae kt" href="https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html#ixzz6OYNB9oii" rel="noopener ugc nofollow" target="_blank"> <strong class="jz hj"> REST控制器</strong> </a> <strong class="jz hj">，为创建、操作和删除员工</strong>提供端点。</p><p id="59c5" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><code class="du la lb lc ld b">EmployeeService</code>类被连接到控制器中以返回值。此外，为了简单起见，我们重用实体作为数据传输对象:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="a3f4" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><code class="du la lb lc ld b">@RestController</code>注释指定该类是一个控制器，能够处理请求。它结合了<code class="du la lb lc ld b">@Controller</code>和<code class="du la lb lc ld b">@ResponseBody</code>注释。</p><p id="8717" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><strong class="jz hj"> Spring提供了几个注释来处理不同的传入HTTP请求，比如GET、POST、PUT和DELETE </strong>。这些注释是<code class="du la lb lc ld b">@GetMapping</code>、<code class="du la lb lc ld b">@PostMapping</code>、<code class="du la lb lc ld b">@PutMapping</code>和<code class="du la lb lc ld b">@DeleteMapping</code>。</p><h1 id="770a" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">8.运行应用程序</h1><p id="e53c" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们可以在终端中使用以下命令运行应用程序:</p><pre class="iy iz ja jb fd mi ld mj mk aw ml bi"><span id="954b" class="lu jg hi ld b fi mm mn l mo mp">gradle bootRun</span></pre><p id="709f" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">Spring Boot应用程序将在<a class="ae kt" href="http://localhost:8080." rel="noopener ugc nofollow" target="_blank"> http://localhost:8080开始运行。</a></p><h1 id="4136" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">9.探索API</h1><h2 id="24a5" class="lu jg hi bd jh lv lw lx jl ly lz ma jp kg mb mc jr kk md me jt ko mf mg jv mh bi translated">9.1.创建员工</h2><p id="1fba" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们发送以下请求来创建员工:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="8cc3" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">我们收到以下<a class="ae kt" href="https://javarevisited.blogspot.com/2013/04/convert-json-array-to-string-array-list-java-from.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>格式的响应:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><h2 id="3a46" class="lu jg hi bd jh lv lw lx jl ly lz ma jp kg mb mc jr kk md me jt ko mf mg jv mh bi translated">9.2.获取所有员工</h2><p id="5493" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们发送以下请求来获取所有员工:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="4276" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">我们收到以下JSON格式的响应:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><h2 id="b664" class="lu jg hi bd jh lv lw lx jl ly lz ma jp kg mb mc jr kk md me jt ko mf mg jv mh bi translated">9.3.获得员工</h2><p id="f938" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们发送以下请求，根据员工id获取员工:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="6af3" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">我们收到以下JSON格式的响应:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><h2 id="ca1f" class="lu jg hi bd jh lv lw lx jl ly lz ma jp kg mb mc jr kk md me jt ko mf mg jv mh bi translated">9.4.更新员工</h2><p id="afa3" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们发送以下请求，根据员工id更新员工属性:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="df4f" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">我们收到以下JSON格式的响应:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><h2 id="1610" class="lu jg hi bd jh lv lw lx jl ly lz ma jp kg mb mc jr kk md me jt ko mf mg jv mh bi translated">9.5.删除员工</h2><p id="3fdc" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们发送以下请求，根据员工id删除一名员工:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="le lf l"/></div></figure><h1 id="1c65" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">10.结论</h1><p id="ae12" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在本教程中，我们研究了如何使用科特林和Spring Boot创建一个微服务应用并公开REST API。在这个过程中，我还使用了一些我们在构建这样的应用程序时可以利用的最佳实践。</p><p id="b58b" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">这些例子的代码可以在<a class="ae kt" href="https://github.com/anirban99/spring-boot-examples/tree/main/spring-boot-boilerplate" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h1 id="4c4d" class="jf jg hi bd jh ji mx jk jl jm my jo jp io mz ip jr ir na is jt iu nb iv jv jw bi translated">资源:</h1><ul class=""><li id="2597" class="lg lh hi jz b ka kb kd ke kg nc kk nd ko ne ks ll lm ln lo bi translated"><a class="ae kt" href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions" rel="noopener ugc nofollow" target="_blank"> Spring框架文档</a></li><li id="d4f7" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><a class="ae kt" href="https://www.expatdev.com/posts/how-to-create-a-spring-boot-project/" rel="noopener ugc nofollow" target="_blank">如何创建Spring Boot项目</a></li><li id="59d7" class="lg lh hi jz b ka lp kd lq kg lr kk ls ko lt ks ll lm ln lo bi translated"><a class="ae kt" href="https://github.com/anirban99/spring-boot-examples/tree/main/spring-boot-boilerplate" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></li></ul></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="bb06" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><em class="kz">最初发表于</em> <a class="ae kt" href="https://theanirban.dev" rel="noopener ugc nofollow" target="_blank"> <em class="kz">阿尼班的科技博客</em> </a></p></div></div>    
</body>
</html>