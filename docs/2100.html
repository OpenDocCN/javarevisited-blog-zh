<html>
<head>
<title>JAVA Developer Guide to start with Observer Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从观察者设计模式开始的JAVA开发人员指南</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-developer-guide-to-start-with-observer-design-pattern-17355b138329?source=collection_archive---------2-----------------------#2022-05-09">https://medium.com/javarevisited/java-developer-guide-to-start-with-observer-design-pattern-17355b138329?source=collection_archive---------2-----------------------#2022-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f11188e12972c118e0adafd6e112ecb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zt_MjUMW2yrqQZSd"/></div></div><p class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae iu" href="https://unsplash.com/@laughayette?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marten Newhall </a>拍摄的照片</p></figure><p id="6975" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你使用过<a class="ae iu" rel="noopener" href="/javarevisited/top-10-apache-kafka-online-training-courses-and-certifications-621f3c13b38c">卡夫卡</a>或者<a class="ae iu" href="https://javarevisited.blogspot.com/2020/05/top-16-jms-java-messaging-service-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank"> JMS </a>，你很可能知道发布-订阅交互模型。在消息传递应用程序中，当发布者对象生成主题内容时，订阅主题或话题的订阅者对象会收到通知。理论上，订阅服务器可以订阅多个发布服务器。观察者设计模式有助于解决发布/订阅模型，该模型允许许多观察者对象看到主题事件。</p><h1 id="781a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">观察者模式是什么？</h1><p id="4768" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://javarevisited.blogspot.com/2011/12/observer-design-pattern-java-example.html" rel="noopener ugc nofollow" target="_blank">观察者模式</a>是《设计模式:可重用面向对象软件的元素》一书中的<strong class="ix hj">行为设计模式</strong>之一。当对象之间存在一对多关系时，使用观察者模式，例如，如果一个对象被修改，它的依赖对象将被自动通知和更新。在这种模式中，观察另一个对象状态的对象称为<strong class="ix hj">观察者</strong>，被观察的对象称为<strong class="ix hj">主体</strong>。</p><p id="d955" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Twitter和脸书等所有社交媒体网站都是这种模式的典型例子。您关注一个用户，当该用户添加内容时，您和该用户的所有其他关注者都会收到通知。其他示例包括RSS提要和电子邮件订阅，您可以选择关注或订阅，并收到新提要的最新通知。</p><h1 id="c618" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">观察者模式JAVA示例</h1><p id="ec3e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">假设我们正在构建一个加密货币购买/销售应用程序，它允许用户根据收到的价格变化事件通知来触发购买或销售流程。对于这个例子，我将有几个观察者订阅加密货币。当加密货币价格下跌时，买方观察员将购买一些股票。同样，如果<a class="ae iu" href="https://javarevisited.blogspot.com/2022/01/5-best-courses-to-learn-cryptocurrency.html" rel="noopener ugc nofollow" target="_blank">加密货币</a>价格上涨，卖方观察员将卖出股票。</p><figure class="kx ky kz la fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/01/5-best-courses-to-learn-cryptocurrency.html"><div class="er es kw"><img src="../Images/eb463161824ed21fd436f92fa7e4153a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jOA_ZAql32zww5rw"/></div></a><p class="iq ir et er es is it bd b be z dx translated">杰里米·贝赞格在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="7dfd" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">主题定义</h2><p id="1e3a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在Subject接口中，声明了三个方法。<strong class="ix hj"> addObserver </strong>方法用于添加订阅者，<strong class="ix hj"> removeObserver </strong>方法用于删除现有订阅者，<strong class="ix hj"> notifyObservers </strong>方法用于向所有订阅者发送通知。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><p class="iq ir et er es is it bd b be z dx translated">主题界面</p></figure><h2 id="3763" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">具体主题</h2><p id="e669" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于具体的Subject，我创建了一个<strong class="ix hj"> CryptoCurrency </strong>类，其中包含了来自<strong class="ix hj"> Subject </strong>接口的所有实现方法，以及用于加密货币的名称和价格的新字段。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><p class="iq ir et er es is it bd b be z dx translated">具体主题</p></figure><h2 id="4f77" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">观察者定义</h2><p id="27ce" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在<strong class="ix hj">观察者</strong>接口中，只有一个方法被声明为<strong class="ix hj">通知</strong>，该方法将被具体的主体调用。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><p class="iq ir et er es is it bd b be z dx translated">观察者界面</p></figure><h2 id="9258" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">具体的观察者</h2><p id="6ba6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于具体的观察者，我创建了3个类。<strong class="ix hj"> PriceWatcher </strong>类被创建用来告诉更新<strong class="ix hj">加密货币</strong>具体主体的当前和以前的价格。<strong class="ix hj"> CryptoCurrencyBuyer </strong>类是为调用外部API在货币低于一定金额时购买加密货币而创建的。类似地，创建了<strong class="ix hj"> CryptoCurrencySeller </strong>类，用于在货币达到一定金额以上时调用外部API来出售加密货币。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><p class="iq ir et er es is it bd b be z dx translated">第一个具体的观察者</p></figure><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><p class="iq ir et er es is it bd b be z dx translated">第二具体观察者</p></figure><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><p class="iq ir et er es is it bd b be z dx translated">第三具体观察员</p></figure><h2 id="3a1d" class="lb ju hi bd jv lc ld le jz lf lg lh kd jg li lj kh jk lk ll kl jo lm ln kp lo bi translated">观察者模式在起作用</h2><p id="c4fc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在下面的演示代码中，创建了一个比特币和五个观察者。当比特币价格更新时，所有订户都会收到通知。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lp lq l"/></div><p class="iq ir et er es is it bd b be z dx translated">带输出的主方法</p></figure><p id="9b10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">源代码可从以下网址获得:<a class="ae iu" href="https://github.com/s3c-d43m0n/Desing-Patterns-in-JAVA/tree/main/Behavioral/Observer" rel="noopener ugc nofollow" target="_blank">https://github . com/s3c-d43m0n/Desing-Patterns-in-JAVA/tree/main/Behavioral/Observer</a></p><h1 id="c9b6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">实施中的关键点</h1><ul class=""><li id="b34a" class="lr ls hi ix b iy kr jc ks jg lt jk lu jo lv js lw lx ly lz bi translated">这里的<strong class="ix hj">主体</strong>和<strong class="ix hj">观察者</strong>是接口。但是它也可以是一个抽象类，并不局限于只使用接口。</li><li id="8a1e" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated"><strong class="ix hj">具体主体</strong>需要根据要求维护<strong class="ix hj">集合</strong>中的所有<strong class="ix hj">观察者</strong>。在这里，我使用了<strong class="ix hj"> CopyOnWriteArrayList </strong>(故障安全)集合来存储所有的观察器，因为我有一些<strong class="ix hj">观察器</strong>，它们将在<strong class="ix hj">notify observators</strong>方法中迭代时自行移除。</li><li id="73fc" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">当<strong class="ix hj">具体主体</strong>的状态发生变化时，需要调用<strong class="ix hj"> notifyObservers </strong>方法。</li><li id="7d52" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">每个<strong class="ix hj">具体观察者</strong>需要实现<strong class="ix hj">通知</strong>方法，以便根据其需求采取行动，消耗<strong class="ix hj">主题</strong>的变化。</li><li id="47f4" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">对于每个<strong class="ix hj">具体观察者</strong>，需要用<strong class="ix hj">添加观察者</strong>的方法与<strong class="ix hj">主体</strong>连接，用<strong class="ix hj">移除观察者</strong>的方法分离。</li></ul><p id="a701" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mf">你最喜欢的设计模式是什么，或者如果你想更好地理解任何其他模式或主题，请随时联系我，在</em><a class="ae iu" href="https://www.linkedin.com/in/ritvik92/" rel="noopener ugc nofollow" target="_blank"><em class="mf">LinkedIn</em></a><em class="mf">或</em><a class="ae iu" href="https://forms.gle/XFsuo1ZbP35gfqAX7" rel="noopener ugc nofollow" target="_blank"><em class="mf">Google Form</em></a><em class="mf">上，我下次会尽力介绍！</em></p><p id="2413" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请把这个分享给你所有的媒体朋友，然后点击那个👏按钮，以扩大它的范围。未来更新请关注 <a class="ae iu" rel="noopener" href="/@ritvik.singh.chauhan"> <em class="mf"> me </em> </a> <em class="mf">。感谢阅读。</em></p></div></div>    
</body>
</html>