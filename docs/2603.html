<html>
<head>
<title>What Is Method Overloading and Method Overriding in Java?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Java中的方法重载和方法重写？</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/what-is-method-overloading-and-method-overriding-in-java-latest-a7b74f83b7b6?source=collection_archive---------9-----------------------#2022-12-14">https://medium.com/javarevisited/what-is-method-overloading-and-method-overriding-in-java-latest-a7b74f83b7b6?source=collection_archive---------9-----------------------#2022-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="a193" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">面向对象编程</h2><div class=""/><div class=""><h2 id="b989" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">关于多态性你只需要知道。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/29e38ebb9ed3867db261ccc102fba581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhR0GNM_wrfEawQ4HfU2ZQ.jpeg"/></div></div><p class="js jt et er es ju jv bd b be z dx translated"><strong class="bd jw">un splash上Clément H拍摄的照片</strong></p></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="b58b" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">多态是面向对象编程中的关键概念之一。通过这篇文章，我们将学习方法重载和重写。这是初学者被问得最多的面试问题之一。此外，我们将理解定义重载和重写的规则，以及每个Java开发人员都应该知道的重要的基调。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="fc8c" class="la lb hi bd jw lc ld le lf lg lh li lj ix lk iy ll ja lm jb ln jd lo je lp lq bi translated">什么是方法重载？</h1><p id="f7cc" class="pw-post-body-paragraph ke kf hi kg b kh lr is kj kk ls iv km kn lt kp kq kr lu kt ku kv lv kx ky kz hb bi translated">1.方法重载意味着<strong class="kg hs">一个类中有两个或更多的方法有相同的名字但是不同的参数(实参)。</strong></p><p id="c877" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">2.方法<strong class="kg hs">可能有也可能没有不同的返回类型。</strong></p><p id="e223" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">3.<strong class="kg hs">方法重载减少了重复代码</strong>，并允许我们为不同的目的使用相同的方法名。</p><p id="e2ac" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">4.方法重载也称为<strong class="kg hs">编译时多态性</strong> <em class="lw">，因为在编译代码时，编译器会根据</em> <strong class="kg hs"> <em class="lw">方法名、返回类型和参数来决定要调用哪个方法。</em>T15】</strong></p><p id="f08b" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">5.重载也可能发生在继承的情况下。这是因为子类<strong class="kg hs"> <em class="lw">已经有了从父类</em> </strong>继承的方法的一个版本，并且还可以编写该方法的另一个重载版本。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="6fa7" class="la lb hi bd jw lc ld le lf lg lh li lj ix lk iy ll ja lm jb ln jd lo je lp lq bi translated">方法重载的规则是什么？</h1><p id="3760" class="pw-post-body-paragraph ke kf hi kg b kh lr is kj kk ls iv km kn lt kp kq kr lu kt ku kv lv kx ky kz hb bi translated">1.方法必须有<strong class="kg hs">相同的名字</strong>但是<strong class="kg hs">不同的方法签名</strong>(不同数量的参数，不同类型的参数，不同的参数序列)。</p><p id="c38b" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">2.重载方法<strong class="kg hs">可能有也可能没有不同的返回类型。</strong></p><p id="47cd" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">3.重载方法<strong class="kg hs">可能有也可能没有不同的访问修饰符。</strong></p><p id="d322" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">4.重载方法<strong class="kg hs">可能抛出不同的已检查或未检查异常。</strong></p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="0da2" class="la lb hi bd jw lc ld le lf lg lh li lj ix lk iy ll ja lm jb ln jd lo je lp lq bi translated">演示重载的示例程序:</h1><p id="bb3e" class="pw-post-body-paragraph ke kf hi kg b kh lr is kj kk ls iv km kn lt kp kq kr lu kt ku kv lv kx ky kz hb bi translated">在下面的程序中，我已经解释了<strong class="kg hs">方法重载的概念。在阅读程序时，我建议阅读与代码相关的注释，以便更好地理解。</strong></p><p id="1a7f" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">方法重载的一个例子:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lx ly l"/></div><p class="js jt et er es ju jv bd b be z dx translated">方法重载的一个例子</p></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="027e" class="la lb hi bd jw lc ld le lf lg lh li lj ix lk iy ll ja lm jb ln jd lo je lp lq bi translated">什么是方法重写？</h1><p id="3eec" class="pw-post-body-paragraph ke kf hi kg b kh lr is kj kk ls iv km kn lt kp kq kr lu kt ku kv lv kx ky kz hb bi translated">1.方法覆盖是用已经写在父类中的<strong class="kg hs">相同方法名和相同方法签名</strong>在子类中定义一个方法。</p><p id="4fcb" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">2.<strong class="kg hs">被覆盖方法的返回类型可以是父类方法的返回类型的子类型。</strong></p><p id="a0b8" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">例如，如果父类方法返回<strong class="kg hs">车辆</strong>，那么子类的被覆盖方法的返回类型可以是<strong class="kg hs">车辆</strong>类的任何子类，例如，<strong class="kg hs">汽车</strong>可以是子类中被覆盖方法的返回类型。(假设Vehicle为父类，Car为Vehicle类的子类)。</p><p id="32b6" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">3.它不能有更低的访问修饰符。</p><p id="b00b" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">例如，如果父类方法有一个受保护的访问修饰符，那么子类重写的方法不能有私有的访问修饰符，但是允许公共的。</p><p id="9954" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">4.对被覆盖的方法使用<strong class="kg hs"> @override annotation </strong>，这样如果我们不遵循覆盖规则，编译器就会显示错误。</p><p id="7fbf" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">5.方法覆盖被称为<strong class="kg hs">动态多态<em class="lw">，因为要调用的方法是由JVM在运行时决定的。</em> </strong></p><p id="aa12" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">6.<strong class="kg hs">静态方法不能被覆盖，</strong>只有实例方法被覆盖。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="51fe" class="la lb hi bd jw lc ld le lf lg lh li lj ix lk iy ll ja lm jb ln jd lo je lp lq bi translated">关于方法重写，有几点需要记住:</h1><p id="e570" class="pw-post-body-paragraph ke kf hi kg b kh lr is kj kk ls iv km kn lt kp kq kr lu kt ku kv lv kx ky kz hb bi translated">1.只有继承的方法可以被重写。</p><p id="ec84" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">2.不能重写构造函数和私有方法(仅对类可见)。</p><p id="065d" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">3.不能重写最终方法。</p><p id="b965" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">4.子类可以使用<code class="du lz ma mb mc b"><strong class="kg hs">super.methodName()</strong></code>来调用被覆盖方法的超类版本。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="9ee2" class="la lb hi bd jw lc ld le lf lg lh li lj ix lk iy ll ja lm jb ln jd lo je lp lq bi translated">演示覆盖的示例程序:</h1><p id="6ff8" class="pw-post-body-paragraph ke kf hi kg b kh lr is kj kk ls iv km kn lt kp kq kr lu kt ku kv lv kx ky kz hb bi translated">在下面的程序中，我已经解释了<strong class="kg hs">方法覆盖。在阅读程序时，我再次建议阅读与代码相关的注释，以便更好地理解。</strong></p><p id="f6e5" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">重写的示例:</p><p id="2fa8" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">将车辆视为父类:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lx ly l"/></div><p class="js jt et er es ju jv bd b be z dx translated">作为父类的车辆</p></figure><p id="d3e8" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">继承父类的子类:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lx ly l"/></div><p class="js jt et er es ju jv bd b be z dx translated">汽车作为子类</p></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="fe67" class="pw-post-body-paragraph ke kf hi kg b kh ki is kj kk kl iv km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated"><em class="lw">本文到此为止。希望你喜欢这篇文章。</em></p><h1 id="7595" class="la lb hi bd jw lc md le lf lg me li lj ix mf iy ll ja mg jb ln jd mh je lp lq bi translated">您可以关注<a class="mi mj ge" href="https://medium.com/u/2c3b611409dc?source=post_page-----a7b74f83b7b6--------------------------------" rel="noopener" target="_blank">维克拉姆·古普塔</a>了解类似内容。</h1></div></div>    
</body>
</html>