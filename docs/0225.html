<html>
<head>
<title>Project Valhalla: Fast and Furious Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">瓦尔哈拉工程:速度与激情Java</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/project-valhalla-fast-and-furious-java-ce2e46b4ee59?source=collection_archive---------0-----------------------#2019-12-30">https://medium.com/javarevisited/project-valhalla-fast-and-furious-java-ce2e46b4ee59?source=collection_archive---------0-----------------------#2019-12-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5b28" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">探索新内联类型的性能改进</h2></div><p id="6606" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我为2019年Java降临节日历写了这篇文章。我在这里重新发布了一些小的更正。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/eaf4c027498c284a65bc306c26fc4231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mhcbUyej6MW9TvDo.jpg"/></div></div><p class="kg kh et er es ki kj bd b be z dx translated"><a class="ae jt" href="https://pixabay.com/photos/fantasy-beautiful-dawn-sunset-sky-3077928/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/photos/fantasy-beautiful-dawn-sunset-sky-3077928/</a></p></figure><p id="e65b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Valhalla项目是关于Java和所有JVM的未来的最激动人心的项目之一。它仍处于实验状态，但在这篇文章中，我们将看看如何尝试它，我们将实现一个小程序来验证这种性能改进是可能的。</p><p id="92af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Valhalla的目标是引入一种新的内联类型(又名值类型)，它将:<em class="kk">“代码像类一样工作，就像int一样”</em>。</p><p id="587c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目前，在JVM中有八种原语类型，每一种都与字母表中的一个“签名字母”相关联:</p><p id="bfba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> B </strong>字节有符号字节<br/> <strong class="iz hj"> C </strong> char Unicode字符用UTF-16 <br/> <strong class="iz hj"> D </strong> double双精度浮点值<br/> <strong class="iz hj"> F </strong> float单精度浮点值<br/> <strong class="iz hj"> I </strong> int整数<br/> <strong class="iz hj"> J </strong>长整数<br/> <strong class="iz hj"> S </strong>短有符号短<br/><strong class="iz hj">Z<strong class="iz hj"/></strong></p><p id="9081" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，我们还有其他物品:</p><p id="e288" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类名引用了类名的一个实例</p><p id="1bee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你打印出一个通用对象的<code class="du kl km kn ko b">toString()</code>方法的结果，你可能会注意到签名字母。</p><p id="e051" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">瓦尔哈拉工程为一种新类型引入了一个新字母:</p><p id="0e3c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Q  ClassName内联类型</p><p id="da1f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些新类型最终将取代我们应用程序中的原始类型，移除当前的装箱类型(整数等)，带来一个仅基于引用和内联类型的无缝新世界。</p><p id="868b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这仍是未来的事，现在让我们享受一下当前早期版本中已经有的东西。</p><h2 id="ce8c" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">入门指南</h2><p id="7061" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">为了简化设置，项目瓦尔哈拉团队在8月30日发布了一个早期访问版本。</p><p id="7cb3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以从这里下载并在JAVA_HOME中将其配置为标准的http://jdk.java.net/valhalla/ JDK(版本14):<a class="ae jt" href="http://jdk.java.net/valhalla/" rel="noopener ugc nofollow" target="_blank"/></p><p id="06be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，目前(2019年12月)IntelliJ和Gradle无法编译具有该语言新功能的源代码。我们需要使用JDK的命令行工具或ant。</p><p id="4af7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在Github上分享了一个<a class="ae jt" href="https://github.com/uberto/testValueTypes" rel="noopener ugc nofollow" target="_blank">库</a>，里面有几个例子和运行它们所需的ant构建脚本。</p><h2 id="76f5" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">瓦尔哈拉角</h2><p id="28a3" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">让我们从一些非常简单的东西开始，让我们用两个坐标字段定义一个点类型。</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="4690" class="kp kq hi ko b fi lt lu l lv lw"><strong class="ko hj">inline</strong> public class Point {<br/>  public int x;<br/>  public int y;</span><span id="bbf2" class="kp kq hi ko b fi lx lu l lv lw">public Point(int x, int y) {<br/>    this.x = x;<br/>    this.y = y;<br/>  }<br/>}</span></pre><p id="8387" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">唯一的变化是第一行的关键字<code class="du kl km kn ko b"><strong class="iz hj">inline</strong></code>。Point是一个内联类型，现在我们来看看它与普通类的区别。</p><h2 id="5bf1" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">像类一样编码</h2><ul class=""><li id="dda6" class="ly lz hi iz b ja lk jd ll jg ma jk mb jo mc js md me mf mg bi translated">它可以使用<strong class="iz hj">新建</strong>来创建</li><li id="b80c" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">如您所见，您可以像普通类一样声明字段、构造函数和方法</li><li id="99c8" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">它可以实现一个接口，重写这些方法。</li><li id="5182" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">它可以由泛型使用，并且可以有泛型参数</li></ul><h2 id="e63b" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">像int一样工作</h2><ul class=""><li id="9422" class="ly lz hi iz b ja lk jd ll jg ma jk mb jo mc js md me mf mg bi translated">类型点是<strong class="iz hj">不可变</strong>。字段x和y被自动视为最终值。我们可以决定它们是私有的还是公共的，但是我们不能修改它们。</li><li id="087d" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">Point已经自动生成了equals、toString和hashcode方法。我们可以使用像int和double这样的<strong class="iz hj"> == </strong>运算符来测试它的相等性。</li><li id="374f" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">点没有空值。如果你想表示一个零点，你需要使用新的“内联加宽”，这是一种类固醇拳击。</li><li id="0721" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">点实例并不与它们的引用分开分配，它们直接在内存中表示，就像原始类型一样。</li><li id="7e51" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">Point有一个默认值，对应于Point(0，0)。您可以使用新的JVM <code class="du kl km kn ko b">default</code>指令创建一个“默认”点。</li><li id="3fa3" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">点不能从另一个类型继承，并且没有任何东西可以从它继承。</li></ul><h2 id="8573" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">工作进展</h2><p id="ab31" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">一些特性仍未完成，它们可能无法在当前版本中工作，或者会改变它们在未来版本中的工作方式。特别是:</p><ul class=""><li id="d1f8" class="ly lz hi iz b ja jb jd je jg mm jk mn jo mo js md me mf mg bi translated">不可能对内联类型使用同步操作。所以没有同步的方法、锁、等待/通知。</li><li id="b0fb" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">反射:不可能将它们与参照物区分开来。为此会有一些特殊的接口。</li><li id="c508" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">线程安全:目前不可能有一个易变的行为并在原子操作中使用它们。</li></ul><p id="f697" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要想更全面地了解瓦尔哈拉项目的特性，请参阅最后链接的文章。这里我们将集中讨论它的性能方面。</p><h2 id="da88" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">紧凑阵列</h2><p id="5617" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">内联类最令人兴奋的特性之一是创建数组的方式。</p><p id="f212" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在基元的情况下，数组的每个位置都有类型的直接表示；例如，在长数组的情况下，长数组的64位。</p><p id="d85a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相反，在引用对象的情况下，数组将只包含对在堆上分配内存的对象的引用。</p><p id="ed38" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着从数组中读取对象首先要读取引用，然后从它的实际位置获取内存。如果对象引用了字段，这些也会导致从远程内存位置获取数据。</p><p id="80ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，内联类型像原语一样工作。</p><p id="6b56" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了体验一下这有多重要，让我们制作一个简单的测试程序，对一个大数组中给定账户的所有交易求和。</p><p id="9d73" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们交易的简单表示，包括金额、账户和交易证券。</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="b2e2" class="kp kq hi ko b fi lt lu l lv lw">public class TradeRef {<br/>  public final double amount;<br/>  public final String account;<br/>  public final String security;<br/>  <br/>  public TradeRef(double amount, String account, String security){<br/>    this.amount = amount;<br/>    this.account = account;<br/>    this.security = security;<br/>  }</span><span id="e549" class="kp kq hi ko b fi lx lu l lv lw">@Override<br/>  public boolean equals(Object o) {<br/>    if (this == o) return true;<br/>    if (o == null || getClass() != o.getClass()) return false;<br/>    TradeRefEncoded that = (TradeRefEncoded) o;<br/>    <br/>    return Double.compare(that.amount, amount) == 0 &amp;&amp; <br/>      account == that.account &amp;&amp; security == that.security;<br/>  }</span><span id="44d1" class="kp kq hi ko b fi lx lu l lv lw">@Override<br/>  public int hashCode() {<br/>    return Objects.hash(amount, account, security);<br/>  }<br/>}</span></pre><p id="22e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，我们将定义一个<code class="du kl km kn ko b">TradeInline</code>类，与inline修饰符相同:</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="f010" class="kp kq hi ko b fi lt lu l lv lw">inline public class TradeInline {<br/>  final double amount;<br/>  final String account;<br/>  final String security;</span><span id="de01" class="kp kq hi ko b fi lx lu l lv lw">public TradeInline(double amount, String account, String sec){<br/>    this.amount = amount;<br/>    this.account = account;<br/>    this.security = sec;<br/>  }<br/>}</span></pre><p id="8f90" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编译完成后，我们可以从命令行使用<code class="du kl km kn ko b">javap</code>来打印生成的字节码:</p><p id="c0b4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kl km kn ko b">javap -s antbuild/com/ubertob/ministring/TradeInline.class</code></p><p id="4514" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是输出结果:</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="005a" class="kp kq hi ko b fi lt lu l lv lw">public final <strong class="ko hj">value</strong> class com.ubertob.ministring.TradeInline {</span><span id="1c87" class="kp kq hi ko b fi lx lu l lv lw">final double amount; descriptor: D</span><span id="7052" class="kp kq hi ko b fi lx lu l lv lw">final java.lang.String account; descriptor: Ljava/lang/String;</span><span id="8599" class="kp kq hi ko b fi lx lu l lv lw">final java.lang.String security; descriptor: Ljava/lang/String;</span><span id="e4fa" class="kp kq hi ko b fi lx lu l lv lw">public final int hashCode(); descriptor: ()I</span><span id="fcc5" class="kp kq hi ko b fi lx lu l lv lw">public final boolean equals(java.lang.Object); descriptor: (Ljava/lang/Object;)Z</span><span id="3c6b" class="kp kq hi ko b fi lx lu l lv lw">public final java.lang.String toString(); descriptor: ()Ljava/lang/String;</span><span id="868e" class="kp kq hi ko b fi lx lu l lv lw">public static com.ubertob.ministring.TradeInline com.ubertob.ministring.TradeInline(double, java.lang.String, java.lang.String); descriptor: (DLjava/lang/String;Ljava/lang/String;)<strong class="ko hj">Q</strong>com/ubertob/ministring/TradeInline;<br/>}</span></pre><p id="e62c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到:</p><ol class=""><li id="ce3e" class="ly lz hi iz b ja jb jd je jg mm jk mn jo mo js mp me mf mg bi translated">第一行中的值修饰符</li><li id="6479" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js mp me mf mg bi translated">最后一个列表中的Q描述符</li><li id="60d0" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js mp me mf mg bi translated">我们的源代码中没有的自动生成的方法<code class="du kl km kn ko b">hashCode</code>、<code class="du kl km kn ko b">equals</code>和<code class="du kl km kn ko b">toString</code>。</li></ol><h2 id="1915" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">将字符串编码为长整型</h2><p id="40cb" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">我们的<code class="du kl km kn ko b">TradeInline</code>类仍然有两个字符串作为字段。我们能把它们串联起来吗？</p><p id="354f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，目前不可能在内联类型中展平字符串和数组。未来有一个名为Array 2.0的计划可以实现这一点。</p><p id="6c13" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以做的是将一个字符串压缩到一个<code class="du kl km kn ko b">long</code>类型中，尽管我们需要接受一些限制。</p><p id="3143" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kl km kn ko b">long</code>类型有64位，所以使用基本64编码(6位)我们可以在里面存储多达10个字符。</p><p id="28d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，我们假设证券和账户的最大长度为10个字符，并且它们仅由大写字母、数字和有限数量的特殊字符组成。</p><p id="aa74" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们的<code class="du kl km kn ko b">MiniString</code>内联类型的代码，带有编码和解码静态函数:</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="9bff" class="kp kq hi ko b fi lt lu l lv lw">inline public class MiniString {<br/>  <br/>  long raw;</span><span id="6ca5" class="kp kq hi ko b fi lx lu l lv lw">public MiniString(String str) {<br/>    raw = encode(str);<br/>  }</span><span id="7db7" class="kp kq hi ko b fi lx lu l lv lw">public String get() {<br/>    return decode(raw);<br/>  }</span><span id="86b7" class="kp kq hi ko b fi lx lu l lv lw">public static final int MAX_MINISTR_LEN = 10;<br/>  public static final int MINI_STR_BASE = 64;<br/>  public static final String letters = "=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 _-!?.$&amp;%@#:[]{}()*&lt;&gt;:;',/^";<br/>  <br/>  public static long encode(String str) {<br/>    String prepared = prepareString(str);<br/>    long encoded = 0;<br/>    for (char c : prepared.toCharArray()) {<br/>      int x = letters.indexOf(c);<br/>      encoded = encoded * MINI_STR_BASE + x;<br/>    }<br/>    return encoded;<br/>  }</span><span id="5a2e" class="kp kq hi ko b fi lx lu l lv lw">private static String prepareString(String str) {<br/>    StringBuilder prepared = new StringBuilder();<br/>    for (char c : str.toCharArray()) {<br/>    if (letters.indexOf(c) &gt;= 0)<br/>      prepared.append(c);<br/>      if (prepared.length() &gt; MAX_MINISTR_LEN)<br/>        break;<br/>      }<br/>    return prepared.toString();<br/>  }</span><span id="8092" class="kp kq hi ko b fi lx lu l lv lw">public static String decode(long number) {<br/>    StringBuilder decoded = new StringBuilder();<br/>    long remaining = number;<br/>    while (true) {<br/>      int mod = (int) ( remaining % MINI_STR_BASE);<br/>      char c = letters.charAt(mod);<br/>      decoded.insert(0, c);<br/>      if ( remaining &lt; MINI_STR_BASE)<br/>        break;<br/>      remaining = remaining / MINI_STR_BASE;<br/>    }<br/>    return decoded.toString();<br/>  }<br/>}</span></pre><p id="daa8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用新的<code class="du kl km kn ko b">MiniString</code>为帐户和安全性定义一个<code class="du kl km kn ko b">TradeMiniString</code>内联类型。</p><p id="bc5e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是生成的字节码:</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="f3b3" class="kp kq hi ko b fi lt lu l lv lw">public final value class com.ubertob.ministring.TradeMiniString {<br/>final double amount; descriptor: D</span><span id="a23f" class="kp kq hi ko b fi lx lu l lv lw">final com.ubertob.ministring.MiniString account; descriptor: <strong class="ko hj">Q</strong>com/ubertob/ministring/MiniString;</span><span id="8e65" class="kp kq hi ko b fi lx lu l lv lw">final com.ubertob.ministring.MiniString security; descriptor: <strong class="ko hj">Q</strong>com/ubertob/ministring/MiniString;</span><span id="e0a1" class="kp kq hi ko b fi lx lu l lv lw">public final int hashCode(); descriptor: ()I</span><span id="077d" class="kp kq hi ko b fi lx lu l lv lw">public final boolean equals(java.lang.Object); descriptor: (Ljava/lang/Object;)Z</span><span id="82e4" class="kp kq hi ko b fi lx lu l lv lw">public final java.lang.String toString(); descriptor: ()Ljava/lang/String;</span><span id="42c6" class="kp kq hi ko b fi lx lu l lv lw">public static com.ubertob.ministring.TradeMiniString com.ubertob.ministring.TradeMiniString(double, java.lang.String, java.lang.String); descriptor: (D<strong class="ko hj">L</strong>java/lang/String;<strong class="ko hj">L</strong>java/lang/String;)<strong class="ko hj">Q</strong>com/ubertob/ministring/TradeMiniString;</span><span id="fd6c" class="kp kq hi ko b fi lx lu l lv lw">}</span></pre><p id="29ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意,<code class="du kl km kn ko b">MiniString</code>帐户的描述符是如何以内联类型的Q开头，而不是以引用类型的L开头的。</p><p id="3bea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，为了进行公平的比较，我们还定义了一个<code class="du kl km kn ko b">TradeRefEncoded</code>类，使用相同的技巧对类型为<code class="du kl km kn ko b">long</code>的字段中的账户和证券进行编码。</p><p id="f6d4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在我的GitHub <a class="ae jt" href="https://github.com/uberto/testValueTypes" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到完整的代码。</p><p id="09da" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在查看性能之前，我们先来看看我们的交易对象是如何使用内存的。</p><p id="8567" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一标准<code class="du kl km kn ko b">TradeRef</code>标准对象:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mq"><img src="../Images/a05be1918d221a5d4adcdfdb5016a83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*p_x4b5v97R0wgC8t"/></div></figure><p id="442d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">左边是我们的大数组。然后是一个指向TradeRef对象的指针，然后是另外两个指向字符串的指针。</p><p id="4932" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据创建的顺序，分配的内存区域在我们的堆中可能相距很远。</p><p id="d5d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个性能问题，因为从不同区域获取内存是CPU最慢的操作之一。</p><p id="0e96" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">马丁·汤姆森的这篇经典帖子是较好的解释之一:<br/><a class="ae jt" href="https://mechanical-sympathy.blogspot.com/2012/08/memory-access-patterns-are-important.html" rel="noopener ugc nofollow" target="_blank">https://mechanical-sympathy . blogspot . com/2012/08/memory-access-patterns-are-important . html</a></p><p id="b582" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看一个简单的内联级值内存表示图:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mq"><img src="../Images/672c042c518f9ec6e4213c36d7eec1c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*kMtH4SBOKERlchri"/></div></figure><p id="330b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里整个值对象直接在数组上。因此，数组比第一种情况大。因此，如果您的数组包含许多空值，压缩单元可能是一个缺点。反正对我们来说不是。</p><p id="a170" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，让我们看看TradeMiniString是如何在内存中分配的:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mr"><img src="../Images/cf44f7cbbb92323bc3407a2bddd01aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/0*zAw9gO6hnqEOcpeW"/></div></div></figure><p id="e333" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以看到它完全停留在数组元素内部，没有外部指针。</p><p id="1ead" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是可能的，因为我们接受对那些字符串中可以包含的内容的重大限制；尽管如此，当只使用字符串存储数据库或股票代码中的ID时，这是一个可以接受的折衷方案。</p><h2 id="77d5" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">性能比较</h2><p id="cd40" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">为了比较性能，我们可以创建四个500万个元素的数组，每个数组对应一种交易类型:</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="4ad1" class="kp kq hi ko b fi lt lu l lv lw">static final int arraySize = 5_000_000;</span><span id="4ff9" class="kp kq hi ko b fi lx lu l lv lw">public TradeRef[] tradeRefs = new TradeRef[arraySize];</span><span id="ea65" class="kp kq hi ko b fi lx lu l lv lw">public TradeRefEncoded[] tradesRefEncoded = new TradeRefEncoded[arraySize];</span><span id="7af8" class="kp kq hi ko b fi lx lu l lv lw">public TradeInline[] tradesInline = new TradeInline[arraySize];</span><span id="22cd" class="kp kq hi ko b fi lx lu l lv lw">public TradeMiniString[] tradesMiniString = new TradeMiniString[arraySize];</span></pre><p id="1089" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们用相同的随机值填充它们:</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="df0b" class="kp kq hi ko b fi lt lu l lv lw">public static void generatingTradesAndBrowing() {<br/>  var tr = new TradeRepository();<br/>  tr.fillWithRandomData();<br/>  var searcherRef = new TradeRefBrowser(tr.tradeRefs);<br/>  var searcherInline = new InlineTradeBrowser(tr.tradesInline);<br/>  var searcherRefEncoded = new TradeRefEncodedBrowser(tr.tradesRefEncoded);<br/>  var searcherMiniString = new MiniStringTradeBrowser(tr.tradesMiniString);<br/>  var account = tr.tradeRefs[1000].account;</span><span id="95f5" class="kp kq hi ko b fi lx lu l lv lw">while (true) {<br/>    benchmarks(searcherRef, searcherInline, searcherRefEncoded, searcherMiniString, account);<br/>  }<br/>}</span></pre><p id="46ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们反复搜索每一个，打印出经过的时间。</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="f9da" class="kp kq hi ko b fi lt lu l lv lw">private static void benchmarks(TradeRefBrowser searcherRef, InlineTradeBrowser searcherInline, TradeRefEncodedBrowser searcherRefEncoded, MiniStringTradeBrowser searcherMiniString, String account) {<br/>  cronoSum(() -&gt; searcherRef.sumByAccountFor(account), "Ref with for");<br/>  cronoSum(() -&gt; searcherRef.sumByAccountStream(account), "Ref with stream");<br/>  cronoSum(() -&gt; searcherRefEncoded.sumByAccountFor(account), "RefEncoded with for");<br/>  cronoSum(() -&gt; searcherRefEncoded.sumByAccountStream(account), "RefEncoded with stream");<br/>  cronoSum(() -&gt; searcherInline.sumByAccountFor(account), "Inline with for");<br/>  cronoSum(() -&gt; searcherMiniString.sumByAccountFor(account), "MiniString with for");<br/>}</span></pre><p id="e967" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们不太关心具体的数字，所以我们继续循环并打印结果。几分钟后，当Java Hotspot编译器优化并内联大多数方法时，计时趋于稳定。</p><p id="be70" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用两种方法进行过滤和求和:for循环或更好的流映射和reduce:</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="a74c" class="kp kq hi ko b fi lt lu l lv lw">public double sumByAccountStream(String account){<br/>  return Arrays.stream(repo)<br/>   .filter( trade -&gt; trade.account.equals(account))<br/>   .map(trade -&gt; trade.amount)<br/>   .reduce(0.0, (a, b) -&gt; a+b);<br/>}</span><span id="fe5b" class="kp kq hi ko b fi lx lu l lv lw">public double sumByAccountFor(String account){<br/>  double res = 0;<br/>  for (int i = 0; i &lt; repo.length; i++) {<br/>    TradeRef tradeRef = repo[i];<br/>    if (tradeRef.account.equals(account))<br/>      res = res + tradeRef.amount;<br/>  }<br/>  return res;<br/>}</span></pre><p id="5649" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，streams(还)不支持内联类，当我尝试时，我得到了这个错误:</p><pre class="jv jw jx jy fd lp ko lq lr aw ls bi"><span id="5b2e" class="kp kq hi ko b fi lt lu l lv lw">Exception in thread "main" java.lang.ClassFormatError: Illegal class name "Qcom/ubertob/ministring/TradeMiniString;" in class file &lt;Unknown&gt;<br/>at java.base/jdk.internal.misc.Unsafe.defineAnonymousClass0(Native Method)<br/>at java.base/jdk.internal.misc.Unsafe.defineAnonymousClass(Unsafe.java:1345)<br/>at java.base/java.lang.invoke.InnerClassLambdaMetafactory.spinInnerClass(InnerClassLambdaMetafactory.java:324)<br/>at java.base/java.lang.invoke.InnerClassLambdaMetafactory.buildCallSite(InnerClassLambdaMetafactory.java:192)<br/>at java.base/java.lang.invoke.LambdaMetafactory.metafactory(LambdaMetafactory.java:329)<br/>at java.base/java.lang.invoke.BootstrapMethodInvoker.invoke(BootstrapMethodInvoker.java:127)<br/>at java.base/java.lang.invoke.CallSite.makeSite(CallSite.java:307)<br/>at java.base/java.lang.invoke.MethodHandleNatives.linkCallSiteImpl(MethodHandleNatives.java:259)<br/>at java.base/java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:249)<br/>at com.ubertob.ministring.MiniStringTradeBrowser.sumByAccountStream(Unknown Source)</span></pre><p id="5d3a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此目前，我们只能使用for循环来衡量性能。</p><h2 id="3855" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">奇特的图表(终于)</h2><p id="039e" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">实际的数字在这里并不重要，所以我只是抓取了一个在我的Linux笔记本电脑上运行该应用程序的有意义的样本。</p><p id="b23a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们感兴趣的不是数字，而是它们之间的相对速度。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ms"><img src="../Images/4e6fed37f8da8b89d35ccccbc4520653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SS2VCZ5rLPFqegUpAgcm7g.png"/></div></div></figure><p id="0388" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以在这里看到这种情况下的改进是多么巨大:内联TradeMiniString快了20多倍！</p><p id="a4c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事件与TradeRefEncoded相比仍然快6倍！</p><p id="061c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这似乎好得难以置信，因此我们可以使用更好的方法来衡量实际性能。</p><p id="721d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Brendan Gregg编写了一些方便的工具来使用Linux内核性能工具来分析Java程序。</p><p id="17ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有几篇博文是关于如何制作以及如何阅读火焰图的:<a class="ae jt" rel="noopener" href="/netflix-techblog/java-in-flames-e763b3d32166"><br/>https://medium . com/网飞-tech blog/Java-in-flames-e 763 B3 d 32166</a></p><p id="9b01" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们的火焰:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mt"><img src="../Images/fa2461b2880cd4559708c27c0502ca2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OH-PUJUVXzeEWruK9sv1oQ.png"/></div></div></figure><p id="38c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在GitHub库<a class="ae jt" href="https://github.com/uberto/testValueTypes/blob/master/flame_java_4.svg" rel="noopener ugc nofollow" target="_blank">这里</a>找到实际的svg文件。</p><p id="2e18" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到四个绿色块(包括带箭头的块),表示这四种方法使用CPU的时间。在这个图中，绿色块是Java调用，而红色块是内核系统调用。</p><p id="93b8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">峰值是与结果打印和垃圾收集相关的其他方法。我们可以忽略它们。</p><p id="2fc3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从左边开始，第一个块是InlineTrade，使用常规字符串。它明显小于最后两个块，这两个块代表TradeRef和TradeRefEncoded。</p><p id="d548" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能已经猜到了，箭头所指的块是TradeMiniString duration，它非常短，您只能看到名称的几个字符。</p><p id="7b8e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">性能分析中每种方法的相对持续时间如下图所示:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mu"><img src="../Images/94e4d7239fa05ab6a1025f9ca3e6761b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYXlXyleBL13x6dWdIS00g.png"/></div></div></figure><p id="df74" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相对计时相似，内联比Ref快6倍，内联编码比Ref编码快5.5倍。</p><h2 id="bd06" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">结论</h2><p id="2e67" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">现在进行精确测量还为时过早，但已经很清楚，Valhalla内嵌类型有潜力为特定类型的关键应用带来巨大的性能提升。</p><p id="008f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仍然有许多粗糙的边缘和痛苦的决定要做，但瓦尔哈拉工程的整体形状是非常令人兴奋的。</p><p id="5aef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自从上一个早期版本以来，源代码已经有了很多改进。让我们希望有另一个稳定的版本来测试更多的功能。</p><h2 id="c562" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">了解更多信息的资源</h2><p id="7b72" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">这个和其他例子的完整代码:<br/><a class="ae jt" href="https://github.com/uberto/testValueTypes" rel="noopener ugc nofollow" target="_blank"/></p><p id="2210" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近一个关于德沃克斯的瓦尔哈拉的视频是<br/>https://devoxx.be/talk/?id=41660</p><p id="d014" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Brian Goetz谈瓦尔哈拉国<br/><a class="ae jt" href="http://cr.openjdk.java.net/~briangoetz/valhalla/sov/02-object-model.html" rel="noopener ugc nofollow" target="_blank">http://Cr . open JDK . Java . net/~ briangoetz/Valhalla/SOV/02-object-model . html</a></p><p id="36ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Ben Evans对内联类型的深入解释:<br/><a class="ae jt" href="https://www.infoq.com/articles/inline-classes-java/?itm_source=infoq&amp;itm_campaign=user_page&amp;itm_medium=link" rel="noopener ugc nofollow" target="_blank">https://www.infoq.com/articles/inline-classes-java</a></p><p id="5789" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我之前早期访问构建的帖子:<br/><a class="ae jt" rel="noopener" href="/@ramtop/a-taste-of-value-types-1a8a136fcfe2">https://medium . com/@ ram top/a-taste-of-value-types-1a8a 136 fcfe 2</a></p></div></div>    
</body>
</html>