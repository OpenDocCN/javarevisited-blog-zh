<html>
<head>
<title>Let’s Learn Together Sessions: The Project Lombok</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们一起学习会话:龙目岛项目</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/lets-learn-together-sessions-the-project-lombok-6eaabefa63da?source=collection_archive---------2-----------------------#2020-06-12">https://medium.com/javarevisited/lets-learn-together-sessions-the-project-lombok-6eaabefa63da?source=collection_archive---------2-----------------------#2020-06-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="60a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将告诉你Lombok，Java开发人员使用的最流行的库之一，它消除了Java的冗长。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0ca911ad071fa59005fdbea5c45f799e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8ikwMiYlStk56xU3"/></div></div><p class="jp jq et er es jr js bd b be z dx translated">在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jt" href="https://unsplash.com/@mtsjrdl?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mathis Jrdl </a>拍摄的照片</p></figure><h1 id="42c4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是龙目岛项目？</h1><p id="2c0a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">龙目岛是印尼的一个岛屿，可惜在这篇文章里，我们就不谈这个岛的美了。</p><p id="a394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java仍然是软件世界中最常用的编程语言之一，因为它是一种稳定、强大和有用的语言，所以years.Java赢得了这个位置。得益于这些，<a class="ae jt" rel="noopener" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"> Java </a>在不同的领域和用途中获得了越来越多的社区，从电子商务到图像处理应用。</p><p id="6d8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然人们乐于使用Java，但许多Java开发人员抱怨与其他编程语言相比，Java的结构过于冗长。龙目岛项目就在这一点上展开。project Lombok的官网对Lombok的定义是::</p><blockquote class="kx"><p id="d01e" class="ky kz hi bd la lb lc ld le lf lg jc dx translated">" Project Lombok是一个java库，可以自动插入到你的编辑器和构建工具中，增加你的java的味道."</p></blockquote><p id="ba1b" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">Lombok主要是<strong class="ih hj">减少样板代码</strong>和<strong class="ih hj">在开发过程中为开发者节约时间</strong>。它使用IDE在编译时生成所有这些样板代码。它使用Java自带的注释处理函数<a class="ae jt" href="https://jcp.org/aboutJava/communityprocess/final/jsr269/index.html" rel="noopener ugc nofollow" target="_blank"> JSR-269 </a>。</p><p id="c82c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Lombok </strong> </a> <strong class="ih hj">是一个开源项目</strong>，因此每个人都可以很容易地将Lombok作为一个依赖项添加到他们的项目中，这要感谢他们的依赖管理工具，例如<a class="ae jt" rel="noopener" href="/javarevisited/6-best-maven-courses-for-beginners-in-2020-23ea3cba89"> Maven </a>、<a class="ae jt" rel="noopener" href="/javarevisited/5-best-gradle-courses-and-books-to-learn-in-2021-93f49ce8ff8e"> Gradle、</a>或<a class="ae jt" href="https://javarevisited.blogspot.com/2015/01/difference-between-maven-ant-jenkins-and-hudson.html#axzz6d0HXyv00" rel="noopener ugc nofollow" target="_blank"> Ant </a>。因为Lombok在编译时生成代码，所以如果您第一次尝试使用Lombok，就会在构建时遇到解析器错误。Lombok通过为流行的ide解析器开发插件解决了这个问题。</p><p id="f58d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Lombok易于使用，并提供了配置选项，如启用/禁用一些Lombok功能并更改它们的行为，如返回错误或警告，以及抛出非空变量的<a class="ae jt" href="https://javarevisited.blogspot.com/2013/05/ava-tips-and-best-practices-to-avoid-nullpointerexception-program-application.html" rel="noopener ugc nofollow" target="_blank"> NullPointerException </a>或IllegalArgumentException。</p><h1 id="6876" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">从何说起？</strong></h1><p id="93aa" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果您想在您的项目中使用Lombok，您必须首先使用依赖项管理工具将它作为一个依赖项添加到您的项目中。如果您使用的是<a class="ae jt" rel="noopener" href="/javarevisited/top-10-free-courses-to-learn-maven-jenkins-and-docker-for-java-developers-51fa7a1e66f6"> Maven </a>，您可以将Lombok添加到pom.xml文件中，如下所示:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="06e4" class="lr jv hi ln b fi ls lt l lu lv">&lt;dependencies&gt;<br/>	&lt;dependency&gt;<br/>		&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>		&lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>		&lt;version&gt;1.18.12&lt;/version&gt;<strong class="ln hj">#remove for latest version</strong><br/>		&lt;scope&gt;provided&lt;/scope&gt;<br/>	&lt;/dependency&gt;<br/>&lt;/dependencies&gt;</span></pre><p id="b207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你用<a class="ae jt" href="https://javarevisited.blogspot.com/2020/05/top-5-courses-and-books-to-learn-gradle.html#axzz6fk6WjYD0" rel="noopener ugc nofollow" target="_blank"> Gradle </a>，有两个备选方案可以用。第一种是使用名为<a class="ae jt" href="https://plugins.gradle.org/plugin/io.freefair.lombok" rel="noopener ugc nofollow" target="_blank"> Frefair </a>的工具，它为您的项目提供了Lombok和delombok功能。您可以将它添加为依赖项，如下所示:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="075b" class="lr jv hi ln b fi ls lt l lu lv">buildscript {<br/>  dependencies {<br/>    classpath "io.freefair.gradle:lombok-plugin:5.1.0"<br/>  }<br/>}<br/><br/>apply plugin: "io.freefair.lombok"</span></pre><p id="e82d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种选择只关心Lombok功能的编译范围。它告诉<a class="ae jt" href="https://javarevisited.blogspot.com/2020/06/maven-vs-gradle-beginners-introduction.html#axzz6dHZ7oEpK" rel="noopener ugc nofollow" target="_blank"> Gradle </a>只在编译时将Lombok添加到它的作用域中。您可以在build.gradle的帮助下集成此功能，如下所示:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="ebcb" class="lr jv hi ln b fi ls lt l lu lv">dependencies {<br/>	compileOnly 'org.projectlombok:lombok:1.18.12'<br/>	annotationProcessor 'org.projectlombok:lombok:1.18.12'<br/>	<br/>	testCompileOnly 'org.projectlombok:lombok:1.18.12'<br/>	testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'<br/>}</span></pre><p id="9bf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我已经说过的，Lombok在编译时生成代码，所以在编译时会出现解析错误。Java解析器在构建期间无法找到来自<a class="ae jt" href="https://javarevisited.blogspot.com/2021/08/how-to-use-lombok-library-in-java.html" rel="noopener ugc nofollow" target="_blank"> Lombok注释</a>的一些方法和定义，因此需要定制来破解Java，以便在构建期间从错误中恢复项目。Lombok为大多数流行的ide提供定制的解析器插件，如<a class="ae jt" rel="noopener" href="/javarevisited/7-best-courses-to-learn-intellij-idea-for-beginners-and-experienced-java-programmers-2e9aa9bb0c05"> IntelliJIDEA </a>、<a class="ae jt" rel="noopener" href="/javarevisited/6-free-best-eclipse-ide-courses-for-java-programmers-1229ee9e5d87"> Eclipse </a>等等…</p><p id="7495" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以按照下面的两个步骤为我最喜欢的IDE IntelliJIDEA添加Lombok解析器插件:</p><ul class=""><li id="33a5" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc mb mc md me bi translated">通过搜索从首选项面板下的插件面板安装Lombok，并重新启动IntelliJIDEA。</li><li id="9ab3" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">打开偏好设置面板，启用Lombok并自定义Lombok的配置，如果您需要的话，如下图所示。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://javarevisited.blogspot.com/2018/09/top-5-courses-to-learn-intellij-idea-java-and-android-development.html#axzz6A8Vy1sea"><div class="er es mk"><img src="../Images/e0d1186fc286b9579c3c94526b7e0828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWmEDUQ7KR2ffT4_zLZnYw.png"/></div></a><p class="jp jq et er es jr js bd b be z dx translated">偏好设置中的Lombok插件面板</p></figure><p id="cf0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你已经准备好用Lombok进行开发了。</p><h1 id="0716" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何在Java中使用Lombok？</h1><p id="8228" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Lombok使用Java的注释处理功能在编译时生成样板代码。我将用真实的用例逐一介绍一些Lombok注释。</p><h2 id="a9f6" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">1-) @Val和@Var:</h2><p id="b2cc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用局部变量和循环变量时，不再需要借助Lombok注释“<strong class="ih hj">Val”</strong>来指定类型。Lombok从初始化表达式中获取对象类型。Val变量会被定义为final，所以如果需要不可变的变量，可以使用Lombok的Val，而不是将变量声明为<a class="ae jt" href="https://javarevisited.blogspot.com/2011/12/final-variable-method-class-java.html" rel="noopener ugc nofollow" target="_blank"> final关键字</a>。</p><p id="d352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，<strong class="ih hj">“var”</strong>类型与Val颇为相似，但它们之间唯一的区别是var类型没有被定义为<a class="ae jt" href="https://javarevisited.blogspot.com/2016/09/21-java-final-modifier-keyword-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank"> final </a>。</p><p id="4bda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，我做了一个使用Var和Val对象类型的简单例子。这个例子只是使用这两种类型的Lombok注释列出了有序和无序返回。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="1416" class="lr jv hi ln b fi ls lt l lu lv">public void returnToDoListWithPrioritizedOrder(){<br/><br/>    HashMap&lt;Integer,String&gt; todoListWithPriorities =  new HashMap&lt;&gt;();<br/>    todoListWithPriorities.put(3,"clean the house");<br/>    todoListWithPriorities.put(1,"feed the cats");<br/>    todoListWithPriorities.put(4,"water the garden");<br/>    todoListWithPriorities.put(5,"go to the gym");<br/>    todoListWithPriorities.put(2,"go to the shopping");<br/><br/><strong class="ln hj">    var copyOfToDoListWithProrities = todoListWithPriorities;<br/></strong><br/>    <em class="my">out</em>.println("To Do List Not Ordered:");<br/><br/>    for(<strong class="ln hj">var toDoObject : copyOfToDoListWithProrities.entrySet()</strong>){<br/>        <em class="my">out</em>.println("Priority: "+ toDoObject.getKey()+" To Do: "+toDoObject.getValue());<br/>    }<br/><br/>    <strong class="ln hj">val prioritizedOrderToDoList = new TreeMap&lt;&gt;(todoListWithPriorities);</strong><br/><br/>    <em class="my">out</em>.println("To Do List Ordered:");<br/><br/>    for(<strong class="ln hj">val toDoObject : prioritizedOrderToDoList.entrySet()</strong>){<br/>        <em class="my">out</em>.println("Priority: "+ toDoObject.getKey()+" To Do: "+toDoObject.getValue());<br/>    }<br/>    <br/>}</span></pre><h2 id="aa1c" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">2-)@非空批注:</h2><p id="faeb" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">非空注释是最常用的Lombok注释之一，它对函数或构造函数参数生成空检查<a class="ae jt" href="http://javarevisited.blogspot.sg/2017/01/how-to-check-for-null-values-in-sql.html#axzz4r9r7atOR" rel="noopener ugc nofollow" target="_blank">。Lombok在编译时将以下代码片段添加到方法或构造函数中:</a></p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="e406" class="lr jv hi ln b fi ls lt l lu lv">if (param == null) throw new NullPointerException("param is marked @NonNull but is null");</span></pre><p id="f6ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果由NonNull注释定义的参数为Null，它抛出<a class="ae jt" href="https://www.java67.com/2021/05/how-to-solve-nullpointerexception-in-java.html" rel="noopener ugc nofollow" target="_blank"> NullPointerException </a>异常，并带有包含参数名的注释。这是Lombok的默认配置，但是您可以在Lombok配置功能的帮助下更改应用程序的行为。</p><p id="5b88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，您必须创建一个文件，并在项目目录中将其命名为<strong class="ih hj"> "lombok.config" </strong>。对于非空注释，在<a class="ae jt" href="https://javarevisited.blogspot.com/2014/12/9-things-about-null-in-java.html" rel="noopener ugc nofollow" target="_blank">空变量</a>的情况下，可以返回警告而不是异常。或者可以将异常类型从NullPointerException更改为另一种类型，如IllegalArgumentException。配置示例如下:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="42ad" class="lr jv hi ln b fi ls lt l lu lv"><strong class="ln hj">lombok.nonNull.flagUsage</strong> = WARNING<br/><strong class="ln hj">lombok.nonNull.exceptionType</strong> = IllegalArgumentException</span></pre><p id="1b76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了演示注释的功能，我做了一个简单的例子来检查文本是否是一个<a class="ae jt" href="https://www.java67.com/2012/09/palindrome-java-program-to-check-number.html" rel="noopener ugc nofollow" target="_blank">回文</a>。我向方法参数添加了非空注释，以防止对空文本运行回文检查，并提供直接抛出警告:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="5fbb" class="lr jv hi ln b fi ls lt l lu lv">public boolean isPalindrome (<strong class="ln hj">@NonNull</strong> String text){<br/>    for(int i=0;i&lt;text.length()/2;i++){<br/>        if(text.charAt(i) != text.charAt(text.length()-1-i)){<br/>            return false;<br/>        }<br/>    }<br/>    return true;<br/>}</span></pre><h2 id="a9ad" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">3-)@清理注释:</h2><p id="8775" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在Java 7中，Java揭示了用<a class="ae jt" href="https://javarevisited.blogspot.com/2011/09/arm-automatic-resource-management-in.html" rel="noopener ugc nofollow" target="_blank"> try-with-resources块</a>退出try块后关闭资源的功能。Lombok用<strong class="ih hj">清理</strong>注释提供了一种替代方法。在作用域结束时，它自动触发<strong class="ih hj">【close】</strong>方法。</p><p id="81b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想在Java中使用I / O或stream，你可以通过使用CleanUp注释来避免内存泄漏和基于资源的错误。我实现了一个示例，它使用CleanUp注释从一个文件读取文本并将文本写入另一个文件。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="b0a0" class="lr jv hi ln b fi ls lt l lu lv">public String getSecretNumberFromFile(){<br/><br/>    try{<br/><br/>        <strong class="ln hj">@Cleanup var reader = new BufferedReader(new FileReader("lombok/secretcode.txt"));</strong><br/><br/>        return reader.readLine();<br/><br/>    } catch (IOException ex) {<br/>        <em class="my">err</em>.format("Exception message is: %s%n", ex);<br/>        return null;<br/>    }<br/>}<br/><br/>public void setSecretNumberToBackUpFile(@NonNull String secretNumber){<br/><br/>    var dateFormatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");<br/>    String formattedDate = dateFormatter.format(Calendar.<em class="my">getInstance</em>().getTime());<br/><br/>    String outputLink = "lombok/secretcode-"+formattedDate+".txt";<br/><br/>    try {<br/>        <strong class="ln hj">@Cleanup FileOutputStream outputStream = new FileOutputStream(outputLink);</strong><br/><br/>        outputStream.write(secretNumber.getBytes());<br/><br/>    } catch (IOException ex) {<br/>        <em class="my">err</em>.format("Exception message is: %s%n", ex);<br/>    }<br/><br/>}</span></pre><h2 id="68ee" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated"><strong class="ak"> 4-) @Getter和@Setter注释:</strong></h2><p id="0466" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Getter/Setter是访问<a class="ae jt" href="https://javarevisited.blogspot.com/2011/11/static-keyword-method-variable-java.html" rel="noopener ugc nofollow" target="_blank">类变量</a>并为这些变量赋值的Java功能之一。它保护对类变量的直接访问，以隐藏属性的内部表示。它提供了类属性的封装和可用性。</p><p id="b8c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是对于Java开发人员来说，如果他们的项目中有多个POJO类，那么它们就被认为是样板代码。Lombok实现了<strong class="ih hj"> Getter和Setter </strong>注释来减少这些函数的冗长。</p><p id="ebf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您只能向类或类变量添加Getter和Setter批注。所有这些方法都被Lombok定义为public。此外，您可以通过指定访问级别来定义这些注释。(合法访问级别为<a class="ae jt" href="https://javarevisited.blogspot.com/2012/10/difference-between-private-protected-public-package-access-java.html#axzz6j8KhisSX" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">【公共】</strong><strong class="ih hj"/><strong class="ih hj">【包】</strong>【私有】 </a> <strong class="ih hj">)。</strong>除了这些级别，还可以通过指定AccessLevel.NONE来删除变量的getter或setter操作</p><p id="236e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经用Getter和Setter注释对具有不同访问级别的变量定义了示例POJO类，如下所示:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="c70e" class="lr jv hi ln b fi ls lt l lu lv"><strong class="ln hj">@Getter<br/>@Setter</strong><br/>public class StudentObject {<br/>    public StudentObject(){<br/>        setSecretCode();<br/>        this.advisor = Advisor.<em class="my">getRandomAdvisor</em>();<br/>    }<br/><br/>    <strong class="ln hj">@NonNull<br/>    @Getter(AccessLevel.<em class="my">NONE</em>)</strong><br/>    private int schoolNumber;<br/><br/>    <strong class="ln hj">@Getter(AccessLevel.<em class="my">PRIVATE</em>)</strong><br/>    private String personName;</span><span id="b938" class="lr jv hi ln b fi mz lt l lu lv">    private String major;<br/><br/>    <strong class="ln hj">@Getter(AccessLevel.<em class="my">NONE</em>) @Setter(AccessLevel.<em class="my">PRIVATE</em>)</strong> private int studentSecretCode;<br/><br/>    <strong class="ln hj">@Setter(AccessLevel.<em class="my">NONE</em>)</strong> private Advisor advisor;<br/><br/>    private void setSecretCode(){<br/>        Random random = new Random();<br/>        this.setStudentSecretCode(random.nextInt());<br/>    }<br/>}</span></pre><h2 id="0d92" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">5-) @ToString批注:</h2><p id="1024" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在Java中，如果你创建一个新的类，一些方法会自动出现，而不需要定义它们。这些方法是<strong class="ih hj"> java.lang.Object，</strong>的一部分，所以每个对象都有它。<strong class="ih hj"> </strong> <a class="ae jt" href="http://javarevisited.blogspot.sg/2012/09/override-tostring-method-java-tips-example-code.html#axzz54v9Z26qM" rel="noopener ugc nofollow" target="_blank"> ToString </a>就是这些方法中的一种，它显示了一个对象的字符串表示。它被广泛用于记录用户的操作，并将详细的对象参数传递给定制的异常。默认的ToString实现不方便，所以建议通过包含特定的属性来覆盖它。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="7c7a" class="lr jv hi ln b fi ls lt l lu lv">Test test = new Test();<br/><br/><em class="my">out</em>.println(test);<br/><br/><strong class="ln hj">Output:<br/></strong><br/>com.justayar.springboot.util.Test@21f41d55</span></pre><p id="242b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">流行的ide为开发人员提供了用选定的参数自动生成这种方法的功能。借助IDE创建对象方法可以节省时间，但是每次添加参数时都需要递归地更新toString方法。</p><p id="7e96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，Lombok用toString注释创建了一个更好的解决方案。它获取所有非静态字段，并在编译时创建对象的字符串表示。除了默认行为之外，由于使用了<strong class="ih hj"> @ToString，您还可以从toString方法中排除一些属性。排除</strong>。</p><p id="a835" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">反过来，您也可以使用<strong class="ih hj"> @ToString来指定您想要将哪些参数添加到String方法中。包括</strong>注释。对于有更多字段的类来说，这是一个很好的选择，在ToString方法中，我们只需要这么多字段中的一小部分。要在toString上启用此功能，必须按如下方式定义Lombok ToString注释:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="95af" class="lr jv hi ln b fi ls lt l lu lv">@ToString(onlyExplicitlyIncluded = true)</span></pre><p id="2d3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了这些功能之外，由于其<strong class="ih hj">“rank”</strong>配置，Lombok toString还可以根据需要对toString表示中的参数进行排序。</p><p id="e3ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的类是超类的子类，您可以通过将<strong class="ih hj"> callSuper = true </strong>添加到toString注释声明来包含超类的属性，如下所示:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="1ea8" class="lr jv hi ln b fi ls lt l lu lv">@ToString(callSuper = true)</span></pre><p id="32e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">具有不同功能的Lombok ToString注释的简单演示如下:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="e94f" class="lr jv hi ln b fi ls lt l lu lv">@ToString(onlyExplicitlyIncluded = true)<br/>public class Product {<br/><br/>    private int productId;<br/>    @ToString.Include(name="Product Name",rank = 1)<br/>    private String productName;<br/>    @ToString.Include(name="Product Amount",rank=3)<br/>    private int productAmount;<br/>    @ToString.Include(name="Product Unit Price",rank=2)<br/>    private double productUnitPrice;<br/>    @ToString.Include(name="Product Category",rank=4)<br/>    private ProductSubCategory productCategory;<br/>}</span><span id="999b" class="lr jv hi ln b fi mz lt l lu lv">@ToString(onlyExplicitlyIncluded = true)<br/>public class ProductCategory {<br/><br/>    private int categoryId;<br/>    @ToString.Include(name="Main Category Name")<br/>    private String categoryName;<br/>}</span><span id="f144" class="lr jv hi ln b fi mz lt l lu lv">@ToString(callSuper = true)<br/>public class ProductSubCategory extends ProductCategory {<br/><br/>    private int subCategoryId;<br/>    @ToString.Include(name="Sub Category Name",rank=2)<br/>    private String subCategoryName;<br/>}</span><span id="1e54" class="lr jv hi ln b fi mz lt l lu lv">@ToString<br/>public class ShoppingCart {<br/><br/>    @ToString.Exclude<br/>    private int cartId;<br/>    private double cartTotal=0.0;<br/>    private List&lt;Product&gt; productList = new ArrayList&lt;&gt;();<br/><br/>    public void addProductToCart(Product product){<br/>        productList.add(product);<br/>        cartTotal += product.getProductAmount()*product.getProductUnitPrice();<br/>    }<br/><br/>}</span></pre><h2 id="cd8a" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated"><strong class="ak"> 6-) @EqualsAndHashCode: </strong></h2><p id="9518" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">和toString一样，equals和hashCode也是默认的方法，来自于<strong class="ih hj">Java . lang . object .</strong><a class="ae jt" href="https://javarevisited.blogspot.com/2011/02/how-to-write-equals-method-in-java.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">【equals】</strong></a>用来定义一个对象的唯一性，或者标识任意两个对象是否相同。</p><p id="f906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，<a class="ae jt" href="http://javarevisited.blogspot.sg/2013/08/10-equals-and-hashcode-interview.html" rel="noopener ugc nofollow" target="_blank"> hashCode </a>是对象内存地址的整数表示。它返回一个对于每个对象都是唯一的随机整数。如果根据equals方法，两个方法是相同的，则它们生成相同的哈希代码。Lombok允许我们通过<strong class="ih hj"> EqualsAndHashCode </strong>注释来配置equals和hashCode实现。</p><p id="6ddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的行为和参数类似于ToString注释。您可以使用<strong class="ih hj"> @EqualsAndHashCode从<a class="ae jt" href="https://www.java67.com/2012/11/difference-between-operator-and-equals-method-in.html" rel="noopener ugc nofollow" target="_blank">相等检查</a>中排除参数。排除</strong>。</p><p id="27ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以告诉Java只使用由<strong class="ih hj"> @EqualsAndHashCode声明的参数。包含</strong>以检查是否相等。默认情况下，它不能接受非静态和非瞬态字段，但是同样，您也可以包含这样的字段。<strong class="ih hj"><em class="my">【call super】</em></strong>功能还增加了超类字段来检查相等性。</p><p id="e8c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在下面的<strong class="ih hj">中看到Lombok EqualsAndHashCode注释的示例代码片段。</strong></p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="1280" class="lr jv hi ln b fi ls lt l lu lv">@EqualsAndHashCode(onlyExplicitlyIncluded = true)<br/>public class Car {<br/><br/>    @EqualsAndHashCode.Include<br/>    private int year;<br/>    @EqualsAndHashCode.Include<br/>    private double horsePower;<br/>    private FuelType fuelType;<br/>    @EqualsAndHashCode.Include<br/>    private String model;<br/><br/>    private static final double <em class="my">GRAVITY </em>= 9.80665;<br/><br/>    public enum FuelType {<br/>        <em class="my">Gasoline</em>,<br/>        <em class="my">Diesel</em>,<br/>        <em class="my">Cng</em>,<br/>        <em class="my">Ethanol</em>,<br/>        <em class="my">BioDiesel</em>;<br/>    }<br/>}</span><span id="0ce0" class="lr jv hi ln b fi mz lt l lu lv">@EqualsAndHashCode(callSuper=true, onlyExplicitlyIncluded = true)<br/>public class SportCar extends Car{<br/><br/>    @EqualsAndHashCode.Include<br/>    private int maxSpeed;<br/>    private double oneHundredKilometersReachTimeInSeconds;<br/>}</span></pre><h2 id="1252" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">7-) @NoArgsConstructor，@RequiredArgsConstructor，@AllArgsConstructor:</h2><p id="020d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">构造函数是用来初始化对象的方法。在Java中，你可以用不同的字段顺序创建多个构造函数。Lombok通过添加构造函数注释自动为你生成这些<a class="ae jt" href="https://javarevisited.blogspot.com/2012/12/what-is-constructor-in-java-example-chainning-overloading.html" rel="noopener ugc nofollow" target="_blank">构造函数</a>。</p><p id="719c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，您可以通过特定的名称创建带有静态工厂的私有构造函数。您可以创建一个没有任何字段的新对象，也可以创建带有必填字段的新对象，或者创建带有<strong class="ih hj"> @NoArgsConstructor、@RequiredArgsConstructor和@AllArgsConstructor </strong>批注的所有字段的新对象。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="2910" class="lr jv hi ln b fi ls lt l lu lv">@NoArgsConstructor(force = true)<br/>@RequiredArgsConstructor(staticName = "of")  // create private constructor with static factory with named "of"<br/>@AllArgsConstructor<br/>@ToString<br/>public class Dress {<br/><br/>    @NonNull<br/>    private FabricType fabricType;<br/>    private String color;<br/>    private String productionPlace;<br/>    private double price;<br/>    @NonNull<br/>    private String brand;<br/>    private Size size;<br/><br/>    private static final String <em class="my">DRESS_SIZE_UNIT </em>= "cm";<br/><br/>    public enum FabricType{<br/>        <em class="my">Silk</em>,<br/>        <em class="my">Jersey</em>,<br/>        <em class="my">Crepe</em>,<br/>        <em class="my">Linen</em>,<br/>        <em class="my">Cotton</em>,<br/>        <em class="my">Canvas</em>,<br/>        <em class="my">Woven</em>,<br/>        <em class="my">Twill</em>;<br/>    }<br/><br/>    public enum Size{<br/>        <em class="my">Small</em>,<br/>        <em class="my">Medium</em>,<br/>        <em class="my">Large</em>,<br/>        <em class="my">XLarge<br/>    </em>}<br/>}</span></pre><p id="7ee8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用静态工厂方法创建一个带有必填字段的私有构造函数，称为“的<strong class="ih hj">，如下所示:</strong></p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="bc94" class="lr jv hi ln b fi ls lt l lu lv">Dress dressWithRequiredArgs =Dress.<em class="my">of</em>(Dress.FabricType.<em class="my">Cotton</em>,"Prada");</span></pre><h2 id="22fc" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">8-)@数据和@值:</h2><p id="ae2e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Lombok的目标是减少来自类的样板代码，但是如果你使用许多Lombok注释，你必须处理另一种类型的样板代码。</p><p id="fbc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，Lombok从最常用的Lombok注释中创建了一个快捷注释，将其命名为<strong class="ih hj">“Data”。</strong>数据标注包括下图龙目标注:</p><ul class=""><li id="d43a" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc mb mc md me bi translated"><strong class="ih hj">托串</strong></li><li id="e2c9" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><strong class="ih hj"> EqualsAndHashCode </strong></li><li id="4d27" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><strong class="ih hj">吸气剂</strong></li><li id="fa80" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><strong class="ih hj">设定器</strong></li><li id="dcef" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><strong class="ih hj">RequiredArgsConstructor</strong></li></ul><p id="26ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以覆盖<strong class="ih hj"> @Data </strong>批注下的批注。可以用<a class="ae jt" href="http://javarevisited.blogspot.sg/2017/02/5-difference-between-constructor-and-factory-method-in-java.html#axzz4tUeeQOAU" rel="noopener ugc nofollow" target="_blank">静态工厂方法</a>创建一个类似于<strong class="ih hj"> @RequiredArgsConstructor </strong>的私有构造函数。您可以在<strong class="ih hj"> @Getter </strong>和<strong class="ih hj"> @Setter </strong>注释上更改字段的访问级别。您可以看到下面的数据注释示例:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="f2d7" class="lr jv hi ln b fi ls lt l lu lv">@Data(staticConstructor="of")    // It covers lombok annotations: @ToString, @EqualsAndHashCode, @Getter / @Setter and @RequiredArgsConstructor<br/>public class Meal {<br/><br/>    @NonNull<br/>    private String mealName;<br/>    private boolean isSalty;<br/>    @NonNull<br/>    private String region;<br/>    @NonNull<br/>    private List&lt;Ingredient&gt; ingredients;<br/>}</span></pre><p id="c4b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> @Value </strong>注释类似于<strong class="ih hj"> @Data </strong>注释，但可以认为是数据的<a class="ae jt" rel="noopener" href="/javarevisited/how-to-create-an-immutable-list-list-and-map-in-java-5ac1254c128?source=---------31------------------">不可变</a>替代。所有私有的和最终的类字段，setters不是由Lombok生成的。类在值注释中也被设为final。值注释是下面的类声明的简写:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="0eba" class="lr jv hi ln b fi ls lt l lu lv">final @ToString @EqualsAndHashCode @AllArgsConstructor @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE) @Getter</span></pre><h2 id="f770" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated"><strong class="ak"> 9-) @Builder注释:</strong></h2><p id="e1a7" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"> Builder </strong>是<a class="ae jt" href="https://www.journaldev.com/31902/gangs-of-four-gof-design-patterns" rel="noopener ugc nofollow" target="_blank">四人组</a>设计模式之一。它是一种创造性的设计模式，旨在促进对象创建，并使对象对扩展开放。对于包含更多字段的类来说，这是一个非常好的选择。对于那种类，你需要有更多的构造函数。当一个新的字段添加到类中时，您必须更新构造函数。</p><p id="d653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在类中实现<a class="ae jt" href="http://javarevisited.blogspot.sg/2012/06/builder-design-pattern-in-java-example.html" rel="noopener ugc nofollow" target="_blank">构建器模式，您必须创建一个静态内部类，并返回这个内部类作为类中每个setter方法的返回。还实现了一个生成器方法，用生成器创建一个新对象。构建器模式在类中的示例实现如下:</a></p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="55ad" class="lr jv hi ln b fi ls lt l lu lv">public class Bread {<br/><br/>    private BreadType breadType;<br/>    private boolean isIncludeSesame;<br/><br/>    public Bread(Bread.Builder builder) {<br/>        this.breadType = builder.breadType;<br/>        this.isIncludeSesame = builder.isIncludeSesame;<br/>    }<br/><br/>    public BreadType getBreadType() {<br/>        return breadType;<br/>    }<br/><br/>    public boolean isIncludeSesame() {<br/>        return isIncludeSesame;<br/>    }<br/><br/>    public static class Builder{<br/><br/>        private String breadType, isIncludeSesame;<br/><br/>        public Builder(){ }<br/><br/>        public BreadType.Builder breadType(String breadType){<br/>            this.breadType = breadType;<br/>            return this;<br/>        }<br/><br/>        public BreadType.Builder isIncludeSesame(String isIncludeSesame){<br/>            this.isIncludeSesame = isIncludeSesame;<br/>            return this;<br/>        }<br/>    <br/>        public BreadType build(){<br/>            return new BreadType(this);<br/>        }<br/>    }<br/>    <br/>    public enum BreadType{<br/>        <em class="my">Ciabatta</em>,<br/>        <em class="my">WholeWheat</em>,<br/>        <em class="my">White</em>,<br/>        <em class="my">WholeGrain</em>;<br/>    }<br/>}</span></pre><p id="8030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Lombok试图减少构建器模式实现的冗长性。使用<strong class="ih hj"> @Builder </strong>注释，您可以通过下面的代码片段获得相同的功能:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="4286" class="lr jv hi ln b fi ls lt l lu lv">@Data<br/>@Builder<br/>public class Bread {<br/><br/>    private BreadType breadType;<br/>    private boolean isIncludeSesame;<br/><br/><br/><br/>    public enum BreadType{<br/>        <em class="my">Ciabatta</em>,<br/>        <em class="my">WholeWheat</em>,<br/>        <em class="my">White</em>,<br/>        <em class="my">WholeGrain</em>;<br/><br/>    }<br/>}</span></pre><p id="4d82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，Builder annotation还为您提供了其他一些不错的特性。其中一个是<strong class="ih hj">建造者。默认</strong>注释允许您为某些字段分配默认值。用法示例如下</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="b378" class="lr jv hi ln b fi ls lt l lu lv">@Builder.Default<br/>private String orderTime = new SimpleDateFormat("dd-MM-YYYY hh:mm:ss").format(Calendar.<em class="my">getInstance</em>().getTime());</span></pre><p id="e09d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的类包含一个属性，该属性是<a class="ae jt" rel="noopener" href="/javarevisited/7-best-java-collections-and-stream-api-courses-for-beginners-in-2020-3ad18d52c38"> Java集合</a>的子类，比如<a class="ae jt" href="https://www.java67.com/2017/10/java-8-convert-arraylist-to-hashmap-or.html" rel="noopener ugc nofollow" target="_blank"> List或Map，</a>您不必创建一个集合对象来向主对象添加元素。由于有了<strong class="ih hj"> @Singular </strong>注释，您可以逐个添加每个收藏元素。</p><p id="8c8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，在某些情况下，您必须更新用<a class="ae jt" href="https://www.java67.com/2012/09/top-10-java-design-pattern-interview-question-answer.html" rel="noopener ugc nofollow" target="_blank">构建器模式</a>创建的对象。对于这种情况，您必须将对象反向转换为构建器。Lombok也通过<strong class="ih hj"> toBuilder=true </strong>配置提供参数化功能。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="906a" class="lr jv hi ln b fi ls lt l lu lv">@Data<br/>@Builder(toBuilder = true)<br/>public class Menu {<br/><br/>    private Hamburger hamburger;<br/>    private Drink drink;<br/>    private Fries fries;<br/>    @Singular("sauces")<br/>    private List&lt;Sauce&gt; sauces;<br/><br/>    public void giveOrderToKitchen(){<br/><br/>    }<br/>}</span></pre><h2 id="ebc2" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">10-)@ sneaky rows:</h2><p id="83d3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果你的代码包含一个被检查的异常，一种必须在抛出异常的方法中被捕获或声明的异常，你不再需要在抛出块中捕获这些异常，或者将<a class="ae jt" href="https://javarevisited.blogspot.com/2012/02/difference-between-throw-and-throws-in.html" rel="noopener ugc nofollow" target="_blank">抛出声明</a>添加到方法签名中。由于Lombok @ <strong class="ih hj"> SneakyThrows </strong>注释，您可以轻松地抛出检查过的异常。您可以看到带有IOException的SneakyThrows的示例用法，如下所示:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="1bd3" class="lr jv hi ln b fi ls lt l lu lv">public class Reader {<br/><br/>    @SneakyThrows(IOException.class)<br/>    public String getSecretNumberFromFile() {<br/><br/>        var reader = new BufferedReader(new FileReader("lombok/secretcode.txt"));<br/><br/>        return reader.readLine();<br/><br/>    }<br/>}</span></pre><h2 id="1498" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">11-)@同步</h2><p id="58b0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有些应用程序支持多线程结构。许多客户端试图访问同一资源来更新或读取数据。对于这样的场景，Java提供了同步的方法块。</p><p id="7c51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只有一个线程可以执行这个<a class="ae jt" href="https://www.java67.com/2013/01/difference-between-synchronized-block-vs-method-java-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="my">同步块</em> </strong> </a>，其他线程都被阻塞，直到活动线程完成其执行。在Java世界中，这是由<strong class="ih hj">T21监视器</strong>提供的概念。</p><p id="61b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同步块可以被认为是一个监视器。每个线程都试图获取一个要监视的锁，但是在给定时间只有一个线程可以获取。</p><p id="75f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java代码片段示例如下:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="ef66" class="lr jv hi ln b fi ls lt l lu lv">public class Raffle {<br/>    <br/>    private static final Object <em class="my">$LOCK </em>= new Object[0];<br/><br/>    private int currentCounter = 0;<br/><br/>    private static final String [] <em class="my">winnerCounters </em>= {"10","100","1000","10000"};<br/><br/>    public boolean didIWin(){<br/><br/>        synchronized(<em class="my">$LOCK</em>) {<br/><br/>            setCurrentCounter(getCurrentCounter() + 1);<br/><br/>            String predicateCounter = currentCounter + "";<br/><br/>            return Arrays.<em class="my">stream</em>(<em class="my">winnerCounters</em>).anyMatch(predicateCounter::equals);<br/>        }<br/><br/>    }   <br/>}</span></pre><p id="e6d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Lombok试图在编译时用Java的注释处理功能来简化这个<a class="ae jt" href="https://javarevisited.blogspot.com/2011/04/synchronization-in-java-synchronized.html#axzz6ngd8ND25" rel="noopener ugc nofollow" target="_blank">同步过程</a>。上述代码的Lombok替代代码如下:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="05eb" class="lr jv hi ln b fi ls lt l lu lv">@Data<br/>public class Raffle {<br/><br/>    private final Object raffleLock = new Object();<br/><br/>    private int currentCounter = 0;<br/><br/>    private static final String [] <em class="my">winnerCounters </em>= {"10","100","1000","10000"};<br/><br/>    @Synchronized("raffleLock")<br/>    public boolean didIWin(){<br/><br/>        setCurrentCounter(getCurrentCounter()+1);<br/><br/>        String predicateCounter = currentCounter+"";<br/><br/>        return Arrays.<em class="my">stream</em>(<em class="my">winnerCounters</em>).anyMatch(predicateCounter::equals);<br/><br/>    }<br/>}</span></pre><h2 id="c89d" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">12-) @Getter(lazy=true)或LazyGetter</h2><p id="fbe3" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有时候getter的生成真的需要太多时间。这可能会导致高CPU使用率或内存泄漏。对于这样的字段，缓存数据是一个很好的选择。Lombok lazy getter注释为您完成了这项工作。要启用它，您必须声明一个私有的final字段，并用耗时的方法初始化它。</p><p id="0f09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，我们试图列出从0到500000的所有质数。当我们调用这个方法两次时，执行次数如下:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="3f9e" class="lr jv hi ln b fi ls lt l lu lv">There are 41540 numbers in 13 seconds.<br/><br/>There are 41540 numbers in 0 seconds.</span></pre><p id="e057" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为第二个调用来自缓存数据，所以它的执行时间是0秒。此方法的代码片段如下:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="9459" class="lr jv hi ln b fi ls lt l lu lv">@Value<br/>public class PrimeNumber {<br/><br/>    @Getter(lazy = true)<br/>    private final List&lt;Integer&gt; primeNumbers = getAllPrimeNumbers();<br/><br/>    private ArrayList&lt;Integer&gt; getAllPrimeNumbers() {<br/><br/>        ArrayList&lt;Integer&gt; primeNumbers = new ArrayList&lt;&gt;();<br/><br/>        for (int i = 0; i &lt; 500000; i++) {<br/>            if(isPrime(i)){<br/>                primeNumbers.add(i);<br/>            }<br/>        }<br/><br/>        return primeNumbers;<br/>    }<br/><br/>    private boolean isPrime(int number) {<br/>        for (int i = 2; i &lt;= number / 2; ++i) {<br/>            if (number % i == 0) {<br/>                return false;<br/>            }<br/>        }<br/><br/>        return true;<br/>    }<br/>}</span></pre><h2 id="b682" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">13-) @Log(和朋友)</h2><p id="4ed9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">应用开发的一个重要部分是<a class="ae jt" href="https://javarevisited.blogspot.com/2011/05/top-10-tips-on-logging-in-java.html" rel="noopener ugc nofollow" target="_blank">日志</a>。它可以提供丰富的信息，并指导错误分析和调试过程。在Java中，有很多日志框架可供选择，比如<a class="ae jt" href="https://javarevisited.blogspot.com/2013/12/how-to-configure-log4j-in-java-program.html" rel="noopener ugc nofollow" target="_blank"> Log4j </a>、<a class="ae jt" href="https://javarevisited.blogspot.com/2013/08/why-use-sl4j-over-log4j-for-logging-in.html#axzz6JyHI5fGb" rel="noopener ugc nofollow" target="_blank"> Slf4j、</a>等等…</p><p id="349d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在类中使用日志，必须如下初始化logger对象:</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="d05f" class="lr jv hi ln b fi ls lt l lu lv">private static final org.apache.log4j.Logger <em class="my">log </em>= org.apache.log4j.Logger.getLogger(LogExample.class);</span></pre><p id="cb2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果使用Lombok，只需要给类添加<strong class="ih hj"> @Log </strong>注释，Lombok自动为你做初始化过程。在下面的例子中，您可以看到Log4j与一个基本类的集成。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="f9af" class="lr jv hi ln b fi ls lt l lu lv">@Log4j2<br/>public class TextUtils {<br/><br/>    public String reverseOfText(String text){<br/><br/>        <em class="my">log</em>.info("Trying to get reverse of text is "+text);<br/><br/>        return new StringBuilder(text).reverse().toString();<br/>    }<br/>}</span></pre><p id="d06a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了这13个注释，Lombok还提供了一些实验性的注释作为演示，但是我建议在生产环境中使用稳定的Lombok注释。</p><h1 id="46c6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="9e7a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">多年来，Java一直是大型组织构建高度可伸缩和稳定的应用程序的最佳选择之一。Java的开源世界和<a class="ae jt" href="http://java67.com/2012/08/how-java-achieves-platform-independence.html" rel="noopener ugc nofollow" target="_blank">平台无关的JVM </a>特性使其在软件世界中不可或缺。</p><p id="2dcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管大多数Java开发人员喜欢用Java开发应用程序，但Java社区多年来一直认为Java过于冗长。在这一点上，Lombok承担起了责任，为Java开发人员创建了方便而有用的注释。Lombok的目标是减少样板代码，从而消除Java的冗长。</p><p id="7e12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很容易将Lombok集成到您的项目中，学习曲线几乎不存在。用Lombok转换项目不像其他工具或库那样痛苦。</p><p id="21b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我建议你给龙目一个机会，相信我，你以后会感谢我的。</p><blockquote class="kx"><p id="94c8" class="ky kz hi bd la lb lc ld le lf lg jc dx translated">让我们使用Lombok，让Java再次变得伟大:)</p></blockquote><p id="fe22" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">该代码可在<a class="ae jt" href="https://github.com/justayar/SpringBootTemplates/tree/master/lombok" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><h2 id="4576" class="lr jv hi bd jw ml mm mn ka mo mp mq ke iq mr ms ki iu mt mu km iy mv mw kq mx bi translated">感谢您的阅读。随意分享:)</h2></div></div>    
</body>
</html>