<html>
<head>
<title>Cache Replacement Algorithms In Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的缓存替换算法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/cache-replacement-algorithms-in-java-parts1-f63f2962a714?source=collection_archive---------0-----------------------#2021-10-04">https://medium.com/javarevisited/cache-replacement-algorithms-in-java-parts1-f63f2962a714?source=collection_archive---------0-----------------------#2021-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f35bcfc3ea87d2fcd59a4f4b1b52b4d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Dpjuv05Lpimp46TH0mlAyw.jpeg"/></div><p class="im in et er es io ip bd b be z dx translated">来自stock.adobe.com<a class="ae iq" href="https://stock.adobe.com/id/images/id/307936519?as_campaign=Freepik&amp;as_content=api&amp;as_audience=srp&amp;tduid=4baa0a071af609923f6d9c3d56d02745&amp;as_channel=affiliate&amp;as_campclass=redirect&amp;as_source=arvato" rel="noopener ugc nofollow" target="_blank">的</a></p></figure><p id="a0a9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">高速缓存替换算法可以决定当高速缓存满时哪个项目将被移除。现在，这些算法有很多变种；但是，在这篇文章中，我将讨论4种算法:<strong class="it hj">先进先出/后进先出</strong>、<strong class="it hj"> LRU </strong>(最近最少使用)、<strong class="it hj"> LFU </strong>(最少使用)和<strong class="it hj"> MRU </strong>(最近最少使用)算法。</p><p id="bfba" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">准备</strong></p><p id="48b8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于本文中的java代码，我将使用Lombok库。请首先使用您的软件包管理器安装它。对于maven用户，您可以在pom.xml中添加</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="e539" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">至于将被保存在缓存中的对象将具有这样的结构:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="6e60" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于下面4个算法的所有实现，我将使用LinkedList和HashMap数据结构。</p><p id="414a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">先进先出/后进先出</strong></p><p id="d789" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在FIFO中，该算法的行为类似于队列。列表头中的项目将被删除，而不考虑它以前被访问的频率或次数。而LIFO则相反，它的行为就像一个堆栈，尾部的项目将被删除。</p><p id="5cf2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">代码实现如下所示。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="eab7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> LRU </strong></p><p id="f065" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这里，我们替换最长时间未使用的项目。FIFO缓存的实现几乎相同。不同之处在于，当存在缓存命中时，该项将被移动到尾部，而头部是一个很少长时间使用的项。</p><p id="5e16" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里可以看到插图。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jv"><img src="../Images/4352f5a7ec4d35f3fe51351f8a3c22fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UeWBFrsMv7AuWWDXLubxIw.png"/></div></div></figure><p id="3b17" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">ABCDE将立即填充缓存，因为缓存中有足够的空间。D和B的位置将在最末端，因为存在与现有元素的缓存命中。f是缓存中的新项目；因此，首先移除项目A，然后将项目F插入尾部。该实现的java代码如下所示:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="1e02" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> MRU(最近使用)</strong></p><p id="556a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">MRU与LRU相反。在MRU，最近使用的项目将从缓存中删除。这种方法很少使用，但有些情况下可以使用这种策略；比如我们看过那部电影之后的电影推荐。可以使用MRU策略将这部电影从缓存中逐出。</p><p id="0d08" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于实现，我们可以使用前一篇文章中的LRU代码。不同之处在于，我们必须删除LinkedList尾部的一项，因为该项是最近使用的。需要更改的代码部分包括:</p><pre class="jp jq jr js fd ka kb kc kd aw ke bi"><span id="241b" class="kf kg hi kb b fi kh ki l kj kk">public void set(int key, int value) {<br/>    if (this.cache.containsKey(key)) {<br/>        // remove existing node from linked list<br/>        this.ll.remove(this.cache.get(key));<br/>    } else {<br/>        // if linked list size same with capacity then remove last node<br/>        if (this.ll.size() == this.capacity) {<br/>            this.cache.remove(this.ll.getLast().getKey());<br/>            this.ll.removeLast();<br/>        }<br/>    }<br/>    // add new node in tail, and cache node in hash map<br/>    this.ll.addLast(new Node(key, value));<br/>    this.cache.put(key, this.ll.getLast());<br/>}</span></pre><p id="039a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">从上面的代码片段中，我已经更改了代码，使用内置的getLast()方法获取最后一个项目。</p><h1 id="abdd" class="kl kg hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><strong class="ak"> LFU(使用频率最低)</strong></h1><p id="d8b3" class="pw-post-body-paragraph ir is hi it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hb bi translated">在LFU，我们必须跟踪项目的频率。当一个项目进入缓存时，更新该项目的频率。具有最小频率的项目将从缓存中移除。这里可以看到Java的实现。</p><pre class="jp jq jr js fd ka kb kc kd aw ke bi"><span id="d98e" class="kf kg hi kb b fi kh ki l kj kk">@Builder.Default private HashMap&lt;Integer, Node&gt; cache = new HashMap&lt;&gt;();<br/>@Builder.Default private HashMap&lt;Integer, LinkedList&lt;Node&gt;&gt; freqDic = new HashMap&lt;&gt;();<br/><br/>private LinkedList&lt;Node&gt; ll;<br/>private int capacity;<br/>private int size;<br/>private int minFreq;</span></pre><p id="2d39" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在上面的代码中，我使用了3个数据结构(2个HashMap，1个LinkedList)来帮助我构建这个算法。freqDic HashMap的功能是跟踪该项在缓存中的频率。所以，这个HashMap的关键字是frequency，值是LinkedList。LinkedList表示基于时间戳存储在缓存中的实际项目，这意味着头部是最老的，尾部是最新的。对于get实现，算法是:</p><ol class=""><li id="65dd" class="ln lo hi it b iu iv iy iz jc lp jg lq jk lr jo ls lt lu lv bi translated">检查该项是否存在于缓存中，如果不存在则返回null。</li><li id="de41" class="ln lo hi it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv bi translated">从频率散列表中删除项目。如果HashMap中的frequency键没有任何成员，那么删除frequency键。</li><li id="e141" class="ln lo hi it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv bi translated">更新驱逐项的频率，并将更新后的项放入频率散列表中。</li></ol><pre class="jp jq jr js fd ka kb kc kd aw ke bi"><span id="b8cb" class="kf kg hi kb b fi kh ki l kj kk">public Node get(int key) {<br/>   if (!this.cache.containsKey(key)) {<br/>       return null;<br/>   }<br/>   Node temp = this.cache.get(key);<br/>   // remove node from old frequency dictionary<br/>   this.freqDic.get(temp.getFreq()).remove(temp);<br/>   if (this.freqDic.get(temp.getFreq()).isEmpty()) {<br/>       this.freqDic.remove(temp.getFreq());<br/>       if (this.minFreq == temp.getFreq()) {<br/>           this.minFreq += 1;<br/>       }<br/>   }<br/>   // adding new frequency<br/>   Node node = new Node(temp.getKey(), temp.getValue(), temp.getFreq() + 1);<br/>   // update cache and freq dic with new node<br/>   this.cache.put(key, node);<br/><br/>   LinkedList&lt;Node&gt; ll = this.getList(node.getFreq());<br/>   ll.addLast(node);<br/>   this.freqDic.put(node.getFreq(), ll);<br/>   return temp;<br/>}</span></pre><p id="65d8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于set实现，算法有:</p><ol class=""><li id="721d" class="ln lo hi it b iu iv iy iz jc lp jg lq jk lr jo ls lt lu lv bi translated">检查项目是否存在于缓存中，如果存在，执行上面的get算法。</li><li id="6869" class="ln lo hi it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv bi translated">如果缓存的大小小于容量，则将该项添加到缓存中，并将该项追加到频率散列表中以跟踪频率</li><li id="683e" class="ln lo hi it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv bi translated">如果高速缓存的大小与容量相同，那么从高速缓存和频率散列表中移除具有最低频率的项目。如果HashMap中的frequency键没有任何成员，那么删除frequency键。</li></ol><pre class="jp jq jr js fd ka kb kc kd aw ke bi"><span id="aef5" class="kf kg hi kb b fi kh ki l kj kk">public void set(int key, int value) {<br/><br/>    if(this.get(key) != null) {<br/>        return;<br/>    }<br/><br/>    if (this.size == this.capacity) {<br/>        Node delNode = this.freqDic.get(this.minFreq).getFirst();<br/>        // remove minimum frequency<br/>        this.freqDic.get(delNode.getFreq()).remove(delNode);<br/>        if (this.freqDic.get(delNode.getFreq()).isEmpty()) {<br/>            this.freqDic.remove(delNode.getFreq());<br/>        }<br/>        this.cache.remove(delNode.getKey());<br/>        this.size -= 1;<br/>    }<br/><br/>    this.minFreq = 1;<br/>    Node node = new Node(key, value, this.minFreq);<br/>    this.cache.put(key, node);<br/><br/>    LinkedList&lt;Node&gt; ll = this.getList(this.minFreq);<br/>    ll.addLast(node);<br/>    this.freqDic.put(this.minFreq, ll);<br/>    this.size += 1;<br/>}</span></pre></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="835f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">总的来说，LRU和LFU使用得更广泛。Redis等数据库缓存支持这种<a class="ae iq" href="https://docs.redis.com/latest/rs/administering/database-operations/eviction-policy/" rel="noopener ugc nofollow" target="_blank">策略</a>以及随机策略，其中项目将被随机提取，但默认为Volatile-LRU，即LRU，其中expire值在字段中设置。在某些情况下，比如看一部最近上映的电影，MRU政策可以用来解决这个问题。而LIFO/FIFO在高速缓存策略中从不使用，但在堆栈或队列等数据结构中会大量使用。</p><p id="9c14" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">参考文献</strong></p><ol class=""><li id="d2d7" class="ln lo hi it b iu iv iy iz jc lp jg lq jk lr jo ls lt lu lv bi translated"><a class="ae iq" href="https://en.wikipedia.org/wiki/Cache_replacement_policies" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cache_replacement_policies</a></li></ol></div></div>    
</body>
</html>