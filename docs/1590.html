<html>
<head>
<title>Converting Async client to Reactive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将异步客户端转换为被动客户端</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/converting-async-client-to-reactive-69a506f80d34?source=collection_archive---------1-----------------------#2021-09-25">https://medium.com/javarevisited/converting-async-client-to-reactive-69a506f80d34?source=collection_archive---------1-----------------------#2021-09-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/899adef0b2781964fe0d32db4dac30e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5rqDnz9DnTNT5mOm"/></div></div><p class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="11e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在过去的几年里，<a class="ae iu" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">反应式编程</a>越来越流行。这有几个原因。</p><p id="c92d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最重要的是，反应式编程使用非阻塞技术来有效利用CPU。因此，同一组服务器可以处理高得多的负载。此外，声明性范式使得反应式编程易于维护，不像异步编程那样有回调地狱。</p><h1 id="748a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">项目设置</h1><p id="53df" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Java世界中有几个反应式库。本文中的例子将使用<a class="ae iu" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">项目反应器</a>,因为它与Spring框架有很好的集成。</p><p id="5575" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使用Project Reactor，让我们添加<a class="ae iu" rel="noopener" href="/javarevisited/7-best-webflux-and-reactive-spring-boot-courses-for-java-programmers-33b7c6fa8995"> reactive MVC </a>依赖项，这样现在我们将使用Netty server而不是Tomcat。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="1c47" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">高端客户</h1><p id="9d10" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我将用<a class="ae iu" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>作为例子。Elasticsearch是一个分布式数据存储，它提供了一个带有HTTP web界面的全文搜索引擎。</p><p id="5ba1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它有<code class="du lc ld le lf b"><a class="ae iu" href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/master/java-rest-high.html" rel="noopener ugc nofollow" target="_blank">HighLevelRestClient</a></code>，是一个支持异步调用的Java客户端。在本文中，我们将围绕这个支持反应式接口的客户机编写一个包装器。</p><p id="aa24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们定义所需的接口:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="8a99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lc ld le lf b"><a class="ae iu" href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html" rel="noopener ugc nofollow" target="_blank">Mono</a></code>是0或1元素的API。你可以在这里了解更多关于项目反应堆<a class="ae iu" href="https://projectreactor.io/learn" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h1 id="7d71" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">反应式实施</h1><p id="8554" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在让我们实现这个客户端。例如,<code class="du lc ld le lf b">index</code>方法如下:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="1b0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每种方法的回调侦听器是不同的，所以让我们分别定义它们。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="ea1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lc ld le lf b"><a class="ae iu" href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Sinks.html" rel="noopener ugc nofollow" target="_blank">Sink</a></code>允许以编程方式推送无功流信号。</p><p id="802e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用同样的方式实现其他方法，比如<code class="du lc ld le lf b">search</code>。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="4254" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">被动客户端使用</h1><p id="1a94" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">然后我们只需要创建这个客户端的bean:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="7600" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用它来写一个知识库。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="b1f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以现在我们可以使用反应式声明管道的所有优点与ElasticSearch进行交互。</p><p id="92ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在<a class="ae iu" href="https://github.com/wirtsleg/async-to-reactive" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整的源代码。</p></div></div>    
</body>
</html>