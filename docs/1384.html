<html>
<head>
<title>Comprehensive Queries Made Easy: JetEngine Query Builder Review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">全面的查询变得容易:JetEngine查询生成器评论</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/comprehensive-queries-made-easy-jetengine-query-builder-review-26b8c148e8f6?source=collection_archive---------0-----------------------#2021-07-14">https://medium.com/javarevisited/comprehensive-queries-made-easy-jetengine-query-builder-review-26b8c148e8f6?source=collection_archive---------0-----------------------#2021-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="ae64" class="ig ih hi bd ii ij ik il im in io ip dx translated">你知道WordPress插件通常是如何执行数据库查询来获取某些东西(CPT，术语，自定义表格数据等)的吗？)?</p></blockquote><p id="ab3d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ip hb bi translated">所有请求都在输出数据的小部件、短代码或块中配置。</p><p id="1f87" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">根据一种常见的方法，所有查询都配置在显示其数据的块中。</p><blockquote class="jt ju jv"><p id="6bea" class="ir is jw it b iu jo iw ix iy jp ja jb jx jq je jf jy jr ji jj jz js jm jn ip hb bi translated"><strong class="it hj">一方面</strong>，方便是因为可以快速显示区块，设置查询，大功告成。</p><p id="60b2" class="ir is jw it b iu jo iw ix iy jp ja jb jx jq je jf jy jr ji jj jz js jm jn ip hb bi translated"><strong class="it hj">但是另一方面</strong>，如果你需要在页面上从查询中访问数据，这种方法并不合适。</p></blockquote><p id="b326" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">这就是为什么<a class="ae ka" href="https://crocoblock.com/?ref=2817" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> Crocoblock </strong> </a>决定改变解决这个问题的方法，让查询构建器成为一个独立的功能。这不依赖于小部件、块或短代码。在本文中，我将讨论JetEngine  中的一个新的<a class="ae ka" href="https://crocoblock.com/knowledge-base/articles/jetengine-query-builder-overview/?ref=2817" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">查询构建器特性。</strong></a></p><h1 id="2a37" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是JetEngine和Crocoblock？</h1><p id="cb9a" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn ip hb bi translated">开发插件和模板来处理动态数据，甚至不用编码就能构建复杂的网站。该团队用三年时间，用数百个小部件和几十个模板，为Elementor和Gutenberg创建了20个多功能插件。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="db4f" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated"><a class="ae ka" href="https://crocoblock.com/plugins/jetengine/?ref=2817" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> JetEngine </strong> </a>是一个动态内容插件，是Crocoblock团队的一个关键开发。它帮助您创建:</p><ul class=""><li id="8961" class="ll lm hi it b iu jo iy jp jc ln jg lo jk lp ip lq lr ls lt bi translated">自定义文章类型(CPT)</li><li id="a74f" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">自定义内容类型(CCT)</li><li id="f464" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">自定义元字段</li><li id="bcd5" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">元框</li><li id="f6f0" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">选项页面</li></ul><p id="70f6" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">然后，您可以在分类法和关系特性的帮助下对其进行结构化和关联。为了在前端输出所有这些内容，JetEngine附带了用于Elementor 的<strong class="it hj"> 14个小部件和<strong class="it hj"> 10个古腾堡动态块。</strong></strong></p><p id="45e2" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">JetEngine不断更新，最近增加了一个<strong class="it hj">新的查询构建器部分</strong>。它提供了尖端的功能。</p><h1 id="d562" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">JetEngine查询生成器</h1><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/277fb3153f724d2242501a4e6d3f5fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HJkl-DqPm5pJTGtB"/></div></div></figure><p id="ca39" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated"><a class="ae ka" href="https://crocoblock.com/plugins/jetengine/?ref=2817" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">获取JetEngine查询生成器</strong> </a></p><p id="4e41" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">我已经展示并解释了查询设置通常是如何在<a class="ae ka" rel="noopener" href="/javarevisited/5-best-wordpress-courses-for-beginners-and-experienced-website-developers-b45f7976ee40">插件中实现的。</a></p><p id="e34a" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">JetEngine Query Builder提供了一种全新的方法。</p><p id="59a7" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">列表网格或任何呈现项目的块只是一个接收和输出数据的可视包装器。但是从数据库中获取这个列表的查询可以在没有块本身的情况下存在，并且仍然是有用的。</p><p id="85c5" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">因此，这些物品被转移到另一个部门进行处理。稍后，列表网格小部件接收这些项目并显示它们。</p><p id="971d" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">这是这种方法的一个示例:</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mg"><img src="../Images/15d2b25a04f497d3571007ee1411ecf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WVKUgt_2KYYuflP1"/></div></div></figure><p id="50e8" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">如您所见，只有一个查询，但它显示了:</p><ul class=""><li id="b755" class="ll lm hi it b iu jo iy jp jc ln jg lo jk lp ip lq lr ls lt bi translated">在节呈现之前查询项的计数器</li><li id="f5d9" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">列出网格前的部分中已查询项目的计数器</li><li id="474c" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">列出网格本身</li><li id="258e" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">列表网格后的计数器</li></ul><p id="cc9e" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">此外，它还可以根据基于查询结果的设置条件隐藏或显示部分。所有这些都只能从查询实例中执行。</p><p id="56cc" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">查询方法变得更加集中，现在对数据库的任何查询都在同一个界面中配置。在这里，查询作为一个独立的对象存在，可以随时访问。</p><p id="fc09" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">查询被处理一次，然后被缓存。并且在第一次调用该查询之后，所有进一步的查询都将使用缓存的值。这种方法的优势如下:</p><ul class=""><li id="ae1f" class="ll lm hi it b iu jo iy jp jc ln jg lo jk lp ip lq lr ls lt bi translated">良好的性能和速度</li><li id="7764" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">无需为每个小部件重新设置查询</li><li id="422d" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">在页面加载的任何阶段发出请求</li><li id="71d6" class="ll lm hi it b iu lu iy lv jc lw jg lx jk ly ip lq lr ls lt bi translated">添加新查询类型的灵活性</li></ul><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="be01" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">让我们从复杂的技术部分转移到描述新的查询构建器的真正好处。</p><h1 id="49bf" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">为什么需要JetEngine查询构建器？</h1><p id="01ce" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn ip hb bi translated">JetEngine允许查询CPT和CCT项目、术语、用户、评论、SQL表和REST API。</p><p id="e6ed" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">它为此提供了一个设置部分，但是您设置的条件只适用于特定的列表网格。如果您在其他页面上有类似的网格，并且需要进行一些更改，则当这些列表网格出现错误时，您必须在每个页面上手动更改设置。</p><p id="0926" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">又来了<a class="ae ka" href="https://crocoblock.com/knowledge-base/article-category/jet-engine/?ref=2817" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">查询生成器</strong> </a>！</p><p id="7c26" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">它提供了一个单一的界面来<strong class="it hj">创建列表并把它们添加到你需要的任何地方</strong>。您在“查询构建器”菜单选项卡中对列表所做的任何更改都将应用于启用该查询的所有列表网格。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mh"><img src="../Images/7576dc63c61364c3b6a86f914c00c44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zb800dyEmyp_YK9t"/></div></div></figure><p id="2cfb" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">让我们来看看具体的用例。</p><h1 id="6130" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">用例1:追加销售产品</h1><p id="5544" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn ip hb bi translated">借助Query Builder，您可以在单品页面上动态展示相关产品的目录，从而刺激您的客户购买更多产品。此外，您可以设置可见性条件，因此如果没有相关项目，此相关产品部分将不会显示。</p><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es mi"><img src="../Images/6aaa6890d220a5955a602c71b018ae66.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/0*sGLrbO8JKMBXJA2G"/></div></figure><h1 id="556c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">用例2:评论部分</h1><p id="c796" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn ip hb bi translated">现在，您可以在主页上动态显示关于您产品的评论和用户评论。</p><p id="ed55" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">同时，自定义评论的分类、撰写日期等等。</p><h1 id="94cf" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">用例#3:用户的内容</h1><p id="d06d" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn ip hb bi translated">显示用户在其用户资料页面或任何单个页面上留下的评论，并通过帖子状态或日期进行查询。</p><h1 id="49ce" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">总结</h1><p id="dde0" class="pw-post-body-paragraph ir is hi it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn ip hb bi translated">JetEngine是一个动态内容插件，可以帮助你创建即使是最复杂的网站，而无需编码技能。在上一次更新中，JetEngine获得了新模块Query Builder。它以一种全新的方式实现了构建查询。</p><p id="3c20" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated"><strong class="it hj"> Paul Charlton </strong>在<strong class="it hj"> WPTuts Youtube频道</strong>的视频中清楚地展示了这一点:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="f8bb" class="pw-post-body-paragraph ir is hi it b iu jo iw ix iy jp ja jb jc jq je jf jg jr ji jj jk js jm jn ip hb bi translated">简而言之，Query Builder是一个统一的系统，用于排序和显示不同的WordPress元素——文章、术语、用户、评论、<a class="ae ka" rel="noopener" href="/hackernoon/top-5-sql-and-database-courses-to-learn-online-48424533ac61"> SQL表</a>、<a class="ae ka" rel="noopener" href="/javarevisited/10-best-java-web-services-rest-soap-and-api-courses-for-beginners-724a8f51298d"> REST API </a>。</p></div></div>    
</body>
</html>