<html>
<head>
<title>Good News and Bad News, Pivot and Turn — Building DDTJ Day 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">好消息和坏消息，支点和转向—构建DDTJ第6天</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/good-news-and-bad-news-pivot-and-turn-building-ddtj-day-6-3795d30882b9?source=collection_archive---------2-----------------------#2021-12-28">https://medium.com/javarevisited/good-news-and-bad-news-pivot-and-turn-building-ddtj-day-6-3795d30882b9?source=collection_archive---------2-----------------------#2021-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0d5812a8312ff4e73195512c4456060b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhhJySGSDiFZhY-b59FnjA.png"/></div></div></figure><p id="ce9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上周我<a class="ae jo" href="https://dev.to/codenameone/series/15971" rel="noopener ugc nofollow" target="_blank">花了5天时间建造和设计</a>的<a class="ae jo" href="https://github.com/ddtj/ddtj" rel="noopener ugc nofollow" target="_blank"> DDTJ项目</a>。希望我能在这个周末完成MVP。当我们上周离开这个系列时，我被卡住了。本周有一点进步…</p><p id="c17a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于好消息/坏消息的笑话有很多变体。我相信你们都知道它的一些形式…这里有一个面向编程的:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="82bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本着这种精神，我已经取得了一些进展，我们现在正在收集一些数据…坏消息是:我不得不放弃许多概念，性能比没有我们的仪器大约差700倍。呃。</p><h1 id="4f4f" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">我是怎么到这里的？</h1><p id="d2ce" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">上周，在调试远程虚拟机时，我还在对本地存储的对象进行建模。您可能还记得，debug API需要在本地复制对象，以便我们稍后可以分析它们。我们不能将它留在目标虚拟机中，因为随着虚拟机的继续运行，数据将会丢失。</p><p id="11ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我创建了一个数据模型并实现了一个调试器，它可以有效地自动调试应用程序并存储所有数据。不幸的是，这并不像人们希望的那么简单。</p><p id="5a28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最初，我想我应该使用step over API来检查单独的行。这包括一些问题:</p><ul class=""><li id="f4dd" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">不看源代码/字节码，我不知道一行包含什么，我也不想陷入这种复杂性</li><li id="f15b" class="ky kz hi is b it lh ix li jb lj jf lk jj ll jn ld le lf lg bi translated">我不能同时有两个跨越监视器的实例。这是嵌套方法调用、线程等需要的东西。</li></ul><p id="75fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以使用单步执行代码的方法对于这个工具来说是不实际的…</p><h1 id="1eb8" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">方法进入/退出</h1><p id="9bd5" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">幸运的是，几乎所有调试API都支持设置方法进入/退出事件。这让我们可以监控所有重要的点，并记录所有相关的信息。完美…几乎…</p><p id="96e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问题是，假设我们有这样的代码:</p><pre class="jp jq jr js fd lm ln lo lp aw lq bi"><span id="4844" class="lr jw hi ln b fi ls lt l lu lv">public void myMethod(int x) {<br/>    otherObject.otherMethod(x, y);<br/>}</span></pre><p id="ce2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个序列，我将得到4个事件:</p><pre class="jp jq jr js fd lm ln lo lp aw lq bi"><span id="654f" class="lr jw hi ln b fi ls lt l lu lv">Method enter to myMethod<br/>Method enter to otherMethod<br/>Method exit on otherMethod<br/>Method exit on myMethod</span></pre><p id="dc61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，一切顺利。但问题是。我需要记录在<code class="du lw lx ly ln b">myMethod</code>中对<code class="du lw lx ly ln b">otherMethod</code>的调用，这样我可以在以后模拟它。</p><p id="25f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我该怎么做？</p><p id="eeb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要分析数据，并查看与<code class="du lw lx ly ln b">myMethod</code>的呼叫层级相关的数据。</p><p id="9e1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决方案是以某种方式知道进入事件和退出事件是相关的。最初，我试图动态创建退出事件，并将其限制到特定的对象实例。但是递归失败了。</p><p id="2baa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我尝试了几种方法。我现在有一个能用的，但是不理想…</p><h1 id="4a70" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">当前的方法</h1><p id="f9d1" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">当方法进入时，我创建一个唯一可重复的字符串。它大致由以下公式构成:</p><pre class="jp jq jr js fd lm ln lo lp aw lq bi"><span id="81e5" class="lr jw hi ln b fi ls lt l lu lv">threadId + object instance id (if not static) + frame count + callstack</span></pre><p id="73e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个相对较长的字符串，但它是唯一的。当输入一个方法时，我们在地图中放置一个对象，并以此作为键。然后，当退出该方法时，我们使用相同的键找到对象。</p><p id="412f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们可以连接方法入口/出口，从而记录我们需要的所有数据。</p><h1 id="be5b" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">表演</h1><p id="2932" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">不幸的是，这还不够。<code class="du lw lx ly ln b">700x</code>远高于调试环境中合理的<code class="du lw lx ly ln b">10x</code>或可承受的<code class="du lw lx ly ln b">20x</code>性能下降。通常我们需要远离过早的优化，但是如果架构中有概念上的缺陷，我们需要理解它。<code class="du lw lx ly ln b">700x</code>这不是我们可以实际操作的。</p><p id="dc4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我的下一个重点是为拉请求准备好当前的代码，然后继续了解性能影响以及到底是什么导致了这种开销。</p><p id="62f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于这个问题，我有很多理论，但是经验告诉我不要去理会它们。很多时候，我们认为“昂贵”的东西实际上只是一个小小的凸起。我们贴现的东西最终成为了巨大的损失。侧写员会告诉我们时间浪费在哪里，我可以根据事实进行评估。现在我不想看。如果我这样做了，我将不能停下来，重要的是停下来，与主干同步并迭代地移动。</p><h1 id="2d34" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">明天</h1><p id="81ca" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">这是一个简短的帖子，因为我还在忙于发布PR和加快测试速度。一旦完成，我希望能进入侧写阶段。<br/>按照目前的速度，我认为我最初的目标是拥有一个可以为spring boot生成测试的工具，这个目标可能在本周会很高。我将降低对调试hello world应用程序和生成简单测试用例的期望。在我经历了这个API的所有事情之后，这看起来也是一个相当雄心勃勃的目标。</p><p id="b5e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想了解这个系列的最新进展以及我从事的许多其他工作，那么<a class="ae jo" href="https://twitter.com/debugagent" rel="noopener ugc nofollow" target="_blank">在twitter上关注我</a>。</p></div></div>    
</body>
</html>