<html>
<head>
<title>JAVA Developer Guide to begin with Wire-Tap Enterprise Integration Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA开发人员指南从Wire-Tap企业集成模式开始</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-developer-guide-to-begin-with-wire-tap-enterprise-integration-pattern-27a385231dd8?source=collection_archive---------1-----------------------#2022-05-21">https://medium.com/javarevisited/java-developer-guide-to-begin-with-wire-tap-enterprise-integration-pattern-27a385231dd8?source=collection_archive---------1-----------------------#2022-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e6527f5e890d82d29743b2ae1a455a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cB1oV4soM4IsjhD6SW2Pug.jpeg"/></div></div></figure><p id="7bb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">监听是监控机构用来监控电话的术语。如果你在大多数黑客或科幻电影/系列中看到过电话窃听或信号拦截活动，你可能会知道这个术语。软件企业也使用类似的概念来监控或拦截两个服务之间的数据流。Wire-Tap模式有助于解决拦截数据的问题，而不会中断服务之间的流。</p><h1 id="3baa" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是窃听模式？</h1><p id="94b0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Wire-Tap是《企业集成模式:设计、构建和部署消息传递解决方案》一书<a class="ae kr" rel="noopener" href="/javarevisited/top-5-books-to-learn-spring-boot-and-microservices-for-experienced-java-developers-499a9d921d18">中的设计模式之一，该书描述了简单的路由器(也称为Tee)将消息从一个输入通道复制到两个输出通道。</a></p><figure class="kt ku kv kw fd ij er es paragraph-image"><a href="https://www.java67.com/2016/10/top-5-object-oriented-analysis-and-design-patterns-book-java.html"><div class="er es ks"><img src="../Images/653f2f817f805b228c19688e3085ec44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ucsKHrrqfjaoAa80DODsw.png"/></div></a></figure><p id="c9e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在软件系统中的大多数情况下，需要监控或复制流经的数据。这通常是通过截取数据并将其重定向到不同的位置来实现的，如监控仪表板、控制台、文件系统或数据库。这种功能不能改变原始数据，也不能中断服务流程。</p><h1 id="b9ff" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">线抽头模式JAVA示例</h1><p id="f85f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">假设我们正在构建一个消息窃听系统，它拦截来自交换机的数据。在这个例子中，我使用Switch从一个源队列消费数据，并将其推送到一个目标队列。增加了窃听服务，以拦截消息处理器交换机上的数据。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><a href="http://www.java67.com/2013/12/strings-in-switch-case-java-7-tutorial.html"><div class="er es kx"><img src="../Images/789913f5aeb2c89b50093cb18a82335a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzoX4QUUIY2eDEIhI2WjdQ.png"/></div></a></figure><h2 id="a36f" class="ky jp hi bd jq kz la lb ju lc ld le jy jb lf lg kc jf lh li kg jj lj lk kk ll bi translated">消息定义:</h2><p id="cbe5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">对于<strong class="is hj">消息</strong>模型，我有<strong class="is hj"> id </strong>、<strong class="is hj">文本</strong>和<strong class="is hj">消息日期</strong>字段。被覆盖的<strong class="is hj"> toString </strong>方法返回<a class="ae kr" href="https://javarevisited.blogspot.com/2018/02/how-to-parse-json-with-date-field-in-java-jackson-example.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> JSON </strong> </a>类似的字符串进行输出。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h2 id="d8c8" class="ky jp hi bd jq kz la lb ju lc ld le jy jb lf lg kc jf lh li kg jj lj lk kk ll bi translated">发件人服务:</h2><p id="d83a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在发送方服务线程中，生成<strong class="is hj">消息</strong>对象(使用<strong class="is hj"> getMessage </strong>方法)并在<strong class="is hj"> run </strong>方法中将其推送到<a class="ae kr" href="https://javarevisited.blogspot.com/2017/03/difference-between-stack-and-queue-data-structure-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">队列</strong> </a> <strong class="is hj"> </strong>。这里<strong class="is hj"> messageId </strong>字段用于为每个生成的<strong class="is hj">消息</strong>对象生成唯一的密钥。<strong class="is hj">随机</strong>字段用于为<strong class="is hj">消息</strong>对象生成随机<strong class="is hj">文本</strong>。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h2 id="f1c1" class="ky jp hi bd jq kz la lb ju lc ld le jy jb lf lg kc jf lh li kg jj lj lk kk ll bi translated">接收器服务:</h2><p id="3a5d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在接收方服务线程中，消耗<strong class="is hj">队列</strong>中的<strong class="is hj">消息</strong>对象<a class="ae kr" href="https://javarevisited.blogspot.com/2012/03/difference-between-start-and-run-method.html" rel="noopener ugc nofollow" target="_blank">中的<strong class="is hj">运行</strong>方法</a>。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h2 id="b37e" class="ky jp hi bd jq kz la lb ju lc ld le jy jb lf lg kc jf lh li kg jj lj lk kk ll bi translated">消息处理器开关:</h2><p id="cda0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在消息处理器线程中，从<strong class="is hj">源</strong>队列中拉出<strong class="is hj">消息</strong>对象，并将其推送到<strong class="is hj">目的</strong>队列中，但在中间调用<strong class="is hj"> wiretapService </strong>对象的<strong class="is hj"> wiretap </strong>方法来拦截消息。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h2 id="135c" class="ky jp hi bd jq kz la lb ju lc ld le jy jb lf lg kc jf lh li kg jj lj lk kk ll bi translated">窃听服务:</h2><p id="7455" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在窃听服务线程中，每当使用<strong class="is hj">消息</strong>对象调用<strong class="is hj">窃听</strong>方法时，就会使用<strong class="is hj"> MessageCloneUtil </strong>实用程序类创建一个深度克隆的<strong class="is hj">消息</strong>，并将其推送到其<a class="ae kr" href="https://www.java67.com/2022/04/how-to-to-perform-union-of-two-linked.html" rel="noopener ugc nofollow" target="_blank">队列 </a>中进行进一步处理。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h2 id="4591" class="ky jp hi bd jq kz la lb ju lc ld le jy jb lf lg kc jf lh li kg jj lj lk kk ll bi translated">消息克隆实用程序:</h2><p id="9803" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">由于我们在<strong class="is hj">消息</strong>对象中有不可变字段<strong class="is hj"> id </strong>为<strong class="is hj"> long </strong>和<strong class="is hj"> text </strong>为<strong class="is hj"> String </strong>，所以在深度克隆时，我按原样使用它们。但是创建一个新的<a class="ae kr" href="https://www.java67.com/2018/01/how-to-change-date-format-of-string-in-java8.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">日期</strong>对象</a>，其值与原始的<strong class="is hj">输入</strong>相同。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="8d1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">行动中的窃听模式:</strong></p><p id="ec03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的演示代码中，为创建服务创建了两个队列。使用它们两个来创建一个<strong class="is hj"> MessageProcessorSwitch </strong>线程，只使用<strong class="is hj">源</strong>队列来创建一个<strong class="is hj">发送方服务</strong>线程，只使用<strong class="is hj">目的方</strong>队列来创建一个<strong class="is hj">接收方服务</strong>线程。每当<strong class="is hj"> SenderService </strong>线程将<strong class="is hj">消息</strong>推送到<strong class="is hj">源</strong>队列时，两个线程(<strong class="is hj"> ReceiverService </strong>和<strong class="is hj"> WiretapService </strong>)都在获取数据。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="28df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">源代码可从<a class="ae kr" href="https://github.com/s3c-d43m0n/Desing-Patterns-in-JAVA/tree/main/Integration/Wiretap" rel="noopener ugc nofollow" target="_blank">https://github . com/s3c-d43m 0n/Desing-Patterns-in-JAVA/tree/main/Integration/Wiretap</a>获得</p><h1 id="77c1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">实施中的关键点</h1><ul class=""><li id="077e" class="lo lp hi is b it km ix kn jb lq jf lr jj ls jn lt lu lv lw bi translated"><strong class="is hj">消息</strong>对象<strong class="is hj"/></li><li id="a4bf" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated">在实现模式时，不能中断两个服务之间的现有流。这里<strong class="is hj"> WiretapService </strong>被定义为<strong class="is hj"> MessageProcessorSwitch </strong>类中的<strong class="is hj">私有</strong>字段，因为我们不想将其暴露给其他资源。</li><li id="bada" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated">这里我使用了<a class="ae kr" href="https://javarevisited.blogspot.com/2012/12/blocking-queue-in-java-example-ArrayBlockingQueue-LinkedBlockingQueue.html" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">blocking queue</strong></a>对象作为<a class="ae kr" href="https://www.java67.com/2021/07/how-to-implement-thread-safe-bounded-buffer-in-java.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">线程安全</strong>队列</a>，因为我有多个线程拉/推<strong class="is hj">消息</strong>对象。我们可以根据需求进行更改。</li><li id="56be" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated">这里，我将队列用于消费者/生产者场景。<strong class="is hj">高端</strong>软件系统在专门处理<strong class="is hj">微服务</strong>时，大多都在使用<a class="ae kr" href="https://javarevisited.blogspot.com/2020/05/top-16-jms-java-messaging-service-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> JMS </strong> </a>或<a class="ae kr" rel="noopener" href="/javarevisited/top-10-apache-kafka-online-training-courses-and-certifications-621f3c13b38c"> <strong class="is hj"> KAFKA </strong> </a>等排队解决方案。</li></ul><p id="4825" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mc">你最喜欢的设计模式是什么，或者如果你想更好地理解任何其他模式或主题，请随时联系我，在</em><a class="ae kr" href="https://www.linkedin.com/in/ritvik92/" rel="noopener ugc nofollow" target="_blank"><em class="mc">LinkedIn</em></a><em class="mc">或</em><a class="ae kr" href="https://forms.gle/XFsuo1ZbP35gfqAX7" rel="noopener ugc nofollow" target="_blank"><em class="mc">Google Form</em></a><em class="mc">上，我会尽量在下次介绍它！</em></p><p id="3d7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请把这个分享给你所有的媒体朋友，然后点击那个👏按钮，以扩大它的范围。未来更新请关注 <a class="ae kr" rel="noopener" href="/@ritvik.singh.chauhan"> <em class="mc"> me </em> </a> <em class="mc">。感谢阅读。</em></p></div></div>    
</body>
</html>