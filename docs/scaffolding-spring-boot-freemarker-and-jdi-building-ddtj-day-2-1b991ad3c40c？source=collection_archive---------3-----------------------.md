# 搭建 Spring Boot、Freemarker 和 JDI 的脚手架——构建 DDTJ，第 2 天

> 原文：<https://medium.com/javarevisited/scaffolding-spring-boot-freemarker-and-jdi-building-ddtj-day-2-1b991ad3c40c?source=collection_archive---------3----------------------->

![](img/0d5812a8312ff4e73195512c4456060b.png)

昨天我讨论了从头开始构建一个新的开源项目的第一步(这也非常适用于商业项目)。今天，我们继续第一阶段，即搭建实际项目和挑选工具。剧透一下，我选了 Spring Boot 应用框架…

# 为什么我选择了 Spring Boot？

这是一个简单的选择:

*   Spring Boot 非常成熟
*   我很了解 Spring Boot
*   Spring framework 的配置方法将允许项目增长以支持额外的用例
*   Spring Boot 的本地支持将让我把最终的应用打包成一个可执行文件

显而易见的问题是，我为什么要考虑别的东西？

我很矛盾，因为 Spring Native 仍然缺少一些我需要的东西，比如 Freemarker 支持(或者任何模板引擎)。我认为从长远来看，为这个工具提供本地编译是非常重要的。但是对于第一个 MVP，我认为这是一个“过早的优化”。此外，我觉得我所熟悉的春天的替代品并不成熟。

这很重要:尽量避免 MVP 的新技术。我说的“新”是指你不熟悉的工具。

我关心的另一件事是 [Spring Boot](/javarevisited/top-10-courses-to-learn-spring-boot-in-2020-best-of-lot-6ffce88a1b6e) 的大小。其他应用程序开发框架通常以内存占用更小、启动时间更快而自豪。从长远来看，这些事情很重要。但是我认为，以后移植 Spring Boot 应用程序比研究基于供应商利基基准的东西更容易。

我使用 [Spring Initializr 工具](https://start.spring.io/)创建了一个基础项目，它生成了一些样板配置和源代码。我避免了许多您通常添加到 spring 应用程序中的标准 Spring 集成选项，例如:

*   Spring Data —我们不需要数据库访问或数据库连接。为了提高性能，一切都直接存储在内存中。甚至不是内存数据库，没有必要
*   **Spring Security** —应用在虚拟机本地运行。是的，安全是至关重要的，但 Spring Security 过度关注 web 安全。我们甚至不会用 HTTPS 来评选 MVP
*   **春云** —这个工具我们不需要任何云服务。它需要在本地快速工作

我为 RESTful web 服务添加了 Spring Boot web 支持。我考虑过使用 WebFlux，但我不确定它是否能为这种类型的应用程序提供更好的性能。此外，对于新的架构，我认为这并不重要。

目前我不需要 Spring 框架的大部分特性，比如自动配置、依赖管理等等。但随着我们的前进，它们会派上用场。例如，使用外部配置文件定制为特定公司生成的模板的能力在企业设置中非常有用。

现在，我所做的唯一配置更改是设置:

```
server.port=2012
```

在配置属性文件中(我使用 12 月 20 日作为数字，这不是一个众所周知的端口)。spring 的好处在于，即使你在那个端口上有一些东西，使用`-Dserver.port`在不同的端口上启动它也是微不足道的。

# 模板引擎

Spring Boot 广泛支持 Freemarker、Velocity 和百里香。这三个我都用过，但据我所知，大多数是用 Freemarker，而百里香主要是用于 HTML。该项目需要 Java 代码生成，Freemarker 可以做到这一点(Velocity 也可以)。这不是我自己做过的事(用 Freemarker ),但是有很多样本代码。我仍然不确定它是否能很好地满足我的需求，但是当我们生成源代码时，我们会知道的。

目前，我只是添加了依赖项，还没有编写一行 Freemarker 资源模板…我不确定它是否合适，或者对于成品来说是否足够。我们得看看那件事。

无论哪种方式，我们都可以在稍后将它与 Spring MVC 一起用于一个简单的 web 应用程序 UI。

# Java 11 全面普及

我想用 Java 17。当我用 Java 17 作为 JDK 开始甚至生成第一个项目时，我真的想这么做。我的思考过程围绕着使用 Java 17 和 GraalVM 来编译它，但是它还不支持 17，Spring Boot 也不能用 Freemarker 编译到 native。

所以现在我标准化了 Java 11，随着这些项目的成熟，我会重新评估，把我从 JDK 更新周期中解放出来。

# 龙目岛和皮科岛 CLI

因为我要用 JDK 11 号，不能用唱片，所以我用了龙目岛。我知道这是有争议的，但是到目前为止它对我来说是有效的，并且支持 Spring Boot 本地编译。我认为许多人讨厌 Lombok，因为他们在 Spring Data/JPA 代码中误用了 equals/hashcode 支持。这将导致问题，正如我在这里提到的。

对于命令行界面，我使用了 [PicoCLI](https://picocli.info/) 。很久以前我就想写它了，但被其他事情耽搁了。当我们开始运行 Lightrun 时，我研究了许多用于 Java 的 CLI 工具。他们都很糟糕。我和其他人一样喜欢固执己见的方法，但是他们真的不让我定义 CLI 代码的语法。

当我已经放弃的时候，我尝试了 Pico CLI。我的期望很低，但完全被吹走了。它易于使用，同时功能强大。我再也不想看到一个`argv`！

# 一个启示和战略转变

我花了几个月的时间到处思考滴滴涕。许多架构在我脑海中循环，最终我选定了一个。我可以很好地看到大场景…

然后，当我开始搭建 Spring Boot 代码时，我开始意识到这种方法是完全错误和浪费的。这通常是设计的问题。一旦我们将一些事情提交到一个文档中，并跟随“团队”前进，我们经常会觉得我们已经和我们选择的方向结婚了。我们无法“感受”一个设计。当我开始在 Spring Boot 编写代码时，这种方法变得更加清晰。

我最初的方法由三部分组成:

1.  在目标虚拟机中运行的代理，与 Spring Boot 后端通信
2.  存储代理状态的 Spring Boot 后端
3.  与 Spring Boot 后端通信的 CLI 工具

然后我开始想:我们到底为什么需要一个经纪人？

这是我最初的方法，因为大多数工具都是这样构建的，但这个特定的工具只能利用 JDI API，而不是代理 API。如果我们这样做了，我们甚至不需要离开舒适的 Spring Boot。这可能意味着我们可以升级到 Java 17，而目标虚拟机仍然可以运行 Java 8，如果我们愿意的话。

在最初的架构中，我考虑了类文件操作来适应字节码。

这种架构更加简单快捷。它将减少一些通信，应该工作良好。希望规模合适。

# 数据模型

我今天主要关注的是数据模型。将正确的字段放置到位，并定义调试过程将存储调用的结构。我在后端 spring 框架代码和 CLI 代码之间共享了数据模型。

当我还是一个年轻的程序员时，有一条公理:正确的数据结构是项目所需工作的 50%。我不知道是不是 50%，但是当你考虑数据模型的时候，项目的拼图就到位了。

# 单一回购

我选择了单一回购方式，而不是多个项目。这背后有几个原因:

*   这更容易，我们有一个版本，我们在一个地方更新所有的部分
*   开始/跟随/分叉的一个位置
*   CI 和集成测试要容易得多
*   一点是拥有所有的文件，而不是把人们送上一条采摘樱桃的道路

当我开始使用 git 时，人们说服我拆分我的回购，因为“git 就是这么用的”。我愚蠢地听信了那个…巨大的错误。

# CI、声纳和 Snyk

我不喜欢代码评审，对声纳云也不太感冒。在 PR 上得到一个错误消息从来都不是一件有趣的事情…但是它捕捉到了错误并且做得相当好。不像人类评论家，它是迅速的，一致的和彻底的。这有点“极端”，它的一些吹毛求疵让我抓狂，但我觉得它让我成为一名更好的程序员。它真的在我的初始代码中发现了错误，这很神奇，因为代码很少。我喜欢错误消息是主动的，并且有很好的建议。再说一次，比大多数人都要好。

让我疯狂的一件事是，我收到一些“代码气味”警告，这些警告完全没问题，但我不能“删除它们”。例如，我需要使用[com . sun API](https://github.com/ddtj/ddtj/blob/main/Backend/src/main/java/dev/ddtj/backend/javadebugger/MonitoredSession.java#L20-L23),因为没有 Java API 可供选择。这是一个有文档记录的 API，但仍然…或者有一个警告，建议我在[这个块](https://github.com/ddtj/ddtj/blob/main/Backend/src/main/java/dev/ddtj/backend/javadebugger/MonitoredSession.java#L86-L106)中使用 Maps computeIfAbsent 而不是`get()`。一般来说，我会接受的。但是我在这个过程中使用了同步，并且缩小了锁的范围。所以我想在完成“计算”后从那个块返回。这使得锁的效率更高(可以说，因为走出锁而进入另一个锁是有细微差别的...

不管怎样，总是看着警告让我觉得我在做错事。

我将它集成到 GitHub actions 中，这很容易做到，并为 CLI 和 Spring Boot 后端代码添加了工件。因此，当一些东西开始工作，我们将有历史性的建设等。开始工作。相当整洁。

最后，我添加了 [Snyk](https://snyk.io/) ，这对于当前的漏洞状态似乎是必不可少的。既然它对开源项目是免费的，我们应该试着让它出现在我们所有的回购上。集成很简单，这很好。不幸的是目前徽章似乎正遭受[这个问题](https://github.com/snyk/snyk/issues/347)。

代码就在那里；(目前)看起来没什么，但构建项目的基本框架正在形成。

# 明天

这是忙碌的一天，如果你跟踪这个项目，代码正在充实。我目前的主要工作是调试 API 和将我们需要的核心数据导入 Spring Boot 后端。

所以明天我打算更多地讨论这个问题。使用 JDI 和网络界面。我还将讨论代码覆盖、测试等。我甚至可能开始研究我写的代码，讨论我为什么做各种事情。现在它仍然有点太抽象，有代码，但我不知道它是否有任何好处。

如果你觉得这很有趣/有用，你可以在 twitter 上关注我，我在那里发布我做的一切。爸爸开玩笑说…