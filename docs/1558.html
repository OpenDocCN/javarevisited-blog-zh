<html>
<head>
<title>Java 14 — New Language Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 14 —新的语言特性</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-14-new-language-features-1e185b7f120?source=collection_archive---------2-----------------------#2021-09-14">https://medium.com/javarevisited/java-14-new-language-features-1e185b7f120?source=collection_archive---------2-----------------------#2021-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/6ad4a6e51f3556e1afb2dacdf6c9ad50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qm-9NVDX_ceOhTfM8lN1Mg.png"/></div></div></figure><div class=""/><p id="7183" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java 14语言中引入了相当多的更新；也就是说，两个<strong class="is hu">预览版</strong>，一个<strong class="is hu">二次预览版</strong>，以及一个最终版特性是你将在Java 14中看到的新特性。</p><p id="2404" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是我们今天将要深入了解的<em class="jo">新闻:</em></p><ul class=""><li id="ee84" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hu">实例的模式匹配(预览)(JEP 305) </strong></li><li id="cb16" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hu">记录(预览)(JEP 359) </strong></li><li id="e92f" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hu">开关表达式(标准)(JEP 361) </strong></li><li id="c20c" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hu">文本块(第二次预览)(JEP 368) </strong></li></ul><p id="5a8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我会一次解释一个，并且尽可能深入。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="04e2" class="kk kl ht bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><strong class="ak">用于实例的模式匹配(预览)(JEP 305) </strong></h1><p id="b48d" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">我们都使用过<code class="du ln lo lp lq b">instanceof</code>关系运算符，在运行时检查某个对象是否是特定类型的的<em class="jo">实例。</em></p><p id="ae67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">让我们简单回顾一下:<br/> </strong> <code class="du ln lo lp lq b">instanceof</code>运算符，像所有其他<em class="jo">关系运算符</em>一样，形成一个布尔表达式，其一般语法如下:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="6e77" class="lz kl ht lq b fi ma mb l mc md">a instanceof B</span></pre><p id="bedf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它检查对象(<code class="du ln lo lp lq b">a</code>)是否是特定类型(<code class="du ln lo lp lq b">B</code>)、子类型或实现接口的类的实例。如果是，表达式的计算结果为<code class="du ln lo lp lq b">true</code>，否则为<code class="du ln lo lp lq b">false</code>。</p><ul class=""><li id="78cd" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><code class="du ln lo lp lq b">a</code> <em class="jo"> </em>可以是(1)引用变量，(2)类实例化表达式，(3)枚举常量，或者(4)<code class="du ln lo lp lq b">null</code>；</li><li id="a78a" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du ln lo lp lq b">B</code>可以是(1)类名，(2)接口名，或(3)枚举名；</li><li id="adb6" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du ln lo lp lq b">a</code>和<code class="du ln lo lp lq b">B</code>必须是可转换类型——它们必须在继承树关系中，否则就是编译时错误。</li></ul><p id="b350" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，比方说，如果你的方法接受一个类型为<code class="du ln lo lp lq b">java.lang.Object</code>的参数，或者你迭代一个包含子类型实例的bit通用类型的集合，或者如果有任何其他情况，你不确定<em class="jo">的对象在运行时必须处理哪种特定类型</em>，你可能首先想要确切地知道该对象是否是特定类型<code class="du ln lo lp lq b">X</code>的实例；否则，您将无法安全地向下转换对象并访问(操作)其成员。</p><p id="825f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，你必须写出这样的东西:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="6d7c" class="lz kl ht lq b fi ma mb l mc md">if (obj instanceof X) {<br/>   X x = (X)obj;<br/>   //...<br/>}</span></pre><p id="2eb7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重述够了。现在让我们看看上面的例子中有哪些可以改进的地方。它包含:</p><ol class=""><li id="204c" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn me jv jw jx bi translated">测试<code class="du ln lo lp lq b">obj</code>是否为<code class="du ln lo lp lq b">X</code>的实例；</li><li id="1854" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">如果是，则将<code class="du ln lo lp lq b">obj</code>铸造成<code class="du ln lo lp lq b">X</code>型；</li><li id="5e47" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">在问题中声明一个类型的变量，并给它赋值，即casted object(如果<code class="du ln lo lp lq b">ClassCastException</code>没有发生)。</li></ol><p id="ac8d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你不觉得这三个步骤构成了你一直有的重复仪式(have！before now)去做，为了能够使用在编译时类型不确定的接收对象(也就是指<code class="du ln lo lp lq b">x</code>所指的，在强制转换之后)？</p><p id="e94a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">避免这种乏味的仪式是特性的实例的<em class="jo">模式匹配的动机，这表明，每当类型检查布尔表达式计算为<code class="du ln lo lp lq b">true</code>(即实例恰好是它所检查的任何对象的类型)，类型转换应该是不必要的，因为如果你测试对象是否是特定类型的实例，你可能想对该对象做的唯一事情，就是<em class="jo">将它转换为所讨论的类型。</em></em></p><p id="831c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，为了更专注于逻辑，而不是冗长的语言语义(这实际上在使用<code class="du ln lo lp lq b">instanceof</code>时总是必要的)，<em class="jo">模式匹配</em>提出了一种更新、更简洁的语法，对于上面的同一个例子，它看起来像:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="2a97" class="lz kl ht lq b fi ma mb l mc md">if (obj instanceof X x) {<br/>    //x is in scope<br/>} else {<br/>    //x is NOT in scope<br/>}</span></pre><p id="5dea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此语法中:</p><ol class=""><li id="120a" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn me jv jw jx bi translated">每当<code class="du ln lo lp lq b">obj instanceof X</code>为<code class="du ln lo lp lq b">true</code>时，<code class="du ln lo lp lq b">obj</code>引用被转换为类型<code class="du ln lo lp lq b">X</code>，然后被赋值给<code class="du ln lo lp lq b">x</code>；</li><li id="e996" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">注意，绑定变量的范围(在本例中是<code class="du ln lo lp lq b">x</code>)是由<code class="du ln lo lp lq b">if</code>的布尔表达式的语义决定的，它将只在<em class="jo"> true </em>块的范围内。<br/>在上面的例子中，如果<code class="du ln lo lp lq b">obj</code>不是<code class="du ln lo lp lq b">X</code>的一个实例，你将不会把它作为<code class="du ln lo lp lq b">X</code>类型的对象，存储在<code class="du ln lo lp lq b">x.</code>中，在紧接着<code class="du ln lo lp lq b">if</code>的块中；然而，如果它是<code class="du ln lo lp lq b">!(obj instanceof X x)</code>，那么<em class="jo">真</em>块应该是<code class="du ln lo lp lq b">else</code>，这就是绑定变量<code class="du ln lo lp lq b">x</code>应该只在范围内的地方；</li><li id="fe84" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">如果<code class="du ln lo lp lq b">if</code>语句的条件是一个复合布尔表达式(由<code class="du ln lo lp lq b">&amp;&amp;</code>或<code class="du ln lo lp lq b">||</code>组成)，那么绑定变量(用你正在检查的<code class="du ln lo lp lq b">instanceof</code>的类型声明)在<code class="du ln lo lp lq b">&amp;&amp;</code>右边的作用域和<em class="jo">真</em>块中，但是如果在<code class="du ln lo lp lq b">||</code>的右边就不在作用域中。</li></ol><p id="5727" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">形式上:</p><ol class=""><li id="27eb" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn me jv jw jx bi translated">一个<em class="jo">模式</em>是(1)一个可以应用于目标的<em class="jo">谓词</em>和(2)一组<em class="jo">绑定变量</em>的组合，只有谓词成功应用于目标时，才能从目标中提取这些变量；</li><li id="d049" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">类型测试模式由一个指定类型的谓词和一个绑定变量组成；</li><li id="d60c" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated"><code class="du ln lo lp lq b">instanceof</code>操作符被扩展以接受类型测试模式，而不仅仅是类型。在上面的例子中，短语<code class="du ln lo lp lq b">X x</code>是类型测试模式。</li></ol><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/9a9376479a750f7179687fd9e8984933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJqin3GhiGZ37xpCLlUe6A.png"/></div></div></figure><h1 id="80ac" class="kk kl ht bd km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh bi translated"><strong class="ak">记录(预览)(JEP 359) </strong></h1><p id="0116" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">很长一段时间以来，当谈到语法时，Java一直被指责为非常冗长。</p><p id="83fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果您只想创建一个简单的POJO类，该类只用三个字段来模拟Employee:<code class="du ln lo lp lq b">name</code>、<code class="du ln lo lp lq b">surname</code>和<code class="du ln lo lp lq b">position</code>，那么您应该编写以下代码:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="1e61" class="lz kl ht lq b fi ma mb l mc md">public class Employee {<br/>    <br/>    private String name;<br/>    private String surname;<br/>    private Position position;<br/>    <br/>    public Employee() {<br/>    }</span><span id="e46e" class="lz kl ht lq b fi ml mb l mc md">    public Employee(String n, String s, Position p) {<br/>    <br/>        this.name = n;<br/>        this.surname = s;<br/>        this.position = p;<br/>    <br/>    }<br/>    <br/>    public String getName() {<br/>        return this.name;<br/>    }<br/>    <br/>    public String getSurname() {<br/>        return this.name;<br/>    }</span><span id="5a29" class="lz kl ht lq b fi ml mb l mc md">    public Position getPosition() {<br/>        return this.name;<br/>    }</span><span id="fc8b" class="lz kl ht lq b fi ml mb l mc md">    public void setName(String name) {<br/>        this.name = name;<br/>    }</span><span id="5d97" class="lz kl ht lq b fi ml mb l mc md">    public void setSurname(String surname) {<br/>        this.surname = surname;<br/>    }<br/>    <br/>    public void setPosition(Position p) {<br/>        this.position = p;<br/>    }<br/>    <br/>    //toString..</span><span id="655f" class="lz kl ht lq b fi ml mb l mc md">    //hashCode..</span><span id="34a9" class="lz kl ht lq b fi ml mb l mc md">    //equals..</span><span id="0b68" class="lz kl ht lq b fi ml mb l mc md">}</span></pre><p id="34a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有这些代码..构造函数、getters、setters、equals()、hashCode()、toString()..对于创建一个数据载体类来说实在是太多了，您将使用它的实例将数据从一层传送到另一层；从一个抽象到另一个抽象；从一个仓库到另一个。</p><p id="4aa1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正因为如此，开发人员经常会忘记、省略或者忽略一些非常重要的方法(他们低估了这些方法)，比如<code class="du ln lo lp lq b">hashCode()</code>或者<code class="du ln lo lp lq b">equals()</code>。</p><p id="21e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，现代的ide做了大量的代码搭建/生成工作，但是阅读如此冗长的代码，保存它，并对它进行维护——仍然是一笔巨大的、大量的和多余的成本。</p><p id="1aa0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">欢迎光临，<code class="du ln lo lp lq b">record</code> s！</p><p id="cf37" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记录是Java语言中的一种新类型——一种受限形式的类(如<code class="du ln lo lp lq b">enum</code>),它充当不可变数据的透明载体/集合。</p><p id="8a6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记录只是一个数据载体，普通数据集合类型，它的实例持有，并用于携带值/数据。记录不像传统的类那样具有功能性，但是因为这样一个事实，即作为一个开发人员，它们使您从编写大量的模板中解放出来，当涉及到一个纯数据集合类型时，它们构成了一个超级简洁、简短和干净编码的类型。</p><p id="d63e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住:记录为声明类提供了一个紧凑的语法，这些类是浅层不可变数据 的<strong class="is hu"> <em class="jo">透明持有者，记录并不试图为<em class="jo">可变</em>类解决任何问题。</em></strong></p><h2 id="76ee" class="lz kl ht bd km mm mn mo kq mp mq mr ku jb ms mt ky jf mu mv lc jj mw mx lg my bi translated"><em class="mz">我们如何定义记录？</em></h2><p id="f591" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated"><strong class="is hu">记录</strong>是用它的名称和状态描述定义的(两者合起来称为<em class="jo">表示</em>)，当它被编译时，一个与它的表示相匹配的成熟的API由编译器开箱即用地为您生成/提供。记录也可以有一个主体。</p><p id="b5af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问:<em class="jo">什么是状态描述</em>？<br/>答:那只是记录的<em class="jo">组件</em>的逗号分隔列表。稍后，当记录被编译时，编译器使用这个<em class="jo">状态描述</em>生成一个具有相同签名的公共构造函数；</p><p id="4ecb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哎呀！你说的组件是什么意思？<br/>答:它是参数，您在记录名之后(在{花括号}之前)定义，并且编译器将为每个参数生成私有的final字段和特殊的<em class="jo">访问器</em>方法(稍后将详细介绍)。把它想象成构造函数的参数列表，你为你的记录定义的(因为这个组件列表稍后会被使用，正如我已经说过的，来生成相应的公共构造函数)。</p><p id="8d8e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也许引入一些语义重叠的词的术语有点令人困惑，这些词目前还没有出现在Java的词汇表中，我希望我已经澄清了这种困惑。</p><p id="125b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，请记住，<strong class="is hu">记录</strong>是用它的名称和状态描述定义的(可选地，它可以有一个主体)；状态描述依次是<em class="jo">组件列表</em>的记录；而<em class="jo">组件</em>，实际上只是参数，稍后(编译期间)用来生成公共构造函数。</p><p id="c4b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，记录定义的一般语法如下所示:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="3bb8" class="lz kl ht lq b fi ma mb l mc md">[access-modifier] record ([params]){<br/>    //optional body<br/>}</span></pre><blockquote class="na"><p id="adc2" class="nb nc ht bd nd ne nf ng nh ni nj jn dx translated">就这样——你就有了一份成熟、完整、有效的记录。</p></blockquote><p id="3bbf" class="pw-post-body-paragraph iq ir ht is b it nk iv iw ix nl iz ja jb nm jd je jf nn jh ji jj no jl jm jn hb bi translated">请耐心等待，看看您从盒子里获得了什么，只需定义您的记录:</p><ul class=""><li id="a66e" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><code class="du ln lo lp lq b">private final</code>每个组件的字段，每个字段具有与其各自组件相同的类型，并且与组件(参数)变量具有相同的名称；</li><li id="21e4" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du ln lo lp lq b">public</code> <em class="jo">访问每个字段的方法</em>，这些方法的名称与其对应的字段完全相同，并返回这些字段的类型。<br/>注意，这里我们不是在谈论传统的<em class="jo">getter</em>，按照惯例，它们有<em class="jo"> camelCase </em>名称。<em class="jo">访问器</em>，被决定坚持不同的命名约定——与字段名称相同的名称<em class="jo"/>；</li><li id="a82d" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">公共构造函数，其签名与记录的状态描述相同，并从相应的参数初始化每个字段；</li><li id="6eed" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du ln lo lp lq b">equals(Object obj)</code>和<code class="du ln lo lp lq b">hashCode()</code>的实现说<em class="jo">两个记录相等，如果它们是相同的类型并且包含相同的状态</em>；和</li><li id="adcc" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du ln lo lp lq b">toString()</code>实现，包括给定记录的所有组件的字符串表示(及其名称)。</li></ul><p id="41fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，通过定义:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="90e6" class="lz kl ht lq b fi ma mb l mc md">public record Person(String fullName, int age) {}</span></pre><p id="d67b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以有效地获得:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="9c05" class="lz kl ht lq b fi ma mb l mc md">public class Person {<br/>    <br/>    private final String fullName;<br/>    private final int age;</span><span id="bee6" class="lz kl ht lq b fi ml mb l mc md">    public Person(String fullName, int age) {<br/>        this.fullName = fullName;<br/>        this.age = age;<br/>    }</span><span id="3a95" class="lz kl ht lq b fi ml mb l mc md">    public String fullName() {<br/>        return this.fullName;<br/>    }</span><span id="d58c" class="lz kl ht lq b fi ml mb l mc md">    public int age() {<br/>        return this.age;<br/>    }</span><span id="e419" class="lz kl ht lq b fi ml mb l mc md">    //implementation of hashCode()</span><span id="52ab" class="lz kl ht lq b fi ml mb l mc md">    //implementation of equals(Object obj)</span><span id="343d" class="lz kl ht lq b fi ml mb l mc md">    //implementation of toString()</span><span id="bfc3" class="lz kl ht lq b fi ml mb l mc md">}</span></pre><blockquote class="na"><p id="f62f" class="nb nc ht bd nd ne nf ng nh ni nj jn dx translated">你看出区别了吗？</p></blockquote><p id="7fe1" class="pw-post-body-paragraph iq ir ht is b it nk iv iw ix nl iz ja jb nm jd je jf nn jh ji jj no jl jm jn hb bi translated">还有注意！，我不愿意包含我作为注释包含的方法的实现..它会比这个大得多，仍然是非常冗长和庞大的代码。</p><p id="1b14" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，你可以说，<strong class="is hu"> <em class="jo">记录</em> </strong>是一个浅显不可变的数据聚合类，其唯一的目的是存储(也许有助于传输)数据。一旦实例化，它的实例字段就不能重新初始化。</p><h2 id="a002" class="lz kl ht bd km mm mn mo kq mp mq mr ku jb ms mt ky jf mu mv lc jj mw mx lg my bi translated">这里休息一会儿..</h2><h2 id="cbdb" class="lz kl ht bd km mm mn mo kq mp mq mr ku jb ms mt ky jf mu mv lc jj mw mx lg my bi translated">..确保你意识到我上面写的一切。</h2><h2 id="f4ff" class="lz kl ht bd km mm mn mo kq mp mq mr ku jb ms mt ky jf mu mv lc jj mw mx lg my bi translated">如果我是你，我会再读一遍以上部分..可能..:)</h2><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es np"><img src="../Images/a67da41f1bf9358397a292613099ddc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVaEZQd-lx9ijccVntmi8g.png"/></div></div></figure><h2 id="0d8e" class="lz kl ht bd km mm mn mo kq mp mq mr ku jb ms mt ky jf mu mv lc jj mw mx lg my bi translated">让我们继续..</h2><p id="25c2" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">除了记录的语法，在编译期间获得的一些新概念方面(我已经对其进行了去神秘化，将其解释为一个<em class="jo">词汇表</em>)和记录的语义(要求浅不可变的数据聚集器类型)，记录像普通类一样工作。他们可以:</p><ul class=""><li id="ff0e" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">被声明为顶级或嵌套；</li><li id="d1d4" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">要通用；</li><li id="872f" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">实现接口；</li><li id="a781" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">定义静态字段(这些也可以声明)、静态初始化器、构造函数(<em class="jo">见下面的特别说明，关于这个</em>)、实例方法、嵌套类型；</li><li id="8789" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">被注释。</li></ul><p id="78f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，有很多事情他们可以<strong class="is hu"> <em class="jo">不可以</em> </strong>做！</p><p id="adeb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">编译时间限制:</strong></p><ul class=""><li id="43fd" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">记录隐式扩展<code class="du ln lo lp lq b">java.lang.Record</code>(就像<code class="du ln lo lp lq b">enum</code> s扩展<code class="du ln lo lp lq b">java.lang.Enum</code>)。<br/>当记录被编译时，编译器生成这个扩展——因此，它不能扩展任何其他类(包括其他记录)。Java不支持多重继承；</li><li id="e90e" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">记录不能声明或定义实例字段，除非是基于记录<em class="jo">状态描述</em>生成的。</li></ul><blockquote class="nq nr ns"><p id="5ad4" class="iq ir jo is b it iu iv iw ix iy iz ja nt jc jd je nu jg jh ji nv jk jl jm jn hb bi translated">以上两点保证了唯一的<strong class="is hu">状态描述</strong>定义了记录的表示；</p></blockquote><ul class=""><li id="af33" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">记录是隐式的<code class="du ln lo lp lq b">final</code>，(当记录被编译时，编译器从记录中创建<code class="du ln lo lp lq b">public final class YourRecordName extends java.lang.Record</code>)，因此，它不能是抽象的。</li></ul><blockquote class="nq nr ns"><p id="c26c" class="iq ir jo is b it iu iv iw ix iy iz ja nt jc jd je nu jg jh ji nv jk jl jm jn hb bi translated">这个限制再次强调，记录的API仅仅由它的状态描述定义，并且不能通过子类化记录来增强。</p></blockquote><h2 id="2abf" class="lz kl ht bd km mm mn mo kq mp mq mr ku jb ms mt ky jf mu mv lc jj mw mx lg my bi translated"><strong class="ak">记录体中的规范和非规范构造函数</strong></h2><p id="388f" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">Java记录体中定义的构造函数以一种有点特殊的方式工作。</p><p id="f579" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">规范构造函数:<br/> </strong>您可以在记录体中定义规范构造函数(与记录的状态描述签名相匹配的构造函数)，例如:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="b76e" class="lz kl ht lq b fi ma mb l mc md">public record MyRecord(Type1 x, Type2 y) {<br/>    <br/>    public(Type1 x, Type2 y) {<br/>    }</span><span id="6613" class="lz kl ht lq b fi ml mb l mc md">}</span></pre><p id="bdfb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者！您可以完全避开参数列表:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="5d5c" class="lz kl ht lq b fi ma mb l mc md">public record MyRecord(Type1 t, Type2 t) {<br/>    <br/>    public MyRecord {<br/>    }</span><span id="e156" class="lz kl ht lq b fi ml mb l mc md">}</span></pre><p id="828b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这仍然会被编译成规范的构造函数，带有state description定义的所有参数。</p><p id="a177" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，如果在记录体中显式定义规范构造函数:</p><ol class=""><li id="5576" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn me jv jw jx bi translated">构造函数参数的顺序和名称以及状态描述的组成部分<strong class="is hu">必须匹配</strong>(如果规范构造函数是用参数定义的<strong class="is hu">)；</strong></li><li id="8808" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">您<strong class="is hu">必须</strong>初始化记录的所有组成部分(状态描述参数)，无论规范构造函数是否定义有参数。</li></ol><p id="e78f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">非规范构造函数:<br/> </strong>有趣的是，在记录体中定义非规范构造函数也是允许的，但是有一定的限制。</p><p id="9e71" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你定义了一个非规范的构造函数，你必须确保它委托给另一个构造函数(用<code class="du ln lo lp lq b">this([..])</code>调用)..如果“另一个构造函数”也是非规范的，那么它也必须委托给另一个构造函数..如此循环往复，<strong class="is hu">直到</strong>最后一个被委托的非规范构造函数委托给<strong class="is hu">规范构造函数</strong>。如果没有发生这种情况，就有编译时错误。</p><p id="3deb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，请记住，从<em class="jo">状态描述</em>自动导出(生成)的任何行为(方法)也可以明确定义；但是，在这种情况下，你将冒风险，自己去实现那些已经被非常彻底和细致地考虑过的事情。存取器equals()或hashCode()的手动/自定义实现可能会破坏记录的语义，否则将“承诺”交付记录。</p><p id="7e64" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">恭喜你！您刚刚完成了一个非常详细和深入的教程，内容是一个新的、非常重要和酷的主题——Java记录。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/786011819a4eaecd18fbc1c8eb910424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adpy49saC9Oh91HneWNZhw.png"/></div></div></figure><h1 id="6ce4" class="kk kl ht bd km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh bi translated"><strong class="ak">开关表达式(标准)(JEP 361) </strong></h1><p id="ef70" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">放松，这里没什么新鲜的。</p><p id="1192" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的<a class="ae nw" href="https://tsiklauri.medium.com/java-12-switch-expressions-jep-325-preview-feature-ba8e3db9706" rel="noopener"> Java 12 -新语言特性</a>文章中，我已经非常全面地介绍了<strong class="is hu">开关表达式</strong>的第一个预览，随后，我在我的<a class="ae nw" href="https://tsiklauri.medium.com/java-13-new-language-features-eba2408ae30" rel="noopener"> Java 13 -新语言特性</a>文章中概述了第二个预览(更新),这是针对较新的Java 13版本的。</p><p id="6697" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">—<strong class="is hu"><em class="jo">Java 14中的Switch表达式怎么了？</em>T13】</strong></p><p id="d074" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它们是标准化的，自Java 13以来没有任何进一步的修改。</p><p id="2dd0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样。<strong class="is hu">开关表达式(JEP 361) </strong>现在是Java语言完全标准化的一部分。</p><figure class="lr ls lt lu fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/13cda82f07b386aa19742cca86a08702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1x0RTX6qHQB9gmWiytQXwA.png"/></div></div></figure><h1 id="d2ff" class="kk kl ht bd km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld mk lf lg lh bi translated">文本块(第二次预览)(JEP 368)</h1><p id="bf84" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">在我的<a class="ae nw" href="https://tsiklauri.medium.com/java-13-new-language-features-eba2408ae30" rel="noopener"> Java 13 -新语言特性</a>文章中，我们已经详细介绍了文本块的第一次预览，正如你现在所知道的，如果你还没有查看它，让我直接切入正题，进入更新——JEP 368中的新内容，<em class="jo">文本块的第二次预览</em>；什么，即第二个预览添加到已经存在的预览功能——<em class="jo">文本块</em>。</p><p id="c05a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据前任JEP(第一次预览版)从工程师和开发人员那里得到的反馈，针对Java 14的文本块第二次预览版在文本块中增加了<strong class="is hu">两个<em class="jo">新的</em>转义序列</strong>:</p><ol class=""><li id="9f19" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn me jv jw jx bi translated"><code class="du ln lo lp lq b">\&lt;line-terminator&gt;</code>和</li><li id="c652" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated"><code class="du ln lo lp lq b">\s</code></li></ol><h2 id="cd02" class="lz kl ht bd km mm mn mo kq mp mq mr ku jb ms mt ky jf mu mv lc jj mw mx lg my bi translated">\ <line-terminator/></h2><p id="2c39" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated"><code class="du ln lo lp lq b">\&lt;line-terminator&gt;</code> —这是一个新的转义序列，我们可以专门在文本块中使用，以强制取消新行字符。注意，如果你使用一些IDE或文本编辑器，只需按下&lt;回车&gt;并将光标移动到下一行就可以插入<code class="du ln lo lp lq b">line-terminator</code>。你只是通常看不到特殊的<em class="jo">控制字符</em>:<em class="jo"/>CRLF(Windows上)或LF(Linux上)。</p><p id="58f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">— <em class="jo">这是给</em>的什么？<br/> —如上所述，用于抑制换行符。</p><p id="e7cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设你有一个文本块，它应该包含一长行；然而，因为你的屏幕不是无限宽的，你最好在你的源代码中把这一行分成两行，同时把真正的文本(因为它将被编译)保持在一行。<br/>注意！原始文本、真实的数据<em class="jo">必须保持</em>一行，但是仅仅为了方便起见，您想要在您的文本编辑器<strong class="is hu">中将那一长行拆分成两行(或更多行)!由于你的屏幕宽度有限，滚动条宽度太长不方便。<br/>你想把你的长单行文本编码成两行、三行或更多行，但是你想要的原始数据(文本)必须是一行。您可以将其存储在文件中或打印在控制台输出上，它<strong class="is hu">必须是一行</strong>。</strong></p><p id="a9db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是<code class="du ln lo lp lq b">\&lt;line-separator&gt;</code>发挥作用的地方。你用这个转义序列在代码中分解字符串文字，但实际上，这只是给你一个视觉上的安慰——文本本身仍然没有<strong class="is hu">没有</strong>包含换行符，它仍然是一个长行。</p><p id="70e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此代码中的字符串文本:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="3e3c" class="lz kl ht lq b fi ma mb l mc md">String text = """<br/>              I am Giorgi Tsiklauri. I really like \<br/>              coding, teaching, and everything \<br/>              that has to do with computers. I constantly learn \<br/>              and I have a big interest in data structures, \<br/>              algorithms, cyber security, network engineering, \<br/>              climate and astrophysics.<br/>              """</span></pre><p id="944f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="jo">不</em> </strong>是否包含换行符，如果这是打印出来的，写在文件里的，通过网络发送的，或者通过其他方式显示的，那将是一个巨大的行。</p><p id="7447" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是对字符串块的一个非常有用的新补充。</p><p id="6855" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，传统的“字符串文字”不允许源代码级机制将文本分成多行，同时保留真正的原始数据—一行。</p><h2 id="f19e" class="lz kl ht bd km mm mn mo kq mp mq mr ku jb ms mt ky jf mu mv lc jj mw mx lg my bi translated">\s</h2><p id="2d96" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated"><code class="du ln lo lp lq b">\s</code> —这个转义序列简单地转换成一个空格(Java语法中的U+0020或\u0020)。</p><p id="4393" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个转义序列的目的是在需要时保留显式编码的空格，因为默认情况下，编译器会丢弃它们。</p><p id="429c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，代码的结果:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="6ec4" class="lz kl ht lq b fi ma mb l mc md">String text = """<br/>              Beethoven's 9th Symphony is transcendental!     <br/>              """;<br/>System.out.print(text);</span></pre><p id="e91a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将会是:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="6ac9" class="lz kl ht lq b fi ma mb l mc md">Beethoven's 9th Symphony is transcendental!</span></pre><p id="1a45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管如此，在源代码中，我添加了5个空格。它们被丢弃，因为编译器会忽略它们。</p><p id="3178" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，如果你希望保留空格，你可以使用<code class="du ln lo lp lq b">\s</code>，并且<strong class="is hu">注意，</strong>这个转义序列在传统的字符串文字和字符串块中都有效。</p><p id="12f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，要么你编码:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="3fa0" class="lz kl ht lq b fi ma mb l mc md">String text = <br/>        """<br/>        Beethoven's 9th Symphony is transcendental!    \s<br/>        """;</span></pre><p id="eaa5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="f69a" class="lz kl ht lq b fi ma mb l mc md">String text = "Beethoven's 9th Symphony is transcendental!    \s";</span></pre><p id="7163" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该文本将被编译(因此—在任何使用它的地方使用)为:</p><pre class="lr ls lt lu fd lv lq lw lx aw ly bi"><span id="c3bb" class="lz kl ht lq b fi ma mb l mc md">Beethoven's 9th Symphony is transcendental!......</span></pre><p id="201f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我用上面的<code class="du ln lo lp lq b">.</code>符号表示空格。注意，最后的<code class="du ln lo lp lq b">\s</code>也作为空格包含在内。</p><p id="cd36" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是这篇文章的内容。</p><p id="eafa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的关注。关注我的个人资料，获取更多关于Java、JVM、算法和数据结构的帖子。</p></div></div>    
</body>
</html>