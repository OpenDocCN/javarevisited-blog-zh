<html>
<head>
<title>Scheduling methods to execute post transaction commit using Spring TransactionSynchronization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring transaction synchronization执行事务后提交的调度方法</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/scheduling-methods-to-execute-post-transaction-commit-using-spring-transactionsynchronization-8df3fa4f4e37?source=collection_archive---------0-----------------------#2021-10-07">https://medium.com/javarevisited/scheduling-methods-to-execute-post-transaction-commit-using-spring-transactionsynchronization-8df3fa4f4e37?source=collection_archive---------0-----------------------#2021-10-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1473" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都需要的注解</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a417664e94e52d14cba0b7feae36dd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LKrUOuAmqG7dlkpHTuIrA.png"/></div></div></figure><h1 id="efc3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">问题是</h1><p id="54ac" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在spring中使用事务时，通常需要一些特定的方法在事务成功提交后运行，让我们通过一个例子来理解这一点</p><p id="e216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设一个系统中有两个微服务，第一个管理用户生命周期，姑且称之为用户管理服务(UMS)，另一个为用户准备Feed(Feed Service)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ks"><img src="../Images/704193381c7929b8cfe46f5c6a4656b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*euGk_diYpMi1CrzLbjOeEQ.png"/></div><p class="kt ku et er es kv kw bd b be z dx translated">UMS和饲料服务互动</p></figure><p id="5d99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个新用户在平台上注册时，UMS会进行一些验证，然后向<code class="du kx ky kz la b">create_feed</code> Kafka topic推送一条消息。另一方面，提要服务监听关于<code class="du kx ky kz la b">create_feed</code>主题的消息，然后调用UMS来获取用户的兴趣以准备提要。你看到这个流程中的一个巨大问题了吗！？如果注册过程中的任何后续方法失败怎么办——用户详细信息从未保存在系统中，订阅服务<code class="du kx ky kz la b">get user interest call</code>将开始失败。当我们谈论多个微服务交互时，这个问题变得更加突出。</p><p id="c36f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能有许多其他需求，其中需要一些特定的方法来只执行事务提交，让我们看看如何优雅地解决这个问题！</p><h1 id="139a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解决方案🚀</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="ae32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在事务提交后执行一段代码，可以使用<code class="du kx ky kz la b">TransactionSynchronizationAdapter</code>的<code class="du kx ky kz la b">afterCommit</code>方法，应该是这样的</p><pre class="je jf jg jh fd ld la le lf aw lg bi"><span id="bcc9" class="lh jq hi la b fi li lj l lk ll">TransactionSynchronizationManager.registerSynchronization(<br/>    new TransactionSynchronizationAdapter() {<br/>        @Override<br/>        public void afterCommit() {<br/>            // code for publishing message to kafka<br/>        }<br/>});</span></pre><p id="b92b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这种方法可行，但需要在使用它的任何地方添加大量的样板代码，而且这并不是一种非常干净的解决问题的方法。</p><p id="dc8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看如何创建一个注释(<code class="du kx ky kz la b">@PostCommit</code>)并使用spring AOP around advice从后台驱动所有这些。其思想是，每当遇到带有<code class="du kx ky kz la b">@PostCommit</code>注释的方法时，执行被包装在runnable中，并添加到ThreadLocal中执行，当事务完成时，将调用<code class="du kx ky kz la b">TransactionSynchronizationAdapter</code>的<code class="du kx ky kz la b">afterCommit</code>，并且可以执行<code class="du kx ky kz la b">ThreadLocal</code>的所有<code class="du kx ky kz la b">runables</code>。</p><p id="b2df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> #1建筑标注</strong></p><pre class="je jf jg jh fd ld la le lf aw lg bi"><span id="445e" class="lh jq hi la b fi li lj l lk ll">@Target(ElementType.METHOD)<br/>@Retention(RetentionPolicy.RUNTIME)<br/>public @interface PostCommit {<br/>}</span></pre><p id="568c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一部分很简单，类似于用Java创建任何其他注释</p><p id="aeba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> #2构建后置处理适配器</strong></p><p id="ac56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后置处理程序有两个功能</p><ol class=""><li id="e864" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">它将在<code class="du kx ky kz la b">ThreadLocal</code>上记录<code class="du kx ky kz la b">runnables</code></li><li id="d909" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">覆盖<code class="du kx ky kz la b">TransactionSynchronizationAdapter</code>的<code class="du kx ky kz la b">AfterCommit</code>，在事务提交时运行所有注册的<code class="du kx ky kz la b">runnables</code></li></ol><pre class="je jf jg jh fd ld la le lf aw lg bi"><span id="5f3b" class="lh jq hi la b fi li lj l lk ll">@Slf4j<br/>@Component<br/>public class PostCommitAdapter extends TransactionSynchronizationAdapter {<br/>    private static final ThreadLocal&lt;List&lt;Runnable&gt;&gt; RUNNABLE = new ThreadLocal&lt;&gt;();<br/><br/>    <strong class="la hj">// register a new runnable for post commit execution</strong><br/>    public void execute(Runnable runnable) {<br/>        if (TransactionSynchronizationManager.isSynchronizationActive()) {<br/>            List&lt;Runnable&gt; runnables = RUNNABLE.get();<br/>            if (runnables == null) {<br/>                runnables = new ArrayList&lt;&gt;();<br/>                RUNNABLE.set(runnables);<br/>                TransactionSynchronizationManager.registerSynchronization(this);<br/>            }<br/>            return;<br/>        }<br/>        <strong class="la hj">// if transaction synchronisation is not active</strong><br/>        runnable.run();<br/>    }<br/><br/>    @Override<br/>    public void afterCommit() {<br/>        List&lt;Runnable&gt; runnables = RUNNABLE.get();<br/>        runnables.forEach(Runnable::run);<br/>    }<br/><br/>    @Override<br/>    public void afterCompletion(int status) {<br/>        RUNNABLE.remove();<br/>    }<br/>}</span></pre><p id="615a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果事务是活动的，<code class="du kx ky kz la b">execute</code>方法在<code class="du kx ky kz la b">ThreadLocal</code>中注册<code class="du kx ky kz la b">runnables</code>,否则，它简单地继续并执行它。<code class="du kx ky kz la b">afterCommit</code>运行<code class="du kx ky kz la b">ThreadLocal</code>内的所有<code class="du kx ky kz la b">runnables</code></p><p id="6640" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> #3连接适配器&amp;注释使用左右建议</strong></p><p id="4294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将<code class="du kx ky kz la b">PostCommitAdapter</code>的执行方法与<code class="du kx ky kz la b">@PostCommit</code>注释挂钩，在<code class="du kx ky kz la b">@PostCommit</code>注释上创建了一个around advice，它在每个连接点将方法执行封装在runnable中，并调用<code class="du kx ky kz la b">PostCommitAdapter</code>的<code class="du kx ky kz la b">execute</code></p><pre class="je jf jg jh fd ld la le lf aw lg bi"><span id="82e6" class="lh jq hi la b fi li lj l lk ll">@Aspect<br/>@Slf4j<br/>@AllArgsConstructor<br/>@Configuration<br/>public class PostCommitAnnotationAspect {<br/>    private final PostCommitAdapter postCommitAdapter;<br/><br/>    @Pointcut("@annotation(com...&lt;<strong class="la hj">package</strong>&gt;..PostCommit)")<br/>    private void postCommitPointCut(){}<br/><br/><br/>    @Around("postCommitPointCut()")<br/>    public Object aroundAdvice(final ProceedingJoinPoint pjp) {<br/>        postCommitAdapter.execute(new PjpAfterCommitRunnable(pjp));<br/>        return null;<br/>    }<br/><br/>    private static final class PjpAfterCommitRunnable implements Runnable {<br/>        private final ProceedingJoinPoint pjp;<br/><br/>        public PjpAfterCommitRunnable(ProceedingJoinPoint pjp) {<br/>            this.pjp = pjp;<br/>        }<br/><br/>        @Override<br/>        public void run() {<br/>            try {<br/>                pjp.proceed();<br/>            } catch (Throwable e) {<br/>                throw new RuntimeException(e);<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="d630" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用</h1><p id="f58d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">一旦样板文件写好了，用法就简单得不能再简单了，无论在事务提交后执行哪种方法，都必须简单地用<code class="du kx ky kz la b">PostCommit</code>注释对其进行注释。</p><p id="3d20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:考虑两个具有提交后注释方法的类A &amp; B</p><pre class="je jf jg jh fd ld la le lf aw lg bi"><span id="a66c" class="lh jq hi la b fi li lj l lk ll">Class A {<br/>   <strong class="la hj">@PostCommit</strong><br/>   void log(){<br/>      log.info("log from class A")<br/>   }<br/>}</span><span id="4153" class="lh jq hi la b fi ma lj l lk ll">Class B {<br/>   <strong class="la hj">@PostCommit</strong><br/>   void log(){<br/>      log.info("log from class B")<br/>   }<br/>}</span></pre><p id="bf0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和一个调用这些方法的驱动程序类:</p><pre class="je jf jg jh fd ld la le lf aw lg bi"><span id="6d51" class="lh jq hi la b fi li lj l lk ll">Class mainClass {<br/>      <strong class="la hj">@Transactional</strong><br/>      void transactionalMethod(Entity entity){<br/>          someOperation(entity)<br/>          log.info("inside transaction");<br/>          a.log();<br/>          b.log();<br/>          save(entity);<br/>          log.info("end of method");<br/>      }<br/>}</span></pre><p id="01ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预期产出将是:</p><pre class="je jf jg jh fd ld la le lf aw lg bi"><span id="89ee" class="lh jq hi la b fi li lj l lk ll">&gt; inside transaction<br/>&gt; ** saving entity<br/>&gt; log from class A<br/>&gt; log from Class B</span></pre><h1 id="ffa2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="b531" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这篇博客试图解释我们如何利用Spring的<code class="du kx ky kz la b">TransactionSynchronization</code>在事务提交后执行一段代码，以及如何使用Spring AOP将它与一个定制注释挂钩，从后面驱动一切。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="c121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你需要更多的帮助，请随时联系我。请务必关注所有新的更新。谢谢你的阅读。干杯🍺</p><p id="e8f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能喜欢的其他Java和Spring文章和资源</p><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/javarevisited/7-best-webflux-and-reactive-spring-boot-courses-for-java-programmers-33b7c6fa8995"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">面向Java程序员的7门最佳WebFlux和反应式Spring Boot课程</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">我最喜欢的课程2021年学习Java中的反应式编程使用WebFlux、RxJava和反应式Spring Boot来自…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jn mm"/></div></div></a></div><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/javarevisited/10-best-free-dropwizard-vert-x-micronaut-and-quarkus-online-courses-for-java-developers-9c2b4161f17"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">面向Java程序员的10门最佳免费DropWizard、Vert.x、MicroNaut和Quarkus在线课程2021</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">我最喜欢的免费和最好的在线课程，学习像DropWizard这样的前沿Java微服务框架…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mv l"><div class="nb l mx my mz mv na jn mm"/></div></div></a></div><div class="mj mk ez fb ml mm"><a rel="noopener follow" target="_blank" href="/javarevisited/10-best-java-microservices-courses-with-spring-boot-and-spring-cloud-6d04556bdfed"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">2021年Spring Boot和Spring Cloud的10个最佳Java微服务课程</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">我最喜欢的2021年用Spring Boot和Spring Cloud为初学者学习Java微服务的在线课程来自…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">medium.com</p></div></div><div class="mv l"><div class="nc l mx my mz mv na jn mm"/></div></div></a></div></div></div>    
</body>
</html>