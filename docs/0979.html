<html>
<head>
<title>Java Inheritance Tutorial: explained with examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java继承教程:举例说明</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/java-inheritance-tutorial-explained-with-examples-1b5c8f341b54?source=collection_archive---------2-----------------------#2021-02-06">https://medium.com/javarevisited/java-inheritance-tutorial-explained-with-examples-1b5c8f341b54?source=collection_archive---------2-----------------------#2021-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://www.educative.io/subscription?affiliate_id=5073518643380224"><div class="er es if"><img src="../Images/b0e8c92bfc2952432cf798da5da1dd69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cM4KyeKVyxXPHkkIPz8cpw.png"/></div></a><p class="im in et er es io ip bd b be z dx translated">图片来源:作者</p></figure><p id="a647" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继承是基于另一个现有类的特性构建一个新类的过程。它在Java、Python和其他面向对象的语言中大量使用，以提高代码的可重用性，并将程序逻辑简化为分类和层次关系。</p><p id="7883" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，每种语言都有自己独特的实现继承的方式，这使得切换很困难。</p><p id="5ded" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天，我们将为您提供Java编程中继承用法的速成课程，并向您展示如何实现核心继承工具，如类型转换、方法覆盖和<code class="du jo jp jq jr b">final</code>实体。</p><p id="fbf7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">以下是我们今天要讲的内容:</strong></p><ul class=""><li id="7b17" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated">什么是继承？</li><li id="aec1" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">Java中的继承</li><li id="fa02" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">Java继承示例</li><li id="5e2c" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">接下来要学习的高级概念</li></ul><h1 id="e737" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是继承？</h1><p id="05e5" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">继承是一种机制，它允许一个类从另一个类继承属性或行为。多个类可以从同一个父类继承，形成树状层次结构。继承类可以添加从父类继承的特性之外的特性，以允许独特的行为。</p><p id="c972" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继承对于高级面向对象编程(<a class="ae lj" rel="noopener" href="/javarevisited/10-oop-design-principles-you-can-learn-in-2020-f7370cccdd31"> OOP </a>)来说是必不可少的，因为它允许您在整个程序中重用一个类的特性，而无需复制代码。</p><p id="b7ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继承通常用于表示类别(父类)和子类别(子类)。父类设置所有对象中存在的特性，而不考虑子类，而每个子类代表一个更小、更具体的类别。</p><p id="e76d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，您可以创建指定<code class="du jo jp jq jr b">wheels = 4</code>的类<code class="du jo jp jq jr b">Car</code>和包含属性<code class="du jo jp jq jr b">doors = 4</code>的子类<code class="du jo jp jq jr b">Sedan</code>。继承关系的流向往往反映了类似正方形和长方形的逻辑关系；在这种情况下，所有的轿车都是轿车，但不是所有的轿车都是轿车。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><a href="https://javarevisited.blogspot.com/2012/10/what-is-inheritance-in-java-and-oops-programming.html"><div class="er es lk"><img src="../Images/a11994c7ed0ce2e5e5232d585848e237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*TPBeaTQ0u5dwaZkCwXYoNg.png"/></div></a><p class="im in et er es io ip bd b be z dx translated">图片来源:作者</p></figure><p id="287c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继承有三个主要优点:</p><ol class=""><li id="d408" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn lp jy jz ka bi translated"><strong class="is hj">可重用性:</strong>继承允许您在继承现有类的任何类中无限次地重用该类的特性。您可以在相同类型的所有对象之间保持一致的功能，而无需重写代码。</li><li id="25c0" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn lp jy jz ka bi translated"><strong class="is hj">代码结构:</strong>继承为你的程序提供了一个清晰、可绘制的逻辑结构。它允许开发人员将您的代码理解为相关但独特的类别的集合，而不是简单的代码块。</li><li id="2efc" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn lp jy jz ka bi translated"><strong class="is hj">数据隐藏:</strong>基类可以被设置成私有的，这样就不会被派生类修改。这是<a class="ae lj" href="https://javarevisited.blogspot.com/2012/03/what-is-encapsulation-in-java-and-oops.html" rel="noopener ugc nofollow" target="_blank">封装</a>的一个例子，其中对数据的访问被限制为只有那些角色需要它的类。</li></ol><h2 id="74b1" class="lq kh hi bd ki lr ls lt km lu lv lw kq jb lx ly ku jf lz ma ky jj mb mc lc md bi translated">Java中的继承</h2><p id="b9fe" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">每种编程语言对于继承都有稍微不同的术语。<br/>在<a class="ae lj" rel="noopener" href="/javarevisited/10-free-courses-to-learn-java-in-2019-22d1f33a3915"> Java </a>中，父类称为<strong class="is hj">超类</strong>，继承类称为<strong class="is hj">子类</strong>。开发人员也可以将超类称为基类或父类，将子类称为派生类或子类。</p><p id="dba8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">子类在定义过程中使用关键字<code class="du jo jp jq jr b">extends</code>链接到超类。子类可以定义新的本地方法或字段来使用，或者可以使用<code class="du jo jp jq jr b"><strong class="is hj">super</strong></code>关键字来调用继承的方法或超级构造函数。</p><pre class="ll lm ln lo fd me jr mf mg aw mh bi"><span id="9c63" class="lq kh hi jr b fi mi mj l mk ml">class b {<br/>// implementation of inheritedMethod()<br/>}<br/>class a extends b<br/>{  <br/>   inheritedMethod();<br/>}</span></pre><h2 id="48e7" class="lq kh hi bd ki lr ls lt km lu lv lw kq jb lx ly ku jf lz ma ky jj mb mc lc md bi translated">何时使用<code class="du jo jp jq jr b">super</code>关键词</h2><p id="99f5" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated"><code class="du jo jp jq jr b">super</code>本质上是一个从子类中调用的“前一个值”按钮，允许您从父类中读取和访问特性，而不管它们在当前子类中的值。</p><p id="375e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">super</code>关键字用于:</p><ul class=""><li id="15a6" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated"><strong class="is hj">访问父类字段</strong> : <code class="du jo jp jq jr b">super.var</code>读取父类中设置的<code class="du jo jp jq jr b">var</code>的值，而<code class="du jo jp jq jr b">var</code>单独从子类中读取修改后的值。</li><li id="2aee" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated"><strong class="is hj">调用父类方法</strong> : <code class="du jo jp jq jr b">super.method()</code>允许孩子访问<code class="du jo jp jq jr b">method()</code>的父类实现。只有当子类也有同名的方法时，这才是必需的。</li><li id="1b4f" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">使用构造函数:这允许你从子类中创建父类的新实例。</li></ul><p id="5dee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回顾一下，Java中的<a class="ae lj" href="https://www.educative.io/blog/object-oriented-programming-concepts-java#constructors" rel="noopener ugc nofollow" target="_blank">构造函数</a>是用于初始化对象的特殊方法。调用超级构造函数会创建一个新对象，该对象需要父类构造函数中定义的所有字段。</p><p id="1fd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，您可以在其他语句中添加额外的字段，使子实例比父实例更具体。本质上，它允许您将父类构造函数用作子类构造函数的模板。</p><pre class="ll lm ln lo fd me jr mf mg aw mh bi"><span id="c94b" class="lq kh hi jr b fi mi mj l mk ml">public Car(String make, String color, int year, String model, String bodyStyle) {<br/>        super(make, color, year, model);  //parent class constructor<br/>        this.bodyStyle = bodyStyle;       <br/>    }</span></pre></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h1 id="b9d2" class="kg kh hi bd ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld bi translated">继承的类型</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><a href="https://www.java67.com/2016/03/top-21-java-inheritance-interview-Questions-Answer-Programming.html"><div class="er es my"><img src="../Images/f58dde4b9b7a3f0c5709d660b9208ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjuwkWWQVLSVqLwjbuiL1Q.png"/></div></a><p class="im in et er es io ip bd b be z dx translated">图片来源:作者</p></figure><p id="3719" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java中有几种类型的继承:</p><ul class=""><li id="53db" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated"><strong class="is hj">单一继承</strong>是单个子类从超类继承，形成一层继承。</li><li id="65e8" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated"><strong class="is hj">多级继承</strong>是超类被中间类继承，再被派生类继承，形成3级或3级以上的继承。</li><li id="beba" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated"><strong class="is hj">层次继承</strong>是指一个超类作为多个特定子类的基线。这是最常见的继承形式。</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><a href="https://www.java67.com/2015/12/top-30-oops-concept-interview-questions-answers-java.html"><div class="er es mz"><img src="../Images/212fb9de419b9c3093a8a8960f58bcf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5LQlTW4kO5I3odfe_p1Ng.png"/></div></a><p class="im in et er es io ip bd b be z dx translated">图片来源:作者</p></figure><p id="979a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过类和接口继承的组合，还有另外两种类型的继承只在<a class="ae lj" rel="noopener" href="/javarevisited/top-5-java-online-courses-for-beginners-best-of-lot-1e1e240a758"> Java </a>中可用。</p><ul class=""><li id="2c1e" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated"><strong class="is hj">多重继承</strong>，当一个子类从多个父类继承时。</li><li id="9cf2" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated"><strong class="is hj">混合遗传</strong>，以上两种或两种以上遗传的混合。</li></ul><p id="e3c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lj" href="http://javarevisited.blogspot.sg/2011/07/why-multiple-inheritances-are-not.html#axzz55Zuelntp" rel="noopener ugc nofollow" target="_blank"> Java并不<strong class="is hj">支持类</strong></a>的多重继承，这意味着这两种类型的继承对于单独的Java类都是不可能的。然而，一个子类可以继承多个接口(一个抽象类)。因此，如果结合使用接口和类，就可以模拟多个继承。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h1 id="b2bf" class="kg kh hi bd ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld bi translated">Java继承示例</h1><p id="7fec" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">为了帮助您更好地理解继承，让我们来看一些代码示例。寻找到目前为止我们已经看到的继承的语法成分，比如<code class="du jo jp jq jr b">super</code>和共享方法。</p><p id="dd43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要在Java中声明继承，我们只需在子类的标识符后添加<code class="du jo jp jq jr b">extends [superclass]</code>。</p><p id="9a3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个从基类<code class="du jo jp jq jr b">Vehicle</code>继承而来的类<code class="du jo jp jq jr b">Car</code>的例子，它使用私有字符串和getter/setter方法来实现封装。</p><pre class="ll lm ln lo fd me jr mf mg aw mh bi"><span id="5d3d" class="lq kh hi jr b fi mi mj l mk ml">// Base Class Vehicle<br/>class Vehicle {</span><span id="76e6" class="lq kh hi jr b fi na mj l mk ml">  // Private Fields<br/>  private String make; <br/>  private String color; <br/>  private int year;      <br/>  private String model;   <br/></span><span id="6587" class="lq kh hi jr b fi na mj l mk ml">  // Parameterized Constructor<br/>  public Vehicle(String make, String color, int year, String model) {<br/>    this.make = make;<br/>    this.color = color;<br/>    this.year = year;  <br/>    this.model = model; <br/>  }</span><span id="4677" class="lq kh hi jr b fi na mj l mk ml">  // public method to print details<br/>  public void printDetails() {<br/>    System.out.println("Manufacturer: " + make);<br/>    System.out.println("Color: " + color);<br/>    System.out.println("Year: " + year);<br/>    System.out.println("Model: " + model);<br/>  }</span><span id="092e" class="lq kh hi jr b fi na mj l mk ml">}</span><span id="b6ed" class="lq kh hi jr b fi na mj l mk ml">// Derived Class Car<br/>class Car extends Vehicle {</span><span id="8f49" class="lq kh hi jr b fi na mj l mk ml">  // Private field<br/>  private String bodyStyle;</span><span id="4cfa" class="lq kh hi jr b fi na mj l mk ml">  // Parameterized Constructor<br/>  public Car(String make, String color, int year, String model, String bodyStyle) {<br/>    super(make, color, year, model);  //calling parent class constructor<br/>    this.bodyStyle = bodyStyle;       <br/>  }</span><span id="7a18" class="lq kh hi jr b fi na mj l mk ml">  public void carDetails() {  //details of car<br/>    printDetails();         //calling method from parent class<br/>    System.out.println("Body Style: " + bodyStyle);<br/>  }</span><span id="f183" class="lq kh hi jr b fi na mj l mk ml">}</span><span id="f9a0" class="lq kh hi jr b fi na mj l mk ml">class Main {</span><span id="6ebe" class="lq kh hi jr b fi na mj l mk ml">  public static void main(String[] args) {<br/>    Car elantraSedan = new Car("Hyundai", "Red", 2019, "Elantra", "Sedan"); //creation of car Object<br/>    elantraSedan.carDetails(); //calling method to print details<br/>  }</span><span id="6de2" class="lq kh hi jr b fi na mj l mk ml">}</span></pre><p id="1268" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个单一继承的例子，因为只有一个对象从父类继承。在第37行上，你可以看到我们使用<code class="du jo jp jq jr b">super</code>来调用超类构造函数，它简化了我们的<code class="du jo jp jq jr b">Car</code>构造函数。您还可以看到<code class="du jo jp jq jr b">Car</code>如何访问<strong class="is hj">行42 </strong>上的<code class="du jo jp jq jr b">Vehicle</code>类<code class="du jo jp jq jr b">printDetails()</code>方法。</p><blockquote class="nb nc nd"><p id="8526" class="iq ir ne is b it iu iv iw ix iy iz ja nf jc jd je ng jg jh ji nh jk jl jm jn hb bi translated"><code class="du jo jp jq jr b"><em class="hi">printDetails()</em></code> <em class="hi">可以称为没有</em> <code class="du jo jp jq jr b"><em class="hi">super</em></code> <em class="hi">是因为</em> <code class="du jo jp jq jr b"><em class="hi">Car</em></code> <em class="hi">没有自己实现的</em> <code class="du jo jp jq jr b"><em class="hi">printDetails()</em></code> <em class="hi">。只有当程序必须决定使用哪个版本的方法时，才需要</em> <code class="du jo jp jq jr b"><em class="hi">super</em></code> <em class="hi">关键字。</em></p></blockquote><h2 id="e0d7" class="lq kh hi bd ki lr ls lt km lu lv lw kq jb lx ly ku jf lz ma ky jj mb mc lc md bi translated">Java中的类型转换</h2><p id="3acc" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">Java 也允许你引用一个子类作为它的超类的一个实例，本质上把子类当作超类类型。这个过程被称为<a class="ae lj" href="https://javarevisited.blogspot.com/2012/12/what-is-type-casting-in-java-class-interface-example.html#axzz5mFvI6vQr" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"/></a>。这是创建模块化代码的好方法，因为您可以编写适用于同一父类的任何子类的代码。例如，你可以引用一个<code class="du jo jp jq jr b">Car</code>类型的变量作为一个<code class="du jo jp jq jr b">Vehicle</code>类型的对象。</p><pre class="ll lm ln lo fd me jr mf mg aw mh bi"><span id="137b" class="lq kh hi jr b fi mi mj l mk ml">Car car     = new Car();<br/>Vehicle vehicle = car;</span></pre><p id="f32e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先创建一个<code class="du jo jp jq jr b">Car</code>实例，然后将该实例分配给一个<code class="du jo jp jq jr b">Vehicle</code>类型变量。现在<code class="du jo jp jq jr b">Vehicle</code>变量引用指向了<code class="du jo jp jq jr b">Car</code>实例。这允许您将<code class="du jo jp jq jr b">Vehicle</code>的任何子类视为相同的<code class="du jo jp jq jr b">Vehicle</code>类型，即使您不知道它是<code class="du jo jp jq jr b">Vehicle</code>的哪个子类。两种类型的类型转换是向上转换和向下转换。</p><p id="b689" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">向上转换是当你把一个子类当作父类的一个实例时，就像我们之前的例子一样。子类特有的任何字段都将被隐藏，以适应父类的模式。</p><p id="e7a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">向下转换是将父类的一个实例当作它的一个子类来对待。虽然任何子类都可以向上转换，但是只有最初是子类类型的对象才可以向下转换。</p><p id="1a52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，如果一个对象是子类类型的原始对象，但后来被向上转换为父类，则该对象可以向下转换。</p><pre class="ll lm ln lo fd me jr mf mg aw mh bi"><span id="4335" class="lq kh hi jr b fi mi mj l mk ml">//valid code<br/>Car car = new Car();<br/>// upcast to Vehicle<br/>Vehicle vehicle = car;<br/>// downcast to car again<br/>Car car2 =  (Car) vehicle;</span></pre><p id="3b2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">向上转换的对象仍然保留它所拥有的字段，因此可以添加回来，使它再次成为子类类型的有效对象。</p><p id="6f71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，最初属于父类的对象没有任何子类独有的基本字段的值。因此，它可以编译，但会在运行时抛出错误。</p><h2 id="664f" class="lq kh hi bd ki lr ls lt km lu lv lw kq jb lx ly ku jf lz ma ky jj mb mc lc md bi translated">在Java中重写方法</h2><p id="3b8a" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">有时我们需要一个子类来编辑继承方法的行为。<a class="ae lj" href="https://javarevisited.blogspot.com/2018/05/top-5-java-courses-for-beginners-to-learn-online.html#axzz6lZkAcdj7" rel="noopener ugc nofollow" target="_blank"> Java </a>让我们通过创建同名的新方法来覆盖现有方法，从而做到这一点。它还允许我们从接口提供抽象方法的类实现。</p><pre class="ll lm ln lo fd me jr mf mg aw mh bi"><span id="70ad" class="lq kh hi jr b fi mi mj l mk ml">class Parent {<br/>  void myMethod() {<br/>    //original implementation<br/>  }<br/>}<br/>class Child extends Parent {<br/>  @override<br/>  void myMethod() {<br/>    //new implementation<br/>  }<br/>}</span></pre><p id="0775" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lj" href="http://www.java67.com/2012/08/what-is-method-overriding-in-java-example-tutorial.html" rel="noopener ugc nofollow" target="_blank">方法覆盖</a>是实现多态时的一个基本工具，多态是一种设计原则，它允许不同的类对同一方法有不同的实现。如果我们把这个词分解，“poly”的意思是很多，“morph”的意思是形式。</p><p id="b74e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最简单地说，<a class="ae lj" href="https://javarevisited.blogspot.com/2020/04/difference-between-inheritance-and-Polymorphism-in-java-oop.html" rel="noopener ugc nofollow" target="_blank">多态性</a>意味着有许多特定于类的流程形式来完成相同的任务。</p><p id="cd4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是程序必须具备的允许方法重写的特性:</p><ul class=""><li id="fdda" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated">方法重写需要继承，并且应该至少有一个派生类。</li><li id="f943" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">派生类必须具有与基类相同的声明，即访问修饰符、名称、相同的参数和相同的方法返回类型。</li><li id="e12d" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">派生类中的方法必须具有彼此不同的实现。</li><li id="b6f0" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">基类中的方法必须需要在派生类中重写。</li><li id="011f" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">基类/方法不能声明为<code class="du jo jp jq jr b">Final</code>类。要在Java中覆盖一个方法，定义一个与您想要覆盖的方法同名的新方法，并在它上面添加<code class="du jo jp jq jr b">@Override</code>标记。</li></ul><p id="d690" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，您可以看到一个例子，说明我们如何为同一个方法调用创建特定于类的行为。我们的方法调用总是<code class="du jo jp jq jr b">getArea()</code>然而，方法的实现依赖于被评估的形状的类。</p><pre class="ll lm ln lo fd me jr mf mg aw mh bi"><span id="62c9" class="lq kh hi jr b fi mi mj l mk ml">// A sample class Shape which provides a method to get the Shape's area<br/>class Shape {<br/>  public double getArea() {<br/>    return 0;<br/>  }<br/>}<br/>// A Rectangle is a Shape with a specific width and height<br/>class Rectangle extends Shape {   // extended form the Shape class<br/>  private double width;<br/>  private double height;<br/>  public Rectangle(double width, double height) {<br/>    this.width = width;<br/>    this.height = height;<br/>  }<br/>  public double getArea() {<br/>    return width * height; <br/>  }<br/>}<br/>// A Circle is a Shape with a specific radius<br/>class Circle extends Shape {<br/>  private double radius;<br/>  public Circle(double radius) {<br/>    this.radius = radius; <br/>  }<br/>  public double getArea() {<br/>    return 3.14 * radius * radius; <br/>  }<br/>}<br/>class driver {<br/>  public static void main(String args[]) {<br/>    Shape[] shape = new Shape[2]; // Creating shape array of size 2<br/>    shape[0] = new Circle(2); // creating circle object at index 0<br/>    shape[1] = new Rectangle(2, 2); // creating rectangle object at index 1<br/>    // Shape object is calling children classes method<br/>    System.out.println("Area of the Circle: " + shape[0].getArea());<br/>    System.out.println("Area of the Rectangle: " + shape[1].getArea());<br/>  }<br/>}</span></pre><p id="d267" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lj" href="https://javarevisited.blogspot.com/2011/08/what-is-polymorphism-in-java-example.html" rel="noopener ugc nofollow" target="_blank">方法超越</a>的优点是:</p><ul class=""><li id="7775" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated">每个派生类都可以为继承的方法提供自己的特定实现，而无需修改父类方法。</li><li id="c47b" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">对于任何方法，子类都可以使用父类中的实现或自己实现。此选项为您设计解决方案提供了更大的灵活性。</li></ul><h2 id="5e13" class="lq kh hi bd ki lr ls lt km lu lv lw kq jb lx ly ku jf lz ma ky jj mb mc lc md bi translated"><code class="du jo jp jq jr b">final</code>关键字</h2><p id="dcf8" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">在Java中，<code class="du jo jp jq jr b"><a class="ae lj" href="https://javarevisited.blogspot.com/2016/09/21-java-final-modifier-keyword-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank">final</a></code> <a class="ae lj" href="https://javarevisited.blogspot.com/2016/09/21-java-final-modifier-keyword-interview-questions-answers.html" rel="noopener ugc nofollow" target="_blank">关键字</a>可以在声明变量、类或方法时使用，以使值不可更改。实体的值是在初始化时决定的，并且在整个程序中保持不变。试图改变任何声明为<code class="du jo jp jq jr b">final</code>的值将会抛出一个编译器错误。</p><pre class="ll lm ln lo fd me jr mf mg aw mh bi"><span id="b165" class="lq kh hi jr b fi mi mj l mk ml">// declaring a final variable<br/>class FinalVariable {<br/>        final int var = 50;<br/>        var = 60 //This line would give an error<br/>}</span></pre><p id="7012" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">final</code>的确切行为取决于实体的类型:</p><ul class=""><li id="16ce" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated"><code class="du jo jp jq jr b"><strong class="is hj">final</strong></code> <strong class="is hj">参数</strong>不能在功能中的任何地方更改</li><li id="9298" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated"><code class="du jo jp jq jr b"><strong class="is hj">final</strong></code> <strong class="is hj">方法</strong>不能被任何子类覆盖或隐藏</li><li id="8e96" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated"><code class="du jo jp jq jr b"><strong class="is hj">final</strong></code> <strong class="is hj">类</strong>不能是任何子类的父类</li></ul><pre class="ll lm ln lo fd me jr mf mg aw mh bi"><span id="61e6" class="lq kh hi jr b fi mi mj l mk ml">final boolean immutable = true;<br/>boolean mutable = immutable;</span></pre><p id="530f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然<code class="du jo jp jq jr b">final</code>实体的值不能改变，但它们可用于设置非<code class="du jo jp jq jr b">final</code>变量的值。该属性有助于解决多个代码段需要引用同一个实体才能运行的数据可变性问题。</p><p id="0a6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以设置节来引用实体的<code class="du jo jp jq jr b">final</code>版本，使用它来创建非<code class="du jo jp jq jr b">final</code>实体副本，然后对其进行任何操作。使用<code class="du jo jp jq jr b">final</code>确保原始的共享引用保持不变，这样每一部分都可以表现一致。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><h1 id="5f4c" class="kg kh hi bd ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld bi translated">接下来要学习的高级概念</h1><p id="2fdb" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">继承是Java中一个强大的工具，也是理解高级OOP设计的基础。在您的Java开发之旅中，接下来要探索的一些概念是:</p><ul class=""><li id="2040" class="js jt hi is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated">抽象和接口</li><li id="b71b" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">聚合</li><li id="2966" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">作文</li><li id="156d" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">Java 8 APIs</li><li id="5f44" class="js jt hi is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">高级访问修饰符</li></ul><p id="d695" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ne">快乐学习！</em></p></div></div>    
</body>
</html>