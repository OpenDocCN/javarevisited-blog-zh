<html>
<head>
<title>Spring Cloud Gateway: Route and Mutate Request Headers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Cloud Gateway:路由和变更请求头</h1>
<blockquote>原文：<a href="https://medium.com/javarevisited/spring-cloud-gateway-route-and-mutate-request-headers-e44a843b7437?source=collection_archive---------3-----------------------#2022-07-26">https://medium.com/javarevisited/spring-cloud-gateway-route-and-mutate-request-headers-e44a843b7437?source=collection_archive---------3-----------------------#2022-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7d37" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从内部隐藏和利用与安全相关的标题。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6dc74f75c47da75cf678514c6d0eca43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z6Jdaz15FPCIzxgr"/></div></div><p class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@sugarman_joe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">糖人乔</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="9adf" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">简介</strong></h2><p id="4d3a" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">如今，应用程序使用基于令牌的授权并不罕见；然而，虽然这通常没有什么错，但尽可能地限制这些令牌的暴露几乎总是好的。</p><p id="fd18" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">既然如此，我们何不去看看<em class="lk">春云网关</em>？<strong class="ko hj">让我们利用它的路由机制，从内部处理请求头的变化。</strong></p><p id="71e7" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">所以，不再多说——让我们启动并运行一个简单的网关服务。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h2 id="abea" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">项目设置</strong></h2><p id="8a46" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">首先，假设我们有一个内部API，假设它需要一个必须保持安全和私有的头——可能是API密钥、客户端凭证等等。虽然实现其中的任何一项都很有趣，但在本文中，我们不会深入探讨这些细节；相反，我们将有一个假设的API来专门关注<a class="ae jn" rel="noopener" href="/javarevisited/5-best-courses-to-learn-spring-cloud-and-microservices-1ddea1af7012"> Spring Cloud Gateway </a>。</p><p id="ae99" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">现在，让我们来看看<code class="du ls lt lu lv b">pom.xml</code>中的必要依赖项:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="8aae" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">这个pom.xml几乎不言自明；然而，我想指出<code class="du ls lt lu lv b">netty-resolver-dns-native-macos</code>依赖性——我们可以用它来解决M1芯片中的netty兼容性错误。</p><p id="046b" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">接下来，通过一个<code class="du ls lt lu lv b">application.yml</code>文件—让我们为一个假设的服务配置路由:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="e900" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">从上面的片段中，我们可以看出前缀为/hypothetic-path(在谓词下)的请求将被直接路由到<a class="ae jn" href="http://www.java67.com/2013/01/difference-between-url-uri-and-urn.html" rel="noopener ugc nofollow" target="_blank"> URI </a>。另外，请注意，我们在filters下使用了StripPrefix这使得可以将请求路由到我们假设的服务，而不使用尾随前缀。</p><p id="bcb6" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">最后，让我们实现一个定制的GlobalFilter，在请求路由发生之前将一个头包含到请求中:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h2 id="de70" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">启动并运行</strong></h2><p id="ac9c" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">我们就要到了——所以首先，让我们确保我们有一个正在运行的服务来路由来自网关服务的请求。在我们的例子中，我们可以使用假设的api。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2017/11/top-5-free-core-spring-mvc-courses-learn-online.html"><div class="er es ly"><img src="../Images/a3b81a1aecffccce9cd6c8685571b145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyOnA-jsmvnYY9Do5Gsbiw.png"/></div></a></figure><p id="a717" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">现在，剩下的就是运行并尝试通过网关服务发送请求:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/05/50-free-spring-professional-certification-questions.html"><div class="er es lz"><img src="../Images/ed444afb72ea595dbeccee8b2a433fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wO-nYZNoTueguCOks9rmlw.png"/></div></a></figure><p id="7eb0" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><code class="du ls lt lu lv b">curl -v <a class="ae jn" href="http://localhost:8081/hypothetical-path" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/hypothetical-path</a></code></p><p id="12c6" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">如果我们要检查日志，我们可以看到我们已经成功地路由并添加了一个请求头:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://www.java67.com/2021/11/5-best-spring-framework-courses-for.html"><div class="er es ma"><img src="../Images/97ef41e140f3860536293b21b230205e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-O003NnKcw59RDOuscGftQ.png"/></div></a></figure><p id="58bb" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">所以，我们有它。有了<em class="lk"> Spring Cloud Gateway </em>，我们可以用最少的配置和一个过滤器来路由和改变请求。</p><p id="4cc5" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">像往常一样，完整的源代码总是可以在<a class="ae jn" href="https://github.com/emyasa/medium-articles/tree/master/spring-cloud-gateway" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>